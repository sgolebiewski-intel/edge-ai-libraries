From 39776b38fddefd583b53d333d993e635fab72951 Mon Sep 17 00:00:00 2001
From: Zhang Wei E <wei.e.zhang@intel.com>
Date: Mon, 6 May 2024 13:33:20 +0800
Subject: [PATCH 1/8] Add demo examples

Demo list as below:
Inverted Pendulum
ethercat io
fly trigger poc
multiply axis
soe axis

Signed-off-by: Zhang Wei E <wei.e.zhang@intel.com>
---
 configure.ac                                  |    5 +
 examples/InvertedPendulum/Makefile.am         |   44 +
 examples/InvertedPendulum/cJSON/cJSON.c       |  751 +++++++++
 examples/InvertedPendulum/cJSON/cJSON.h       |  149 ++
 examples/InvertedPendulum/configure.json      |   28 +
 examples/InvertedPendulum/def_config.h        |   20 +
 examples/InvertedPendulum/main.c              |  993 ++++++++++++
 examples/InvertedPendulum/main.h              |  140 ++
 .../InvertedPendulum/modbus_server/README     |   30 +
 .../modbus_server/modbus_server.c             |  289 ++++
 .../modbus_server/modbus_server.h             |    8 +
 examples/Makefile.am                          |    7 +-
 examples/ecatdio/Makefile.am                  |   54 +
 examples/ecatdio/main.c                       |  344 +++++
 examples/ecatdio/main.h                       |   54 +
 examples/fly_trigger_poc/Makefile.am          |   54 +
 examples/fly_trigger_poc/main.c               |  455 ++++++
 examples/fly_trigger_poc/main.h               |  159 ++
 examples/multi_axis/Makefile.am               |   54 +
 examples/multi_axis/circle.c                  |   68 +
 examples/multi_axis/circle.h                  |   30 +
 examples/multi_axis/def_config.h              |   23 +
 examples/multi_axis/main.c                    | 1351 +++++++++++++++++
 examples/multi_axis/main.h                    |  153 ++
 examples/multi_axis/modbus_server/README      |   30 +
 .../multi_axis/modbus_server/modbus_server.c  |  279 ++++
 .../multi_axis/modbus_server/modbus_server.h  |    8 +
 examples/soe_axis/Makefile.am                 |   54 +
 examples/soe_axis/soe-axis.c                  |  667 ++++++++
 29 files changed, 6299 insertions(+), 2 deletions(-)
 create mode 100644 examples/InvertedPendulum/Makefile.am
 create mode 100644 examples/InvertedPendulum/cJSON/cJSON.c
 create mode 100644 examples/InvertedPendulum/cJSON/cJSON.h
 create mode 100644 examples/InvertedPendulum/configure.json
 create mode 100644 examples/InvertedPendulum/def_config.h
 create mode 100644 examples/InvertedPendulum/main.c
 create mode 100644 examples/InvertedPendulum/main.h
 create mode 100644 examples/InvertedPendulum/modbus_server/README
 create mode 100644 examples/InvertedPendulum/modbus_server/modbus_server.c
 create mode 100644 examples/InvertedPendulum/modbus_server/modbus_server.h
 create mode 100644 examples/ecatdio/Makefile.am
 create mode 100644 examples/ecatdio/main.c
 create mode 100644 examples/ecatdio/main.h
 create mode 100644 examples/fly_trigger_poc/Makefile.am
 create mode 100644 examples/fly_trigger_poc/main.c
 create mode 100644 examples/fly_trigger_poc/main.h
 create mode 100644 examples/multi_axis/Makefile.am
 create mode 100644 examples/multi_axis/circle.c
 create mode 100644 examples/multi_axis/circle.h
 create mode 100644 examples/multi_axis/def_config.h
 create mode 100644 examples/multi_axis/main.c
 create mode 100644 examples/multi_axis/main.h
 create mode 100644 examples/multi_axis/modbus_server/README
 create mode 100644 examples/multi_axis/modbus_server/modbus_server.c
 create mode 100644 examples/multi_axis/modbus_server/modbus_server.h
 create mode 100644 examples/soe_axis/Makefile.am
 create mode 100644 examples/soe_axis/soe-axis.c

diff --git a/configure.ac b/configure.ac
index 04b78bf4..7fc8cb4c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1389,6 +1389,11 @@ AC_CONFIG_FILES([
         examples/user/Makefile
         examples/xenomai/Makefile
         examples/xenomai_posix/Makefile
+        examples/InvertedPendulum/Makefile
+        examples/ecatdio/Makefile
+        examples/fly_trigger_poc/Makefile
+        examples/multi_axis/Makefile
+        examples/soe_axis/Makefile
         include/Makefile
         lib/Makefile
         lib/libethercat.pc
diff --git a/examples/InvertedPendulum/Makefile.am b/examples/InvertedPendulum/Makefile.am
new file mode 100644
index 00000000..a356fcfc
--- /dev/null
+++ b/examples/InvertedPendulum/Makefile.am
@@ -0,0 +1,44 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_xenomai_posix_example
+
+ec_xenomai_posix_example_SOURCES = main.c modbus_server/modbus_server.c cJSON/cJSON.c
+
+ec_xenomai_posix_example_CFLAGS = \
+	-Wall \
+        -lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS)
+
+ec_xenomai_posix_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm -lmodbus \
+	$(XENOMAI_POSIX_LDFLAGS)
+
+#------------------------------------------------------------------------------
diff --git a/examples/InvertedPendulum/cJSON/cJSON.c b/examples/InvertedPendulum/cJSON/cJSON.c
new file mode 100644
index 00000000..3c436d6a
--- /dev/null
+++ b/examples/InvertedPendulum/cJSON/cJSON.c
@@ -0,0 +1,751 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+/* cJSON */
+/* JSON parser in C. */
+
+#include <string.h>
+#include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <float.h>
+#include <limits.h>
+#include <ctype.h>
+#include "cJSON.h"
+
+
+static const char *ep;
+
+const char *cJSON_GetErrorPtr(void) {return ep;}
+
+static int cJSON_strcasecmp(const char *s1,const char *s2)
+{
+	if (!s1) return (s1==s2)?0:1;if (!s2) return 1;
+	for(; tolower(*s1) == tolower(*s2); ++s1, ++s2)	if(*s1 == 0)	return 0;
+	return tolower(*(const unsigned char *)s1) - tolower(*(const unsigned char *)s2);
+}
+
+static void *(*cJSON_malloc)(size_t sz) = malloc;
+static void (*cJSON_free)(void *ptr) = free;
+
+static char* cJSON_strdup(const char* str)
+{
+      size_t len;
+      char* copy;
+
+      len = strlen(str) + 1;
+      if (!(copy = (char*)cJSON_malloc(len))) return 0;
+      memcpy(copy,str,len);
+      return copy;
+}
+
+void cJSON_InitHooks(cJSON_Hooks* hooks)
+{
+    if (!hooks) { /* Reset hooks */
+        cJSON_malloc = malloc;
+        cJSON_free = free;
+        return;
+    }
+
+	cJSON_malloc = (hooks->malloc_fn)?hooks->malloc_fn:malloc;
+	cJSON_free	 = (hooks->free_fn)?hooks->free_fn:free;
+}
+
+/* Internal constructor. */
+static cJSON *cJSON_New_Item(void)
+{
+	cJSON* node = (cJSON*)cJSON_malloc(sizeof(cJSON));
+	if (node) memset(node,0,sizeof(cJSON));
+	return node;
+}
+
+/* Delete a cJSON structure. */
+void cJSON_Delete(cJSON *c)
+{
+	cJSON *next;
+	while (c)
+	{
+		next=c->next;
+		if (!(c->type&cJSON_IsReference) && c->child) cJSON_Delete(c->child);
+		if (!(c->type&cJSON_IsReference) && c->valuestring) cJSON_free(c->valuestring);
+		if (!(c->type&cJSON_StringIsConst) && c->string) cJSON_free(c->string);
+		cJSON_free(c);
+		c=next;
+	}
+}
+
+/* Parse the input text to generate a number, and populate the result into item. */
+static const char *parse_number(cJSON *item,const char *num)
+{
+	double n=0,sign=1,scale=0;int subscale=0,signsubscale=1;
+
+	if (*num=='-') sign=-1,num++;	/* Has sign? */
+	if (*num=='0') num++;			/* is zero */
+	if (*num>='1' && *num<='9')	do	n=(n*10.0)+(*num++ -'0');	while (*num>='0' && *num<='9');	/* Number? */
+	if (*num=='.' && num[1]>='0' && num[1]<='9') {num++;		do	n=(n*10.0)+(*num++ -'0'),scale--; while (*num>='0' && *num<='9');}	/* Fractional part? */
+	if (*num=='e' || *num=='E')		/* Exponent? */
+	{	num++;if (*num=='+') num++;	else if (*num=='-') signsubscale=-1,num++;		/* With sign? */
+		while (*num>='0' && *num<='9') subscale=(subscale*10)+(*num++ - '0');	/* Number? */
+	}
+
+	n=sign*n*pow(10.0,(scale+subscale*signsubscale));	/* number = +/- number.fraction * 10^+/- exponent */
+	
+	item->valuedouble=n;
+	item->valueint=(int)n;
+	item->type=cJSON_Number;
+	return num;
+}
+
+static int pow2gt (int x)	{	--x;	x|=x>>1;	x|=x>>2;	x|=x>>4;	x|=x>>8;	x|=x>>16;	return x+1;	}
+
+typedef struct {char *buffer; int length; int offset; } printbuffer;
+
+static char* ensure(printbuffer *p,int needed)
+{
+	char *newbuffer;int newsize;
+	if (!p || !p->buffer) return 0;
+	needed+=p->offset;
+	if (needed<=p->length) return p->buffer+p->offset;
+
+	newsize=pow2gt(needed);
+	newbuffer=(char*)cJSON_malloc(newsize);
+	if (!newbuffer) {cJSON_free(p->buffer);p->length=0,p->buffer=0;return 0;}
+	if (newbuffer) memcpy(newbuffer,p->buffer,p->length);
+	cJSON_free(p->buffer);
+	p->length=newsize;
+	p->buffer=newbuffer;
+	return newbuffer+p->offset;
+}
+
+static int update(printbuffer *p)
+{
+	char *str;
+	if (!p || !p->buffer) return 0;
+	str=p->buffer+p->offset;
+	return p->offset+strlen(str);
+}
+
+/* Render the number nicely from the given item into a string. */
+static char *print_number(cJSON *item,printbuffer *p)
+{
+	char *str=0;
+	double d=item->valuedouble;
+	if (d==0)
+	{
+		if (p)	str=ensure(p,2);
+		else	str=(char*)cJSON_malloc(2);	/* special case for 0. */
+		if (str) strcpy(str,"0");
+	}
+	else if (fabs(((double)item->valueint)-d)<=DBL_EPSILON && d<=INT_MAX && d>=INT_MIN)
+	{
+		if (p)	str=ensure(p,21);
+		else	str=(char*)cJSON_malloc(21);	/* 2^64+1 can be represented in 21 chars. */
+		if (str)	sprintf(str,"%d",item->valueint);
+	}
+	else
+	{
+		if (p)	str=ensure(p,64);
+		else	str=(char*)cJSON_malloc(64);	/* This is a nice tradeoff. */
+		if (str)
+		{
+			if (fabs(floor(d)-d)<=DBL_EPSILON && fabs(d)<1.0e60)sprintf(str,"%.0f",d);
+			else if (fabs(d)<1.0e-6 || fabs(d)>1.0e9)			sprintf(str,"%e",d);
+			else												sprintf(str,"%f",d);
+		}
+	}
+	return str;
+}
+
+static unsigned parse_hex4(const char *str)
+{
+	unsigned h=0;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	h=h<<4;str++;
+	if (*str>='0' && *str<='9') h+=(*str)-'0'; else if (*str>='A' && *str<='F') h+=10+(*str)-'A'; else if (*str>='a' && *str<='f') h+=10+(*str)-'a'; else return 0;
+	return h;
+}
+
+/* Parse the input text into an unescaped cstring, and populate item. */
+static const unsigned char firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+static const char *parse_string(cJSON *item,const char *str)
+{
+	const char *ptr=str+1;char *ptr2;char *out;int len=0;unsigned uc,uc2;
+	if (*str!='\"') {ep=str;return 0;}	/* not a string! */
+	
+	while (*ptr!='\"' && *ptr && ++len) if (*ptr++ == '\\') ptr++;	/* Skip escaped quotes. */
+	
+	out=(char*)cJSON_malloc(len+1);	/* This is how long we need for the string, roughly. */
+	if (!out) return 0;
+	
+	ptr=str+1;ptr2=out;
+	while (*ptr!='\"' && *ptr)
+	{
+		if (*ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			ptr++;
+			switch (*ptr)
+			{
+				case 'b': *ptr2++='\b';	break;
+				case 'f': *ptr2++='\f';	break;
+				case 'n': *ptr2++='\n';	break;
+				case 'r': *ptr2++='\r';	break;
+				case 't': *ptr2++='\t';	break;
+				case 'u':	 /* transcode utf16 to utf8. */
+					uc=parse_hex4(ptr+1);ptr+=4;	/* get the unicode char. */
+
+					if ((uc>=0xDC00 && uc<=0xDFFF) || uc==0)	break;	/* check for invalid.	*/
+
+					if (uc>=0xD800 && uc<=0xDBFF)	/* UTF16 surrogate pairs.	*/
+					{
+						if (ptr[1]!='\\' || ptr[2]!='u')	break;	/* missing second-half of surrogate.	*/
+						uc2=parse_hex4(ptr+3);ptr+=6;
+						if (uc2<0xDC00 || uc2>0xDFFF)		break;	/* invalid second-half of surrogate.	*/
+						uc=0x10000 + (((uc&0x3FF)<<10) | (uc2&0x3FF));
+					}
+
+					len=4;if (uc<0x80) len=1;else if (uc<0x800) len=2;else if (uc<0x10000) len=3; ptr2+=len;
+					
+					switch (len) {
+						case 4: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 3: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 2: *--ptr2 =((uc | 0x80) & 0xBF); uc >>= 6;
+						case 1: *--ptr2 =(uc | firstByteMark[len]);
+					}
+					ptr2+=len;
+					break;
+				default:  *ptr2++=*ptr; break;
+			}
+			ptr++;
+		}
+	}
+	*ptr2=0;
+	if (*ptr=='\"') ptr++;
+	item->valuestring=out;
+	item->type=cJSON_String;
+	return ptr;
+}
+
+/* Render the cstring provided to an escaped version that can be printed. */
+static char *print_string_ptr(const char *str,printbuffer *p)
+{
+	const char *ptr;char *ptr2,*out;int len=0,flag=0;unsigned char token;
+	
+	for (ptr=str;*ptr;ptr++) flag|=((*ptr>0 && *ptr<32)||(*ptr=='\"')||(*ptr=='\\'))?1:0;
+	if (!flag)
+	{
+		len=ptr-str;
+		if (p) out=ensure(p,len+3);
+		else		out=(char*)cJSON_malloc(len+3);
+		if (!out) return 0;
+		ptr2=out;*ptr2++='\"';
+		strcpy(ptr2,str);
+		ptr2[len]='\"';
+		ptr2[len+1]=0;
+		return out;
+	}
+	
+	if (!str)
+	{
+		if (p)	out=ensure(p,3);
+		else	out=(char*)cJSON_malloc(3);
+		if (!out) return 0;
+		strcpy(out,"\"\"");
+		return out;
+	}
+	ptr=str;while ((token=*ptr) && ++len) {if (strchr("\"\\\b\f\n\r\t",token)) len++; else if (token<32) len+=5;ptr++;}
+	
+	if (p)	out=ensure(p,len+3);
+	else	out=(char*)cJSON_malloc(len+3);
+	if (!out) return 0;
+
+	ptr2=out;ptr=str;
+	*ptr2++='\"';
+	while (*ptr)
+	{
+		if ((unsigned char)*ptr>31 && *ptr!='\"' && *ptr!='\\') *ptr2++=*ptr++;
+		else
+		{
+			*ptr2++='\\';
+			switch (token=*ptr++)
+			{
+				case '\\':	*ptr2++='\\';	break;
+				case '\"':	*ptr2++='\"';	break;
+				case '\b':	*ptr2++='b';	break;
+				case '\f':	*ptr2++='f';	break;
+				case '\n':	*ptr2++='n';	break;
+				case '\r':	*ptr2++='r';	break;
+				case '\t':	*ptr2++='t';	break;
+				default: sprintf(ptr2,"u%04x",token);ptr2+=5;	break;	/* escape and print */
+			}
+		}
+	}
+	*ptr2++='\"';*ptr2++=0;
+	return out;
+}
+/* Invote print_string_ptr (which is useful) on an item. */
+static char *print_string(cJSON *item,printbuffer *p)	{return print_string_ptr(item->valuestring,p);}
+
+/* Predeclare these prototypes. */
+static const char *parse_value(cJSON *item,const char *value);
+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p);
+static const char *parse_array(cJSON *item,const char *value);
+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p);
+static const char *parse_object(cJSON *item,const char *value);
+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p);
+
+/* Utility to jump whitespace and cr/lf */
+static const char *skip(const char *in) {while (in && *in && (unsigned char)*in<=32) in++; return in;}
+
+/* Parse an object - create a new root, and populate. */
+cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated)
+{
+	const char *end=0;
+	cJSON *c=cJSON_New_Item();
+	ep=0;
+	if (!c) return 0;       /* memory fail */
+
+	end=parse_value(c,skip(value));
+	if (!end)	{cJSON_Delete(c);return 0;}	/* parse failure. ep is set. */
+
+	/* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
+	if (require_null_terminated) {end=skip(end);if (*end) {cJSON_Delete(c);ep=end;return 0;}}
+	if (return_parse_end) *return_parse_end=end;
+	return c;
+}
+/* Default options for cJSON_Parse */
+cJSON *cJSON_Parse(const char *value) {return cJSON_ParseWithOpts(value,0,0);}
+
+/* Render a cJSON item/entity/structure to text. */
+char *cJSON_Print(cJSON *item)				{return print_value(item,0,1,0);}
+char *cJSON_PrintUnformatted(cJSON *item)	{return print_value(item,0,0,0);}
+
+char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt)
+{
+	printbuffer p;
+	p.buffer=(char*)cJSON_malloc(prebuffer);
+	p.length=prebuffer;
+	p.offset=0;
+	return print_value(item,0,fmt,&p);
+	return p.buffer;
+}
+
+
+/* Parser core - when encountering text, process appropriately. */
+static const char *parse_value(cJSON *item,const char *value)
+{
+	if (!value)						return 0;	/* Fail on null. */
+	if (!strncmp(value,"null",4))	{ item->type=cJSON_NULL;  return value+4; }
+	if (!strncmp(value,"false",5))	{ item->type=cJSON_False; return value+5; }
+	if (!strncmp(value,"true",4))	{ item->type=cJSON_True; item->valueint=1;	return value+4; }
+	if (*value=='\"')				{ return parse_string(item,value); }
+	if (*value=='-' || (*value>='0' && *value<='9'))	{ return parse_number(item,value); }
+	if (*value=='[')				{ return parse_array(item,value); }
+	if (*value=='{')				{ return parse_object(item,value); }
+
+	ep=value;return 0;	/* failure. */
+}
+
+/* Render a value to text. */
+static char *print_value(cJSON *item,int depth,int fmt,printbuffer *p)
+{
+	char *out=0;
+	if (!item) return 0;
+	if (p)
+	{
+		switch ((item->type)&255)
+		{
+			case cJSON_NULL:	{out=ensure(p,5);	if (out) strcpy(out,"null");	break;}
+			case cJSON_False:	{out=ensure(p,6);	if (out) strcpy(out,"false");	break;}
+			case cJSON_True:	{out=ensure(p,5);	if (out) strcpy(out,"true");	break;}
+			case cJSON_Number:	out=print_number(item,p);break;
+			case cJSON_String:	out=print_string(item,p);break;
+			case cJSON_Array:	out=print_array(item,depth,fmt,p);break;
+			case cJSON_Object:	out=print_object(item,depth,fmt,p);break;
+		}
+	}
+	else
+	{
+		switch ((item->type)&255)
+		{
+			case cJSON_NULL:	out=cJSON_strdup("null");	break;
+			case cJSON_False:	out=cJSON_strdup("false");break;
+			case cJSON_True:	out=cJSON_strdup("true"); break;
+			case cJSON_Number:	out=print_number(item,0);break;
+			case cJSON_String:	out=print_string(item,0);break;
+			case cJSON_Array:	out=print_array(item,depth,fmt,0);break;
+			case cJSON_Object:	out=print_object(item,depth,fmt,0);break;
+		}
+	}
+	return out;
+}
+
+/* Build an array from input text. */
+static const char *parse_array(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='[')	{ep=value;return 0;}	/* not an array! */
+
+	item->type=cJSON_Array;
+	value=skip(value+1);
+	if (*value==']') return value+1;	/* empty array. */
+
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;		 /* memory fail */
+	value=skip(parse_value(child,skip(value)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item())) return 0; 	/* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_value(child,skip(value+1)));
+		if (!value) return 0;	/* memory fail */
+	}
+
+	if (*value==']') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an array to text */
+static char *print_array(cJSON *item,int depth,int fmt,printbuffer *p)
+{
+	char **entries;
+	char *out=0,*ptr,*ret;int len=5;
+	cJSON *child=item->child;
+	int numentries=0,i=0,fail=0;
+	size_t tmplen=0;
+	
+	/* How many entries in the array? */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle numentries==0 */
+	if (!numentries)
+	{
+		if (p)	out=ensure(p,3);
+		else	out=(char*)cJSON_malloc(3);
+		if (out) strcpy(out,"[]");
+		return out;
+	}
+
+	if (p)
+	{
+		/* Compose the output array. */
+		i=p->offset;
+		ptr=ensure(p,1);if (!ptr) return 0;	*ptr='[';	p->offset++;
+		child=item->child;
+		while (child && !fail)
+		{
+			print_value(child,depth+1,fmt,p);
+			p->offset=update(p);
+			if (child->next) {len=fmt?2:1;ptr=ensure(p,len+1);if (!ptr) return 0;*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;p->offset+=len;}
+			child=child->next;
+		}
+		ptr=ensure(p,2);if (!ptr) return 0;	*ptr++=']';*ptr=0;
+		out=(p->buffer)+i;
+	}
+	else
+	{
+		/* Allocate an array to hold the values for each */
+		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+		if (!entries) return 0;
+		memset(entries,0,numentries*sizeof(char*));
+		/* Retrieve all the results: */
+		child=item->child;
+		while (child && !fail)
+		{
+			ret=print_value(child,depth+1,fmt,0);
+			entries[i++]=ret;
+			if (ret) len+=strlen(ret)+2+(fmt?1:0); else fail=1;
+			child=child->next;
+		}
+		
+		/* If we didn't fail, try to malloc the output string */
+		if (!fail)	out=(char*)cJSON_malloc(len);
+		/* If that fails, we fail. */
+		if (!out) fail=1;
+
+		/* Handle failure. */
+		if (fail)
+		{
+			for (i=0;i<numentries;i++) if (entries[i]) cJSON_free(entries[i]);
+			cJSON_free(entries);
+			return 0;
+		}
+		
+		/* Compose the output array. */
+		*out='[';
+		ptr=out+1;*ptr=0;
+		for (i=0;i<numentries;i++)
+		{
+			tmplen=strlen(entries[i]);memcpy(ptr,entries[i],tmplen);ptr+=tmplen;
+			if (i!=numentries-1) {*ptr++=',';if(fmt)*ptr++=' ';*ptr=0;}
+			cJSON_free(entries[i]);
+		}
+		cJSON_free(entries);
+		*ptr++=']';*ptr++=0;
+	}
+	return out;	
+}
+
+/* Build an object from the text. */
+static const char *parse_object(cJSON *item,const char *value)
+{
+	cJSON *child;
+	if (*value!='{')	{ep=value;return 0;}	/* not an object! */
+	
+	item->type=cJSON_Object;
+	value=skip(value+1);
+	if (*value=='}') return value+1;	/* empty array. */
+	
+	item->child=child=cJSON_New_Item();
+	if (!item->child) return 0;
+	value=skip(parse_string(child,skip(value)));
+	if (!value) return 0;
+	child->string=child->valuestring;child->valuestring=0;
+	if (*value!=':') {ep=value;return 0;}	/* fail! */
+	value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+	if (!value) return 0;
+	
+	while (*value==',')
+	{
+		cJSON *new_item;
+		if (!(new_item=cJSON_New_Item()))	return 0; /* memory fail */
+		child->next=new_item;new_item->prev=child;child=new_item;
+		value=skip(parse_string(child,skip(value+1)));
+		if (!value) return 0;
+		child->string=child->valuestring;child->valuestring=0;
+		if (*value!=':') {ep=value;return 0;}	/* fail! */
+		value=skip(parse_value(child,skip(value+1)));	/* skip any spacing, get the value. */
+		if (!value) return 0;
+	}
+	
+	if (*value=='}') return value+1;	/* end of array */
+	ep=value;return 0;	/* malformed. */
+}
+
+/* Render an object to text. */
+static char *print_object(cJSON *item,int depth,int fmt,printbuffer *p)
+{
+	char **entries=0,**names=0;
+	char *out=0,*ptr,*ret,*str;int len=7,i=0,j;
+	cJSON *child=item->child;
+	int numentries=0,fail=0;
+	size_t tmplen=0;
+	/* Count the number of entries. */
+	while (child) numentries++,child=child->next;
+	/* Explicitly handle empty object case */
+	if (!numentries)
+	{
+		if (p) out=ensure(p,fmt?depth+4:3);
+		else	out=(char*)cJSON_malloc(fmt?depth+4:3);
+		if (!out)	return 0;
+		ptr=out;*ptr++='{';
+		if (fmt) {*ptr++='\n';for (i=0;i<depth-1;i++) *ptr++='\t';}
+		*ptr++='}';*ptr++=0;
+		return out;
+	}
+	if (p)
+	{
+		/* Compose the output: */
+		i=p->offset;
+		len=fmt?2:1;	ptr=ensure(p,len+1);	if (!ptr) return 0;
+		*ptr++='{';	if (fmt) *ptr++='\n';	*ptr=0;	p->offset+=len;
+		child=item->child;depth++;
+		while (child)
+		{
+			if (fmt)
+			{
+				ptr=ensure(p,depth);	if (!ptr) return 0;
+				for (j=0;j<depth;j++) *ptr++='\t';
+				p->offset+=depth;
+			}
+			print_string_ptr(child->string,p);
+			p->offset=update(p);
+			
+			len=fmt?2:1;
+			ptr=ensure(p,len);	if (!ptr) return 0;
+			*ptr++=':';if (fmt) *ptr++='\t';
+			p->offset+=len;
+			
+			print_value(child,depth,fmt,p);
+			p->offset=update(p);
+
+			len=(fmt?1:0)+(child->next?1:0);
+			ptr=ensure(p,len+1); if (!ptr) return 0;
+			if (child->next) *ptr++=',';
+			if (fmt) *ptr++='\n';*ptr=0;
+			p->offset+=len;
+			child=child->next;
+		}
+		ptr=ensure(p,fmt?(depth+1):2);	 if (!ptr) return 0;
+		if (fmt)	for (i=0;i<depth-1;i++) *ptr++='\t';
+		*ptr++='}';*ptr=0;
+		out=(p->buffer)+i;
+	}
+	else
+	{
+		/* Allocate space for the names and the objects */
+		entries=(char**)cJSON_malloc(numentries*sizeof(char*));
+		if (!entries) return 0;
+		names=(char**)cJSON_malloc(numentries*sizeof(char*));
+		if (!names) {cJSON_free(entries);return 0;}
+		memset(entries,0,sizeof(char*)*numentries);
+		memset(names,0,sizeof(char*)*numentries);
+
+		/* Collect all the results into our arrays: */
+		child=item->child;depth++;if (fmt) len+=depth;
+		while (child)
+		{
+			names[i]=str=print_string_ptr(child->string,0);
+			entries[i++]=ret=print_value(child,depth,fmt,0);
+			if (str && ret) len+=strlen(ret)+strlen(str)+2+(fmt?2+depth:0); else fail=1;
+			child=child->next;
+		}
+		
+		/* Try to allocate the output string */
+		if (!fail)	out=(char*)cJSON_malloc(len);
+		if (!out) fail=1;
+
+		/* Handle failure */
+		if (fail)
+		{
+			for (i=0;i<numentries;i++) {if (names[i]) cJSON_free(names[i]);if (entries[i]) cJSON_free(entries[i]);}
+			cJSON_free(names);cJSON_free(entries);
+			return 0;
+		}
+		
+		/* Compose the output: */
+		*out='{';ptr=out+1;if (fmt)*ptr++='\n';*ptr=0;
+		for (i=0;i<numentries;i++)
+		{
+			if (fmt) for (j=0;j<depth;j++) *ptr++='\t';
+			tmplen=strlen(names[i]);memcpy(ptr,names[i],tmplen);ptr+=tmplen;
+			*ptr++=':';if (fmt) *ptr++='\t';
+			strcpy(ptr,entries[i]);ptr+=strlen(entries[i]);
+			if (i!=numentries-1) *ptr++=',';
+			if (fmt) *ptr++='\n';*ptr=0;
+			cJSON_free(names[i]);cJSON_free(entries[i]);
+		}
+		
+		cJSON_free(names);cJSON_free(entries);
+		if (fmt) for (i=0;i<depth-1;i++) *ptr++='\t';
+		*ptr++='}';*ptr++=0;
+	}
+	return out;	
+}
+
+/* Get Array size/item / object item. */
+int    cJSON_GetArraySize(cJSON *array)							{cJSON *c=array->child;int i=0;while(c)i++,c=c->next;return i;}
+cJSON *cJSON_GetArrayItem(cJSON *array,int item)				{cJSON *c=array->child;  while (c && item>0) item--,c=c->next; return c;}
+cJSON *cJSON_GetObjectItem(cJSON *object,const char *string)	{cJSON *c=object->child; while (c && cJSON_strcasecmp(c->string,string)) c=c->next; return c;}
+
+/* Utility for array list handling. */
+static void suffix_object(cJSON *prev,cJSON *item) {prev->next=item;item->prev=prev;}
+/* Utility for handling references. */
+static cJSON *create_reference(cJSON *item) {cJSON *ref=cJSON_New_Item();if (!ref) return 0;memcpy(ref,item,sizeof(cJSON));ref->string=0;ref->type|=cJSON_IsReference;ref->next=ref->prev=0;return ref;}
+
+/* Add item to array/object. */
+void   cJSON_AddItemToArray(cJSON *array, cJSON *item)						{cJSON *c=array->child;if (!item) return; if (!c) {array->child=item;} else {while (c && c->next) c=c->next; suffix_object(c,item);}}
+void   cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (item->string) cJSON_free(item->string);item->string=cJSON_strdup(string);cJSON_AddItemToArray(object,item);}
+void   cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item)	{if (!item) return; if (!(item->type&cJSON_StringIsConst) && item->string) cJSON_free(item->string);item->string=(char*)string;item->type|=cJSON_StringIsConst;cJSON_AddItemToArray(object,item);}
+void	cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)						{cJSON_AddItemToArray(array,create_reference(item));}
+void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item)	{cJSON_AddItemToObject(object,string,create_reference(item));}
+
+cJSON *cJSON_DetachItemFromArray(cJSON *array,int which)			{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return 0;
+	if (c->prev) c->prev->next=c->next;if (c->next) c->next->prev=c->prev;if (c==array->child) array->child=c->next;c->prev=c->next=0;return c;}
+void   cJSON_DeleteItemFromArray(cJSON *array,int which)			{cJSON_Delete(cJSON_DetachItemFromArray(array,which));}
+cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string) {int i=0;cJSON *c=object->child;while (c && cJSON_strcasecmp(c->string,string)) i++,c=c->next;if (c) return cJSON_DetachItemFromArray(object,i);return 0;}
+void   cJSON_DeleteItemFromObject(cJSON *object,const char *string) {cJSON_Delete(cJSON_DetachItemFromObject(object,string));}
+
+/* Replace array/object items with new ones. */
+void   cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) {cJSON_AddItemToArray(array,newitem);return;}
+	newitem->next=c;newitem->prev=c->prev;c->prev=newitem;if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;}
+void   cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem)		{cJSON *c=array->child;while (c && which>0) c=c->next,which--;if (!c) return;
+	newitem->next=c->next;newitem->prev=c->prev;if (newitem->next) newitem->next->prev=newitem;
+	if (c==array->child) array->child=newitem; else newitem->prev->next=newitem;c->next=c->prev=0;cJSON_Delete(c);}
+void   cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem){int i=0;cJSON *c=object->child;while(c && cJSON_strcasecmp(c->string,string))i++,c=c->next;if(c){newitem->string=cJSON_strdup(string);cJSON_ReplaceItemInArray(object,i,newitem);}}
+
+/* Create basic types: */
+cJSON *cJSON_CreateNull(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_NULL;return item;}
+cJSON *cJSON_CreateTrue(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_True;return item;}
+cJSON *cJSON_CreateFalse(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_False;return item;}
+cJSON *cJSON_CreateBool(int b)					{cJSON *item=cJSON_New_Item();if(item)item->type=b?cJSON_True:cJSON_False;return item;}
+cJSON *cJSON_CreateNumber(double num)			{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_Number;item->valuedouble=num;item->valueint=(int)num;}return item;}
+cJSON *cJSON_CreateString(const char *string)	{cJSON *item=cJSON_New_Item();if(item){item->type=cJSON_String;item->valuestring=cJSON_strdup(string);}return item;}
+cJSON *cJSON_CreateArray(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Array;return item;}
+cJSON *cJSON_CreateObject(void)					{cJSON *item=cJSON_New_Item();if(item)item->type=cJSON_Object;return item;}
+
+/* Create Arrays: */
+cJSON *cJSON_CreateIntArray(const int *numbers,int count)		{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateFloatArray(const float *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateDoubleArray(const double *numbers,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateNumber(numbers[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+cJSON *cJSON_CreateStringArray(const char **strings,int count)	{int i;cJSON *n=0,*p=0,*a=cJSON_CreateArray();for(i=0;a && i<count;i++){n=cJSON_CreateString(strings[i]);if(!i)a->child=n;else suffix_object(p,n);p=n;}return a;}
+
+/* Duplication */
+cJSON *cJSON_Duplicate(cJSON *item,int recurse)
+{
+	cJSON *newitem,*cptr,*nptr=0,*newchild;
+	/* Bail on bad ptr */
+	if (!item) return 0;
+	/* Create new item */
+	newitem=cJSON_New_Item();
+	if (!newitem) return 0;
+	/* Copy over all vars */
+	newitem->type=item->type&(~cJSON_IsReference),newitem->valueint=item->valueint,newitem->valuedouble=item->valuedouble;
+	if (item->valuestring)	{newitem->valuestring=cJSON_strdup(item->valuestring);	if (!newitem->valuestring)	{cJSON_Delete(newitem);return 0;}}
+	if (item->string)		{newitem->string=cJSON_strdup(item->string);			if (!newitem->string)		{cJSON_Delete(newitem);return 0;}}
+	/* If non-recursive, then we're done! */
+	if (!recurse) return newitem;
+	/* Walk the ->next chain for the child. */
+	cptr=item->child;
+	while (cptr)
+	{
+		newchild=cJSON_Duplicate(cptr,1);		/* Duplicate (with recurse) each item in the ->next chain */
+		if (!newchild) {cJSON_Delete(newitem);return 0;}
+		if (nptr)	{nptr->next=newchild,newchild->prev=nptr;nptr=newchild;}	/* If newitem->child already set, then crosswire ->prev and ->next and move on */
+		else		{newitem->child=newchild;nptr=newchild;}					/* Set newitem->child and move to it */
+		cptr=cptr->next;
+	}
+	return newitem;
+}
+
+void cJSON_Minify(char *json)
+{
+	char *into=json;
+	while (*json)
+	{
+		if (*json==' ') json++;
+		else if (*json=='\t') json++;	/* Whitespace characters. */
+		else if (*json=='\r') json++;
+		else if (*json=='\n') json++;
+		else if (*json=='/' && json[1]=='/')  while (*json && *json!='\n') json++;	/* double-slash comments, to end of line. */
+		else if (*json=='/' && json[1]=='*') {while (*json && !(*json=='*' && json[1]=='/')) json++;json+=2;}	/* multiline comments. */
+		else if (*json=='\"'){*into++=*json++;while (*json && *json!='\"'){if (*json=='\\') *into++=*json++;*into++=*json++;}*into++=*json++;} /* string literals, which are \" sensitive. */
+		else *into++=*json++;			/* All other characters. */
+	}
+	*into=0;	/* and null-terminate. */
+}
diff --git a/examples/InvertedPendulum/cJSON/cJSON.h b/examples/InvertedPendulum/cJSON/cJSON.h
new file mode 100644
index 00000000..466d10db
--- /dev/null
+++ b/examples/InvertedPendulum/cJSON/cJSON.h
@@ -0,0 +1,149 @@
+/*
+  Copyright (c) 2009 Dave Gamble
+ 
+  Permission is hereby granted, free of charge, to any person obtaining a copy
+  of this software and associated documentation files (the "Software"), to deal
+  in the Software without restriction, including without limitation the rights
+  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+ 
+  The above copyright notice and this permission notice shall be included in
+  all copies or substantial portions of the Software.
+ 
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+  THE SOFTWARE.
+*/
+
+#ifndef cJSON__h
+#define cJSON__h
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* cJSON Types: */
+#define cJSON_False 0
+#define cJSON_True 1
+#define cJSON_NULL 2
+#define cJSON_Number 3
+#define cJSON_String 4
+#define cJSON_Array 5
+#define cJSON_Object 6
+	
+#define cJSON_IsReference 256
+#define cJSON_StringIsConst 512
+
+/* The cJSON structure: */
+typedef struct cJSON {
+	struct cJSON *next,*prev;	/* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
+	struct cJSON *child;		/* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
+
+	int type;					/* The type of the item, as above. */
+
+	char *valuestring;			/* The item's string, if type==cJSON_String */
+	int valueint;				/* The item's number, if type==cJSON_Number */
+	double valuedouble;			/* The item's number, if type==cJSON_Number */
+
+	char *string;				/* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
+} cJSON;
+
+typedef struct cJSON_Hooks {
+      void *(*malloc_fn)(size_t sz);
+      void (*free_fn)(void *ptr);
+} cJSON_Hooks;
+
+/* Supply malloc, realloc and free functions to cJSON */
+extern void cJSON_InitHooks(cJSON_Hooks* hooks);
+
+
+/* Supply a block of JSON, and this returns a cJSON object you can interrogate. Call cJSON_Delete when finished. */
+extern cJSON *cJSON_Parse(const char *value);
+/* Render a cJSON entity to text for transfer/storage. Free the char* when finished. */
+extern char  *cJSON_Print(cJSON *item);
+/* Render a cJSON entity to text for transfer/storage without any formatting. Free the char* when finished. */
+extern char  *cJSON_PrintUnformatted(cJSON *item);
+/* Render a cJSON entity to text using a buffered strategy. prebuffer is a guess at the final size. guessing well reduces reallocation. fmt=0 gives unformatted, =1 gives formatted */
+extern char *cJSON_PrintBuffered(cJSON *item,int prebuffer,int fmt);
+/* Delete a cJSON entity and all subentities. */
+extern void   cJSON_Delete(cJSON *c);
+
+/* Returns the number of items in an array (or object). */
+extern int	  cJSON_GetArraySize(cJSON *array);
+/* Retrieve item number "item" from array "array". Returns NULL if unsuccessful. */
+extern cJSON *cJSON_GetArrayItem(cJSON *array,int item);
+/* Get item "string" from object. Case insensitive. */
+extern cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);
+
+/* For analysing failed parses. This returns a pointer to the parse error. You'll probably need to look a few chars back to make sense of it. Defined when cJSON_Parse() returns 0. 0 when cJSON_Parse() succeeds. */
+extern const char *cJSON_GetErrorPtr(void);
+	
+/* These calls create a cJSON item of the appropriate type. */
+extern cJSON *cJSON_CreateNull(void);
+extern cJSON *cJSON_CreateTrue(void);
+extern cJSON *cJSON_CreateFalse(void);
+extern cJSON *cJSON_CreateBool(int b);
+extern cJSON *cJSON_CreateNumber(double num);
+extern cJSON *cJSON_CreateString(const char *string);
+extern cJSON *cJSON_CreateArray(void);
+extern cJSON *cJSON_CreateObject(void);
+
+/* These utilities create an Array of count items. */
+extern cJSON *cJSON_CreateIntArray(const int *numbers,int count);
+extern cJSON *cJSON_CreateFloatArray(const float *numbers,int count);
+extern cJSON *cJSON_CreateDoubleArray(const double *numbers,int count);
+extern cJSON *cJSON_CreateStringArray(const char **strings,int count);
+
+/* Append item to the specified array/object. */
+extern void cJSON_AddItemToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemToObject(cJSON *object,const char *string,cJSON *item);
+extern void	cJSON_AddItemToObjectCS(cJSON *object,const char *string,cJSON *item);	/* Use this when string is definitely const (i.e. a literal, or as good as), and will definitely survive the cJSON object */
+/* Append reference to item to the specified array/object. Use this when you want to add an existing cJSON to a new cJSON, but don't want to corrupt your existing cJSON. */
+extern void cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item);
+extern void	cJSON_AddItemReferenceToObject(cJSON *object,const char *string,cJSON *item);
+
+/* Remove/Detatch items from Arrays/Objects. */
+extern cJSON *cJSON_DetachItemFromArray(cJSON *array,int which);
+extern void   cJSON_DeleteItemFromArray(cJSON *array,int which);
+extern cJSON *cJSON_DetachItemFromObject(cJSON *object,const char *string);
+extern void   cJSON_DeleteItemFromObject(cJSON *object,const char *string);
+	
+/* Update array items. */
+extern void cJSON_InsertItemInArray(cJSON *array,int which,cJSON *newitem);	/* Shifts pre-existing items to the right. */
+extern void cJSON_ReplaceItemInArray(cJSON *array,int which,cJSON *newitem);
+extern void cJSON_ReplaceItemInObject(cJSON *object,const char *string,cJSON *newitem);
+
+/* Duplicate a cJSON item */
+extern cJSON *cJSON_Duplicate(cJSON *item,int recurse);
+/* Duplicate will create a new, identical cJSON item to the one you pass, in new memory that will
+need to be released. With recurse!=0, it will duplicate any children connected to the item.
+The item->next and ->prev pointers are always zero on return from Duplicate. */
+
+/* ParseWithOpts allows you to require (and check) that the JSON is null terminated, and to retrieve the pointer to the final byte parsed. */
+extern cJSON *cJSON_ParseWithOpts(const char *value,const char **return_parse_end,int require_null_terminated);
+
+extern void cJSON_Minify(char *json);
+
+/* Macros for creating things quickly. */
+#define cJSON_AddNullToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateNull())
+#define cJSON_AddTrueToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateTrue())
+#define cJSON_AddFalseToObject(object,name)		cJSON_AddItemToObject(object, name, cJSON_CreateFalse())
+#define cJSON_AddBoolToObject(object,name,b)	cJSON_AddItemToObject(object, name, cJSON_CreateBool(b))
+#define cJSON_AddNumberToObject(object,name,n)	cJSON_AddItemToObject(object, name, cJSON_CreateNumber(n))
+#define cJSON_AddStringToObject(object,name,s)	cJSON_AddItemToObject(object, name, cJSON_CreateString(s))
+
+/* When assigning an integer value, it needs to be propagated to valuedouble too. */
+#define cJSON_SetIntValue(object,val)			((object)?(object)->valueint=(object)->valuedouble=(val):(val))
+#define cJSON_SetNumberValue(object,val)		((object)?(object)->valueint=(object)->valuedouble=(val):(val))
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/examples/InvertedPendulum/configure.json b/examples/InvertedPendulum/configure.json
new file mode 100644
index 00000000..a28df2ff
--- /dev/null
+++ b/examples/InvertedPendulum/configure.json
@@ -0,0 +1,28 @@
+{
+    "name": "InvertedPendulum configure file",
+	"debug":1,
+	"init":{
+		"max_speed":8,
+		"mid_pos":1937600,
+		"mid_angle":3240,
+		"origin_angle":1200
+	},
+	"angle":{
+    	"P":300000,
+    	"I":0,
+    	"D":8000
+	},
+	"pos":{
+    	"P":30,
+    	"I":0,
+    	"D":770,
+		"div":2
+	},
+	"auto_run":{
+		"debug":0,
+		"pos_pid_mul":-4.0,
+		"tar_pos_mul":0.95,
+		"tar_pos_ratio":0.5,
+		"min_angle_speed":2.0
+	}
+}
diff --git a/examples/InvertedPendulum/def_config.h b/examples/InvertedPendulum/def_config.h
new file mode 100644
index 00000000..efeaaa14
--- /dev/null
+++ b/examples/InvertedPendulum/def_config.h
@@ -0,0 +1,20 @@
+#ifndef __ETHERCAT_CONFIG_H__
+#define __ETHERCAT_CONFIG_H__
+
+#define MEASURE_TIMING 
+#define SERVO_ETHERCAT_ENABLE
+#define SHARE_MEM
+#define MOTOR_CONTROL
+//#define DEBUG_CONSOLE_FS
+
+//#define MOTOR_8AXIS
+//#define MOTOR_6AXIS
+#define MOTOR_2AXIS
+
+#if (defined(MOTOR_8AXIS) && defined(MOTOR_6AXIS)) || \
+    (defined(MOTOR_8AXIS) && defined(MOTOR_2AXIS)) || \
+    (defined(MOTOR_6AXIS) && defined(MOTOR_2AXIS))
+#error "MOTOR_*AXIS macro have multiply definition, only one is supported!"
+#endif
+
+#endif
diff --git a/examples/InvertedPendulum/main.c b/examples/InvertedPendulum/main.c
new file mode 100644
index 00000000..ca8b06ef
--- /dev/null
+++ b/examples/InvertedPendulum/main.c
@@ -0,0 +1,993 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+#include "main.h"
+#include <getopt.h>
+#include "modbus_server/modbus_server.h"
+#include "cJSON/cJSON.h"
+
+#ifdef SHARE_MEM
+#define BUF_SIZE				0x1000
+#define BUF_READ_SIZE			0x0C00
+#define MOTOR_CTL_BUF_SIZE		0x0400
+#define MOTOR_STATUS_ADDRESS	0x0400
+#define MOTOR_CTL_ADDRESS		0x0C00
+char mem_buffer[BUF_READ_SIZE];
+char motor_ctl_buffer[MOTOR_CTL_BUF_SIZE];
+void *shm_addr = NULL;
+int shmid;
+#endif
+
+#ifdef MEASURE_TIMING
+static unsigned int measure_time = 0;
+static int64_t avg_cycle_time;
+static int64_t min_cycle_time;
+static int64_t max_cycle_time;
+static int64_t min_jitter_time;
+static int64_t max_jitter_time;
+#endif
+
+static bool motor_run = false;
+static bool modbus_run = false;
+static int circle_x = 0;
+static int circle_y = 0;
+static pthread_t cyclic_thread;
+static volatile int run = 1;
+static volatile int close_signal = 0;
+
+static ec_master_t *master = NULL;
+static ec_master_state_t master_state = {};
+static Slave_Data ec_slave0;
+
+static ec_domain_t *domain0 = NULL;
+static uint8_t *domain0_pd = NULL;
+static ec_slave_config_t *sc0;
+static unsigned int act_angle = 0;
+static int ec_angle = 0;
+static int ec_angle_filter = 0;
+
+static ec_domain_t *domain1 = NULL;
+static uint8_t *domain1_pd = NULL;
+static ec_slave_config_t *sc1;
+
+static run_way_t run_way = RUN_NULL;
+static int max_speed = 0;
+static int pid_debug = 0;
+static int mid_angle = 0;
+static int origin_angle = 0;
+static unsigned int mid_pos = 0;
+static int angle_P = 0;
+static int angle_I = 0;
+static int angle_D = 0;
+static int pos_P = 0;
+static int pos_I = 0;
+static int pos_D = 0;
+static int pos_div = 0;
+
+static int auto_run_debug = 0;
+static double pos_mul = 0.0;
+static double tar_pos_mul = 0.0;
+static double tar_pos_ratio = 0.0;
+static double min_angle_speed = 0.0;
+
+const static ec_pdo_entry_reg_t domain0_regs[] = {
+    {LAN9252_SLAVE00_Pos, LAN9252_SLAVE00_ID, 0x6020, 0x11, &act_angle, NULL},
+    {}
+};
+
+const static ec_pdo_entry_reg_t domain1_regs[] = {
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x6040, 0x00, &ec_slave0.ctrl_word, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x607a, 0x00, &ec_slave0.tar_pos, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60FF, 0x00, &ec_slave0.tar_vel, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x6060, 0x00, &ec_slave0.mode_sel, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60b8, 0x00, &ec_slave0.touch_probe_func, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x2002, 0x03, &ec_slave0.mode_cw, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x603f, 0x00, &ec_slave0.error_code, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x6041, 0x00, &ec_slave0.status_word, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x6064, 0x00, &ec_slave0.act_pos, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x606c, 0x00, &ec_slave0.act_vel, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x6061, 0x00, &ec_slave0.mode_display, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60b9, 0x00, &ec_slave0.touch_probe_status, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60ba, 0x00, &ec_slave0.touch_probe1_pos, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60bc, 0x00, &ec_slave0.touch_probe2_pos, NULL},
+    {IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID, 0x60fd, 0x00, &ec_slave0.digital_input, NULL},
+    {}
+};
+
+#ifdef SHARE_MEM
+static void write_buf_int16(char* dest,int16_t src)
+{
+	dest[1] = (char)(src>>8);
+	dest[0] = (char)(src);
+}
+
+static void write_buf_int32(char* dest,int32_t src)
+{
+	dest[3] = (char)(src>>8);
+	dest[2] = (char)(src);
+	dest[1] = (char)(src>>24);
+	dest[0] = (char)(src>>16);
+
+}
+
+static void write_buf_int64(char* dest,int64_t src)
+{
+	dest[7] = (char)(src>>8);
+	dest[6] = (char)(src);
+	dest[5] = (char)(src>>24);
+	dest[4] = (char)(src>>16);
+	dest[3] = (char)(src>>40);
+	dest[2] = (char)(src>>32);
+	dest[1] = (char)(src>>56);
+	dest[0] = (char)(src>>48);
+}
+
+static void write_sharemem_ctl_data(char* dest,unsigned short int offset,Ctl_Data *data)
+{
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x00,data->statusword);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x02,data->actualpos);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x06,data->cwmode);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x08,data->controlword);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x0a,data->targetpos);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x0e,data->selmode);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x10,data->actualvel);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x14,data->zeroposition);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x18,data->minposition);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x1c,data->maxposition);
+}
+#endif
+
+static void data_init(void)
+{
+    memset(&ec_slave0,0,sizeof(Slave_Data));
+    sc0 = NULL;
+    sc1 = NULL;
+#ifdef DEBUG_CONSOLE_FS
+    ec_slave0.fd = fopen(LEN0_FILE_NAME,"w+");
+#endif
+}
+
+#ifdef SERVO_ETHERCAT_ENABLE
+static void ec_slave_config_init(ec_slave_config_t *sc)
+{
+    /* Clear RxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 0); /*clear sm pdo 0x1c12*/
+    ecrt_slave_config_sdo8(sc, 0x1600, 0, 0); /*clear sm pdo 0x1600*/
+    /* Define RxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1600, 1, 0x60400010); /*0x6040:0/16bits, control word*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 2, 0x60600008); /*0x6060:0/8bits, modes of operation*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 3, 0x607A0020); /*0x607A:0/32bits, Target postion*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 4, 0x60B80010); /*0x60B8:0/32bits, Touch probe function*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 5, 0x20020010); /*0x2002:0/16bits, cw mode*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 6, 0x60FF0020); /*0x60FF:0/32bits, Target velocity*/
+    ecrt_slave_config_sdo8(sc, 0x1600, 0, 6); /*set number of RxPDO*/
+    ecrt_slave_config_sdo16(sc, 0x1C12, 1, 0x1600 ); /*list all RxPdo in 0x1600*/
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 1 ); /*set number of RxPDO*/
+    /* Clear TxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 0); /*clear sm pdo 0x1c12*/
+    ecrt_slave_config_sdo8(sc, 0x1A00, 0, 0); /*clear sm pdo 0x1A00*/
+    /* Define TxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1A00, 1, 0x60410010); /*0x6041:0/16bits, status word*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 2, 0x60610008); /*0x6061:0/8bits, modes of operation display*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 3, 0x60640020); /*0x6064:0/32bits, Position actual value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 4, 0x60B90010); /*0x60B9:0/16bits, Touch probe status*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 5, 0x60BA0020); /*0x60BA:0/32bits, Touch probe pos 1 pos value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 6, 0x60BC0020); /*0x60BC:0/32bits, Touch probe pos 2 pos value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 7, 0x603F0010); /*0x603F:0/16bits, Error code*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 8, 0x60FD0020); /*0x60FD:0/16bits, Digital inputs*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 9, 0x606C0020); /*0x606C:0/32bits, velocity actual value*/
+    ecrt_slave_config_sdo8(sc, 0x1A00, 0, 9); /*set number of TxPDO*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 1, 0x1A00 ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 1 ); /*set number of TxPDO*/
+}
+
+#ifdef SHARE_MEM
+static char sharemem_init(void)
+{
+    shmid = shmget((key_t)87654321, BUF_SIZE, IPC_CREAT|0666);
+    printf("shmid : %u\n", shmid);
+    if (shmid == -1){
+        perror("shmget error!");
+        return -1;
+    }
+    shm_addr = shmat(shmid, NULL, 0);
+    if (shm_addr == (void *) -1){
+        perror("shmat error!");
+        return -1;
+    }
+    return 0;
+}
+#endif
+
+void rt_check_master_state(void)
+{
+    ec_master_state_t ms;
+    ecrt_master_state(master, &ms);
+    if (ms.slaves_responding != master_state.slaves_responding)
+        printf("%u slave(s).\n", ms.slaves_responding);
+    if (ms.al_states != master_state.al_states)
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    if (ms.link_up != master_state.link_up)
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+    master_state = ms;
+}
+#endif
+
+#ifdef SERVO_ETHERCAT_ENABLE
+static void ec_readmotordata(Ctl_Data* ec_motor,Slave_Data ec_slave){
+    ec_motor->statusword 	= EC_READ_U16(domain1_pd + ec_slave.status_word);
+    ec_motor->actualpos  	= EC_READ_S32(domain1_pd + ec_slave.act_pos);
+    ec_motor->actualvel  	= EC_READ_S32(domain1_pd + ec_slave.act_vel);
+    ec_motor->cwmode     	= EC_READ_U16(domain1_pd + ec_slave.mode_cw);
+    ec_motor->selmode    	= EC_READ_S8(domain1_pd + ec_slave.mode_sel);
+    ec_motor->digitalinput	= (EC_READ_U32(domain1_pd + ec_slave.digital_input))&0x4;
+
+    if(ec_motor->actualvel > MAX_VELOCITY_MOTOR/2)
+        ec_motor->actualvel = ec_motor->actualvel - MAX_VELOCITY_MOTOR;
+
+    if ((ec_motor->statusword & 0x4f) == 0x40)
+        ec_motor->controlword = 0x6;
+    else if ((ec_motor->statusword & 0x6f) == 0x21)
+        ec_motor->controlword = 0x7;
+    else if ((ec_motor->statusword & 0x27f)==0x233){
+        ec_motor->prevpos = ec_motor->actualpos;
+        ec_motor->controlword = 0xf;
+    }
+    else if ((ec_motor->statusword & 0x27f)==0x237)
+        ec_motor->controlword = 0x1f;
+    else
+        ec_motor->controlword = 0x80;
+}
+
+static void ec_writemotordata(Ctl_Data* ec_motor,Slave_Data ec_slave){
+    EC_WRITE_S32(domain1_pd+ec_slave.tar_vel, ec_motor->targetvel );
+    EC_WRITE_U16(domain1_pd+ec_slave.ctrl_word, ec_motor->controlword );
+    if(ec_motor->targetvel == 0)
+        EC_WRITE_U8(domain1_pd+ec_slave.mode_sel, MODE_NULL );
+    else
+        EC_WRITE_U8(domain1_pd+ec_slave.mode_sel, MODE_CSV );
+    ec_motor->prevel = ec_motor->actualvel;
+}
+
+#define FILTERING_TIMES 4
+static int Mean_Filter(int sensor)
+{
+    int i;
+    int Sum_Speed = 0;
+    short int Filter_Speed;
+    static short int Speed_Buf[FILTERING_TIMES]={0};
+    for(i = 1 ; i<FILTERING_TIMES; i++)
+        Speed_Buf[i - 1] = Speed_Buf[i];
+
+    Speed_Buf[FILTERING_TIMES - 1] =sensor;
+
+    for(i = 0 ; i < FILTERING_TIMES; i++)
+        Sum_Speed += Speed_Buf[i];
+
+    Filter_Speed = (short int)(Sum_Speed / FILTERING_TIMES);
+    return Filter_Speed;
+}
+
+static void Get_Filter_Angle(void)
+{
+    static int cnt = 0;
+    static int last_ec_angle = 0;
+    if(++cnt>5){
+        ec_angle_filter = Mean_Filter(ec_angle - last_ec_angle);
+        last_ec_angle = ec_angle;
+        cnt=0;
+    }
+}
+
+//
+//
+static int angle_PID(int angle)
+{
+    static int Integral_bias,Last_Bias, D_Bias;
+    int Bias;
+    int balance;
+
+    Bias = angle;
+    D_Bias = Bias - Last_Bias;
+    Integral_bias += Bias;
+
+    balance = angle_P*Bias + angle_I*Integral_bias - angle_D*D_Bias;
+
+    Last_Bias = Bias;
+    return balance;
+}
+
+static int pos_PID(int Encoder)
+{
+    static int Position_Vel,Last_Position,Position_Bias,Position_Differential;
+    static int Position_Least;
+
+    Position_Least = Encoder - mid_pos;
+    Position_Bias *= 0.8;
+    Position_Bias += Position_Least*0.2;
+    Position_Differential = Position_Bias - Last_Position;
+
+    Position_Vel = (Position_Bias*pos_P + Position_Differential*pos_D)/pos_div;
+
+    Last_Position = Position_Bias;
+    return Position_Vel;
+}
+
+static int Position_PID (float ratio, int Encoder,int Target)
+{
+    static float Bias,Vel,Integral_bias,Last_Bias;
+    Bias = Encoder - Target;
+    Integral_bias += Bias;
+    
+    Vel = ratio*Bias*0.69 + 0.00*Integral_bias - 20*(Bias-Last_Bias);
+    
+    Last_Bias = Bias;
+    return pos_mul*Vel;
+}
+
+static int Auto_Run(int pos)
+{
+    static float Ratio_Count = 0;
+    static int valid_cnt = 0;
+    static int Inverted_Flag = 0;
+    static int Run_Way_Flag2 = 0;
+    float Ratio = 1;
+    static int vel = 0;
+    static int target_pos = 0;
+
+    if(Inverted_Flag == 0)
+    {
+        Ratio_Count++;
+        if(Ratio_Count > 1000)
+            Ratio = 1 + (Ratio_Count - 1000)/5000;
+        if(Ratio > 2)
+            Ratio = 2;
+
+        if(ec_angle_filter > (-1)*min_angle_speed && ec_angle_filter < min_angle_speed && Run_Way_Flag2 == 1)
+        {
+            if(ec_angle > origin_angle && ec_angle < mid_angle)
+                target_pos = mid_pos + PER_CIRCLE_ENCODER*tar_pos_mul;
+            else
+                target_pos = mid_pos - PER_CIRCLE_ENCODER*tar_pos_mul;
+            Run_Way_Flag2 = 0;
+        }
+        if(Run_Way_Flag2 == 0)
+            if(ec_angle > (origin_angle - 300) && ec_angle < (origin_angle + 300))
+                Run_Way_Flag2 = 1;
+
+        vel = Position_PID(Ratio, pos, target_pos);
+
+        if(ec_angle < (mid_angle + 150) && 
+           ec_angle > (mid_angle - 150) && 
+           (pos > PER_CIRCLE_ENCODER*tar_pos_ratio && pos < PER_CIRCLE_ENCODER*(4-tar_pos_ratio)))
+            valid_cnt++;
+        else
+            valid_cnt = 0;
+        if(valid_cnt > 8)
+        {
+            run_way = RUN_MANUAL;
+            printf("Auto Run OK  \n");
+//            Inverted_Flag=1;//  
+        }
+    }
+    
+    if(auto_run_debug)
+        printf("pos:%07d, tar_pos:%07d, vel:%10.3f, ec_angle_filter:%03d, mode:%d, angle:%d, valid:%d\n",
+                pos,
+                target_pos,
+                vel/(float)PER_CIRCLE_ENCODER,
+                ec_angle_filter,
+                Run_Way_Flag2,
+                ec_angle,
+                valid_cnt
+                );
+    return vel;
+
+#if 0
+    else if(Inverted_Flag == 1)// 
+    {
+        Balance_Pwm = balance(Angle_Balance - ANGLE_MIDDLE);//PD
+        if(Inverted_Count++ < 30)//100ms
+            Position_Zero = position_A;
+        else if(++Position_Target > 4)
+            Position_Pwm = Position(position_A),Position_Target=0;
+        if(Inverted_Count > 500 && Inverted_Count < 1200)// 
+        {
+            if(Position_Zero > 220000)
+                Position_Zero -= 20;
+            if(Position_Zero < 220000)
+                Position_Zero += 20;
+        }
+        if(Inverted_Count > 200)
+            Basics_Position_KD = 200;
+        Moto = Balance_Pwm-Position_Pwm; //PDPWM
+    }
+#endif
+}
+
+#endif
+
+static bool load_json(void)
+{
+    long len = 0;
+    char *out = NULL;
+    FILE *fp = fopen("configure.json","r");
+    if(fp == NULL)
+        return false;
+    fseek(fp,0,SEEK_END);
+    len = ftell(fp);
+    out = (char*)malloc(len+1);
+    if(out == NULL){
+        fclose(fp);
+        return false;
+    }
+    fseek(fp,0,SEEK_SET);
+    if(fread(out,1,len,fp) != len)
+    {
+        fclose(fp);
+        free(out);
+        return false;
+    }
+    out[len] = 0;
+    fclose(fp);
+
+    cJSON* root = cJSON_Parse(out);
+    if(root == NULL)
+    {
+        printf("error:%s\n",cJSON_GetErrorPtr());
+        cJSON_Delete(root);
+        free(out);
+        return false;
+    }
+
+    pid_debug        = cJSON_GetObjectItem(root,"debug")->valueint;
+
+    cJSON* init_json = cJSON_GetObjectItem(root,"init");
+    max_speed        = cJSON_GetObjectItem(init_json,"max_speed")->valueint*0x100000;
+    mid_pos          = cJSON_GetObjectItem(init_json,"mid_pos")->valueint;
+    mid_angle        = cJSON_GetObjectItem(init_json,"mid_angle")->valueint;
+    origin_angle     = cJSON_GetObjectItem(init_json,"origin_angle")->valueint;
+
+    cJSON* angle_json = cJSON_GetObjectItem(root,"angle");
+    angle_P           = cJSON_GetObjectItem(angle_json,"P")->valueint;
+    angle_I           = cJSON_GetObjectItem(angle_json,"I")->valueint;
+    angle_D           = cJSON_GetObjectItem(angle_json,"D")->valueint;
+
+    cJSON* pos_json = cJSON_GetObjectItem(root,"pos");
+    pos_P           = cJSON_GetObjectItem(pos_json,"P")->valueint;
+    pos_I           = cJSON_GetObjectItem(pos_json,"I")->valueint;
+    pos_D           = cJSON_GetObjectItem(pos_json,"D")->valueint;
+    pos_div         = cJSON_GetObjectItem(pos_json,"div")->valueint;
+
+    cJSON* auto_json = cJSON_GetObjectItem(root,"auto_run");
+    auto_run_debug   = cJSON_GetObjectItem(auto_json,"debug")->valuedouble;
+    pos_mul          = cJSON_GetObjectItem(auto_json,"pos_pid_mul")->valuedouble;
+    tar_pos_mul      = cJSON_GetObjectItem(auto_json,"tar_pos_mul")->valuedouble;
+    tar_pos_ratio    = cJSON_GetObjectItem(auto_json,"tar_pos_ratio")->valuedouble;
+    min_angle_speed  = cJSON_GetObjectItem(auto_json,"min_angle_speed")->valuedouble;
+
+    cJSON_Delete(root);
+    free(out);
+
+    printf("*** load json ***\n");
+    printf("pid_debug      :  %d \n",pid_debug);
+    printf("max_speed      :  0x%x \n",max_speed);
+    printf("origin_angle   :  %d \n",origin_angle);
+    printf("mid_angle      :  %d \n",mid_angle);
+    printf("mid_pos        :  %d \n",mid_pos);
+    printf("angle          :  P %d,I %d,D %d \n",angle_P,angle_I,angle_D);
+    printf("position       :  P %d,I %d,D %d \n",pos_P,pos_I,pos_D);
+    printf("pos_div        :  %d \n",pos_div);
+    printf("auto_debug     :  %d \n",auto_run_debug);
+    printf("pos_mul        :  %f \n",pos_mul);
+    printf("tar_pos_mul    :  %f \n",tar_pos_mul);
+    printf("tar_pos_ratio  :  %f \n",tar_pos_ratio);
+    printf("min_angle_speed:  %f \n",min_angle_speed);
+
+    return true;
+}
+
+void *my_thread(void *arg)
+{
+    struct timespec next_period, dc_period;
+    unsigned int cycle_counter = 0;
+    unsigned int cycle_counter_max_cycle = 0;
+    unsigned int cycle_counter_max_jitter = 0;
+    static unsigned int last_cycle_counter = 0;
+    uint8_t servo_run = 0;
+    Ctl_Data ec_motor0;
+    motor_state_t motor_state = MOTOR_RUN;
+
+#ifdef MEASURE_TIMING
+    struct timespec startTime, endTime, lastStartTime, rece_startTime, rece_endTime, 
+                    pro_endTime, send_startTime, send_endTime, sharememTime = {};
+    int64_t period_ns = 0, exec_ns = 0, receive_ns = 0, process_ns = 0, send_ns = 0, 
+            motor_ns = 0, other_ns = 0, sharemem_ns = 0, 
+            period_min_ns = 1000000, period_max_ns = 0,exec_min_ns = 1000000, exec_max_ns = 0;
+    int64_t latency_ns = 0;
+    int64_t latency_min_ns = 1000000, latency_max_ns = -1000000;
+    int64_t total_exec_ns=0;
+    int64_t total_cycle_ns=0;
+    static int64_t max_cycle_persec=0,max_jitter_persec=0;
+    avg_cycle_time = 0;
+    min_cycle_time = 1000000;
+    max_cycle_time = -1000000;
+    min_jitter_time = 1000000;
+    max_jitter_time = -1000000;
+#endif
+    struct sched_param param = {.sched_priority = 99};
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+    clock_gettime(CLOCK_MONOTONIC, &next_period);
+#ifdef MEASURE_TIMING
+    lastStartTime = next_period;
+    endTime = next_period;
+#endif
+    if(motor_run == false)
+        motor_state = MOTOR_STOP;
+    memset(&ec_motor0,0,sizeof(Ctl_Data));
+
+    while ((run != 0 )||(close_signal != 0)) {
+        next_period.tv_nsec += CYCLE_US * 1000;
+        while (next_period.tv_nsec >= NSEC_PER_SEC) {
+            next_period.tv_nsec -= NSEC_PER_SEC;
+            next_period.tv_sec++;
+        }
+        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_period, NULL);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &startTime);
+        latency_ns = DIFF_NS(next_period, startTime);
+        period_ns = DIFF_NS(lastStartTime, startTime);
+        exec_ns = DIFF_NS(lastStartTime, endTime);
+        receive_ns = DIFF_NS(rece_startTime, rece_endTime);
+        process_ns = DIFF_NS(rece_endTime, pro_endTime);
+        send_ns = DIFF_NS(send_startTime, send_endTime);
+        motor_ns = DIFF_NS(pro_endTime, dc_period);
+        other_ns = DIFF_NS(dc_period, send_startTime);
+        sharemem_ns = DIFF_NS(endTime, sharememTime);
+        lastStartTime = startTime;
+
+        if (latency_ns > latency_max_ns) 
+            latency_max_ns = latency_ns;
+        if (latency_ns < latency_min_ns)
+            latency_min_ns = latency_ns;
+        if (period_ns > period_max_ns)
+            period_max_ns = period_ns;
+        if (period_ns < period_min_ns)
+            period_min_ns = period_ns;
+        if (exec_ns > exec_max_ns)
+            exec_max_ns = exec_ns;
+        if (exec_ns < exec_min_ns)
+            exec_min_ns = exec_ns;
+        total_exec_ns += exec_ns;
+#endif
+        cycle_counter++;
+	    if(close_signal > 0)
+		    close_signal--;
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &rece_startTime);
+#endif
+#ifdef SERVO_ETHERCAT_ENABLE
+        ecrt_master_receive(master);
+#endif
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &rece_endTime);
+#endif
+        ecrt_domain_process(domain0);
+        ecrt_domain_process(domain1);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &pro_endTime);
+#endif
+        if ((!(cycle_counter % CYCLE_COUNTER_PERSEC))&&(close_signal==0)) {
+#ifdef SERVO_ETHERCAT_ENABLE
+	        rt_check_master_state();
+#endif
+#ifdef MEASURE_TIMING
+            if(min_cycle_time > exec_min_ns)
+                min_cycle_time = exec_min_ns;
+            if(max_cycle_time < exec_max_ns){
+                cycle_counter_max_cycle = cycle_counter;
+                max_cycle_time = exec_max_ns;
+            }
+            if(min_jitter_time > latency_min_ns)
+                min_jitter_time = latency_min_ns;
+            if(max_jitter_time < latency_max_ns){
+                cycle_counter_max_jitter = cycle_counter;
+                max_jitter_time = latency_max_ns;
+            }
+            last_cycle_counter = cycle_counter;
+            max_cycle_persec = exec_max_ns;
+            max_jitter_persec = latency_max_ns;
+            period_max_ns = -1000000;
+            period_min_ns = 1000000;
+            exec_max_ns = -1000000;
+            exec_min_ns = 1000000;
+            latency_max_ns = -1000000;
+            latency_min_ns = 1000000;
+            total_cycle_ns += total_exec_ns;
+            total_exec_ns = 0;
+            if(servo_run == 0){
+                cycle_counter = 0;
+                total_cycle_ns = 0;
+                min_jitter_time = 1000000;
+                max_jitter_time = -1000000;
+                min_cycle_time = 1000000;
+                max_cycle_time = -1000000;
+                servo_run = 1;
+            }
+#endif
+        }
+#ifdef SERVO_ETHERCAT_ENABLE
+        ec_readmotordata(&ec_motor0,ec_slave0);
+        ec_angle = EC_READ_U16(domain0_pd + act_angle);
+
+        if (ec_motor0.controlword == 0x1f){
+            if(run_way == RUN_NULL){
+                if((ec_angle > (mid_angle + 500))||(ec_angle < (mid_angle - 500)))
+                    run_way = RUN_AUTO;
+                else
+                    run_way = RUN_MANUAL;
+            }
+            if(motor_state == MOTOR_RUN){
+                Get_Filter_Angle();
+                if(run_way == RUN_AUTO){
+                    ec_motor0.targetvel = Auto_Run(ec_motor0.actualpos);
+                }
+                else if(run_way == RUN_MANUAL){
+                    static int pos_cnt = 0;
+                    static int angle_vel = 0;
+                    static int pos_vel = 0;
+                    if(cycle_counter > 1000000/CYCLE_US){
+                        angle_vel = angle_PID(ec_angle - mid_angle);
+                        if(++pos_cnt > 4){
+                            pos_cnt = 0;
+                            pos_vel = pos_PID(ec_motor0.actualpos);
+                        }
+                        ec_motor0.targetvel = angle_vel + pos_vel;
+
+                        if (pid_debug)
+                            printf("%10.3f, %10.3f, %10.3f, %10.3f, %10.3f, %ld\n",
+                                (ec_angle-mid_angle)/4096.0*360.0,
+                                (angle_vel)/(float)PER_CIRCLE_ENCODER,
+                                (pos_vel)/(float)PER_CIRCLE_ENCODER,
+                                ec_motor0.targetvel/(float)PER_CIRCLE_ENCODER,
+                                ec_motor0.actualvel/(float)PER_CIRCLE_ENCODER,
+                                ec_motor0.actualpos);
+                    }
+                }
+                if(ec_motor0.targetvel > max_speed)
+                    ec_motor0.targetvel = max_speed;
+                else if(ec_motor0.targetvel < (-1)*max_speed)
+                    ec_motor0.targetvel = (-1)*max_speed;
+                ec_writemotordata(&ec_motor0,ec_slave0);
+                if(motor_run == false)
+                    motor_state = MOTOR_STOP;
+            }
+        }else{
+            EC_WRITE_U16(domain1_pd+ec_slave0.ctrl_word, ec_motor0.controlword );
+            EC_WRITE_U8(domain1_pd+ec_slave0.mode_sel, MODE_NULL );
+        }
+
+        clock_gettime(CLOCK_MONOTONIC, &dc_period);
+        ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+        ecrt_master_sync_reference_clock(master);
+        ecrt_master_sync_slave_clocks(master);
+        ecrt_domain_queue(domain0);
+        ecrt_domain_queue(domain1);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &send_startTime);
+#endif
+        ecrt_master_send(master);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &send_endTime);
+#endif
+#endif
+#ifdef MEASURE_TIMING
+    	clock_gettime(CLOCK_MONOTONIC, &endTime);
+#endif
+#ifdef SHARE_MEM
+	    if(cycle_counter > 1){
+	        memset(mem_buffer,0,BUF_READ_SIZE);
+	        write_buf_int64(mem_buffer,period_ns);
+	        write_buf_int64(mem_buffer+8,max_cycle_persec);
+	        write_buf_int64(mem_buffer+16,max_jitter_persec);
+	        write_buf_int32(mem_buffer+24,cycle_counter);
+	        write_buf_int32(mem_buffer+28,circle_x);
+	        write_buf_int32(mem_buffer+32,circle_y);
+	        write_buf_int64(mem_buffer+36,min_cycle_time);
+	        write_buf_int64(mem_buffer+44,max_cycle_time);
+	        write_buf_int64(mem_buffer+52,min_jitter_time);
+	        write_buf_int64(mem_buffer+60,max_jitter_time);
+	        write_buf_int32(mem_buffer+68,cycle_counter_max_cycle);
+	        write_buf_int32(mem_buffer+72,cycle_counter_max_jitter);
+	        write_buf_int64(mem_buffer+76,receive_ns);
+	        write_buf_int64(mem_buffer+84,process_ns);
+	        write_buf_int64(mem_buffer+92,send_ns);
+	        write_buf_int64(mem_buffer+100,motor_ns);
+	        write_buf_int64(mem_buffer+108,other_ns);
+	        write_buf_int64(mem_buffer+116,sharemem_ns);
+            write_sharemem_ctl_data(mem_buffer,0x00,&ec_motor0);
+            memcpy(motor_ctl_buffer, (pthread_mutex_t *)(shm_addr+MOTOR_CTL_ADDRESS), MOTOR_CTL_BUF_SIZE);
+            memset((pthread_mutex_t *)(shm_addr+MOTOR_CTL_ADDRESS), 0xff,MOTOR_CTL_BUF_SIZE);
+            memcpy((pthread_mutex_t *)shm_addr, mem_buffer, BUF_READ_SIZE);
+	    }
+	    else
+	        memset((pthread_mutex_t *)shm_addr, 0, BUF_SIZE);
+#ifdef MOTOR_CONTROL
+	    if(cycle_counter > 1000){
+	        //motor start/stop
+	        if(motor_ctl_buffer[0x01] == MOTOR_RUN)
+	    	    motor_state = MOTOR_RUN;
+	        else if(motor_ctl_buffer[0x01] == MOTOR_STOP)
+		        motor_state = MOTOR_STOP;
+#endif
+	    }
+#endif
+#ifdef MEASURE_TIMING
+    	clock_gettime(CLOCK_MONOTONIC, &sharememTime);
+#endif
+#ifdef MEASURE_TIMING
+	    if(measure_time != 0)
+		    if(cycle_counter >= measure_time)
+	    		run = 0;
+#endif
+    }
+#ifdef MEASURE_TIMING
+    avg_cycle_time = total_cycle_ns/last_cycle_counter;
+    printf("*********************************************\n");
+    printf("average cycle time  %10.3f\n", (float)avg_cycle_time/1000);
+    printf("cycle counter       %10d\n", last_cycle_counter);
+    printf("cycle time          %10.3f ... %10.3f\n", (float)min_cycle_time/1000, (float)max_cycle_time/1000);
+    printf("jitter time         %10.3f ... %10.3f\n", (float)min_jitter_time/1000, (float)max_jitter_time/1000);
+    printf("*********************************************\n");
+#endif
+    return NULL;
+}
+
+void signal_handler(int sig)
+{
+    run = 0;
+    close_signal = 1000000/CYCLE_US; //1s
+}
+
+static void getOptions(int argc, char **argv)
+{
+    int index;
+    static struct option longOptions[] = {
+		//name		has_arg				flag	val
+		{"modbus",	no_argument,		NULL,	'm'},
+		{"run",		no_argument,		NULL,	'r'},
+		{"time",	required_argument,	NULL,	't'},
+		{"help",	no_argument,		NULL,	'h'},
+		{}
+    };
+    do{
+	index = getopt_long(argc, argv, "t:hmr", longOptions, NULL);
+	switch(index){
+		case 'm':
+			modbus_run = true;
+			printf("create modbus server \n");
+			break;
+		case 'r':
+			motor_run = true;
+			printf("run:true\n");
+			break;
+	    case 't':
+			measure_time = atoi(optarg);
+			printf("measure time: %d min\n",measure_time);
+			measure_time = measure_time*60*(1000000/CYCLE_US);
+			break;
+	    case 'h':
+			printf("Global options:\n");
+			printf("  --modbus -m  Open modbus server.\n");
+			printf("  --run	   -r  Motor start running.\n");
+			printf("  --time   -t  Set measure time for minutes.\n");		
+			printf("  --help   -h  Show this help.\n");
+			printf("default  time:10 min\n");
+			exit(0);
+			break;
+	    default:
+			break;
+		}
+    }
+    while(index != -1);
+}
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+    struct timespec dc_period;
+    int ret;
+
+    getOptions(argc,argv);
+    data_init();
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+#ifdef SERVO_ETHERCAT_ENABLE
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0);
+    if (!master) {
+        return -1;
+    }
+
+    printf("Creating domain ...\n");
+    domain0 = ecrt_master_create_domain(master);
+    if (!domain0){
+        return -1;
+    }
+    domain1 = ecrt_master_create_domain(master);
+    if (!domain1){
+        return -1;
+    }
+
+    // Create configuration for bus coupler
+    sc0 = ecrt_master_slave_config(master, LAN9252_SLAVE00_Pos, LAN9252_SLAVE00_ID);
+    if (!sc0) {
+        printf("Slave0 sc is NULL \n");
+        return -1;
+    }
+    sc1 = ecrt_master_slave_config(master, IS620N_SLAVE00_Pos, IS620N_SLAVE00_ID);
+    if (!sc1) {
+        printf("Slave1 sc is NULL \n");
+        return -1;
+    }
+
+    printf("Creating slave configurations...\n");
+    ec_slave_config_init(sc1);
+
+
+/*
+    if (ecrt_slave_config_pdos(sc0, EC_END, slave0_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  0 \n");
+        return -1;
+    }
+    */
+    if (ecrt_slave_config_pdos(sc1, EC_END, slave1_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  1 \n");
+        return -1;
+    }
+
+    ecrt_master_set_send_interval(master, CYCLE_US);
+
+    if (ecrt_domain_reg_pdo_entry_list(domain0, domain0_regs)) {
+        fprintf(stderr, "PDO 0 entry registration failed!\n");
+        return -1;
+    }
+    if (ecrt_domain_reg_pdo_entry_list(domain1, domain1_regs)) {
+        fprintf(stderr, "PDO 1 entry registration failed!\n");
+        return -1;
+    }
+
+    ecrt_slave_config_sdo8(sc1, 0x6060, 0x00, MODE_CSV);
+    ecrt_slave_config_sdo16(sc1, 0x2002, 0x03, 1);
+
+    /*Configuring DC signal*/
+    ecrt_slave_config_dc(sc0, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(sc1, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+
+    /* Set the initial master time and select a slave to use as the DC
+     * reference clock, otherwise pass NULL to auto select the first capable
+     * slave. Note: This can be used whether the master or the ref slave will
+     * be used as the systems master DC clock
+    */
+    clock_gettime(CLOCK_MONOTONIC, &dc_period);
+
+    /* Attention: The initial application time is also used for phase
+     * calcuation for the SYNC0/1 interrupts. Please be sure to call it at
+     * the correct phase to the realtime cycle
+    */
+    ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+
+    ret = ecrt_master_select_reference_clock(master, sc1);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to select reference clock: %s\n",strerror(-ret));
+        return ret;
+    }
+
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    if (!(domain0_pd = ecrt_domain_data(domain0))) {
+        fprintf(stderr, "Failed to get domain0 data pointer.\n");
+        return -1;
+    }
+    if (!(domain1_pd = ecrt_domain_data(domain1))) {
+        fprintf(stderr, "Failed to get domain1 data pointer.\n");
+        return -1;
+    }
+#endif
+
+#ifdef SHARE_MEM
+    if(sharemem_init() == -1)
+        return -1;
+#endif
+
+    if(load_json() == false)
+        return -1;
+
+	if(modbus_run == true)
+		modbus_server_create_entry();
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t thattr;
+    pthread_attr_init(&thattr);
+    pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+
+    if (pthread_create(&cyclic_thread, &thattr, &my_thread, NULL)) {
+        fprintf(stderr, "pthread_create cyclic task failed\n");
+		return 1;
+    }
+
+    while (run || close_signal != 0) {
+	    sched_yield();
+    }
+
+	if(modbus_run == true)
+		modbus_server_exit_entry();
+    pthread_join(cyclic_thread, NULL);
+
+#ifdef SERVO_ETHERCAT_ENABLE
+    ecrt_slave_config_sdo16(sc1, 0x6040, 0x00, 0x100);
+    printf("End of Program\n");
+    ecrt_release_master(master);
+#endif
+
+#ifdef SHARE_MEM
+    if (shmdt(shm_addr) == -1){
+        printf("shmdt error!\n");
+        exit(1);
+    }
+#endif
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/InvertedPendulum/main.h b/examples/InvertedPendulum/main.h
new file mode 100644
index 00000000..156c0d3f
--- /dev/null
+++ b/examples/InvertedPendulum/main.h
@@ -0,0 +1,140 @@
+#ifndef __ETHERCAT_6AIXS_MAIN_H__
+#define __ETHERCAT_6AIXS_MAIN_H__
+
+#include <stdio.h>
+#include "ecrt.h"
+#include "def_config.h"
+
+#define DEBUG_FILE_NAME  	    "debug.txt"
+#define CYCLE_US    		    1000
+#define PERIOD_NS   		    (CYCLE_US*1000)
+#define NSEC_PER_SEC    	    (1000000000L)
+#define TIMESPEC2NS(T)  	    ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DIFF_NS(A,B)    	    (((B).tv_sec - (A).tv_sec)*NSEC_PER_SEC + ((B).tv_nsec)-(A).tv_nsec)
+#define CYCLE_COUNTER_PERSEC    (NSEC_PER_SEC/PERIOD_NS)
+
+// process data
+#define LAN9252_SLAVE00_Pos  	0, 0
+#define LAN9252_SLAVE00_ID   	0x00000009, 0x00009252
+
+#define IS620N_SLAVE00_Pos  	0, 1
+#define IS620N_SLAVE00_ID   	0x00100000, 0x000c0108
+
+#define Pi                      3.141592654
+#define PER_CIRCLE_ENCODER      0x100000
+#define MAX_VELOCITY_MOTOR		0x66665f92
+
+enum{
+    MODE_PP     = 1,
+    MODE_PV     = 3,
+    MODE_PT     = 4,
+    MODE_NULL   = 5,
+    MODE_HM     = 6,
+    MODE_IP     = 7,
+    MODE_CSP    = 8,   //
+    MODE_CSV    = 9,   //
+    MODE_CST    = 10   //
+};
+
+typedef enum{
+	MOTOR_START = 0,
+	MOTOR_RUN,
+	MOTOR_STOP
+}motor_state_t;
+
+typedef enum{
+    RUN_NULL = 0,
+    RUN_AUTO,
+    RUN_MANUAL
+}run_way_t;
+
+typedef enum{
+	GO_HOME = 0,
+	GO_MINIMUM,
+	GO_HOME_FINISH
+}go_home_t;
+
+typedef struct{
+    FILE *fd;
+    unsigned int ctrl_word;
+    unsigned int mode_sel;
+    unsigned int tar_pos;
+    unsigned int act_pos;
+    unsigned int tar_vel;
+    unsigned int act_vel;
+    unsigned int touch_probe_func;
+    unsigned int error_code;
+    unsigned int status_word;
+    unsigned int mode_display;
+    unsigned int touch_probe_status;
+    unsigned int touch_probe1_pos;
+    unsigned int touch_probe2_pos;
+    unsigned int digital_input;
+    unsigned int mode_cw;
+}Slave_Data;
+
+typedef struct{
+    unsigned short statusword;
+    unsigned short controlword;
+    unsigned long prevpos;
+    unsigned long actualpos;
+    unsigned long targetpos;
+    int prevel;
+    int actualvel;
+    int targetvel;
+    unsigned short cwmode;
+    unsigned int digitalinput;
+    char selmode;
+    go_home_t gohome_history;
+    int zeroposition;
+    int minposition;
+    int maxposition;
+}Ctl_Data;
+
+ec_pdo_entry_info_t slave0_pdo_entries[] = {
+	{0x6020, 0x11, 16}
+};
+
+ec_pdo_info_t slave0_pdos[] = {
+   {0x1a02, 1, slave0_pdo_entries + 0}
+};
+
+ec_sync_info_t slave0_syncs[] = {
+   {0, EC_DIR_INPUT, 1, slave0_pdos + 0, EC_WD_DISABLE},
+   {0xff}
+};
+
+ec_pdo_entry_info_t slave1_pdo_entries[] = {
+	{0x6040, 0x00, 16},
+	{0x607A, 0x00, 32},
+	{0x60FF, 0x00, 32},
+	{0x6060, 0x00, 8},
+	{0x60B8, 0x00, 16},
+	{0x2002, 0x03, 16},
+	{0x603F, 0x00, 16},
+	{0x6041, 0x00, 16},
+	{0x6064, 0x00, 32},
+	{0x6061, 0x00, 8},
+	{0x60B9, 0x00, 16},
+	{0x60BA, 0x00, 32},
+	{0x60BC, 0x00, 32},
+	{0x60FD, 0x00, 32},
+	{0x606C, 0x00, 32},
+};
+
+ec_pdo_info_t slave1_pdos[] = {
+   {0x1600, 6, slave1_pdo_entries + 0},
+   {0x1a00, 9, slave1_pdo_entries + 6},
+};
+
+ec_sync_info_t slave1_syncs[] = {
+   {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+   {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+   {2, EC_DIR_OUTPUT, 1, slave1_pdos + 0, EC_WD_ENABLE},
+   {3, EC_DIR_INPUT, 1, slave1_pdos + 1, EC_WD_DISABLE},
+   {0xff}
+};
+
+
+#endif
+
diff --git a/examples/InvertedPendulum/modbus_server/README b/examples/InvertedPendulum/modbus_server/README
new file mode 100644
index 00000000..ffceb524
--- /dev/null
+++ b/examples/InvertedPendulum/modbus_server/README
@@ -0,0 +1,30 @@
+------------------------------------------------------------------------------
+
+This is the README file of the modbus server.
+
+------------------------------------------------------------------------------
+
+Contents:
+1) Requirements
+2) Building
+
+------------------------------------------------------------------------------
+
+1) Requirements
+===============
+
+gcc
+
+libmodbus-3.0.6
+
+------------------------------------------------------------------------------
+
+2) Building
+==========================
+
+-L/usr/local/lib/ -lmodbus
+
+sudo make
+
+------------------------------------------------------------------------------
+
diff --git a/examples/InvertedPendulum/modbus_server/modbus_server.c b/examples/InvertedPendulum/modbus_server/modbus_server.c
new file mode 100644
index 00000000..cae2c439
--- /dev/null
+++ b/examples/InvertedPendulum/modbus_server/modbus_server.c
@@ -0,0 +1,289 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <getopt.h>
+#include "/usr/local/include/modbus/modbus.h"
+#include "modbus_server.h"
+
+//#define LOCK_OPEN
+
+#define _FC_READ_COILS                0x01
+#define _FC_READ_DISCRETE_INPUTS      0x02
+#define _FC_READ_HOLDING_REGISTERS    0x03
+#define _FC_READ_INPUT_REGISTERS      0x04
+#define _FC_WRITE_SINGLE_COIL         0x05
+#define _FC_WRITE_SINGLE_REGISTER     0x06
+#define _FC_READ_EXCEPTION_STATUS     0x07
+#define _FC_WRITE_MULTIPLE_COILS      0x0F
+#define _FC_WRITE_MULTIPLE_REGISTERS  0x10
+#define _FC_REPORT_SLAVE_ID           0x11
+#define _FC_WRITE_AND_READ_REGISTERS  0x17
+
+static int server_socket;
+static modbus_t *ctx = NULL;
+static modbus_mapping_t *mb_mapping = NULL;
+static void *shm_addr = NULL;
+static int shmid;
+#ifdef LOCK_OPEN
+static pthread_mutex_t *sharedlock;
+#endif
+
+// option variables
+static int modbus_max_num_client = 5;
+static bool modbus_debug = false;
+static key_t shm_key = 87654321;
+static int modbus_port = 502;
+static int shm_size = 4096;
+static char modbus_address[18]; 
+
+//multi-thread
+static pthread_t modbus_thread;
+
+static void modbus_data_proc(uint8_t *data,int len)
+{
+	if((data == NULL)||(len == 0)){
+		if(modbus_debug)
+			printf("data recv error! len:%d \n",len);
+		return;
+	}
+	int offset = 7;
+	int function = data[offset];
+	uint16_t address = ((uint16_t)data[offset + 1] << 8) + data[offset + 2];
+	if(address > shm_size/2)
+	{
+		printf("address error! :0x%x \n",address);
+		return;
+	}
+	if(modbus_debug){
+		if(data[7] == 0x06){
+			unsigned short int modbus_recv_data = (data[10]<<8) | data[11];
+			printf("recv data: 0x%04x ,len: %d  \n",modbus_recv_data,len);
+		}
+	}
+	switch(function){
+		case _FC_READ_COILS:{
+			if(modbus_debug)
+				printf("_FC_READ_COILS \n");
+			break;
+			}
+        case _FC_READ_DISCRETE_INPUTS:{
+			if(modbus_debug)
+				printf("_FC_READ_DISCRETE_INPUTS \n");
+			break;
+			}
+        case _FC_READ_HOLDING_REGISTERS:{
+			modbus_reply(ctx, data, len, mb_mapping);
+			break;
+			}
+        case _FC_READ_INPUT_REGISTERS:{
+			if(modbus_debug)
+				printf("_FC_READ_INPUT_REGISTERS \n");
+			break;
+			}
+        case _FC_WRITE_SINGLE_COIL:{
+			if(modbus_debug)
+				printf("_FC_WRITE_SINGLE_COIL \n");
+			break;
+			}
+        case _FC_WRITE_SINGLE_REGISTER:{
+			if(modbus_debug)
+				printf("_FC_WRITE_SINGLE_REGISTER,len:%d,address:0x%x \n",len,address);
+			modbus_reply(ctx, data, len, mb_mapping);
+#ifdef LOCK_OPEN
+			pthread_mutex_lock(sharedlock);
+#endif
+			memmove(shm_addr+address*2,data+offset+3,2);
+#ifdef LOCK_OPEN
+			pthread_mutex_unlock(sharedlock);
+#endif
+			break;
+			}
+        case _FC_WRITE_MULTIPLE_COILS:{
+			if(modbus_debug)
+				printf("_FC_WRITE_MULTIPLE_COILS \n");
+			break;
+			}
+        case _FC_WRITE_MULTIPLE_REGISTERS:{
+			uint16_t nb = (data[offset + 3] << 8) + data[offset + 4];
+			if(modbus_debug)
+				printf("_FC_WRITE_MULTIPLE_REGISTERS,len:%d,address:0x%x \n",nb,address);
+			modbus_reply(ctx, data, len, mb_mapping);
+#ifdef LOCK_OPEN
+			pthread_mutex_lock(sharedlock);
+#endif
+			memmove(shm_addr+address*2,data+offset+6,nb*2);
+#ifdef LOCK_OPEN
+			pthread_mutex_unlock(sharedlock);
+#endif
+			break;
+			}
+        case _FC_REPORT_SLAVE_ID:{
+			if(modbus_debug)
+				printf("_FC_REPORT_SLAVE_ID \n");
+			break;
+        		}
+        case _FC_READ_EXCEPTION_STATUS:{
+			if(modbus_debug)
+				printf("_FC_READ_EXCEPTION_STATUS \n");
+			break;
+			}
+        case _FC_WRITE_AND_READ_REGISTERS:{
+			if(modbus_debug)
+				printf("_FC_WRITE_AND_READ_REGISTERS \n");
+			break;
+			}
+        default:
+			if(modbus_debug)
+				printf("FUNCTION CODE ERROR!!! \n");
+			break;
+	}
+}
+
+static void *modbus_server_thread(void *arg)
+{
+	int rc;
+	fd_set refset;
+	fd_set rdset;
+	int fdmax;/* Maximum file descriptor number */
+	int master_socket;
+
+	memset(modbus_address,0,sizeof(modbus_address));
+	memcpy(modbus_address,"0.0.0.0",7);
+	if(modbus_debug){
+		printf("modbus IP            : %s \n",modbus_address);
+		printf("modbus_max_num_client: %d \n",modbus_max_num_client);
+		printf("shm_key              : %d \n",shm_key);
+		printf("modbus_port          : %d \n",modbus_port);
+		printf("shm_size             : %d \n",shm_size);
+	}
+
+	shmid = shmget(shm_key, shm_size, 0666|IPC_CREAT);
+	printf("shmid : %u\n", shmid);
+	if (shmid == -1){
+		perror("shmget error!");
+		exit(1);
+	}
+
+	shm_addr = shmat(shmid, NULL, 0);
+	if (shm_addr == (void *) -1){
+		perror("shmat error!");
+		exit(1);
+	}
+
+#ifdef LOCK_OPEN
+	sharedlock = (pthread_mutex_t*)shm_addr;
+#endif
+
+	ctx = modbus_new_tcp(modbus_address, modbus_port);
+	if(ctx == NULL){
+		fprintf(stderr, "Failed to new tcp: %s\n",modbus_strerror(errno));
+		exit(1);
+	}
+
+	if(modbus_debug)
+		modbus_set_debug(ctx, TRUE);
+	else
+		modbus_set_debug(ctx, FALSE);
+	mb_mapping = modbus_mapping_new(0, 0, 0, 0);
+	mb_mapping->nb_registers = shm_size/2;
+	mb_mapping->tab_registers = shm_addr;
+
+	server_socket = modbus_tcp_listen(ctx, modbus_max_num_client);
+	if(server_socket == -1){
+		fprintf(stderr, "Failed to listen tcp: %s\n",modbus_strerror(errno));
+		exit(1);
+	}
+
+	/* Clear the reference set of socket */
+	FD_ZERO(&refset);
+	/* Add the server socket */
+	FD_SET(server_socket, &refset);
+	/* Keep track of the max file descriptor */
+	fdmax = server_socket;
+
+	while(1){
+		rdset = refset;
+		if (select(fdmax+1, &rdset, NULL, NULL, NULL) == -1) {
+			perror("Server select() failure.");
+			return NULL;
+		}
+
+		/* Run through the existing connections looking for data to be read */
+		for (master_socket = 0; master_socket <= fdmax; master_socket++) {
+			if (FD_ISSET(master_socket, &rdset)) {
+				if (master_socket == server_socket) {
+					/* A client is asking a new connection */
+					socklen_t addrlen;
+					struct sockaddr_in clientaddr;
+					int newfd;
+					/* Handle new connections */
+					addrlen = sizeof(clientaddr);
+					memset(&clientaddr, 0, sizeof(clientaddr));
+					newfd = accept(server_socket, (struct sockaddr *)&clientaddr, &addrlen);
+					if (newfd == -1) {
+						perror("Server accept() error");
+					} else {
+						FD_SET(newfd, &refset);
+						if (newfd > fdmax) {
+						/* Keep track of the maximum */
+						fdmax = newfd;
+						}
+						printf("New connection from %s:%d on socket %d\n",
+						inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port, newfd);
+					}
+				} else {
+				/* An already connected master has sent a new query */
+				uint8_t query[MODBUS_TCP_MAX_ADU_LENGTH];
+				modbus_set_socket(ctx, master_socket);
+				rc = modbus_receive(ctx, query);
+				if (rc != -1) {
+					modbus_data_proc(query,rc);
+				}else {
+					/* Connection closed by the client, end of server */
+					printf("Connection closed on socket %d\n", master_socket);
+					close(master_socket);
+					/* Remove from reference set */
+					FD_CLR(master_socket, &refset);
+					if (master_socket == fdmax) {
+						fdmax--;
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+void modbus_server_create_entry(void)
+{
+	pthread_attr_t thattr;
+	pthread_attr_init(&thattr);
+	pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+	if(pthread_create(&modbus_thread, &thattr, &modbus_server_thread, NULL)){
+		printf("pthread_create modbus task failed \n");
+		return;
+	}
+}
+
+void modbus_server_exit_entry(void)
+{
+	close(server_socket);
+	modbus_free(ctx);
+	shmdt(shm_addr);
+	shmctl(shmid, IPC_RMID, 0);
+	pthread_cancel(modbus_thread);
+	pthread_join(modbus_thread,NULL);
+}
+
diff --git a/examples/InvertedPendulum/modbus_server/modbus_server.h b/examples/InvertedPendulum/modbus_server/modbus_server.h
new file mode 100644
index 00000000..988b8b1b
--- /dev/null
+++ b/examples/InvertedPendulum/modbus_server/modbus_server.h
@@ -0,0 +1,8 @@
+#ifndef MODBUS_SERVER_H
+#define MODBUS_SERVER_H
+
+void modbus_server_create_entry(void);
+void modbus_server_exit_entry(void);
+
+#endif
+
diff --git a/examples/Makefile.am b/examples/Makefile.am
index d73d0977..7307c7e1 100644
--- a/examples/Makefile.am
+++ b/examples/Makefile.am
@@ -21,7 +21,7 @@
 
 include $(top_srcdir)/Makefile.kbuild
 
-SUBDIRS =
+SUBDIRS = multi_axis ecatdio soe_axis
 
 if ENABLE_USERLIB
 SUBDIRS += \
@@ -65,6 +65,9 @@ DIST_SUBDIRS = \
 	tty \
 	user \
 	xenomai \
-	xenomai_posix
+	xenomai_posix \
+	multi_axis \
+	fly_trigger_poc \
+	InvertedPendulum
 
 #-----------------------------------------------------------------------------
diff --git a/examples/ecatdio/Makefile.am b/examples/ecatdio/Makefile.am
new file mode 100644
index 00000000..dca8720f
--- /dev/null
+++ b/examples/ecatdio/Makefile.am
@@ -0,0 +1,54 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_ecatdio_example
+
+ec_ecatdio_example_SOURCES = main.c
+
+if ENABLE_XENOMAI
+ec_ecatdio_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS)
+
+ec_ecatdio_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm -lmodbus \
+	$(XENOMAI_POSIX_LDFLAGS)
+else
+ec_ecatdio_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+ec_ecatdio_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat -lrt -lpthread -lmodbus
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/ecatdio/main.c b/examples/ecatdio/main.c
new file mode 100644
index 00000000..0595e713
--- /dev/null
+++ b/examples/ecatdio/main.c
@@ -0,0 +1,344 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+#include "main.h"
+#include <getopt.h>
+
+#define SHARE_MEM
+
+#ifdef SHARE_MEM
+#define BUF_SIZE				0x1000
+char mem_buffer[BUF_SIZE];
+void *shm_addr = NULL;
+int shmid;
+#endif
+
+static uint32_t horselight_tick = 1000;
+
+static pthread_t cyclic_thread;
+static volatile int run = 1;
+
+static ec_master_t *master = NULL;
+static ec_master_state_t master_state = {};
+static Slave_Data ec_slave0;
+
+static ec_domain_t *domain = NULL;
+static uint8_t *domain_pd = NULL;
+static ec_slave_config_t *sc;
+
+const static ec_pdo_entry_reg_t domain_regs[] = {
+    {SLAVE00_POS, SLAVE00_ID, 0x7001, 0x01, &ec_slave0.digital_output0, NULL},
+    {SLAVE00_POS, SLAVE00_ID, 0x7001, 0x02, &ec_slave0.digital_output1, NULL},
+    {SLAVE00_POS, SLAVE00_ID, 0x6001, 0x01, &ec_slave0.digital_input0, NULL},
+    {SLAVE00_POS, SLAVE00_ID, 0x6001, 0x02, &ec_slave0.digital_input1, NULL},
+    {}
+};
+
+#ifdef SHARE_MEM
+static void write_buf_int16(char* dest,int16_t src)
+{
+	dest[1] = (char)(src>>8);
+	dest[0] = (char)(src);
+}
+
+static void write_buf_int32(char* dest,int32_t src)
+{
+	dest[3] = (char)(src>>8);
+	dest[2] = (char)(src);
+	dest[1] = (char)(src>>24);
+	dest[0] = (char)(src>>16);
+
+}
+
+static void write_buf_int64(char* dest,int64_t src)
+{
+	dest[7] = (char)(src>>8);
+	dest[6] = (char)(src);
+	dest[5] = (char)(src>>24);
+	dest[4] = (char)(src>>16);
+	dest[3] = (char)(src>>40);
+	dest[2] = (char)(src>>32);
+	dest[1] = (char)(src>>56);
+	dest[0] = (char)(src>>48);
+}
+#endif
+
+static void data_init(void)
+{
+    memset(&ec_slave0,0,sizeof(Slave_Data));
+    sc = NULL;
+}
+
+#ifdef SHARE_MEM
+static char sharemem_init(void)
+{
+    shmid = shmget((key_t)87654321, BUF_SIZE, IPC_CREAT|0666);
+    printf("shmid : %u\n", shmid);
+    if (shmid == -1){
+        perror("shmget error!");
+        return -1;
+    }
+    shm_addr = shmat(shmid, NULL, 0);
+    if (shm_addr == (void *) -1){
+        perror("shmat error!");
+        return -1;
+    }
+	memset((pthread_mutex_t *)shm_addr, 0, BUF_SIZE);
+    return 0;
+}
+#endif
+
+static void rt_check_domain_state(void)
+{
+	static ec_domain_state_t domain_state = {};
+	ec_domain_state_t ds = {};
+
+	ecrt_domain_state(domain, &ds);
+	if(ds.working_counter != domain_state.working_counter)
+		printf("Domain: WC %u.\n", ds.working_counter);
+	if(ds.wc_state != domain_state.wc_state)
+		printf("Domain: State %u.\n", ds.wc_state);
+
+	domain_state = ds;
+}
+
+static void rt_check_master_state(void)
+{
+	ec_master_state_t ms;
+    ecrt_master_state(master, &ms);
+    if (ms.slaves_responding != master_state.slaves_responding)
+        printf("%u slave(s).\n", ms.slaves_responding);
+    if (ms.al_states != master_state.al_states)
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    if (ms.link_up != master_state.link_up)
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+    master_state = ms;
+}
+
+static void ec_read_pdo_entry(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    ec_motor->digitalinput0	    = EC_READ_U8(domain_pd + ec_slave.digital_input0);
+    ec_motor->digitalinput1	    = EC_READ_U8(domain_pd + ec_slave.digital_input1);
+}
+
+static void ec_write_pdo_entry(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    EC_WRITE_U8(domain_pd+ec_slave.digital_output0, ec_motor->digitaloutput0);
+    EC_WRITE_U8(domain_pd+ec_slave.digital_output1, ec_motor->digitaloutput1);
+}
+
+static void horselight_proc(Ctl_Data* ec_motor)
+{
+    static int i=0;
+    static char buf[2] = {0x00,0x00};
+    if(i<8){
+        buf[0] = (1<<i);
+        buf[1] = 0x00;
+    }else{
+        buf[0] = 0x00;
+        buf[1] = (1<<(i%8));
+    }
+    i++;
+    if(i == 16)
+        i=0;
+    ec_motor->digitaloutput0 = buf[0];
+    ec_motor->digitaloutput1 = buf[1];
+}
+
+void *my_thread(void *arg)
+{
+    struct timespec next_period = {0, 0};
+    unsigned int cycle_counter = 0;
+    Ctl_Data ec_motor0;
+
+    struct sched_param param = {.sched_priority = 99};
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+    clock_gettime(CLOCK_MONOTONIC, &next_period);
+    memset(&ec_motor0,0,sizeof(Ctl_Data));
+
+    while (run != 0 ) {
+        next_period.tv_nsec += CYCLE_US * 1000;
+        while (next_period.tv_nsec >= NSEC_PER_SEC) {
+            next_period.tv_nsec -= NSEC_PER_SEC;
+            next_period.tv_sec++;
+        }
+        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_period, NULL);
+        cycle_counter++;
+        ecrt_master_receive(master);
+        ecrt_domain_process(domain);
+		rt_check_domain_state();
+
+        if (!(cycle_counter % CYCLE_COUNTER_PERSEC)) {
+	        rt_check_master_state();
+        }
+        
+        if(cycle_counter % horselight_tick == 0)
+            horselight_proc(&ec_motor0);
+		
+        ec_write_pdo_entry(&ec_motor0,ec_slave0);
+        ec_read_pdo_entry(&ec_motor0,ec_slave0);
+
+        ecrt_domain_queue(domain);
+        ecrt_master_send(master);
+#ifdef SHARE_MEM
+		memcpy(mem_buffer,(pthread_mutex_t *)shm_addr,2);
+#endif
+    }
+    return NULL;
+}
+
+void signal_handler(int sig)
+{
+    run = 0;
+}
+
+static void getOptions(int argc, char **argv)
+{
+    int index;
+    static struct option longOptions[] = {
+		//name		has_arg				flag	val
+		{"tick",	required_argument,	NULL,	't'},
+		{"help",	no_argument,		NULL,	'h'},
+		{}
+    };
+    do{
+	index = getopt_long(argc, argv, "t:h", longOptions, NULL);
+	switch(index){
+		case 't':
+			horselight_tick = atoi(optarg);
+			printf("set tick:%d ms \n",horselight_tick);
+			break;
+	    case 'h':
+			printf("Global options:\n");
+			printf("  --tick    -t  Set horse light cycle tick,default:%d ms\n",horselight_tick);
+			printf("  --help    -h  Show this help.\n");
+			exit(0);
+			break;
+	    default:
+			break;
+		}
+    }
+    while(index != -1);
+}
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+    getOptions(argc,argv);
+    data_init();
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0);
+    if (!master) {
+        return -1;
+    }
+
+    printf("Creating domain ...\n");
+    domain = ecrt_master_create_domain(master);
+    if (!domain){
+        return -1;
+    }
+
+    sc = ecrt_master_slave_config(master, SLAVE00_POS, SLAVE00_ID);
+    if (!sc) {
+        printf("Slave1 sc is NULL \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  1 \n");
+        return -1;
+    }
+
+    if (ecrt_domain_reg_pdo_entry_list(domain, domain_regs)) {
+        fprintf(stderr, "PDO entry registration failed!\n");
+        return -1;
+    }
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    if (!(domain_pd = ecrt_domain_data(domain))) {
+        fprintf(stderr, "Failed to get domain data pointer.\n");
+        return -1;
+    }
+
+#ifdef SHARE_MEM
+    if(sharemem_init() == -1)
+        return -1;
+#endif
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t thattr;
+    pthread_attr_init(&thattr);
+    pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+
+    if (pthread_create(&cyclic_thread, &thattr, &my_thread, NULL)) {
+        fprintf(stderr, "pthread_create cyclic task failed\n");
+		return 1;
+    }
+
+    while (run)
+	    sched_yield();
+
+    pthread_join(cyclic_thread, NULL);
+
+#ifdef SHARE_MEM
+    if (shmdt(shm_addr) == -1){
+        printf("shmdt error!\n");
+        exit(1);
+    }
+#endif
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/ecatdio/main.h b/examples/ecatdio/main.h
new file mode 100644
index 00000000..40d23b3a
--- /dev/null
+++ b/examples/ecatdio/main.h
@@ -0,0 +1,54 @@
+#ifndef __ETHERCAT_6AIXS_MAIN_H__
+#define __ETHERCAT_6AIXS_MAIN_H__
+
+#include <stdio.h>
+#include "ecrt.h"
+
+#define CYCLE_US    			1000
+#define PERIOD_NS   			(CYCLE_US*1000)
+#define NSEC_PER_SEC    		(1000000000L)
+#define TIMESPEC2NS(T)  		((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DIFF_NS(A,B)    		(((B).tv_sec - (A).tv_sec)*NSEC_PER_SEC + ((B).tv_nsec)-(A).tv_nsec)
+#define CYCLE_COUNTER_PERSEC    (NSEC_PER_SEC/PERIOD_NS)
+
+#define SLAVE00_POS  			0, 0
+#define SLAVE00_ID   			0x00000a09, 0x00000201
+
+typedef struct{
+    ec_slave_config_t *sc;
+    unsigned int digital_output0;
+    unsigned int digital_output1;
+    unsigned int digital_input0;
+    unsigned int digital_input1;
+}Slave_Data;
+
+typedef struct{
+    unsigned char digitaloutput0;
+    unsigned char digitaloutput1;
+    unsigned char digitalinput0;
+    unsigned char digitalinput1;
+}Ctl_Data;
+
+ec_pdo_entry_info_t slave_pdo_entries[] = {
+	{0x7001, 0x01, 8},
+	{0x7001, 0x02, 8},
+	{0x6001, 0x01, 8},
+	{0x6001, 0x02, 8},
+};
+
+ec_pdo_info_t slave_pdos[] = {
+    {0x1600, 1, slave_pdo_entries + 0},
+    {0x1601, 1, slave_pdo_entries + 1},
+    {0x1a00, 1, slave_pdo_entries + 2},
+    {0x1a01, 1, slave_pdo_entries + 3},
+};
+
+ec_sync_info_t slave_syncs[] = {
+   {0, EC_DIR_OUTPUT, 1, slave_pdos+0, EC_WD_ENABLE},
+   {1, EC_DIR_OUTPUT, 1, slave_pdos+1, EC_WD_ENABLE},
+   {2, EC_DIR_INPUT, 2, slave_pdos+2, EC_WD_DISABLE},
+   {0xff}
+};
+
+#endif
+
diff --git a/examples/fly_trigger_poc/Makefile.am b/examples/fly_trigger_poc/Makefile.am
new file mode 100644
index 00000000..8854ab38
--- /dev/null
+++ b/examples/fly_trigger_poc/Makefile.am
@@ -0,0 +1,54 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = fly_trigger_poc
+
+fly_trigger_poc_SOURCES = main.c
+
+if ENABLE_XENOMAI
+fly_trigger_poc_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS)
+
+fly_trigger_poc_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm \
+	$(XENOMAI_POSIX_LDFLAGS)
+else
+fly_trigger_poc_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+fly_trigger_poc_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat -lrt -lpthread
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/fly_trigger_poc/main.c b/examples/fly_trigger_poc/main.c
new file mode 100644
index 00000000..a364dbde
--- /dev/null
+++ b/examples/fly_trigger_poc/main.c
@@ -0,0 +1,455 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+#include "main.h"
+#include <getopt.h>
+
+#define ROUND_TRIGGER 10 // every ROUND_TRIGGER rounds, the camera will be triggered once 
+
+static pthread_t cyclic_thread;
+static volatile int run = 1;
+
+static ec_master_t *master = NULL;
+static ec_master_state_t master_state = {};
+
+static ec_domain_t *domain = NULL;
+static uint8_t *domain_pd = NULL;
+static ec_slave_config_t *io_sc;
+static ec_slave_config_t *servo_sc;
+
+static int32_t default_speed = 10;
+
+typedef struct{
+    uint8_t trigger;
+    uint32_t triggeroffset;
+    uint64_t timestamp;
+    uint32_t timestampoffset;
+} io_slave;
+
+static io_slave io;
+
+typedef struct {
+    uint16_t ctrlword;
+    uint32_t ctrlwordoffset;
+    int32_t targetvel;
+    uint32_t targetveloffset;
+    uint8_t modesel;
+    uint32_t modeseloffset;
+    uint16_t statusword;
+    uint32_t statuswordoffset;
+    int32_t actualpos;
+    uint32_t actualposoffset;
+    int32_t actualvel;
+    uint32_t actualveloffset;
+} servo_slave;
+
+static servo_slave servo;
+
+
+const static ec_pdo_entry_reg_t domain_regs[] = {
+#ifdef OMRON_IO_USED
+    {IO_POS, IO_ID, 0x7000, 0x01, &io.triggeroffset, NULL},
+    {IO_POS, IO_ID, 0x7010, 0x01, &io.timestampoffset, NULL},
+#endif
+#ifdef ITEG_IO_USED
+    {IO_POS, IO_ID, 0x7001, 0x01, &io.triggeroffset, NULL},
+#endif
+    {SERVO_POS, SERVO_ID, 0x6040, 0x00, &servo.ctrlwordoffset, NULL},
+    {SERVO_POS, SERVO_ID, 0x60FF, 0x00, &servo.targetveloffset, NULL},
+    {SERVO_POS, SERVO_ID, 0x6060, 0x00, &servo.modeseloffset, NULL},
+    {SERVO_POS, SERVO_ID, 0x6041, 0x00, &servo.statuswordoffset, NULL},
+    {SERVO_POS, SERVO_ID, 0x6064, 0x00, &servo.actualposoffset, NULL},
+    {SERVO_POS, SERVO_ID, 0x606c, 0x00, &servo.actualveloffset, NULL},
+    {}
+};
+
+static void data_init(void)
+{
+    io_sc = NULL;
+    servo_sc = NULL;
+}
+
+static void rt_check_domain_state(void)
+{
+    static ec_domain_state_t domain_state = {};
+    ec_domain_state_t ds = {};
+
+    ecrt_domain_state(domain, &ds);
+    if(ds.working_counter != domain_state.working_counter)
+	printf("Domain: WC %u.\n", ds.working_counter);
+    if(ds.wc_state != domain_state.wc_state)
+	printf("Domain: State %u.\n", ds.wc_state);
+
+    domain_state = ds;
+}
+
+static void rt_check_master_state(void)
+{
+    ec_master_state_t ms;
+    ecrt_master_state(master, &ms);
+    if (ms.slaves_responding != master_state.slaves_responding)
+        printf("%u slave(s).\n", ms.slaves_responding);
+    if (ms.al_states != master_state.al_states)
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    if (ms.link_up != master_state.link_up)
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+    master_state = ms;
+}
+
+static uint16_t coe_cia402_statemachine(uint16_t status)
+{
+    if ((status&0x4F) == 0x0) {         // Not ready to Switch on
+        return 0x80;
+    } else if ((status&0x4F) == 0x40) { // Switch on Disabled
+        return 0x6;
+    } else if ((status&0x6F) == 0x21) { // Ready to Switch on
+        return 0x7;
+    } else if ((status&0x6F) == 0x23) { // Switch on
+        return 0xF;
+    } else if ((status&0x6F) == 0x27) { // Operation enabled
+        return 0x1F;
+    } else if ((status&0x6F) == 0x07) { // Quick stop active
+        return 0x0;
+    } else if ((status&0x4F) == 0x0F) { // Fault reaction active
+        return 0x80;
+    } else if ((status&0x4F) == 0x08) { // Fault
+        return 0x80;
+    }
+    return 0x80;
+}
+
+static void ec_read_pdo_entry()
+{
+    servo.statusword = EC_READ_U16(domain_pd + servo.statuswordoffset);
+    servo.actualpos = EC_READ_S32(domain_pd + servo.actualposoffset);
+    servo.actualvel = EC_READ_S32(domain_pd + servo.actualveloffset);
+}
+
+#ifdef PANASONIC_USED
+#define PER_CIRCLE_ENCODER		0x20000
+#endif
+#ifdef INOVANCE_USED
+#define PER_CIRCLE_ENCODER		0x100000
+#endif
+static uint8_t is_vel_uniform()
+{
+    return 1;
+    int32_t diff = servo.actualvel - servo.targetvel;
+    if ((diff < 5)&&(diff > -5))
+	    return 1;
+    else
+	    return 0;
+}
+
+static void fly_trigger_proc(uint64_t ts)
+{
+	static uint8_t tc= 2;
+    uint64_t timeoffset;
+    servo.targetvel = default_speed*PER_CIRCLE_ENCODER;
+    if ((is_vel_uniform() == 1) && (servo.actualvel))
+    {
+	if (servo.actualpos >= 0)
+            timeoffset = (int64_t)(servo.actualpos%(PER_CIRCLE_ENCODER*ROUND_TRIGGER))*NSEC_PER_SEC/servo.actualvel;
+	else
+            timeoffset = (int64_t)(PER_CIRCLE_ENCODER*ROUND_TRIGGER + servo.actualpos%(PER_CIRCLE_ENCODER*ROUND_TRIGGER))*NSEC_PER_SEC/servo.actualvel;
+#ifdef OMRON_IO_USED
+        if (timeoffset < 2*PERIOD_NS) {
+	    io.trigger = 0;
+	    tc = 2;
+	    io.timestamp = ts + timeoffset;
+	    EC_WRITE_U8(domain_pd+io.triggeroffset, io.trigger);
+	    EC_WRITE_U64(domain_pd+io.timestampoffset, io.timestamp);
+	} else {
+	    if (io.trigger == 0) {
+		    if (tc == 2) {
+			io.trigger = 0;
+			tc=0;
+		    }
+		    else
+	          	io.trigger = 0x1;
+	     
+
+	        io.timestamp = 0;
+		//printf("trigger\n");
+		EC_WRITE_U8(domain_pd+io.triggeroffset, io.trigger);
+		EC_WRITE_U64(domain_pd+io.timestampoffset, io.timestamp);
+	    }
+	}
+#endif
+#ifdef ITEG_IO_USED
+        if (timeoffset < PERIOD_NS) {
+	    io.trigger = 0;
+	    EC_WRITE_U8(domain_pd+io.triggeroffset, io.trigger);
+	} else {
+	    if (io.trigger == 0) {
+	        io.trigger = 1;
+		//printf("trigger\n");
+		EC_WRITE_U8(domain_pd+io.triggeroffset, io.trigger);
+	    }
+	}
+#endif
+    }
+    EC_WRITE_S32(domain_pd+servo.targetveloffset, servo.targetvel);
+    EC_WRITE_U16(domain_pd+servo.ctrlwordoffset, servo.ctrlword);
+    EC_WRITE_U8(domain_pd+servo.modeseloffset, servo.modesel);
+}
+
+void *my_thread(void *arg)
+{
+    struct timespec next_period = {0, 0};
+    struct timespec dc_period = {0, 0};
+    unsigned int cycle_counter = 0;
+
+    struct sched_param param = {.sched_priority = 99};
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+    clock_gettime(CLOCK_MONOTONIC, &next_period);
+
+    while (run != 0 ) {
+        next_period.tv_nsec += CYCLE_US * 1000;
+        while (next_period.tv_nsec >= NSEC_PER_SEC) {
+            next_period.tv_nsec -= NSEC_PER_SEC;
+            next_period.tv_sec++;
+        }
+        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_period, NULL);
+        cycle_counter++;
+        ecrt_master_receive(master);
+        ecrt_domain_process(domain);
+	//rt_check_domain_state();
+
+        //if (!(cycle_counter % CYCLE_COUNTER_PERSEC)) {
+	//    rt_check_master_state();
+        //}
+
+	ec_read_pdo_entry();
+
+	servo.ctrlword = coe_cia402_statemachine(servo.statusword);
+	if (servo.ctrlword == 0x1f) {
+            fly_trigger_proc(TIMESPEC2NS(next_period));
+	} else {
+	    EC_WRITE_U16(domain_pd+servo.ctrlwordoffset, servo.ctrlword);
+	}
+	
+	clock_gettime(CLOCK_MONOTONIC, &dc_period);
+	ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+	ecrt_master_sync_reference_clock(master);
+	ecrt_master_sync_slave_clocks(master);
+
+        ecrt_domain_queue(domain);
+        ecrt_master_send(master);
+    }
+    return NULL;
+}
+
+void signal_handler(int sig)
+{
+    run = 0;
+}
+
+static void getOptions(int argc, char **argv)
+{
+    int index;
+    static struct option longOptions[] = {
+	//name		has_arg				flag	val
+	{"velocity",	required_argument,		NULL,	'v'},
+	{"help",	no_argument,		NULL,	'h'},
+	{}
+    };
+    do{
+	index = getopt_long(argc, argv, "v:h", longOptions, NULL);
+	switch(index){
+	    case 'v':
+		default_speed = atof(optarg);
+		if (default_speed > 50)
+		    default_speed = 50;
+		if (default_speed < -50)
+		    default_speed = -50;
+		break;
+	    case 'h':
+		printf("Global options:\n");
+		printf("  --velocity    -v  Set target velocity(circle/s). default: 10\n");
+		printf("  --help    -h  Show this help.\n");
+		exit(0);
+		break;
+	    default:
+		break;
+	}
+    }
+    while(index != -1);
+}
+
+static void ec_slave_config_omron_init(ec_slave_config_t *sc)
+{
+    /* Clear RxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 0); /*clear sm pdo 0x1c12*/
+    /* Define RxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1600, 1, 0x70000101); /*0x7000:1*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 2, 0x70000201); /*0x7000:2*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 3, 0x0000000E); /*0x0000:0*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 4, 0x70100140); /*0x7010:1*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 5, 0x70100240); /*0x7010:2*/
+    ecrt_slave_config_sdo16(sc, 0x1C12, 1, 0x1600 ); /*list all RxPdo in 0x1600*/
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 1 ); /*set number of RxPDO*/
+    /* Define TxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1BF8, 1, 0x30030340); /*0x3003:3*/
+    ecrt_slave_config_sdo32(sc, 0x1BF8, 2, 0x30060340); /*0x3006:3*/
+    ecrt_slave_config_sdo32(sc, 0x1BF4, 1, 0x00000008); /*0x0000:0*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 1, 0x60110101); /*0x6011:1*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 2, 0x00000001); /*0x0000:0*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 3, 0x60110201); /*0x6011:2*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 4, 0x0000000D); /*0x0000:0*/
+    ecrt_slave_config_sdo8(sc, 0x1BF8, 0, 2); /*set number of TxPDO*/
+    ecrt_slave_config_sdo8(sc, 0x1BF4, 0, 1); /*set number of TxPDO*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 1, 0x1BF8 ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 2, 0x1BFF ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 3, 0x1BF4 ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 4, 0x1A00 ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 4 ); /*set number of TxPDO*/
+    ecrt_slave_config_sdo8(sc, 0x2002, 2, 1 ); /*set number of TxPDO*/
+}
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+    struct timespec dc_period = {0, 0};
+    getOptions(argc,argv);
+    data_init();
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0);
+    if (!master) {
+        return -1;
+    }
+
+    printf("Creating domain ...\n");
+    domain = ecrt_master_create_domain(master);
+    if (!domain){
+        return -1;
+    }
+
+    io_sc = ecrt_master_slave_config(master, IO_POS, IO_ID);
+    if (!io_sc) {
+        printf("Slave0 sc is NULL \n");
+        return -1;
+    }
+    servo_sc = ecrt_master_slave_config(master, SERVO_POS, SERVO_ID);
+    if (!servo_sc) {
+        printf("Servo sc is NULL \n");
+        return -1;
+    }
+#ifdef OMRON_IO_USED
+    ec_slave_config_omron_init(io_sc);
+#endif
+#ifdef ITEG_IO_USED
+    if (ecrt_slave_config_pdos(io_sc, EC_END, io_syncs)) {
+    	fprintf(stderr, "Failed to configure PDOs.\n");
+	return -1;
+    }
+#endif
+    if (ecrt_slave_config_pdos(servo_sc, EC_END, servo_syncs)) {
+    	fprintf(stderr, "Failed to configure PDOs.\n");
+	return -1;
+    }
+
+    ecrt_master_set_send_interval(master, CYCLE_US);
+    if (ecrt_domain_reg_pdo_entry_list(domain, domain_regs)) {
+        fprintf(stderr, "PDO entry registration failed!\n");
+        return -1;
+    }
+
+    servo.modesel = 9;
+    ecrt_slave_config_sdo8(servo_sc, 0x6060, 0x00, servo.modesel);
+#ifdef PANASONIC_USED
+    ecrt_slave_config_sdo32(servo_sc, 0x60C5, 0x00, 0x000f4240); //max acc
+    ecrt_slave_config_sdo32(servo_sc, 0x60C6, 0x00, 0xffffffff);
+    ecrt_slave_config_sdo32(servo_sc, 0x6085, 0x00, 0xffffffff); //quick stop dcc
+#endif
+
+#ifdef OMRON_IO_USED
+    ecrt_slave_config_dc(io_sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+#endif
+    ecrt_slave_config_dc(servo_sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+
+    clock_gettime(CLOCK_MONOTONIC, &dc_period);
+    ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+    ecrt_master_select_reference_clock(master, servo_sc);
+
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    if (!(domain_pd = ecrt_domain_data(domain))) {
+        fprintf(stderr, "Failed to get domain data pointer.\n");
+        return -1;
+    }
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t thattr;
+    pthread_attr_init(&thattr);
+    pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+
+    if (pthread_create(&cyclic_thread, &thattr, &my_thread, NULL)) {
+        fprintf(stderr, "pthread_create cyclic task failed\n");
+		return 1;
+    }
+
+    while (run)
+	    sched_yield();
+
+    pthread_join(cyclic_thread, NULL);
+
+    ecrt_slave_config_sdo32(servo_sc, 0x6040, 0x00, 0x0100);
+    ecrt_release_master(master);
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/fly_trigger_poc/main.h b/examples/fly_trigger_poc/main.h
new file mode 100644
index 00000000..3e694377
--- /dev/null
+++ b/examples/fly_trigger_poc/main.h
@@ -0,0 +1,159 @@
+#ifndef __FLY_TRIGGER_POC_MAIN_H__
+#define __FLY_TRIGGER_POC_MAIN_H__
+
+#include <stdio.h>
+#include "ecrt.h"
+
+//#define PANASONIC_USED
+#define INOVANCE_USED
+
+//#define OMRON_IO_USED
+#define ITEG_IO_USED
+
+#define CYCLE_US    			1000
+#define PERIOD_NS   			(CYCLE_US*1000)
+#define NSEC_PER_SEC    		(1000000000L)
+#define TIMESPEC2NS(T)  		((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DIFF_NS(A,B)    		(((B).tv_sec - (A).tv_sec)*NSEC_PER_SEC + ((B).tv_nsec)-(A).tv_nsec)
+#define CYCLE_COUNTER_PERSEC    (NSEC_PER_SEC/PERIOD_NS)
+
+/* Omron NX-ECC203+OD2154*/
+#define OMRON_SLAVE00_POS  			0, 1
+#define OMRON_SLAVE00_ID   			0x00000083, 0x000000aa
+
+#define ITEG_SLAVE00_POS  			0, 1
+#define ITEG_SLAVE00_ID   			0x00000a09, 0x00000201
+
+/* Panasonic servo */
+#define MADHT_SLAVE01_POS  			0, 0
+#define MADHT_SLAVE01_ID   			0x0000066f, 0x60380004
+
+/* Inovance servo */
+#define INOV_SLAVE01_POS  			0, 0
+#define INOV_SLAVE01_ID   			0x00100000, 0x000c0108
+
+ec_pdo_entry_info_t omron_pdo_entries[] = {
+	{0x7000, 0x01, 1},
+	{0x7000, 0x02, 1},
+	{0x0000, 0x00, 14}, /* Gap */
+	{0x7010, 0x01, 64},
+	{0x7010, 0x02, 64},
+	{0x3003, 0x03, 64},
+	{0x3006, 0x03, 64},
+	{0x2002, 0x01, 8},
+	{0x0000, 0x00, 8}, /* Gap */
+	{0x6011, 0x01, 1},
+	{0x0000, 0x00, 1}, /* Gap */
+	{0x6011, 0x02, 1},
+	{0x0000, 0x00, 13}, /* Gap */
+};
+
+ec_pdo_info_t omron_pdos[] = {
+    {0x1600, 5, omron_pdo_entries + 0},
+    {0x1bf8, 2, omron_pdo_entries + 5},
+    {0x1bff, 1, omron_pdo_entries + 7},
+    {0x1bf4, 1, omron_pdo_entries + 8},
+    {0x1a00, 4, omron_pdo_entries + 9},
+};
+
+ec_sync_info_t omron_syncs[] = {
+   {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+   {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+   {2, EC_DIR_OUTPUT, 1, omron_pdos+0, EC_WD_ENABLE},
+   {3, EC_DIR_INPUT, 4, omron_pdos+1, EC_WD_DISABLE},
+   {0xff}
+};
+
+ec_pdo_entry_info_t iteg_pdo_entries[] = {
+	{0x7001, 0x01, 8},
+	{0x7001, 0x02, 8},
+	{0x6001, 0x01, 8},
+	{0x6001, 0x02, 8},
+};
+
+ec_pdo_info_t iteg_pdos[] = {
+    {0x1600, 1, iteg_pdo_entries + 0},
+    {0x1601, 1, iteg_pdo_entries + 1},
+    {0x1a00, 1, iteg_pdo_entries + 2},
+    {0x1a01, 1, iteg_pdo_entries + 3},
+};
+
+ec_sync_info_t iteg_syncs[] = {
+   {0, EC_DIR_OUTPUT, 1, iteg_pdos+0, EC_WD_ENABLE},
+   {1, EC_DIR_OUTPUT, 1, iteg_pdos+1, EC_WD_ENABLE},
+   {2, EC_DIR_INPUT, 2, iteg_pdos+2, EC_WD_DISABLE},
+   {0xff}
+};
+
+#ifdef OMRON_IO_USED
+#define IO_POS  			OMRON_SLAVE00_POS
+#define IO_ID   			OMRON_SLAVE00_ID
+ec_sync_info_t* io_syncs = omron_syncs;
+#endif
+#ifdef ITEG_IO_USED
+#define IO_POS  			ITEG_SLAVE00_POS
+#define IO_ID   			ITEG_SLAVE00_ID
+ec_sync_info_t* io_syncs = iteg_syncs;
+#endif
+
+/* Panasonic Servo */
+ec_pdo_entry_info_t pana_pdo_entries[] = {
+	{0x6040, 0x00, 16},
+	{0x60ff, 0x00, 32},
+	{0x6060, 0x00, 8},
+	{0x6041, 0x00, 16},
+	{0x6064, 0x00, 32},
+	{0x606c, 0x00, 32},
+	{0x60fd, 0x00, 32},
+};
+
+ec_pdo_info_t pana_pdos[] = {
+	{0x1601, 3, pana_pdo_entries + 0},
+	{0x1a01, 3, pana_pdo_entries + 3},
+};
+
+ec_sync_info_t pana_syncs[] = {
+	{0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+	{1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+	{2, EC_DIR_OUTPUT, 1, pana_pdos + 0 , EC_WD_DISABLE},
+	{3, EC_DIR_INPUT, 1, pana_pdos + 1 , EC_WD_DISABLE},
+	{0xff}
+};
+
+/* Inovance Servo */
+ec_pdo_entry_info_t inov_pdo_entries[] = {
+	{0x6040, 0x00, 16},
+	{0x60ff, 0x00, 32},
+	{0x6060, 0x00, 8},
+	{0x6041, 0x00, 16},
+	{0x6064, 0x00, 32},
+	{0x606c, 0x00, 32},
+	{0x60fd, 0x00, 32},
+};
+
+ec_pdo_info_t inov_pdos[] = {
+	{0x1600, 3, inov_pdo_entries + 0},
+	{0x1a00, 3, inov_pdo_entries + 3},
+};
+
+ec_sync_info_t inov_syncs[] = {
+	{0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+	{1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+	{2, EC_DIR_OUTPUT, 1, inov_pdos + 0 , EC_WD_ENABLE},
+	{3, EC_DIR_INPUT, 1, inov_pdos + 1 , EC_WD_DISABLE},
+	{0xff}
+};
+
+#ifdef PANASONIC_USED
+#define SERVO_POS  			MADHT_SLAVE01_POS
+#define SERVO_ID   			MADHT_SLAVE01_ID
+ec_sync_info_t* servo_syncs = pana_syncs;
+#endif
+#ifdef INOVANCE_USED
+#define SERVO_POS  			INOV_SLAVE01_POS
+#define SERVO_ID   			INOV_SLAVE01_ID
+ec_sync_info_t* servo_syncs = inov_syncs;
+#endif
+
+#endif
+
diff --git a/examples/multi_axis/Makefile.am b/examples/multi_axis/Makefile.am
new file mode 100644
index 00000000..ac82f85c
--- /dev/null
+++ b/examples/multi_axis/Makefile.am
@@ -0,0 +1,54 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_multi_axis_example
+
+ec_multi_axis_example_SOURCES = main.c circle.c modbus_server/modbus_server.c
+
+if ENABLE_XENOMAI
+ec_multi_axis_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS)
+
+ec_multi_axis_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm -lmodbus \
+	$(XENOMAI_POSIX_LDFLAGS)
+else
+ec_multi_axis_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+ec_multi_axis_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat -lrt -lpthread -lmodbus
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/multi_axis/circle.c b/examples/multi_axis/circle.c
new file mode 100644
index 00000000..0b54d457
--- /dev/null
+++ b/examples/multi_axis/circle.c
@@ -0,0 +1,68 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+#include "circle.h"
+#include "def_config.h"
+
+#define Per_Circle  (2*3.1415926)
+
+static double getLenBetweenAxis(axis_pos a, axis_pos b)
+{
+    double diff1,diff2;
+    diff1 = a.x-b.x;
+    diff2 = a.y-b.y;
+    return sqrt(diff1*diff1+diff2*diff2);
+}
+
+void circle_init(circle_prop* prop)
+{
+    double diff,len;
+    len = getLenBetweenAxis(prop->servo_pos1, prop->servo_pos2);
+    if(prop->servo_len1 > prop->servo_len2){
+        diff = (prop->servo_len1*prop->servo_len1 - prop->servo_len2*prop->servo_len2)/len;
+        prop->current_pos.x = (len+diff)/2 + prop->servo_pos1.x;
+        prop->current_pos.y = prop->servo_pos1.y - sqrt(prop->servo_len1*prop->servo_len1-(len+diff)*(len+diff)/4);
+    }else{
+        diff = (prop->servo_len2*prop->servo_len2 - prop->servo_len1*prop->servo_len1)/len;
+        prop->current_pos.x = prop->servo_pos2.x - (len+diff)/2;
+        prop->current_pos.y = prop->servo_pos2.y - sqrt(prop->servo_len2*prop->servo_len2-(len+diff)*(len+diff)/4);
+    }
+    prop->center_pos.x = prop->current_pos.x + prop->circle_radius;
+    prop->center_pos.y = prop->current_pos.y;
+    prop->current_angle = 0.0000;
+}
+
+void circle_CurPosAdjust(circle_prop* prop, double a_len, double b_len, int* position_x, int* position_y)
+{
+	double diff,len;
+	float2int data_x,data_y;
+	len = getLenBetweenAxis(prop->servo_pos1, prop->servo_pos2);
+	if(a_len > b_len){
+		diff = (a_len*a_len-b_len*b_len)/len;
+		prop->current_pos.x = (len+diff)/2 + prop->servo_pos1.x;
+		prop->current_pos.y = prop->servo_pos1.y - sqrt(a_len*a_len-(len+diff)*(len+diff)/4);
+	}else{
+		diff = (b_len*b_len-a_len*a_len)/len;
+		prop->current_pos.x = prop->servo_pos2.x - (len+diff)/2;
+		prop->current_pos.y = prop->servo_pos2.y - sqrt(b_len*b_len-(len+diff)*(len+diff)/4);
+	}
+	data_x.f = prop->current_pos.x;
+	data_y.f = prop->current_pos.y;
+	*position_x = data_x.i;
+	*position_y = data_y.i;
+}
+
+void circle_TargetByStep(circle_prop* prop, double step, double* a_len, double* b_len)
+{
+	double target_angle;
+	axis_pos target_pos;
+	target_angle = prop->current_angle+step;
+	target_pos.x = prop->center_pos.x - prop->circle_radius * cos(target_angle);
+	target_pos.y = prop->center_pos.y + prop->circle_radius * sin(target_angle);
+	*a_len = getLenBetweenAxis(target_pos, prop->servo_pos1);
+	*b_len = getLenBetweenAxis(target_pos, prop->servo_pos2);
+	prop->current_angle += step;
+	if (prop->current_angle >= Per_Circle)
+		prop->current_angle -= Per_Circle;
+}
+
diff --git a/examples/multi_axis/circle.h b/examples/multi_axis/circle.h
new file mode 100644
index 00000000..11ea0f2a
--- /dev/null
+++ b/examples/multi_axis/circle.h
@@ -0,0 +1,30 @@
+#ifndef __CIRCLE_ALOG_H__
+#define __CIRCLE_ALOG_H__
+
+typedef union{
+    float f;
+    int i;
+} float2int;
+
+typedef struct {
+    double x;
+    double y;
+} axis_pos;
+
+typedef struct {
+    axis_pos servo_pos1;
+    axis_pos servo_pos2;
+    double servo_len1;
+    double servo_len2;
+    unsigned long circle_radius;
+	axis_pos center_pos;
+	axis_pos current_pos;
+	double current_angle;
+} circle_prop;
+
+void circle_init(circle_prop *prop);
+void circle_CurPosAdjust(circle_prop *prop, double a_len, double b_len, int* position_x, int* position_y);
+void circle_TargetByStep(circle_prop *prop, double step, double* a_len, double* b_len);
+
+#endif
+
diff --git a/examples/multi_axis/def_config.h b/examples/multi_axis/def_config.h
new file mode 100644
index 00000000..9011b9c1
--- /dev/null
+++ b/examples/multi_axis/def_config.h
@@ -0,0 +1,23 @@
+#ifndef __ETHERCAT_CONFIG_H__
+#define __ETHERCAT_CONFIG_H__
+
+//#define DEBUG_CONSOLE_FS
+
+#define MEASURE_TIMING 
+#define SERVO_ETHERCAT_ENABLE
+#define SHARE_MEM
+#define MOTOR_CONTROL
+#define MODBUS_SERVER
+
+#define MOTOR_8AXIS
+//#define MOTOR_6AXIS
+//#define MOTOR_2AXIS
+
+#if (defined(MOTOR_8AXIS) && defined(MOTOR_6AXIS)) || \
+    (defined(MOTOR_8AXIS) && defined(MOTOR_2AXIS)) || \
+    (defined(MOTOR_6AXIS) && defined(MOTOR_2AXIS))
+#error "MOTOR_*AXIS macro have multiply definition, only one is supported!"
+#endif
+
+#endif
+
diff --git a/examples/multi_axis/main.c b/examples/multi_axis/main.c
new file mode 100644
index 00000000..9cec65a5
--- /dev/null
+++ b/examples/multi_axis/main.c
@@ -0,0 +1,1351 @@
+/******************************************************************************
+ *
+ *  $Id$
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <string.h>
+#include <unistd.h>
+#include <limits.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+#include "main.h"
+#include "circle.h"
+#include <getopt.h>
+#ifdef MODBUS_SERVER
+#include "modbus_server/modbus_server.h"
+#endif
+
+#ifdef SHARE_MEM
+#define BUF_SIZE				0x1000
+#define BUF_READ_SIZE			0x0C00
+#define MOTOR_CTL_BUF_SIZE		0x0400
+#define MOTOR_STATUS_ADDRESS	0x0400
+#define MOTOR_CTL_ADDRESS		0x0C00
+char mem_buffer[BUF_READ_SIZE];
+char motor_ctl_buffer[MOTOR_CTL_BUF_SIZE];
+void *shm_addr = NULL;
+int shmid;
+#endif
+
+//static unsigned int err_value = 0xffffffff; /* 1um = 50*20/0x100000 */
+
+circle_prop prop;
+static unsigned int measure_time = 0;
+static pthread_t cyclic_thread;
+static volatile int run = 1;
+static volatile int close_signal = 0;
+static bool motor_run = false;
+
+static ec_master_t *master = NULL;
+ec_domain_t *domain = NULL;
+ec_domain_state_t domain_state;
+uint8_t *domain_pd = NULL;
+
+#ifdef SERVO_ETHERCAT_ENABLE
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+static unsigned char motor34_vel = 5;
+static unsigned char motor56_vel = 15;
+static unsigned char motor78_vel = 2;
+#endif
+#endif
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+static Slave_Data ec_slave0;
+static Slave_Data ec_slave1;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+static Slave_Data ec_slave2;
+static Slave_Data ec_slave3;
+static Slave_Data ec_slave4;
+static Slave_Data ec_slave5;
+static Slave_Data ec_slave6;
+static Slave_Data ec_slave7;
+#endif
+
+const static ec_pdo_entry_reg_t domain0_regs[] = {
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x6040, 0x00, &ec_slave0.ctrl_word, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x607a, 0x00, &ec_slave0.tar_pos, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x6060, 0x00, &ec_slave0.mode_sel, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60b8, 0x00, &ec_slave0.touch_probe_func, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x2002, 0x03, &ec_slave0.mode_cw, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x603f, 0x00, &ec_slave0.error_code, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x6041, 0x00, &ec_slave0.status_word, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x6064, 0x00, &ec_slave0.pos_act, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x6061, 0x00, &ec_slave0.mode_display, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60b9, 0x00, &ec_slave0.touch_probe_status, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60ba, 0x00, &ec_slave0.touch_probe1_pos, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60bc, 0x00, &ec_slave0.touch_probe2_pos, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60fd, 0x00, &ec_slave0.digital_input, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x606c, 0x00, &ec_slave0.vel_act, NULL},
+    {IS620N_Slave00_Pos, IS620N_SLAVE00_ID, 0x60f4, 0x00, &ec_slave0.err_pos, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x6040, 0x00, &ec_slave1.ctrl_word, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x607a, 0x00, &ec_slave1.tar_pos, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x6060, 0x00, &ec_slave1.mode_sel, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60b8, 0x00, &ec_slave1.touch_probe_func, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x2002, 0x03, &ec_slave1.mode_cw, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x603f, 0x00, &ec_slave1.error_code, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x6041, 0x00, &ec_slave1.status_word, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x6064, 0x00, &ec_slave1.pos_act, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x6061, 0x00, &ec_slave1.mode_display, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60b9, 0x00, &ec_slave1.touch_probe_status, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60ba, 0x00, &ec_slave1.touch_probe1_pos, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60bc, 0x00, &ec_slave1.touch_probe2_pos, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60fd, 0x00, &ec_slave1.digital_input, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x606c, 0x00, &ec_slave1.vel_act, NULL},
+    {IS620N_Slave01_Pos, IS620N_SLAVE01_ID, 0x60f4, 0x00, &ec_slave1.err_pos, NULL},
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x6040, 0x00, &ec_slave2.ctrl_word, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x607a, 0x00, &ec_slave2.tar_pos, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x6060, 0x00, &ec_slave2.mode_sel, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60b8, 0x00, &ec_slave2.touch_probe_func, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x2002, 0x03, &ec_slave2.mode_cw, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x603f, 0x00, &ec_slave2.error_code, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x6041, 0x00, &ec_slave2.status_word, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x6064, 0x00, &ec_slave2.pos_act, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x6061, 0x00, &ec_slave2.mode_display, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60b9, 0x00, &ec_slave2.touch_probe_status, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60ba, 0x00, &ec_slave2.touch_probe1_pos, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60bc, 0x00, &ec_slave2.touch_probe2_pos, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60fd, 0x00, &ec_slave2.digital_input, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x606c, 0x00, &ec_slave2.vel_act, NULL},
+    {IS620N_Slave02_Pos, IS620N_SLAVE02_ID, 0x60f4, 0x00, &ec_slave2.err_pos, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x6040, 0x00, &ec_slave3.ctrl_word, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x607a, 0x00, &ec_slave3.tar_pos, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x6060, 0x00, &ec_slave3.mode_sel, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60b8, 0x00, &ec_slave3.touch_probe_func, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x2002, 0x03, &ec_slave3.mode_cw, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x603f, 0x00, &ec_slave3.error_code, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x6041, 0x00, &ec_slave3.status_word, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x6064, 0x00, &ec_slave3.pos_act, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x6061, 0x00, &ec_slave3.mode_display, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60b9, 0x00, &ec_slave3.touch_probe_status, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60ba, 0x00, &ec_slave3.touch_probe1_pos, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60bc, 0x00, &ec_slave3.touch_probe2_pos, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60fd, 0x00, &ec_slave3.digital_input, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x606c, 0x00, &ec_slave3.vel_act, NULL},
+    {IS620N_Slave03_Pos, IS620N_SLAVE03_ID, 0x60f4, 0x00, &ec_slave3.err_pos, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x6040, 0x00, &ec_slave4.ctrl_word, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x607a, 0x00, &ec_slave4.tar_pos, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x6060, 0x00, &ec_slave4.mode_sel, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60b8, 0x00, &ec_slave4.touch_probe_func, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x2002, 0x03, &ec_slave4.mode_cw, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x603f, 0x00, &ec_slave4.error_code, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x6041, 0x00, &ec_slave4.status_word, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x6064, 0x00, &ec_slave4.pos_act, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x6061, 0x00, &ec_slave4.mode_display, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60b9, 0x00, &ec_slave4.touch_probe_status, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60ba, 0x00, &ec_slave4.touch_probe1_pos, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60bc, 0x00, &ec_slave4.touch_probe2_pos, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60fd, 0x00, &ec_slave4.digital_input, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x606c, 0x00, &ec_slave4.vel_act, NULL},
+    {IS620N_Slave04_Pos, IS620N_SLAVE04_ID, 0x60f4, 0x00, &ec_slave4.err_pos, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x6040, 0x00, &ec_slave5.ctrl_word, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x607a, 0x00, &ec_slave5.tar_pos, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x6060, 0x00, &ec_slave5.mode_sel, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60b8, 0x00, &ec_slave5.touch_probe_func, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x2002, 0x03, &ec_slave5.mode_cw, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x603f, 0x00, &ec_slave5.error_code, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x6041, 0x00, &ec_slave5.status_word, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x6064, 0x00, &ec_slave5.pos_act, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x6061, 0x00, &ec_slave5.mode_display, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60b9, 0x00, &ec_slave5.touch_probe_status, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60ba, 0x00, &ec_slave5.touch_probe1_pos, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60bc, 0x00, &ec_slave5.touch_probe2_pos, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60fd, 0x00, &ec_slave5.digital_input, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x606c, 0x00, &ec_slave5.vel_act, NULL},
+    {IS620N_Slave05_Pos, IS620N_SLAVE05_ID, 0x60f4, 0x00, &ec_slave5.err_pos, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x6040, 0x00, &ec_slave6.ctrl_word, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x607a, 0x00, &ec_slave6.tar_pos, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x6060, 0x00, &ec_slave6.mode_sel, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60b8, 0x00, &ec_slave6.touch_probe_func, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x2002, 0x03, &ec_slave6.mode_cw, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x603f, 0x00, &ec_slave6.error_code, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x6041, 0x00, &ec_slave6.status_word, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x6064, 0x00, &ec_slave6.pos_act, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x6061, 0x00, &ec_slave6.mode_display, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60b9, 0x00, &ec_slave6.touch_probe_status, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60ba, 0x00, &ec_slave6.touch_probe1_pos, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60bc, 0x00, &ec_slave6.touch_probe2_pos, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60fd, 0x00, &ec_slave6.digital_input, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x606c, 0x00, &ec_slave6.vel_act, NULL},
+    {IS620N_Slave06_Pos, IS620N_SLAVE06_ID, 0x60f4, 0x00, &ec_slave6.err_pos, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x6040, 0x00, &ec_slave7.ctrl_word, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x607a, 0x00, &ec_slave7.tar_pos, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x6060, 0x00, &ec_slave7.mode_sel, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60b8, 0x00, &ec_slave7.touch_probe_func, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x2002, 0x03, &ec_slave7.mode_cw, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x603f, 0x00, &ec_slave7.error_code, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x6041, 0x00, &ec_slave7.status_word, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x6064, 0x00, &ec_slave7.pos_act, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x6061, 0x00, &ec_slave7.mode_display, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60b9, 0x00, &ec_slave7.touch_probe_status, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60ba, 0x00, &ec_slave7.touch_probe1_pos, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60bc, 0x00, &ec_slave7.touch_probe2_pos, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60fd, 0x00, &ec_slave7.digital_input, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x606c, 0x00, &ec_slave7.vel_act, NULL},
+    {IS620N_Slave07_Pos, IS620N_SLAVE07_ID, 0x60f4, 0x00, &ec_slave7.err_pos, NULL},
+#endif
+    {}
+};
+
+#ifdef SHARE_MEM
+static void write_buf_int16(char* dest,int16_t src)
+{
+	dest[1] = (char)(src>>8);
+	dest[0] = (char)(src);
+}
+
+static void write_buf_int32(char* dest,int32_t src)
+{
+	dest[3] = (char)(src>>8);
+	dest[2] = (char)(src);
+	dest[1] = (char)(src>>24);
+	dest[0] = (char)(src>>16);
+
+}
+
+static void write_buf_int64(char* dest,int64_t src)
+{
+	dest[7] = (char)(src>>8);
+	dest[6] = (char)(src);
+	dest[5] = (char)(src>>24);
+	dest[4] = (char)(src>>16);
+	dest[3] = (char)(src>>40);
+	dest[2] = (char)(src>>32);
+	dest[1] = (char)(src>>56);
+	dest[0] = (char)(src>>48);
+}
+
+static void write_sharemem_ctl_data(char* dest,unsigned short int offset,Ctl_Data *data)
+{
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x00,data->statusword);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x02,data->actualpos);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x06,data->cwmode);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x08,data->controlword);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x0a,data->targetpos);
+	write_buf_int16(dest+MOTOR_STATUS_ADDRESS+offset+0x0e,data->selmode);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x10,data->actualvel);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x14,data->zeroposition);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x18,data->minposition);
+	write_buf_int32(dest+MOTOR_STATUS_ADDRESS+offset+0x1c,data->maxposition);
+}
+#endif
+
+static void data_init(void)
+{
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    memset(&ec_slave0,0,sizeof(Slave_Data));
+    memset(&ec_slave1,0,sizeof(Slave_Data));
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    memset(&ec_slave2,0,sizeof(Slave_Data));
+    memset(&ec_slave3,0,sizeof(Slave_Data));
+    memset(&ec_slave4,0,sizeof(Slave_Data));
+    memset(&ec_slave5,0,sizeof(Slave_Data));
+    memset(&ec_slave6,0,sizeof(Slave_Data));
+    memset(&ec_slave7,0,sizeof(Slave_Data));
+#endif
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ec_slave0.sc = NULL;
+    ec_slave1.sc = NULL;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ec_slave2.sc = NULL;
+    ec_slave3.sc = NULL;
+    ec_slave4.sc = NULL;
+    ec_slave5.sc = NULL;
+    ec_slave6.sc = NULL;
+    ec_slave7.sc = NULL;
+#endif
+
+#ifdef DEBUG_CONSOLE_FS
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ec_slave0.fd = fopen(LEN0_FILE_NAME,"w+");
+    ec_slave1.fd = fopen(LEN1_FILE_NAME,"w+");
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ec_slave2.fd = fopen(LEN2_FILE_NAME,"w+");
+    ec_slave3.fd = fopen(LEN3_FILE_NAME,"w+");
+    ec_slave4.fd = fopen(LEN4_FILE_NAME,"w+");
+    ec_slave5.fd = fopen(LEN5_FILE_NAME,"w+");
+    ec_slave6.fd = fopen(LEN6_FILE_NAME,"w+");
+    ec_slave7.fd = fopen(LEN7_FILE_NAME,"w+");
+#endif
+#endif
+}
+
+static void axis_circle_init(void){
+    /* mm */
+    prop.servo_pos1.x = 0.0;
+    prop.servo_pos1.y = 300.0;
+    prop.servo_pos2.x = 300.0;
+    prop.servo_pos2.y = 300.0;
+    prop.servo_len1 = 300.0;
+    prop.servo_len2 = 280.0;
+    prop.circle_radius = 150;
+    circle_init(&prop);
+}
+
+#ifdef SHARE_MEM
+static char sharemem_init(void)
+{
+    shmid = shmget((key_t)87654321, BUF_SIZE, IPC_CREAT|0666);
+    printf("shmid : %u\n", shmid);
+    if (shmid == -1){
+        perror("shmget error!");
+        return -1;
+    }
+    shm_addr = shmat(shmid, NULL, 0);
+    if (shm_addr == (void *) -1){
+        perror("shmat error!");
+        return -1;
+    }
+    return 0;
+}
+#endif
+
+#ifdef SERVO_ETHERCAT_ENABLE
+static void ec_slave_config_init(ec_slave_config_t *sc)
+{
+    /* Clear RxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 0); /*clear sm pdo 0x1c12*/
+    ecrt_slave_config_sdo8(sc, 0x1600, 0, 0); /*clear sm pdo 0x1600*/
+    /* Define RxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1600, 1, 0x60400010); /*0x6040:0/16bits, control word*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 2, 0x60600008); /*0x6060:0/8bits, modes of operation*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 3, 0x607A0020); /*0x607A:0/32bits, Target postion*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 4, 0x60B80010); /*0x60B8:0/32bits, Touch probe function*/
+    ecrt_slave_config_sdo32(sc, 0x1600, 5, 0x20020010); /*0x2002:0/16bits, cw mode*/
+    ecrt_slave_config_sdo8(sc, 0x1600, 0, 5); /*set number of RxPDO*/
+    ecrt_slave_config_sdo16(sc, 0x1C12, 1, 0x1600 ); /*list all RxPdo in 0x1600*/
+    ecrt_slave_config_sdo8(sc, 0x1C12, 0, 1 ); /*set number of RxPDO*/
+    /* Clear TxPDO */
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 0); /*clear sm pdo 0x1c12*/
+    ecrt_slave_config_sdo8(sc, 0x1A00, 0, 0); /*clear sm pdo 0x1A00*/
+    /* Define TxPDO */
+    ecrt_slave_config_sdo32(sc, 0x1A00, 1, 0x60410010); /*0x6041:0/16bits, status word*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 2, 0x60610008); /*0x6061:0/8bits, modes of operation display*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 3, 0x60640020); /*0x6064:0/32bits, Position actual value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 4, 0x60B90010); /*0x60B9:0/16bits, Touch probe status*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 5, 0x60BA0020); /*0x60BA:0/32bits, Touch probe pos 1 pos value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 6, 0x60BC0020); /*0x60BC:0/32bits, Touch probe pos 2 pos value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 7, 0x603F0010); /*0x603F:0/16bits, Error code*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 8, 0x60FD0020); /*0x60FD:0/16bits, Digital inputs*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 9, 0x606C0020); /*0x606C:0/32bits, velocity actual value*/
+    ecrt_slave_config_sdo32(sc, 0x1A00, 10, 0x60F40020); /*0x60F4:0/32bits, Error position value*/
+    ecrt_slave_config_sdo8(sc, 0x1A00, 0, 10); /*set number of TxPDO*/
+    ecrt_slave_config_sdo16(sc, 0x1C13, 1, 0x1A00 ); /*list all TxPdo in 0x1C13*/
+    ecrt_slave_config_sdo8(sc, 0x1C13, 0, 1 ); /*set number of TxPDO*/
+}
+
+/*****************************************************************************
+ * Realtime task
+ ****************************************************************************/
+static void rt_check_domain_state(void)
+{
+    ec_domain_state_t ds = {};
+
+    ecrt_domain_state(domain, &ds);
+    if (ds.working_counter != domain_state.working_counter)
+        printf("Domain: WC %u.\n", ds.working_counter);
+    if (ds.wc_state != domain_state.wc_state)
+        printf("Domain: State %u.\n", ds.wc_state);
+    domain_state = ds;
+}
+
+static void rt_check_master_state(void)
+{
+	static ec_master_state_t master_state = {};
+    ec_master_state_t ms;
+
+    ecrt_master_state(master, &ms);
+    if (ms.slaves_responding != master_state.slaves_responding)
+        printf("%u slave(s).\n", ms.slaves_responding);
+    if (ms.al_states != master_state.al_states)
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    if (ms.link_up != master_state.link_up)
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+
+    master_state = ms;
+}
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+static double calc_len(unsigned long pos, unsigned long prevpos)
+{
+    long inter = pos - prevpos;
+    return (double)(inter*SERVO_AXIS_SIZE/MAX_DECODER_COUNT);
+}
+
+static signed long calc_targetoffset(double target, double current)
+{
+	return (signed long)(((target-current)/SERVO_AXIS_SIZE)*MAX_DECODER_COUNT);
+}
+#endif
+
+static void ec_readmotordata(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    ec_motor->statusword 	= EC_READ_U16(domain_pd + ec_slave.status_word);
+    ec_motor->actualpos  	= EC_READ_S32(domain_pd + ec_slave.pos_act);
+    ec_motor->cwmode     	= EC_READ_U16(domain_pd + ec_slave.mode_cw);
+    ec_motor->selmode    	= EC_READ_S8(domain_pd + ec_slave.mode_sel);
+    ec_motor->actualvel		= EC_READ_S32(domain_pd + ec_slave.vel_act);
+    ec_motor->leftinput	    = (EC_READ_U32(domain_pd + ec_slave.digital_input))&0x1;
+    ec_motor->homeinput	    = (EC_READ_U32(domain_pd + ec_slave.digital_input))&0x2;
+    ec_motor->rightinput	= (EC_READ_U32(domain_pd + ec_slave.digital_input))&0x4;
+    ec_motor->errpos		= EC_READ_U32(domain_pd + ec_slave.err_pos);
+    if(ec_motor->actualvel > MAX_VELOCITY_MOTOR/2)
+        ec_motor->actualvel = ec_motor->actualvel - MAX_VELOCITY_MOTOR;
+    if ((ec_motor->statusword & 0x4f) == 0x40)
+        ec_motor->controlword = 0x6;
+    else if ((ec_motor->statusword & 0x6f) == 0x21)
+        ec_motor->controlword = 0x7;
+    else if ((ec_motor->statusword & 0x27f)==0x233){
+        ec_motor->prevpos = ec_motor->actualpos;
+        ec_motor->controlword = 0xf;
+    }
+    else if ((ec_motor->statusword & 0x27f)==0x237)
+        ec_motor->controlword = 0x1f;
+    else
+        ec_motor->controlword = 0x80;
+}
+
+static void ec_writemotordata(Ctl_Data* ec_motor,Slave_Data ec_slave)
+{
+    EC_WRITE_S32(domain_pd+ec_slave.tar_pos, ec_motor->targetpos );
+    EC_WRITE_U16(domain_pd+ec_slave.ctrl_word, ec_motor->controlword );
+    EC_WRITE_U8(domain_pd+ec_slave.mode_sel, 8 );
+    ec_motor->prevpos = ec_motor->actualpos;
+}
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+#define		Pi	3.141592654
+static long getCosPos(unsigned int *time, int min,int max,int index)
+{
+    long pos = 0;
+    int A = min - max;
+    float TA = motor34_vel*1000000.0/CYCLE_US;
+    float TB = motor56_vel*1000000.0/CYCLE_US;
+
+    if(time == NULL)
+        return 0;
+    if(index == 2) {
+        if(*time == 0)
+            return 0;
+        pos = -A*(cos(2.0*Pi*(*time)/TA) - cos(2.0*Pi*(*time-1)/TA));
+        if(*time >= TA)
+            *time = 0;
+        return pos;
+    }
+    else if(index == 3){
+        if(*time == 0)
+            return 0;
+        pos = -A*(cos(2.0*Pi*(*time)/TB) - cos(2.0*Pi*(*time-1)/TB));
+        if(*time >= TB)
+            *time = 0;
+        return pos;
+    }
+    return 0;
+}
+
+#define     A       0xa00000
+static long getSinPos(unsigned int time)
+{
+    long pos = 0;
+    float T = motor78_vel*1000000.0/CYCLE_US;
+
+    if(time == 0)
+	    return 0;
+    else{
+	    pos = A*(sin(2.0*Pi*time/T) - sin(2.0*Pi*(time-1)/T));
+	    return pos;
+    }
+}
+#endif
+#endif
+
+void *my_thread(void *arg)
+{
+    struct timespec next_period;
+    unsigned int cycle_counter = 0;
+
+#ifdef SERVO_ETHERCAT_ENABLE
+    struct timespec dc_period;
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+	int circle_x=0;
+	int circle_y=0;
+    double cur_slave0_len = prop.servo_len1;
+    double cur_slave1_len = prop.servo_len2;
+    unsigned char circle0_run = MOTOR_START;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    unsigned int motor23_timecounter = 0;
+    unsigned int motor45_timecounter = 0;
+    unsigned char circle1_run = MOTOR_START;
+    unsigned char circle2_run = MOTOR_START;
+    unsigned char circle3_run = MOTOR_START;
+#endif
+	if(motor_run == false){
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+		circle0_run = MOTOR_STOP;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+		circle3_run = MOTOR_STOP;
+#endif
+	}
+#endif
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    Ctl_Data ec_motor0;
+    Ctl_Data ec_motor1;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    Ctl_Data ec_motor2;
+    Ctl_Data ec_motor3;
+    Ctl_Data ec_motor4;
+    Ctl_Data ec_motor5;
+    Ctl_Data ec_motor6;
+    Ctl_Data ec_motor7;
+#endif
+
+#ifdef MEASURE_TIMING
+    unsigned int cycle_counter_max_cycle = 0;
+    unsigned int cycle_counter_max_jitter = 0;
+    unsigned int last_cycle_counter = 0;
+    uint8_t servo_run = 0;
+
+	struct timespec startTime = {0, 0};
+	struct timespec endTime = {0, 0};
+	struct timespec	lastStartTime ={0, 0};
+	struct timespec rece_startTime = {0, 0};
+	struct timespec rece_endTime = {0, 0};
+	struct timespec pro_endTime = {0, 0};
+	struct timespec send_startTime = {0, 0};
+	struct timespec send_endTime = {0, 0};
+
+    int64_t period_ns = 0, exec_ns = 0, receive_ns = 0, process_ns, send_ns,
+            period_min_ns = 1000000, period_max_ns = 0,
+            exec_min_ns = 1000000, exec_max_ns = 0;
+    int64_t latency_ns = 0;
+    int64_t latency_min_ns = 1000000, latency_max_ns = -1000000;
+    int64_t total_exec_ns=0;
+    int64_t total_cycle_ns=0;
+    static int64_t max_cycle_persec=0, max_jitter_persec=0;
+    int64_t avg_cycle_time = 0;
+    int64_t min_cycle_time = 1000000;
+    int64_t max_cycle_time = -1000000;
+    int64_t min_jitter_time = 1000000;
+    int64_t max_jitter_time = -1000000;
+#endif
+
+    struct sched_param param = {.sched_priority = 99};
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    memset(&ec_motor0,0,sizeof(Ctl_Data));
+    memset(&ec_motor1,0,sizeof(Ctl_Data));
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    memset(&ec_motor2,0,sizeof(Ctl_Data));
+    memset(&ec_motor3,0,sizeof(Ctl_Data));
+    memset(&ec_motor4,0,sizeof(Ctl_Data));
+    memset(&ec_motor5,0,sizeof(Ctl_Data));
+    memset(&ec_motor6,0,sizeof(Ctl_Data));
+    memset(&ec_motor7,0,sizeof(Ctl_Data));
+#endif
+
+	clock_gettime(CLOCK_MONOTONIC, &next_period);
+#ifdef MEASURE_TIMING
+	lastStartTime = next_period;
+	endTime = next_period;
+#endif
+
+    while ((run != 0 )||(close_signal != 0)) {
+        next_period.tv_nsec += CYCLE_US * 1000;
+        while (next_period.tv_nsec >= NSEC_PER_SEC) {
+			next_period.tv_nsec -= NSEC_PER_SEC;
+			next_period.tv_sec++;
+	    }
+
+        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &next_period, NULL);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &startTime);
+        latency_ns = DIFF_NS(next_period, startTime);
+        period_ns = DIFF_NS(lastStartTime, startTime);
+        exec_ns = DIFF_NS(lastStartTime, endTime);
+        receive_ns = DIFF_NS(rece_startTime, rece_endTime);
+        process_ns = DIFF_NS(rece_endTime, pro_endTime);
+        send_ns = DIFF_NS(send_startTime, send_endTime);
+        lastStartTime = startTime;
+
+        if (latency_ns > latency_max_ns) 
+            latency_max_ns = latency_ns;
+        if (latency_ns < latency_min_ns)
+            latency_min_ns = latency_ns;
+        if (period_ns > period_max_ns)
+            period_max_ns = period_ns;
+        if (period_ns < period_min_ns)
+            period_min_ns = period_ns;
+        if (exec_ns > exec_max_ns)
+            exec_max_ns = exec_ns;
+        if (exec_ns < exec_min_ns)
+            exec_min_ns = exec_ns;
+        total_exec_ns += exec_ns;
+#endif
+        cycle_counter++;
+	    if(close_signal > 0)
+		    close_signal--;
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &rece_startTime);
+#endif
+#ifdef SERVO_ETHERCAT_ENABLE
+        ecrt_master_receive(master);
+#endif
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &rece_endTime);
+#endif
+#ifdef SERVO_ETHERCAT_ENABLE
+        ecrt_domain_process(domain);
+#endif
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &pro_endTime);
+#endif
+        if ((!(cycle_counter % CYCLE_COUNTER_PERSEC))&&(close_signal==0)) {
+#ifdef SERVO_ETHERCAT_ENABLE
+	        rt_check_master_state();
+#endif
+#ifdef MEASURE_TIMING
+            if(min_cycle_time > exec_min_ns)
+                min_cycle_time = exec_min_ns;
+            if(max_cycle_time < exec_max_ns){
+                cycle_counter_max_cycle = cycle_counter;
+                max_cycle_time = exec_max_ns;
+            }
+            if(min_jitter_time > latency_min_ns)
+                min_jitter_time = latency_min_ns;
+            if(max_jitter_time < latency_max_ns){
+                cycle_counter_max_jitter = cycle_counter;
+                max_jitter_time = latency_max_ns;
+            }
+            last_cycle_counter = cycle_counter;
+            max_cycle_persec = exec_max_ns;
+            max_jitter_persec = latency_max_ns;
+            period_max_ns = -1000000;
+            period_min_ns = 1000000;
+            exec_max_ns = -1000000;
+            exec_min_ns = 1000000;
+            latency_max_ns = -1000000;
+            latency_min_ns = 1000000;
+            total_cycle_ns += total_exec_ns;
+            total_exec_ns = 0;
+            if(servo_run == 0){
+                cycle_counter = 0;
+                total_cycle_ns = 0;
+                min_jitter_time = 1000000;
+                max_jitter_time = -1000000;
+                min_cycle_time = 1000000;
+                max_cycle_time = -1000000;
+                servo_run = 1;
+            }
+#endif
+        }
+
+#ifdef SERVO_ETHERCAT_ENABLE
+        rt_check_domain_state();
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+        ec_readmotordata(&ec_motor0,ec_slave0);
+        ec_readmotordata(&ec_motor1,ec_slave1);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+        ec_readmotordata(&ec_motor2,ec_slave2);
+        ec_readmotordata(&ec_motor3,ec_slave3);
+        ec_readmotordata(&ec_motor4,ec_slave4);
+        ec_readmotordata(&ec_motor5,ec_slave5);
+        ec_readmotordata(&ec_motor6,ec_slave6);
+        ec_readmotordata(&ec_motor7,ec_slave7);
+#endif
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+        if ((ec_motor0.controlword==0x1f)&&(ec_motor1.controlword==0x1f)){
+            double diff0, diff1;
+            double axis0_len, axis1_len;
+            if (circle0_run == MOTOR_START){
+                circle0_run = MOTOR_RUN;
+                ec_motor0.targetpos = ec_motor0.actualpos;
+                ec_motor1.targetpos = ec_motor1.actualpos;
+                ec_motor0.prevpos = ec_motor0.actualpos;
+                ec_motor1.prevpos = ec_motor1.actualpos;
+                ec_writemotordata(&ec_motor0,ec_slave0);
+                ec_writemotordata(&ec_motor1,ec_slave1);
+            }
+	        else if(circle0_run == MOTOR_RUN){
+    	        //if((abs(ec_motor0.errpos) <= err_value)&&
+    	        //    (abs(ec_motor1.errpos) <= err_value))
+	            {
+            	    diff0 = calc_len(ec_motor0.actualpos, ec_motor0.prevpos);
+            	    cur_slave0_len += diff0;
+            	    diff1 = calc_len(ec_motor1.actualpos, ec_motor1.prevpos);
+            	    cur_slave1_len += diff1;
+            	    circle_CurPosAdjust(&prop, cur_slave0_len, cur_slave1_len, &circle_x, &circle_y);
+            	    circle_TargetByStep(&prop, 0.00005, &axis0_len, &axis1_len);
+            	    ec_motor0.targetpos = ec_motor0.actualpos + calc_targetoffset(axis0_len, cur_slave0_len);
+            	    ec_motor1.targetpos = ec_motor1.actualpos + calc_targetoffset(axis1_len, cur_slave1_len);
+            	    ec_writemotordata(&ec_motor0,ec_slave0);
+            	    ec_writemotordata(&ec_motor1,ec_slave1);
+	            }
+            }
+        }
+        else if(circle0_run == MOTOR_START){
+            EC_WRITE_U16(domain_pd+ec_slave0.ctrl_word, ec_motor0.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave0.mode_sel, 5 );
+            EC_WRITE_U16(domain_pd+ec_slave1.ctrl_word, ec_motor1.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave1.mode_sel, 5 );
+        } else if(circle0_run == MOTOR_RUN)
+            circle0_run = MOTOR_START;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+        if ((ec_motor2.controlword==0x1f)&&(ec_motor3.controlword==0x1f)){
+            long pos = 0;
+            if (circle1_run == MOTOR_START){
+                circle1_run = MOTOR_RUN;
+                ec_motor2.targetpos = ec_motor2.actualpos;
+                ec_motor3.targetpos = ec_motor3.actualpos;
+                ec_motor2.prevpos = ec_motor2.actualpos;
+                ec_motor3.prevpos = ec_motor3.actualpos;
+                ec_motor2.cwmode = 0;
+                ec_motor3.cwmode = 1;
+                ec_writemotordata(&ec_motor2,ec_slave2);
+                ec_writemotordata(&ec_motor3,ec_slave3);
+            }
+	        else if(circle1_run == MOTOR_RUN){
+		        if((ec_motor2.gohome_history == GO_HOME_FINISH)&&(ec_motor3.gohome_history == GO_HOME_FINISH)){
+                    //if((abs((ec_motor2.errpos) <= err_value)&&
+		       		//(abs(ec_motor3.errpos) <= err_value)))
+                    {
+                        pos = getCosPos(&motor23_timecounter,ec_motor2.minposition,ec_motor2.maxposition,2);
+                    	ec_motor2.targetpos = ec_motor2.targetpos - pos;
+                    	pos = getCosPos(&motor23_timecounter,ec_motor3.minposition,ec_motor3.maxposition,2);
+                    	ec_motor3.targetpos = ec_motor3.targetpos - pos;
+			            motor23_timecounter++;
+                    	ec_writemotordata(&ec_motor2,ec_slave2);
+                    	ec_writemotordata(&ec_motor3,ec_slave3);
+                    }
+		        }
+		        else{
+		            if((ec_motor2.leftinput)&&(ec_motor2.gohome_history == GO_HOME)){
+			            ec_motor2.zeroposition = ec_motor2.actualpos;
+			            ec_motor2.minposition = ec_motor2.actualpos + 0x300000;
+			            ec_motor2.maxposition = ec_motor2.actualpos + 0x700000;
+			            ec_motor3.zeroposition = ec_motor3.actualpos;
+			            ec_motor3.minposition = ec_motor3.actualpos - 0x300000;
+			            ec_motor3.maxposition = ec_motor3.actualpos - 0x700000;
+			            ec_motor2.gohome_history = GO_MINIMUM;
+			            ec_writemotordata(&ec_motor2,ec_slave2);
+			            ec_writemotordata(&ec_motor3,ec_slave3);
+		            }
+		            else if(ec_motor2.gohome_history == GO_MINIMUM){
+			            if(((long)ec_motor2.targetpos - ec_motor2.minposition) <= 0){
+			                ec_motor2.targetpos = ec_motor2.targetpos + 200;
+			                ec_motor3.targetpos = ec_motor3.targetpos - 200;
+			                ec_writemotordata(&ec_motor2,ec_slave2);
+			                ec_writemotordata(&ec_motor3,ec_slave3);
+			            }
+			            else{
+			                ec_motor2.gohome_history = GO_HOME_FINISH;
+			                ec_motor3.gohome_history = GO_HOME_FINISH;
+				            if(motor_run == false)
+					            circle1_run = MOTOR_STOP;
+			            }
+		            }
+		            else if(ec_motor2.gohome_history == GO_HOME){
+			            ec_motor2.targetpos = ec_motor2.targetpos - 200;
+			            ec_motor3.targetpos = ec_motor3.targetpos + 200;
+			            ec_writemotordata(&ec_motor2,ec_slave2);
+			            ec_writemotordata(&ec_motor3,ec_slave3);
+		            }
+		        }
+            }
+        }
+        else if(circle1_run == MOTOR_START){
+            EC_WRITE_U16(domain_pd+ec_slave2.ctrl_word, ec_motor2.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave2.mode_sel, 5 );
+            EC_WRITE_U16(domain_pd+ec_slave3.ctrl_word, ec_motor3.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave3.mode_sel, 5 );
+        } else if(circle1_run == MOTOR_RUN)
+            circle1_run = MOTOR_START;
+        if ((ec_motor4.controlword==0x1f)&&(ec_motor5.controlword==0x1f)) {
+            long pos = 0;
+            if (circle2_run == MOTOR_START){
+                circle2_run = MOTOR_RUN;
+                ec_motor4.targetpos = ec_motor4.actualpos;
+                ec_motor5.targetpos = ec_motor5.actualpos;
+                ec_motor4.prevpos = ec_motor4.actualpos;
+                ec_motor5.prevpos = ec_motor5.actualpos;
+                ec_writemotordata(&ec_motor4,ec_slave4);
+                ec_writemotordata(&ec_motor5,ec_slave5);
+            }
+	        else if(circle2_run == MOTOR_RUN){
+		        if((ec_motor4.gohome_history == GO_HOME_FINISH)&&(ec_motor5.gohome_history == GO_HOME_FINISH)){
+                    //if((abs((ec_motor4.errpos) <= err_value)&&
+					// (abs(ec_motor5.errpos) <= err_value)))
+                    {
+                    	pos = getCosPos(&motor45_timecounter,ec_motor4.minposition,ec_motor4.maxposition,3);
+                    	ec_motor4.targetpos = ec_motor4.targetpos - pos;
+                    	pos = getCosPos(&motor45_timecounter,ec_motor5.minposition,ec_motor5.maxposition,3);
+                    	ec_motor5.targetpos = ec_motor5.targetpos - pos;
+			            motor45_timecounter++;
+                    	ec_writemotordata(&ec_motor4,ec_slave4);
+                    	ec_writemotordata(&ec_motor5,ec_slave5);
+                    }
+		        }
+		        else{
+		            if((ec_motor5.leftinput)&&(ec_motor5.gohome_history == GO_HOME)){
+			            ec_motor4.zeroposition = ec_motor4.actualpos;
+			            ec_motor4.minposition = ec_motor4.actualpos + 0x400000;
+			            ec_motor4.maxposition = ec_motor4.actualpos + 0x1400000;
+			            ec_motor5.zeroposition = ec_motor5.actualpos;
+			            ec_motor5.minposition = ec_motor5.actualpos + 0x400000;
+			            ec_motor5.maxposition = ec_motor5.actualpos + 0x1400000;
+			            ec_motor5.gohome_history = GO_MINIMUM;
+			            ec_writemotordata(&ec_motor4,ec_slave4);
+			            ec_writemotordata(&ec_motor5,ec_slave5);
+		            }
+		            else if(ec_motor5.gohome_history == GO_MINIMUM){
+			            if(((long)ec_motor5.targetpos - ec_motor5.minposition) <= 0){
+			                ec_motor4.targetpos = ec_motor4.targetpos + 200;
+			                ec_motor5.targetpos = ec_motor5.targetpos + 200;
+			                ec_writemotordata(&ec_motor4,ec_slave4);
+			                ec_writemotordata(&ec_motor5,ec_slave5);
+			            }
+			            else{
+			                ec_motor4.gohome_history = GO_HOME_FINISH;
+			                ec_motor5.gohome_history = GO_HOME_FINISH;
+				            if(motor_run == false)
+					            circle2_run = MOTOR_STOP;
+			            }
+		            }
+		            else if(ec_motor5.gohome_history == GO_HOME){
+			            ec_motor4.targetpos = ec_motor4.targetpos - 200;
+			            ec_motor5.targetpos = ec_motor5.targetpos - 200;
+			            ec_writemotordata(&ec_motor4,ec_slave4);
+			            ec_writemotordata(&ec_motor5,ec_slave5);
+		            }
+		        }
+            }
+        }
+        else if(circle2_run == MOTOR_START){
+            EC_WRITE_U16(domain_pd+ec_slave4.ctrl_word, ec_motor4.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave4.mode_sel, 5 );
+            EC_WRITE_U16(domain_pd+ec_slave5.ctrl_word, ec_motor5.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave5.mode_sel, 5 );
+        } else if(circle2_run == MOTOR_RUN)
+            circle2_run = MOTOR_START;
+        if ((ec_motor6.controlword==0x1f)&&(ec_motor7.controlword==0x1f)) {
+#if 1
+			long pos = 0;
+			static unsigned int sin_time = 0;
+#endif
+            if (circle3_run == MOTOR_START){
+                circle3_run = MOTOR_RUN;
+                ec_motor6.targetpos = ec_motor6.actualpos;
+                ec_motor7.targetpos = ec_motor7.actualpos;
+                ec_motor6.prevpos = ec_motor6.actualpos;
+                ec_motor7.prevpos = ec_motor7.actualpos;
+                ec_writemotordata(&ec_motor6,ec_slave6);
+                ec_writemotordata(&ec_motor7,ec_slave7);
+            }
+	        else if(circle3_run == MOTOR_RUN){
+                //if((abs((ec_motor6.errpos) <= err_value)&&
+				//(abs(ec_motor7.errpos) < err_value)))
+                {
+		    		if(close_signal){
+                    	ec_motor6.targetpos = ec_motor6.targetpos + 1000*close_signal*CYCLE_US/1000000;
+                    	ec_motor7.targetpos = ec_motor7.targetpos - 1000*close_signal*CYCLE_US/1000000;
+		    		}
+		    		else{
+#if 0
+                    	ec_motor6.targetpos = ec_motor6.targetpos + 1000;
+                    	ec_motor7.targetpos = ec_motor7.targetpos - 1000;
+#else
+						pos = getSinPos(sin_time++);
+						ec_motor6.targetpos = ec_motor6.targetpos + pos;
+						ec_motor7.targetpos = ec_motor7.targetpos - pos;
+#endif
+		    		}
+                    ec_writemotordata(&ec_motor6,ec_slave6);
+                    ec_writemotordata(&ec_motor7,ec_slave7);
+                }
+            }
+        }
+        else if(circle3_run == MOTOR_START){
+            EC_WRITE_U16(domain_pd+ec_slave6.ctrl_word, ec_motor6.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave6.mode_sel, 5 );
+            EC_WRITE_U16(domain_pd+ec_slave7.ctrl_word, ec_motor7.controlword );
+            EC_WRITE_U8(domain_pd+ec_slave7.mode_sel, 5 );
+        } else if(circle3_run == MOTOR_RUN)
+            circle3_run = MOTOR_START;
+#endif
+    	clock_gettime(CLOCK_MONOTONIC, &dc_period);
+        ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+        ecrt_master_sync_reference_clock(master);
+        ecrt_master_sync_slave_clocks(master);
+        ecrt_domain_queue(domain);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &send_startTime);
+#endif
+        ecrt_master_send(master);
+#ifdef MEASURE_TIMING
+        clock_gettime(CLOCK_MONOTONIC, &send_endTime);
+#endif
+#endif
+
+#ifdef MEASURE_TIMING
+    	clock_gettime(CLOCK_MONOTONIC, &endTime);
+#endif
+#ifdef SHARE_MEM
+	    if(cycle_counter > 1){
+	        memset(mem_buffer,0,BUF_READ_SIZE);
+#ifdef MEASURE_TIMING
+	        write_buf_int64(mem_buffer,period_ns);
+	        write_buf_int64(mem_buffer+8,max_cycle_persec);
+	        write_buf_int64(mem_buffer+16,max_jitter_persec);
+	        write_buf_int32(mem_buffer+24,cycle_counter);
+#ifdef SERVO_ETHERCAT_ENABLE
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+	        write_buf_int32(mem_buffer+28,circle_x);
+	        write_buf_int32(mem_buffer+32,circle_y);
+#endif
+#endif
+	        write_buf_int64(mem_buffer+36,min_cycle_time);
+	        write_buf_int64(mem_buffer+44,max_cycle_time);
+	        write_buf_int64(mem_buffer+52,min_jitter_time);
+	        write_buf_int64(mem_buffer+60,max_jitter_time);
+            write_buf_int32(mem_buffer+68,cycle_counter_max_cycle);
+            write_buf_int32(mem_buffer+72,cycle_counter_max_jitter);
+            write_buf_int64(mem_buffer+76,receive_ns);
+            write_buf_int64(mem_buffer+84,process_ns);
+            write_buf_int64(mem_buffer+92,send_ns);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+            write_sharemem_ctl_data(mem_buffer,0x00,&ec_motor0);
+            write_sharemem_ctl_data(mem_buffer,0x40,&ec_motor1);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+            write_sharemem_ctl_data(mem_buffer,0x80,&ec_motor2);
+            write_sharemem_ctl_data(mem_buffer,0xC0,&ec_motor3);
+            write_sharemem_ctl_data(mem_buffer,0x100,&ec_motor4);
+            write_sharemem_ctl_data(mem_buffer,0x140,&ec_motor5);
+            write_sharemem_ctl_data(mem_buffer,0x180,&ec_motor6);
+            write_sharemem_ctl_data(mem_buffer,0x1C0,&ec_motor7);
+#endif
+            memcpy(motor_ctl_buffer, (pthread_mutex_t *)(shm_addr+MOTOR_CTL_ADDRESS), MOTOR_CTL_BUF_SIZE);
+            memset((pthread_mutex_t *)(shm_addr+MOTOR_CTL_ADDRESS), 0xff,MOTOR_CTL_BUF_SIZE);
+            memcpy((pthread_mutex_t *)shm_addr, mem_buffer, BUF_READ_SIZE);
+        }
+        else
+            memset((pthread_mutex_t *)shm_addr, 0, BUF_SIZE);
+#ifdef MOTOR_CONTROL
+        if(cycle_counter > 1000){
+            /* motor start/stop */
+#ifdef SERVO_ETHERCAT_ENABLE
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+            if(motor_ctl_buffer[0x01] == MOTOR_RUN)
+                circle0_run = MOTOR_START;
+            else if(motor_ctl_buffer[0x01] == MOTOR_STOP)
+                circle0_run = MOTOR_STOP;
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+            if((ec_motor2.gohome_history == GO_HOME_FINISH)&&(ec_motor3.gohome_history == GO_HOME_FINISH))
+            {
+                if(motor_ctl_buffer[0x41] == MOTOR_RUN)
+                    circle1_run = MOTOR_RUN;
+                else if(motor_ctl_buffer[0x41] == MOTOR_STOP)
+                    circle1_run = MOTOR_STOP;
+            }
+            if((ec_motor4.gohome_history == GO_HOME_FINISH)&&(ec_motor5.gohome_history == GO_HOME_FINISH))
+            {
+                if(motor_ctl_buffer[0x81] == MOTOR_RUN)
+                    circle2_run = MOTOR_RUN;
+                else if(motor_ctl_buffer[0x81] == MOTOR_STOP)
+                    circle2_run = MOTOR_STOP;
+            }
+            if(motor_ctl_buffer[0xC1] == MOTOR_RUN)
+                circle3_run = MOTOR_START;
+            else if(motor_ctl_buffer[0xC1] == MOTOR_STOP)
+                circle3_run = MOTOR_STOP;
+#endif
+#endif
+            /* set vel */
+#if 0
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+            if((motor_ctl_buffer[0x43] > 1)&&(motor_ctl_buffer[0x43] < 100))
+                motor34_vel = motor_ctl_buffer[0x43];
+            else
+                motor34_vel = 10;
+            if((motor_ctl_buffer[0x83] > 1)&&(motor_ctl_buffer[0x83] < 100))
+                motor56_vel = motor_ctl_buffer[0x83];
+            else
+                motor56_vel = 10;
+            if((motor_ctl_buffer[0xC3] > 1)&&(motor_ctl_buffer[0xC3] < 100))
+                motor78_vel = motor_ctl_buffer[0xC3];
+            else
+                motor78_vel = 10;
+#endif
+#endif
+    	}
+#endif
+#endif
+#ifdef MEASURE_TIMING
+        if(measure_time != 0)
+            if(cycle_counter >= measure_time)
+                run = 0;
+#endif
+    }
+#ifdef MEASURE_TIMING
+	if(last_cycle_counter)
+		avg_cycle_time = total_cycle_ns/last_cycle_counter;
+    printf("*********************************************\n");
+    printf("average cycle time  %10.3f\n", (float)avg_cycle_time/1000);
+    printf("cycle counter       %10d\n", last_cycle_counter);
+    printf("cycle time          %10.3f ... %10.3f\n", (float)min_cycle_time/1000, (float)max_cycle_time/1000);
+    printf("jitter time         %10.3f ... %10.3f\n", (float)min_jitter_time/1000, (float)max_jitter_time/1000);
+    printf("*********************************************\n");
+#endif
+    return NULL;
+}
+
+/****************************************************************************
+ * Signal handler
+ ***************************************************************************/
+void signal_handler(int sig)
+{
+    run = 0;
+    close_signal = 1000000/CYCLE_US; /* 1s */
+}
+
+static void getOptions(int argc, char **argv)
+{
+    int index;
+    static struct option longOptions[] = {
+		/* name		has_arg				flag	val */
+		{"run",		no_argument,		NULL,	'r'},
+		{"time",	required_argument,	NULL,	't'},
+		{"help",	no_argument,		NULL,	'h'},
+		{}
+    };
+    do{
+		index = getopt_long(argc, argv, "t:hr", longOptions, NULL);
+		switch(index){
+		case 'r':
+			motor_run = true;
+			printf("run:true\n");
+		break;
+		case 't':
+			measure_time = atoi(optarg);
+			printf("measure time: %d min\n",measure_time);
+			measure_time = measure_time*60*(1000000/CYCLE_US);
+		break;
+		case 'h':
+			printf("Global options:\n");
+			printf("  --run	   -r  Motor start running.\n");
+			printf("  --time   -t  Set measure time for minutes.\n");		
+			printf("  --help   -h  Show this help.\n");
+			printf("default  time: infinity\n");
+			exit(0);
+		break;
+		default:
+		break;
+		}
+    }while(index != -1);
+}
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+int main(int argc, char *argv[])
+{
+#ifdef SERVO_ETHERCAT_ENABLE
+    struct timespec dc_period;
+    int ret;
+#endif
+
+	getOptions(argc,argv);
+    data_init();
+    axis_circle_init();
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+#ifdef SERVO_ETHERCAT_ENABLE
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0);
+    if (!master)
+        return -1;
+
+    printf("Creating domain ...\n");
+    domain = ecrt_master_create_domain(master);
+    if (!domain)
+        return -1;
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+     /* Create configuration for bus coupler */
+    ec_slave0.sc = ecrt_master_slave_config(master, IS620N_Slave00_Pos, IS620N_SLAVE00_ID);
+    if (!ec_slave0.sc) {
+        printf("Slave0 sc is NULL \n");
+        return -1;
+    }
+    ec_slave1.sc = ecrt_master_slave_config(master, IS620N_Slave01_Pos, IS620N_SLAVE01_ID);
+    if (!ec_slave1.sc) {
+        printf("Slave1 sc is NULL \n");
+        return -1;
+    }
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ec_slave2.sc = ecrt_master_slave_config(master, IS620N_Slave02_Pos, IS620N_SLAVE02_ID);
+    if (!ec_slave2.sc) {
+        printf("Slave2 sc is NULL \n");
+        return -1;
+    }
+    ec_slave3.sc = ecrt_master_slave_config(master, IS620N_Slave03_Pos, IS620N_SLAVE03_ID);
+    if (!ec_slave3.sc) {
+        printf("Slave3 sc is NULL \n");
+        return -1;
+    }
+    ec_slave4.sc = ecrt_master_slave_config(master, IS620N_Slave04_Pos, IS620N_SLAVE04_ID);
+    if (!ec_slave4.sc) {
+        printf("Slave4 sc is NULL \n");
+        return -1;
+    }
+    ec_slave5.sc = ecrt_master_slave_config(master, IS620N_Slave05_Pos, IS620N_SLAVE05_ID);
+    if (!ec_slave5.sc) {
+        printf("Slave5 sc is NULL \n");
+        return -1;
+    }
+    ec_slave6.sc = ecrt_master_slave_config(master, IS620N_Slave06_Pos, IS620N_SLAVE06_ID);
+    if (!ec_slave6.sc) {
+        printf("Slave6 sc is NULL \n");
+        return -1;
+    }
+    ec_slave7.sc = ecrt_master_slave_config(master, IS620N_Slave07_Pos, IS620N_SLAVE07_ID);
+    if (!ec_slave7.sc) {
+        printf("Slave7 sc is NULL \n");
+        return -1;
+    }
+#endif
+    printf("Creating slave configurations...\n");
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ec_slave_config_init(ec_slave0.sc);
+    ec_slave_config_init(ec_slave1.sc);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ec_slave_config_init(ec_slave2.sc);
+    ec_slave_config_init(ec_slave3.sc);
+    ec_slave_config_init(ec_slave4.sc);
+    ec_slave_config_init(ec_slave5.sc);
+    ec_slave_config_init(ec_slave6.sc);
+    ec_slave_config_init(ec_slave7.sc);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    if (ecrt_slave_config_pdos(ec_slave0.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  0 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave1.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  1 \n");
+        return -1;
+    }
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    if (ecrt_slave_config_pdos(ec_slave2.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  2 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave3.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  3 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave4.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  4 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave5.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  5 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave6.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  6 \n");
+        return -1;
+    }
+    if (ecrt_slave_config_pdos(ec_slave7.sc, EC_END, slave_syncs)) {
+        fprintf(stderr, "Failed to configure PDOs.  7 \n");
+        return -1;
+    }
+#endif
+    ecrt_master_set_send_interval(master, CYCLE_US);
+    if (ecrt_domain_reg_pdo_entry_list(domain, domain0_regs)) {
+        fprintf(stderr, "PDO entry registration failed!\n");
+        return -1;
+    }
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ecrt_slave_config_sdo8(ec_slave0.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave1.sc, 0x6060, 0x00, 8);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ecrt_slave_config_sdo8(ec_slave2.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave3.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave4.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave5.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave6.sc, 0x6060, 0x00, 8);
+    ecrt_slave_config_sdo8(ec_slave7.sc, 0x6060, 0x00, 8);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ecrt_slave_config_sdo16(ec_slave0.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave1.sc, 0x2002, 0x03, 1);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ecrt_slave_config_sdo16(ec_slave2.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave3.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave4.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave5.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave6.sc, 0x2002, 0x03, 1);
+    ecrt_slave_config_sdo16(ec_slave7.sc, 0x2002, 0x03, 1);
+#endif
+    /*Configuring DC signal*/
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ecrt_slave_config_dc(ec_slave0.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave1.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ecrt_slave_config_dc(ec_slave2.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave3.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave4.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave5.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave6.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+    ecrt_slave_config_dc(ec_slave7.sc, 0x0300, PERIOD_NS, PERIOD_NS/2, 0, 0);
+#endif
+    /* Set the initial master time and select a slave to use as the DC
+     * reference clock, otherwise pass NULL to auto select the first capable
+     * slave. Note: This can be used whether the master or the ref slave will
+     * be used as the systems master DC clock
+    */
+    clock_gettime(CLOCK_MONOTONIC, &dc_period);
+
+    /* Attention: The initial application time is also used for phase
+     * calcuation for the SYNC0/1 interrupts. Please be sure to call it at
+     * the correct phase to the realtime cycle
+    */
+    ecrt_master_application_time(master, TIMESPEC2NS(dc_period));
+
+#if defined(MOTOR_6AXIS)
+    ret = ecrt_master_select_reference_clock(master, ec_slave2.sc);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ret = ecrt_master_select_reference_clock(master, ec_slave0.sc);
+#endif
+    if (ret < 0) {
+        fprintf(stderr, "Failed to select reference clock: %s\n",strerror(-ret));
+        return ret;
+    }
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master))
+        return -1;
+
+    if (!(domain_pd = ecrt_domain_data(domain))) {
+        fprintf(stderr, "Failed to get domain data pointer.\n");
+        return -1;
+    }
+#endif
+
+#ifdef SHARE_MEM
+    if(sharemem_init() == -1)
+        return -1;
+#endif
+
+#ifdef MODBUS_SERVER
+	modbus_server_create_entry();
+#endif
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t thattr;
+    pthread_attr_init(&thattr);
+    pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+    if (pthread_create(&cyclic_thread, &thattr, &my_thread, NULL)) {
+        fprintf(stderr, "pthread_create cyclic task failed\n");
+		return 1;
+    }
+    while (run || close_signal != 0)
+	    sched_yield();
+
+#ifdef MODBUS_SERVER
+	modbus_server_exit_entry();
+#endif
+
+    pthread_join(cyclic_thread, NULL);
+
+#ifdef SERVO_ETHERCAT_ENABLE
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+    ecrt_slave_config_sdo16(ec_slave0.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave1.sc, 0x6040, 0x00, 0x100);
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+    ecrt_slave_config_sdo16(ec_slave2.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave3.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave4.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave5.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave6.sc, 0x6040, 0x00, 0x100);
+    ecrt_slave_config_sdo16(ec_slave7.sc, 0x6040, 0x00, 0x100);
+#endif
+    printf("End of Program\n");
+    ecrt_release_master(master);
+#endif
+
+#ifdef SHARE_MEM
+    if (shmdt(shm_addr) == -1){
+        printf("shmdt error!\n");
+        exit(1);
+    }
+#endif
+
+    return 0;
+}
+
+/****************************************************************************/
diff --git a/examples/multi_axis/main.h b/examples/multi_axis/main.h
new file mode 100644
index 00000000..03b9edaa
--- /dev/null
+++ b/examples/multi_axis/main.h
@@ -0,0 +1,153 @@
+#ifndef __ETHERCAT_6AIXS_MAIN_H__
+#define __ETHERCAT_6AIXS_MAIN_H__
+
+#include <stdio.h>
+#include "ecrt.h"
+#include "def_config.h"
+
+#ifdef DEBUG_CONSOLE_FS
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+#define LEN0_FILE_NAME  		"len0.txt"
+#define LEN1_FILE_NAME  		"len1.txt"
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+#define LEN2_FILE_NAME  		"len2.txt"
+#define LEN3_FILE_NAME  		"len3.txt"
+#define LEN4_FILE_NAME  		"len4.txt"
+#define LEN5_FILE_NAME  		"len5.txt"
+#define LEN6_FILE_NAME  		"len6.txt"
+#define LEN7_FILE_NAME  		"len7.txt"
+#endif
+#endif
+
+#define CYCLE_US    			250
+#define PERIOD_NS   			(CYCLE_US*1000)
+#define NSEC_PER_SEC    		(1000000000L)
+#define TIMESPEC2NS(T)  		((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DIFF_NS(A,B)    		(((B).tv_sec - (A).tv_sec)*NSEC_PER_SEC + ((B).tv_nsec)-(A).tv_nsec)
+#define CYCLE_COUNTER_PERSEC    (NSEC_PER_SEC/PERIOD_NS)
+
+#define MAX_DECODER_COUNT		0x100000
+#define MAX_VELOCITY_MOTOR		0x66665f92
+#define SERVO_AXIS_SIZE			20.0
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+#define IS620N_Slave00_Pos  	0, 0
+#define IS620N_Slave01_Pos  	0, 1
+#endif
+#if defined(MOTOR_8AXIS)
+#define IS620N_Slave02_Pos  	0, 2
+#define IS620N_Slave03_Pos  	0, 3
+#define IS620N_Slave04_Pos  	0, 4
+#define IS620N_Slave05_Pos  	0, 5
+#define IS620N_Slave06_Pos  	0, 6
+#define IS620N_Slave07_Pos  	0, 7
+#endif
+#if defined(MOTOR_6AXIS)
+#define IS620N_Slave02_Pos  	0, 0
+#define IS620N_Slave03_Pos  	0, 1
+#define IS620N_Slave04_Pos  	0, 2
+#define IS620N_Slave05_Pos  	0, 3
+#define IS620N_Slave06_Pos  	0, 4
+#define IS620N_Slave07_Pos  	0, 5
+#endif
+
+#if defined(MOTOR_8AXIS) || defined(MOTOR_2AXIS)
+#define IS620N_SLAVE00_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE01_ID   	0x00100000, 0x000c0108
+#endif
+#if defined(MOTOR_8AXIS) || defined(MOTOR_6AXIS)
+#define IS620N_SLAVE02_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE03_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE04_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE05_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE06_ID   	0x00100000, 0x000c0108
+#define IS620N_SLAVE07_ID   	0x00100000, 0x000c0108
+#endif
+
+enum{
+	MOTOR_START = 0,
+	MOTOR_RUN,
+	MOTOR_STOP
+};
+
+typedef enum{
+	GO_HOME = 0,
+	GO_MINIMUM,
+	GO_HOME_FINISH
+}go_home_t;
+
+typedef struct{
+#ifdef DEBUG_CONSOLE_FS
+    FILE *fd;
+#endif
+    ec_slave_config_t *sc;
+    unsigned int ctrl_word;
+    unsigned int mode_sel;
+    unsigned int tar_pos;
+    unsigned int touch_probe_func;
+    unsigned int error_code;
+    unsigned int status_word;
+    unsigned int mode_display;
+    unsigned int pos_act;
+    unsigned int touch_probe_status;
+    unsigned int touch_probe1_pos;
+    unsigned int touch_probe2_pos;
+    unsigned int digital_input;
+    unsigned int mode_cw;
+    unsigned int vel_act;
+	unsigned int err_pos;
+}Slave_Data;
+
+typedef struct{
+    unsigned short statusword;
+    unsigned short controlword;
+    unsigned long prevpos;
+    unsigned long actualpos;
+    unsigned long targetpos;
+    unsigned short cwmode;
+    unsigned int leftinput;
+    unsigned int homeinput;
+    unsigned int rightinput;
+    signed char selmode;
+    signed int actualvel;
+	signed int errpos;
+    go_home_t gohome_history;
+    signed int zeroposition;
+    signed int minposition;
+    signed int maxposition;
+}Ctl_Data;
+
+ec_pdo_entry_info_t slave_pdo_entries[] = {
+	{0x6040, 0x00, 16},
+	{0x6060, 0x00, 8},
+	{0x607A, 0x00, 32},
+	{0x60B8, 0x00, 16},
+	{0x2002, 0x03, 16},
+	{0x6041, 0x00, 16},
+	{0x6061, 0x00, 8},
+	{0x6064, 0x00, 32},
+	{0x60B9, 0x00, 16},
+	{0x60BA, 0x00, 32},
+	{0x60BC, 0x00, 32},
+	{0x603F, 0x00, 16},
+	{0x60FD, 0x00, 32},
+	{0x606C, 0x00, 32},
+	{0x60F4, 0x00, 32},
+};
+
+ec_pdo_info_t slave_pdos[] = {
+   {0x1600, 5, slave_pdo_entries + 0},
+   {0x1a00, 10, slave_pdo_entries + 5},
+};
+
+ec_sync_info_t slave_syncs[] = {
+   {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+   {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+   {2, EC_DIR_OUTPUT, 1, slave_pdos + 0, EC_WD_ENABLE},
+   {3, EC_DIR_INPUT, 1, slave_pdos + 1, EC_WD_DISABLE},
+   {0xff}
+};
+
+#endif
+
diff --git a/examples/multi_axis/modbus_server/README b/examples/multi_axis/modbus_server/README
new file mode 100644
index 00000000..ffceb524
--- /dev/null
+++ b/examples/multi_axis/modbus_server/README
@@ -0,0 +1,30 @@
+------------------------------------------------------------------------------
+
+This is the README file of the modbus server.
+
+------------------------------------------------------------------------------
+
+Contents:
+1) Requirements
+2) Building
+
+------------------------------------------------------------------------------
+
+1) Requirements
+===============
+
+gcc
+
+libmodbus-3.0.6
+
+------------------------------------------------------------------------------
+
+2) Building
+==========================
+
+-L/usr/local/lib/ -lmodbus
+
+sudo make
+
+------------------------------------------------------------------------------
+
diff --git a/examples/multi_axis/modbus_server/modbus_server.c b/examples/multi_axis/modbus_server/modbus_server.c
new file mode 100644
index 00000000..4e4a66d6
--- /dev/null
+++ b/examples/multi_axis/modbus_server/modbus_server.c
@@ -0,0 +1,279 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <sys/shm.h>
+#include <sys/ipc.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+#include <signal.h>
+#include <pthread.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <getopt.h>
+#include <modbus/modbus.h>
+#include "modbus_server.h"
+
+//#define LOCK_OPEN
+
+#define _FC_READ_COILS                0x01
+#define _FC_READ_DISCRETE_INPUTS      0x02
+#define _FC_READ_HOLDING_REGISTERS    0x03
+#define _FC_READ_INPUT_REGISTERS      0x04
+#define _FC_WRITE_SINGLE_COIL         0x05
+#define _FC_WRITE_SINGLE_REGISTER     0x06
+#define _FC_READ_EXCEPTION_STATUS     0x07
+#define _FC_WRITE_MULTIPLE_COILS      0x0F
+#define _FC_WRITE_MULTIPLE_REGISTERS  0x10
+#define _FC_REPORT_SLAVE_ID           0x11
+#define _FC_WRITE_AND_READ_REGISTERS  0x17
+
+static int server_socket;
+static modbus_t *ctx = NULL;
+static modbus_mapping_t *mb_mapping = NULL;
+static void *shm_addr = NULL;
+static int shmid;
+#ifdef LOCK_OPEN
+static pthread_mutex_t *sharedlock;
+#endif
+
+/* option variables */
+static int modbus_max_num_client = 5;
+static bool modbus_debug = false;
+static key_t shm_key = 87654321;
+static int modbus_port = 502;
+static int shm_size = 4096;
+static char modbus_address[18]; 
+
+/* multi-thread */
+static pthread_t modbus_thread;
+
+static void modbus_data_proc(uint8_t *data,int len)
+{
+	if((data == NULL)||(len == 0)){
+		if(modbus_debug)
+			printf("data recv error! len:%d \n",len);
+		return;
+	}
+	int offset = 7;
+	int function = data[offset];
+	uint16_t address,nb;
+	if(modbus_debug){
+		if(data[7] == 0x06){
+			unsigned short int modbus_recv_data = (data[10]<<8) | data[11];
+			printf("recv data: 0x%04x ,len: %d  \n",modbus_recv_data,len);
+		}
+	}
+	switch(function){
+	case _FC_READ_COILS:
+		if(modbus_debug)
+			printf("_FC_READ_COILS \n");
+		break;
+	case _FC_READ_DISCRETE_INPUTS:
+		if(modbus_debug)
+			printf("_FC_READ_DISCRETE_INPUTS \n");
+		break;
+	case _FC_READ_HOLDING_REGISTERS:
+		modbus_reply(ctx, data, len, mb_mapping);
+		break;
+	case _FC_READ_INPUT_REGISTERS:
+		if(modbus_debug)
+			printf("_FC_READ_INPUT_REGISTERS \n");
+		break;
+	case _FC_WRITE_SINGLE_COIL:
+		if(modbus_debug)
+			printf("_FC_WRITE_SINGLE_COIL \n");
+		break;
+	case _FC_WRITE_SINGLE_REGISTER:
+		address = ((uint16_t)data[offset + 1] << 8) + data[offset + 2];
+		if(address > shm_size/2){
+			printf("address error! :0x%x \n",address);
+			return;
+		}
+		if(modbus_debug)
+			printf("_FC_WRITE_SINGLE_REGISTER,len:%d,address:0x%x \n",len,address);
+		modbus_reply(ctx, data, len, mb_mapping);
+#ifdef LOCK_OPEN
+		pthread_mutex_lock(sharedlock);
+#endif
+		memmove(shm_addr+address*2,data+offset+3,2);
+#ifdef LOCK_OPEN
+		pthread_mutex_unlock(sharedlock);
+#endif
+		break;
+	case _FC_WRITE_MULTIPLE_COILS:
+		if(modbus_debug)
+			printf("_FC_WRITE_MULTIPLE_COILS \n");
+		break;
+	case _FC_WRITE_MULTIPLE_REGISTERS:
+		address = ((uint16_t)data[offset + 1] << 8) + data[offset + 2];
+		if(address > shm_size/2){
+			printf("address error! :0x%x \n",address);
+			return;
+		}
+		nb = (data[offset + 3] << 8) + data[offset + 4];
+		if(modbus_debug)
+			printf("_FC_WRITE_MULTIPLE_REGISTERS,len:%d,address:0x%x \n",nb,address);
+		modbus_reply(ctx, data, len, mb_mapping);
+#ifdef LOCK_OPEN
+		pthread_mutex_lock(sharedlock);
+#endif
+		memmove(shm_addr+address*2,data+offset+6,nb*2);
+#ifdef LOCK_OPEN
+		pthread_mutex_unlock(sharedlock);
+#endif
+		break;
+	case _FC_REPORT_SLAVE_ID:
+		if(modbus_debug)
+			printf("_FC_REPORT_SLAVE_ID \n");
+		break;
+	case _FC_READ_EXCEPTION_STATUS:
+		if(modbus_debug)
+			printf("_FC_READ_EXCEPTION_STATUS \n");
+		break;
+	case _FC_WRITE_AND_READ_REGISTERS:
+		if(modbus_debug)
+			printf("_FC_WRITE_AND_READ_REGISTERS \n");
+		break;
+	default:
+		if(modbus_debug)
+			printf("FUNCTION CODE ERROR!!! \n");
+		break;
+	}
+}
+
+static void *modbus_server_thread(void *arg)
+{
+	int rc;
+	fd_set refset;
+	fd_set rdset;
+	int fdmax;/* Maximum file descriptor number */
+	int master_socket;
+
+	memset(modbus_address,0,sizeof(modbus_address));
+	memcpy(modbus_address,"0.0.0.0",8);
+	if(modbus_debug){
+		printf("modbus IP            : %s \n",modbus_address);
+		printf("modbus_max_num_client: %d \n",modbus_max_num_client);
+		printf("shm_key              : %d \n",shm_key);
+		printf("modbus_port          : %d \n",modbus_port);
+		printf("shm_size             : %d \n",shm_size);
+	}
+
+	shmid = shmget(shm_key, shm_size, 0666|IPC_CREAT);
+	printf("shmid : %u\n", shmid);
+	if (shmid == -1){
+		perror("shmget error!");
+		exit(1);
+	}
+
+	shm_addr = shmat(shmid, NULL, 0);
+	if (shm_addr == (void *) -1){
+		perror("shmat error!");
+		exit(1);
+	}
+
+#ifdef LOCK_OPEN
+	sharedlock = (pthread_mutex_t*)shm_addr;
+#endif
+
+	ctx = modbus_new_tcp(modbus_address, modbus_port);
+	if(ctx == NULL){
+		fprintf(stderr, "Failed to new tcp: %s\n",modbus_strerror(errno));
+		exit(1);
+	}
+
+	if(modbus_debug)
+		modbus_set_debug(ctx, TRUE);
+	else
+		modbus_set_debug(ctx, FALSE);
+	mb_mapping = modbus_mapping_new(0, 0, 0, 0);
+	mb_mapping->nb_registers = shm_size;
+	mb_mapping->tab_registers = shm_addr;
+
+	server_socket = modbus_tcp_listen(ctx, modbus_max_num_client);
+	if(server_socket == -1){
+		fprintf(stderr, "Failed to listen tcp: %s\n",modbus_strerror(errno));
+		exit(1);
+	}
+
+	/* Clear the reference set of socket */
+	FD_ZERO(&refset);
+	/* Add the server socket */
+	FD_SET(server_socket, &refset);
+	/* Keep track of the max file descriptor */
+	fdmax = server_socket;
+
+	while(1){
+		rdset = refset;
+		if (select(fdmax+1, &rdset, NULL, NULL, NULL) == -1) {
+			perror("Server select() failure.");
+			return NULL;
+		}
+		/* Run through the existing connections looking for data to be read */
+		for(master_socket = 0; master_socket <= fdmax; master_socket++){
+			if(FD_ISSET(master_socket, &rdset)){
+				if(master_socket == server_socket){
+					/* A client is asking a new connection */
+					socklen_t addrlen;
+					struct sockaddr_in clientaddr;
+					int newfd;
+					/* Handle new connections */
+					addrlen = sizeof(clientaddr);
+					memset(&clientaddr, 0, sizeof(clientaddr));
+					newfd = accept(server_socket, (struct sockaddr *)&clientaddr, &addrlen);
+					if(newfd == -1)
+						perror("Server accept() error");
+					else{
+						FD_SET(newfd, &refset);
+						if(newfd > fdmax)	/* Keep track of the maximum */
+							fdmax = newfd;
+						printf("New connection from %s:%d on socket %d\n",
+						inet_ntoa(clientaddr.sin_addr), clientaddr.sin_port, newfd);
+					}
+				}else{
+					/* An already connected master has sent a new query */
+					uint8_t query[MODBUS_TCP_MAX_ADU_LENGTH];
+					modbus_set_socket(ctx, master_socket);
+					rc = modbus_receive(ctx, query);
+					if(rc != -1)
+						modbus_data_proc(query,rc);
+					else{
+						/* Connection closed by the client, end of server */
+						printf("Connection closed on socket %d\n", master_socket);
+						close(master_socket);
+						/* Remove from reference set */
+						FD_CLR(master_socket, &refset);
+						if(master_socket == fdmax)
+							fdmax--;
+					}
+				}
+			}
+		}
+	}
+}
+
+void modbus_server_create_entry(void)
+{
+	pthread_attr_t thattr;
+	pthread_attr_init(&thattr);
+	pthread_attr_setdetachstate(&thattr, PTHREAD_CREATE_JOINABLE);
+	if(pthread_create(&modbus_thread, &thattr, &modbus_server_thread, NULL)){
+		printf("pthread_create modbus task failed \n");
+		return;
+	}
+}
+
+void modbus_server_exit_entry(void)
+{
+	close(server_socket);
+	modbus_free(ctx);
+	shmdt(shm_addr);
+	shmctl(shmid, IPC_RMID, 0);
+	pthread_cancel(modbus_thread);
+	pthread_join(modbus_thread,NULL);
+}
+
diff --git a/examples/multi_axis/modbus_server/modbus_server.h b/examples/multi_axis/modbus_server/modbus_server.h
new file mode 100644
index 00000000..988b8b1b
--- /dev/null
+++ b/examples/multi_axis/modbus_server/modbus_server.h
@@ -0,0 +1,8 @@
+#ifndef MODBUS_SERVER_H
+#define MODBUS_SERVER_H
+
+void modbus_server_create_entry(void);
+void modbus_server_exit_entry(void);
+
+#endif
+
diff --git a/examples/soe_axis/Makefile.am b/examples/soe_axis/Makefile.am
new file mode 100644
index 00000000..1d3e0aa2
--- /dev/null
+++ b/examples/soe_axis/Makefile.am
@@ -0,0 +1,54 @@
+#------------------------------------------------------------------------------
+#
+#  $Id$
+#
+#  Copyright (C) 2006-2012  Florian Pose, Ingenieurgemeinschaft IgH
+#
+#  This file is part of the IgH EtherCAT Master.
+#
+#  The IgH EtherCAT Master is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License version 2, as
+#  published by the Free Software Foundation.
+#
+#  The IgH EtherCAT Master is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
+#  Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License along with
+#  the IgH EtherCAT Master; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+#
+#  ---
+#
+#  The license mentioned above concerns the source code only. Using the
+#  EtherCAT technology and brand is only permitted in compliance with the
+#  industrial property and similar rights of Beckhoff Automation GmbH.
+#
+#------------------------------------------------------------------------------
+
+noinst_PROGRAMS = ec_soe_axis_example
+
+ec_soe_axis_example_SOURCES = soe-axis.c
+
+if ENABLE_XENOMAI
+ec_soe_axis_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include \
+	$(XENOMAI_POSIX_CFLAGS)
+
+ec_soe_axis_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat_rtdm \
+	$(XENOMAI_POSIX_LDFLAGS)
+else
+ec_soe_axis_example_CFLAGS = \
+	-Wall \
+	-lm  \
+	-I$(top_srcdir)/include
+
+ec_soe_axis_example_LDFLAGS = \
+	-L$(top_builddir)/lib/.libs -lethercat -lrt -lpthread
+endif
+
+#------------------------------------------------------------------------------
diff --git a/examples/soe_axis/soe-axis.c b/examples/soe_axis/soe-axis.c
new file mode 100644
index 00000000..af8e216e
--- /dev/null
+++ b/examples/soe_axis/soe-axis.c
@@ -0,0 +1,667 @@
+/******************************************************************************
+ *
+ *  $Id: main.c,v 3bdd7a747fae 2012/09/20 13:28:25 fp $
+ *
+ *  Copyright (C)      2011  IgH Andreas Stewering-Bone
+ *                     2012  Florian Pose <fp@igh-essen.com>
+ *
+ *  This file is part of the IgH EtherCAT master
+ *
+ *  The IgH EtherCAT Master is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License version 2, as
+ *  published by the Free Software Foundation.
+ *
+ *  The IgH EtherCAT master is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+ *  Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with the IgH EtherCAT master. If not, see <http://www.gnu.org/licenses/>.
+ *
+ *  ---
+ *
+ *  The license mentioned above concerns the source code only. Using the
+ *  EtherCAT technology and brand is only permitted in compliance with the
+ *  industrial property and similar rights of Beckhoff Automation GmbH.
+ *
+ *****************************************************************************/
+
+#include <errno.h>
+#include <string.h>
+#include <stdbool.h>
+#include <limits.h>
+#include <mqueue.h>
+#include <signal.h>
+#include <semaphore.h>
+#include <pthread.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+
+#include "ecrt.h"
+
+#define NSEC_PER_SEC        (1000000000)
+#define TIMESPEC2NS(T)      ((uint64_t) (T).tv_sec * NSEC_PER_SEC + (T).tv_nsec)
+#define DC_FILTER_CNT       1024
+#define SYNC_MASTER_TO_REF  1
+#define PERIOD_US           (500)
+#define PERIOD_NS           (PERIOD_US*1000)
+#define CLOCK_TO_USE        CLOCK_MONOTONIC     // CLOCK_REALTIME
+#define SERVO_OPMODE_CSP    8
+#define DIFF_NS(A, B)       (((B).tv_sec - (A).tv_sec) * NSEC_PER_SEC + \
+	                        (B).tv_nsec - (A).tv_nsec)
+#define DC_DIFF_TOLERATE    10000
+
+const struct timespec cycletime = {0, PERIOD_NS};
+static pthread_t cyclic_thread;
+
+static int run = 1;
+
+// #define PERF_MEASURE    1
+#ifdef PERF_MEASURE
+#define TEN_MILLIONS	10000000
+static sem_t display_sem;
+static pthread_t perfmeas_thread;
+static int32_t minjitter, maxjitter, avgjitter;
+static int32_t g_minjitter = TEN_MILLIONS, g_maxjitter = -TEN_MILLIONS;
+static uint32_t dcdiff_min, dcdiff_max, dcdiff_avg;
+static uint32_t g_dcdiff_min = 0x7fffffff, g_dcdiff_max = 0;
+void *perfmeas_task(void *arg);
+#endif
+
+// #define SYNC_DEBUG
+#ifdef SYNC_DEBUG
+#define DEBUG_BUFSIZE   100000
+uint32_t dc_off[DEBUG_BUFSIZE];
+int32_t vel_debug[DEBUG_BUFSIZE];
+uint64_t debug_count = 0;
+#endif
+
+
+/***************************************************************************
+ * EtherCAT master
+*/
+static ec_master_t *master = NULL;
+static ec_master_state_t master_state = {};
+
+static ec_domain_t *domain = NULL;
+static uint8_t *domain_pd = NULL;
+static ec_domain_state_t domain_state;
+
+/***************************************************************************
+ * Slaves 
+*/
+ec_slave_info_t slave_info;
+ec_slave_config_t *slave_config;
+
+int offset_controlword = 0;
+int offset_signal_ctrlword = 0;
+int offset_targetposition = 0;
+int offset_opmode = 0;
+int offset_statusword = 0;
+int offset_class1_diagnostics = 0;
+int offset_class2_diagnostics = 0;
+int offset_actualposition = 0;
+int offset_actualvel = 0;
+
+uint32_t servo_position_init = 0;
+
+/***************************************************************************
+/* Slave information
+ */
+#define HCS01_SoE       0x00000024, 0x00242804
+
+#define DC_ASSIGN_ACTIVATE  0x0500
+
+const static ec_pdo_entry_reg_t domain0_regs[] = {
+    {0, 0, HCS01_SoE, 0x0086, 0x00, &offset_controlword},
+    {0, 0, HCS01_SoE, 0x002f, 0x00, &offset_targetposition},
+    {0, 0, HCS01_SoE, 0x0091, 0x00, &offset_signal_ctrlword},
+    {0, 0, HCS01_SoE, 0x0087, 0x00, &offset_statusword},
+    {0, 0, HCS01_SoE, 0x0033, 0x00, &offset_actualposition},
+    {0, 0, HCS01_SoE, 0x000b, 0x00, &offset_class1_diagnostics},
+    {0, 0, HCS01_SoE, 0x000c, 0x00, &offset_class2_diagnostics},
+    {},
+};
+
+/* Master 0, Slave 0
+ * Vendor ID:       0x00000024
+ * Product code:    0x00242804
+ * Revision number: 0x00000003
+ */
+
+ec_pdo_entry_info_t slave_0_pdo_entries[] = {
+    {0x0086, 0x00, 16},
+    {0x002f, 0x00, 32},
+    {0x0091, 0x00, 16},
+    {0x0087, 0x00, 16},
+    {0x0033, 0x00, 32},
+    {0x000b, 0x00, 16},
+    {0x000c, 0x00, 16},
+};
+
+ec_pdo_info_t slave_0_pdos[] = {
+    {0x0018, 3, slave_0_pdo_entries + 0},
+    {0x0010, 4, slave_0_pdo_entries + 3},
+};
+
+ec_sync_info_t slave_0_syncs[] = {
+    {0, EC_DIR_OUTPUT, 0, NULL, EC_WD_DISABLE},
+    {1, EC_DIR_INPUT, 0, NULL, EC_WD_DISABLE},
+    {2, EC_DIR_OUTPUT, 1, slave_0_pdos + 0, EC_WD_ENABLE},
+    {3, EC_DIR_INPUT, 1, slave_0_pdos + 1, EC_WD_ENABLE},
+    {0xff}
+};
+
+/*****************************************************************************
+ * Realtime task
+ ****************************************************************************/
+
+struct timespec timespec_add(struct timespec time1, struct timespec time2)
+{
+	struct timespec result;
+
+	if ((time1.tv_nsec + time2.tv_nsec) >= NSEC_PER_SEC) {
+		result.tv_sec = time1.tv_sec + time2.tv_sec + 1;
+		result.tv_nsec = time1.tv_nsec + time2.tv_nsec - NSEC_PER_SEC;
+	} else {
+		result.tv_sec = time1.tv_sec + time2.tv_sec;
+		result.tv_nsec = time1.tv_nsec + time2.tv_nsec;
+	}
+
+	return result;
+}
+
+static int64_t diff_ts_ns(struct timespec *left, struct timespec *right)
+{
+	return (int64_t)(left->tv_sec - right->tv_sec) * NSEC_PER_SEC + left->tv_nsec - right->tv_nsec;
+}
+
+void rt_check_domain_state(void)
+{
+    static ec_domain_state_t ds;
+    static ec_domain_state_t ds_last;
+
+    ecrt_domain_state(domain, &ds);
+        
+    if (ds.working_counter != ds_last.working_counter) {
+        printf("Domain: WC %u.\n", ds.working_counter);
+    }
+
+    if (ds.wc_state != ds_last.wc_state) {
+        printf("Domain: State %u.\n", ds.wc_state);
+    }
+
+    ds_last = ds;
+}
+
+/****************************************************************************/
+
+void rt_check_master_state(void)
+{
+    ec_master_state_t ms;
+
+    ecrt_master_state(master, &ms);
+
+    if (ms.al_states != master_state.al_states) {
+        printf("AL states: 0x%02X.\n", ms.al_states);
+    }
+
+    if (ms.link_up != master_state.link_up) {
+        printf("Link is %s.\n", ms.link_up ? "up" : "down");
+    }
+
+    master_state = ms;
+}
+
+/***************************************************************************
+ * Cyclic task
+*/
+void *cyclic_task(void *arg)
+{
+    struct timespec wakeup_time, app_time;
+    int i = 0;
+    bool dc_sync_ok = false;
+    unsigned int dc_sync_counter = 0;
+    uint32_t dc_diff = 0;
+    uint16_t servo_controlword, signal_ctrlword, class1_diagnostics, class2_diagnostics;
+    uint16_t servo_status, servo_status_last;
+    int32_t actual_position;
+    int32_t actual_vel;
+    int32_t target_position;
+    int32_t speed;
+    uint32_t speed_count = 0;
+    uint8_t speed_mode = 0;
+    struct sched_param param = {.sched_priority = 99};
+    char task_name[32];
+    int err;
+
+#ifdef PERF_MEASURE
+    uint32_t dc_min = 0x7fffffff, dc_max = 0, dc_sum = 0;
+    uint32_t run_counter = 0;
+    int32_t minj = TEN_MILLIONS, maxj = -TEN_MILLIONS, jitter = 0, jitter_sum = 0;
+    struct timespec now_time, last_time;
+#endif
+
+    pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
+    snprintf(task_name, sizeof(task_name), "cyclic_task-%d", getpid());
+    err = pthread_setname_np(pthread_self(), task_name);
+    if (err)
+	error(1, err, "pthread_setname_np(cyclic_task)");
+
+    clock_gettime(CLOCK_TO_USE, &wakeup_time);
+    while (run)
+    {
+        wakeup_time = timespec_add(wakeup_time, cycletime);
+        clock_nanosleep(CLOCK_TO_USE, TIMER_ABSTIME, &wakeup_time, NULL);
+
+#ifdef PERF_MEASURE
+        clock_gettime(CLOCK_TO_USE, &now_time);
+        jitter = (int32_t)diff_ts_ns(&now_time, &wakeup_time);
+#endif
+        // receive EtherCAT
+        ecrt_master_receive(master);
+        ecrt_domain_process(domain);
+
+        dc_diff = ecrt_master_sync_monitor_process(master);
+        if(!dc_sync_ok)
+        {
+            if(dc_diff < DC_DIFF_TOLERATE)
+                dc_sync_counter++;
+            else
+                dc_sync_counter = 0;
+
+            if(dc_sync_counter > 1000)
+                dc_sync_ok = true;
+            else
+                dc_sync_ok = false;
+        }
+
+        rt_check_domain_state();
+        rt_check_master_state();
+
+        if(dc_sync_ok)
+        {
+            actual_position = EC_READ_S32(domain_pd + offset_actualposition);
+            servo_status = EC_READ_U16(domain_pd + offset_statusword);
+            class1_diagnostics = EC_READ_U16(domain_pd + offset_class1_diagnostics);
+            class2_diagnostics = EC_READ_U16(domain_pd + offset_class2_diagnostics);
+
+            if((servo_status & 0x3000) != 0)
+            {
+                signal_ctrlword = 0x0001;
+                target_position = actual_position;
+            }
+
+            if((servo_status & 0xf000) == 0x8000){
+                servo_controlword = 0xe000;
+                target_position = actual_position;
+                signal_ctrlword = 0x0;
+            }else if((servo_status & 0xf000) == 0xc000){
+                servo_controlword = 0xe000;
+                signal_ctrlword = 0x0;
+            }
+
+            if ((servo_status & 0xf000) == 0xc000)
+            {
+                target_position = actual_position + 5000;
+            }
+
+            EC_WRITE_U16(domain_pd + offset_signal_ctrlword, signal_ctrlword);
+            EC_WRITE_S32(domain_pd + offset_targetposition, target_position);
+            EC_WRITE_U16(domain_pd + offset_controlword, servo_controlword);
+        }
+
+        // write application time to master
+        clock_gettime(CLOCK_TO_USE, &app_time);
+        ecrt_master_application_time(master, TIMESPEC2NS(app_time));
+        ecrt_master_sync_reference_clock(master);
+        ecrt_master_sync_slave_clocks(master);
+        ecrt_master_sync_monitor_queue(master);
+
+        // send process data
+        ecrt_domain_queue(domain);
+
+        ecrt_master_send(master);
+
+#ifdef PERF_MEASURE
+        if (dc_sync_ok)
+        {
+            run_counter += 1;
+            
+            if (jitter < minj){
+                minj = jitter;
+            }
+            if (jitter > maxj){
+                maxj = jitter;
+            }
+            jitter_sum += jitter;
+
+            if(dc_diff > dc_max){
+                dc_max = dc_diff;
+            }
+            if(dc_diff < dc_min){
+                dc_min = dc_diff;
+            }
+            dc_sum += dc_diff;
+
+            if (2*(NSEC_PER_SEC/PERIOD_NS) == run_counter)
+            {
+                minjitter = minj;
+                maxjitter = maxj;
+                avgjitter = jitter_sum/run_counter;
+
+                dcdiff_min = dc_min;
+                dcdiff_max = dc_max;
+                dcdiff_avg = dc_sum/run_counter;
+
+                run_counter = 0;
+                jitter = 0;
+                jitter_sum = 0;
+                minj = TEN_MILLIONS;
+                maxj = -TEN_MILLIONS;
+
+                dc_diff = 0;
+                dc_sum = 0;
+                dc_min = 0x7fffffff;
+                dc_max = 0;
+
+                sem_post(&display_sem);
+            }
+        }
+#endif
+
+        if(!run){
+            exit(0);
+        }
+
+    }
+
+    return NULL;
+}
+
+/****************************************************************************
+ * Signal handler
+ ***************************************************************************/
+
+void signal_handler(int sig)
+{
+    run = 0;
+}
+
+#ifdef PERF_MEASURE
+void *perfmeas_task(void *arg)
+{
+    int32_t minj , maxj, avgj;
+    int32_t min_cyc , max_cyc, avg_cyc;
+    uint32_t dc_min, dc_max, dc_avg;
+    char task_name[32];
+    int err, print_line = 0;
+    time_t meas_timestart = 0, time_now = 0, dt = 0;
+
+    sem_init(&display_sem, 0, 0);
+    time(&meas_timestart);
+
+    snprintf(task_name, sizeof(task_name), "perfmeas_task-%d", getpid());
+    err = pthread_setname_np(pthread_self(), task_name);
+    if (err)
+        error(1, err, "pthread_setname_np(perfmeas_task)");
+
+    while (run)
+    {
+        time(&time_now);    
+        dt = time_now - meas_timestart;
+
+        sem_wait(&display_sem);
+        minj = minjitter;
+        maxj = maxjitter;
+        avgj = avgjitter;
+
+        dc_min = dcdiff_min;
+        dc_max = dcdiff_max;
+        dc_avg = dcdiff_avg;
+
+        if (minj < g_minjitter) {
+            g_minjitter = minj;
+        }
+        if (maxj > g_maxjitter) {
+            g_maxjitter = maxj;
+        }
+
+        if (dc_min < g_dcdiff_min) {
+            g_dcdiff_min = dc_min;
+        }
+        if (dc_max > g_dcdiff_max){
+            g_dcdiff_max = dc_max;
+        }
+
+        if (print_line == 0){
+            print_line = 0;
+            printf("\n= = = = = = = = = = = = = = %.2ld:%.2ld:%.2ld = = = = = = = = = = = = = = = =\n",
+                        dt/3600, (dt/60)%60, dt%60);
+            printf("perf_meas %11s %11s %11s %11s %11s\n",
+                         "min", "avg", "max", "best", "worst");
+        }
+        else {
+            print_line -= 1;
+        }
+
+        printf("latency   %11d %11d %11d %11d %11d\n", 
+                           minj, avgj, maxj, g_minjitter, g_maxjitter);
+        printf("dc-off    %11d %11d %11d %11d %11d\n", 
+                           dc_min, dc_avg, dc_max, g_dcdiff_min, g_dcdiff_max);
+    }
+    
+
+}
+#endif
+
+/****************************************************************************
+ * Main function
+ ***************************************************************************/
+
+int main(int argc, char *argv[])
+{
+    size_t *sdo_upload_size = malloc(sizeof(size_t));;
+    struct timespec system_time;
+    uint32_t abort_data = 0;
+    uint32_t obj_value;
+    int i =0, j = 0;
+    int ret;
+
+    signal(SIGTERM, signal_handler);
+    signal(SIGINT, signal_handler);
+
+    mlockall(MCL_CURRENT | MCL_FUTURE);
+
+    printf("Requesting master...\n");
+    master = ecrt_request_master(0); 
+    if (!master) {
+        printf("Requesting master failed! \n");
+        return -1;
+    }
+
+    ecrt_master_set_send_interval(master, PERIOD_US);
+
+    domain = ecrt_master_create_domain(master);
+    if (!domain){
+        printf("Failed to create pd domain");
+        return -1;
+    }
+
+    printf("Getting slave info... \n");
+    ret = ecrt_master_get_slave(master, i, &slave_info);
+    if(ret != 0)
+    {
+        printf("Error in getting slave info!\n");
+        return -1;
+    }
+    printf("Obtaining slave configuration 0x%08X:0x%08X\n",slave_info.vendor_id, slave_info.product_code);
+    slave_config = ecrt_master_slave_config( master, 
+                                                    slave_info.alias, 
+                                                    slave_info.position,
+                                                    slave_info.vendor_id, 
+                                                    slave_info.product_code);
+    if(!slave_config){
+        fprintf(stderr, "Failed to get slave configuration.\n");
+        return -1;
+    }
+
+    uint8_t value_s_15[2] = {0x07, 0x00};
+    ret = ecrt_slave_config_idn(slave_config, 0, 15, EC_AL_STATE_PREOP, value_s_15, 2);
+    if(ret < 0){
+        fprintf(stderr, "Failed to set telegram type.\n");
+        return -1;
+    }
+
+    uint8_t value_s_16[10] = {0x06, 0x00, 0x06, 0x00, 0x33, 0x00, 0x0b, 0x00, 0x0c, 0x00};
+    ret = ecrt_slave_config_idn(slave_config, 0, 16, EC_AL_STATE_PREOP, value_s_16, 10);
+    if(ret < 0){
+        fprintf(stderr, "Failed to ecrt_slave_config_idn.\n");
+        return -1;
+    }
+
+    uint8_t value_s_24[8] = {0x04, 0x00, 0x04, 0x00, 0x2f, 0x00, 0x91, 0x00};
+    ret = ecrt_slave_config_idn(slave_config, 0, 24, EC_AL_STATE_PREOP, value_s_24, 8);
+    if(ret < 0){
+        fprintf(stderr, "Failed to ecrt_slave_config_idn.\n");
+        return -1;
+    }
+
+    ecrt_slave_config_pdo_assign_clear(slave_config, 2);
+    ecrt_slave_config_pdo_assign_clear(slave_config, 3);
+
+    ecrt_slave_config_pdo_assign_add(slave_config, 2, 24);
+    ecrt_slave_config_pdo_assign_add(slave_config, 3, 16);
+
+    ecrt_slave_config_pdo_mapping_clear(slave_config, 24);
+    ecrt_slave_config_pdo_mapping_clear(slave_config, 16);
+
+    ecrt_slave_config_pdo_mapping_add(slave_config, 24, 0x86, 0, 16);    // s-0-134 Control word
+    ecrt_slave_config_pdo_mapping_add(slave_config, 24, 0x2f, 0, 32);    // s-0-47 Position command
+    ecrt_slave_config_pdo_mapping_add(slave_config, 24, 0x91, 0, 16);    // s-0-145 Signal control word
+
+    ecrt_slave_config_pdo_mapping_add(slave_config, 16, 0x87, 0, 16);    // s-0-135 Status word
+    ecrt_slave_config_pdo_mapping_add(slave_config, 16, 0x33, 0, 32);    // s-0-51 Position feedback value
+    ecrt_slave_config_pdo_mapping_add(slave_config, 16, 0x0b, 0, 16);    // s-0-11 Class 1 diagnostics
+    ecrt_slave_config_pdo_mapping_add(slave_config, 16, 0x0c, 0, 16);    // s-0-12 Class 2 diagnostics
+
+    uint8_t value_s_32[2] = {0x0b, 0x00};
+    ret = ecrt_slave_config_idn(slave_config, 0, 32, EC_AL_STATE_PREOP, value_s_32, 2);
+    if(ret < 0){
+        fprintf(stderr, "Failed to set operration mode.\n");
+        return -1;
+    }
+
+
+    uint8_t value_s_1[2] = {0xf4, 0x01};
+    ret = ecrt_slave_config_idn(slave_config, 0, 1, EC_AL_STATE_PREOP, value_s_1, 2);
+    if(ret < 0){
+        fprintf(stderr, "Failed to set operration mode.\n");
+        return -1;
+    }
+
+    ret = ecrt_slave_config_reg_pdo_entry(slave_config, 0x86, 0, domain, NULL);
+    if(ret < 0){
+        fprintf(stderr, "Failed to ecrt_slave_config_reg_pdo_entry \n");
+    }else{
+        offset_controlword = ret;
+        printf("offset_controlword = 0x%08x \n", ret);
+    }
+
+    ret = ecrt_slave_config_reg_pdo_entry(slave_config, 0x2f, 0, domain, NULL);
+    if(ret < 0){
+        fprintf(stderr, "Failed to ecrt_slave_config_reg_pdo_entry \n");
+    }else{
+        offset_targetposition = ret;
+        printf("offset_targetposition = 0x%08x \n", ret);
+    }
+
+    ret = ecrt_slave_config_reg_pdo_entry(slave_config, 0x91, 0, domain, NULL);
+    if(ret < 0){
+        fprintf(stderr, "Failed to ecrt_slave_config_reg_pdo_entry \n");
+    }else{
+        offset_signal_ctrlword = ret;
+        printf("offset_signal_ctrlword = 0x%08x \n", ret);
+    }
+
+    offset_statusword = ecrt_slave_config_reg_pdo_entry(slave_config, 0x87, 0, domain, NULL);
+    offset_actualposition = ecrt_slave_config_reg_pdo_entry(slave_config, 0x33, 0, domain, NULL);
+    offset_class1_diagnostics = ecrt_slave_config_reg_pdo_entry(slave_config, 0x0b, 0, domain, NULL);
+    offset_class2_diagnostics = ecrt_slave_config_reg_pdo_entry(slave_config, 0x0c, 0, domain, NULL);
+
+    /*Configuring DC signal*/
+    printf("Configure distributed clocks... \n");
+    ecrt_slave_config_dc(slave_config, DC_ASSIGN_ACTIVATE, PERIOD_NS, PERIOD_NS/2, 0, 0);      
+
+    clock_gettime(CLOCK_TO_USE, &system_time);
+    ecrt_master_application_time(master, TIMESPEC2NS(system_time));
+
+    ret = ecrt_master_select_reference_clock(master, slave_config);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to select reference clock: %s\n", strerror(-ret));
+        return -1;
+    }
+
+    printf("Activating master...\n");
+    if (ecrt_master_activate(master)) {
+        return -1;
+    }
+
+    printf("Getting pointer to pdos... \n");
+    if (!(domain_pd = ecrt_domain_data(domain))) {
+        fprintf(stderr, "Failed to get domain data pointer.\n");
+        return -1;
+    }
+    else{
+        printf("Success to ecrt_domain_data(domain).\n");
+    }
+
+#ifdef PERF_MEASURE
+    /* Create display thread */
+    pthread_attr_t display_attr;
+
+    pthread_attr_init(&display_attr);
+    ret = pthread_attr_setschedpolicy(&display_attr, SCHED_OTHER);
+    if (ret)
+        error(1, ret, "pthread_attr_setschedpolicy()");
+    ret = pthread_attr_setdetachstate(&display_attr, PTHREAD_CREATE_JOINABLE);
+    if (ret)
+        error(1, ret, "pthread_attr_setdetachstate()");
+    ret = pthread_create(&perfmeas_thread, &display_attr, &perfmeas_task, NULL);
+    if (ret) {
+        fprintf(stderr, "%s: Creat perfmeas_task failed\n", strerror(-ret));
+		return -1;
+    }
+#endif
+
+    /* Create cyclic RT-thread */
+    pthread_attr_t rttask_attr;
+
+    pthread_attr_init(&rttask_attr);
+    ret = pthread_attr_setdetachstate(&rttask_attr, PTHREAD_CREATE_JOINABLE);
+    if (ret)
+        error(1, ret, "pthread_attr_setdetachstate()");
+    ret = pthread_create(&cyclic_thread, &rttask_attr, &cyclic_task, NULL);
+    if (ret) {
+        fprintf(stderr, "%s: Create cyclic_task failed\n", strerror(-ret));
+		return -1;
+    }
+
+    while (run) {
+        usleep(100000);
+    }
+
+    pthread_join(cyclic_thread, NULL);
+
+    printf("End of Program\n");
+    ecrt_release_master(master);
+
+    return 0;
+}
+
+/****************************************************************************/
-- 
2.45.2

