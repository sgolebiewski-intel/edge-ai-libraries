From ced89a9f2c4dd85104aaa9fde9a63f8599ca1b87 Mon Sep 17 00:00:00 2001
From: Jeremy Ouillette <jeremy.ouillette@intel.com>
Date: Tue, 24 Jun 2025 23:24:52 -0700
Subject: [PATCH] Add oneAPI support.

---
 CHANGES.md                                    |   13 +
 CMakeLists.txt                                |   17 +-
 PCLConfig.cmake.in                            |   13 +-
 README.md                                     |   25 +-
 cmake/pcl_options.cmake                       |    3 +
 cmake/pcl_win_dir.cmake                       |   25 +
 common/include/pcl/for_each_type.h            |    2 +-
 common/include/pcl/impl/instantiate.hpp       |    2 +-
 debian/README.source                          |   10 +
 debian/changelog                              |  510 ++++++
 debian/clean                                  |    1 +
 debian/control                                |  656 ++++++++
 debian/copyright                              |  636 ++++++++
 debian/gbp.conf                               |   22 +
 debian/libpcl-apps1.12.install                |    1 +
 debian/libpcl-common1.12.install              |    1 +
 debian/libpcl-dev.install                     |    4 +
 debian/libpcl-doc.doc-base                    |    9 +
 debian/libpcl-doc.docs                        |    1 +
 debian/libpcl-doc.examples                    |    1 +
 debian/libpcl-doc.links                       |    1 +
 debian/libpcl-features1.12.install            |    1 +
 debian/libpcl-filters1.12.install             |    1 +
 debian/libpcl-io1.12.install                  |    2 +
 debian/libpcl-kdtree1.12.install              |    1 +
 debian/libpcl-keypoints1.12.install           |    1 +
 debian/libpcl-ml1.12.install                  |    1 +
 debian/libpcl-octree1.12.install              |    1 +
 debian/libpcl-oneapi-common1.12.install       |    1 +
 debian/libpcl-oneapi-features1.12.install     |    1 +
 debian/libpcl-oneapi-filters1.12.install      |    1 +
 debian/libpcl-oneapi-kdtree1.12.install       |    1 +
 debian/libpcl-oneapi-octree1.12.install       |    1 +
 debian/libpcl-oneapi-registration1.12.install |    1 +
 ...libpcl-oneapi-sample-consensus1.12.install |    1 +
 debian/libpcl-oneapi-search1.12.install       |    1 +
 debian/libpcl-oneapi-segmentation1.12.install |    1 +
 debian/libpcl-oneapi-surface1.12.install      |    1 +
 debian/libpcl-oneapi.install                  |    0
 debian/libpcl-outofcore1.12.install           |    1 +
 debian/libpcl-people1.12.install              |    1 +
 debian/libpcl-recognition1.12.install         |    1 +
 debian/libpcl-registration1.12.install        |    1 +
 debian/libpcl-sample-consensus1.12.install    |    1 +
 debian/libpcl-search1.12.install              |    1 +
 debian/libpcl-segmentation1.12.install        |    1 +
 debian/libpcl-stereo1.12.install              |    1 +
 debian/libpcl-surface1.12.install             |    1 +
 debian/libpcl-tracking1.12.install            |    1 +
 debian/libpcl-visualization1.12.install       |    1 +
 debian/manpages/pcl_add_gaussian_noise.1      |   24 +
 debian/manpages/pcl_boundary_estimation.1     |   28 +
 debian/manpages/pcl_cluster_extraction.1      |   28 +
 debian/manpages/pcl_compute_cloud_error.1     |   30 +
 debian/manpages/pcl_compute_hull.1            |   26 +
 .../manpages/pcl_convert_pcd_ascii_binary.1   |   16 +
 debian/manpages/pcl_convolve.1                |   38 +
 debian/manpages/pcl_crop_to_hull.1            |   24 +
 debian/manpages/pcl_demean_cloud.1            |   20 +
 debian/manpages/pcl_extract_feature.1         |   33 +
 debian/manpages/pcl_fast_bilateral_filter.1   |   33 +
 debian/manpages/pcl_feature_matching.1        |   43 +
 debian/manpages/pcl_fpfh_estimation.1         |   26 +
 debian/manpages/pcl_gp3_surface.1             |   25 +
 .../pcl_ground_based_rgbd_people_detector.1   |   37 +
 debian/manpages/pcl_hdl_viewer_simple.1       |   22 +
 debian/manpages/pcl_image_grabber_saver.1     |   31 +
 debian/manpages/pcl_image_grabber_viewer.1    |   48 +
 debian/manpages/pcl_linemod_detection.1       |   18 +
 .../pcl_marching_cubes_reconstruction.1       |   35 +
 debian/manpages/pcl_mesh2pcd.1                |   28 +
 debian/manpages/pcl_mesh_sampling.1           |   27 +
 debian/manpages/pcl_mls_smoothing.1           |   31 +
 debian/manpages/pcl_normal_estimation.1       |   35 +
 debian/manpages/pcl_obj2vtk.1                 |   20 +
 .../pcl_obj_rec_ransac_accepted_hypotheses.1  |   25 +
 .../manpages/pcl_obj_rec_ransac_model_opps.1  |   19 +
 .../manpages/pcl_obj_rec_ransac_orr_octree.1  |   20 +
 ...cl_obj_rec_ransac_orr_octree_zprojection.1 |   20 +
 debian/manpages/pcl_obj_rec_ransac_result.1   |   19 +
 .../manpages/pcl_obj_rec_ransac_scene_opps.1  |   19 +
 debian/manpages/pcl_octree_viewer.1           |   20 +
 debian/manpages/pcl_oni2pcd.1                 |   17 +
 debian/manpages/pcl_oni_viewer.1              |   21 +
 debian/manpages/pcl_openni_3d_concave_hull.1  |   17 +
 debian/manpages/pcl_openni_3d_convex_hull.1   |   17 +
 .../manpages/pcl_openni_boundary_estimation.1 |   17 +
 debian/manpages/pcl_openni_change_viewer.1    |   23 +
 debian/manpages/pcl_openni_fast_mesh.1        |   17 +
 .../manpages/pcl_openni_feature_persistence.1 |   30 +
 .../pcl_openni_ii_normal_estimation.1         |   16 +
 debian/manpages/pcl_openni_image.1            |   54 +
 debian/manpages/pcl_openni_mls_smoothing.1    |   28 +
 .../manpages/pcl_openni_octree_compression.1  |   85 +
 .../pcl_openni_organized_compression.1        |   60 +
 debian/manpages/pcl_openni_pcd_recorder.1     |   31 +
 .../manpages/pcl_openni_planar_convex_hull.1  |   22 +
 .../manpages/pcl_openni_planar_segmentation.1 |   22 +
 debian/manpages/pcl_openni_save_image.1       |   48 +
 debian/manpages/pcl_openni_tracking.1         |   27 +
 debian/manpages/pcl_openni_uniform_sampling.1 |   22 +
 debian/manpages/pcl_openni_viewer.1           |   59 +
 debian/manpages/pcl_outlier_removal.1         |   37 +
 debian/manpages/pcl_passthrough_filter.1      |   33 +
 debian/manpages/pcl_pcd2ply.1                 |   20 +
 debian/manpages/pcl_pcd2png.1                 |   54 +
 debian/manpages/pcl_pcd2vtk.1                 |   20 +
 debian/manpages/pcl_pcd_change_viewpoint.1    |   24 +
 debian/manpages/pcl_pcd_convert_NaN_nan.1     |   16 +
 debian/manpages/pcl_pcd_grabber_viewer.1      |   53 +
 debian/manpages/pcl_pcd_select_object_plane.1 |   19 +
 debian/manpages/pcl_pclzf2pcd.1               |   20 +
 debian/manpages/pcl_plane_projection.1        |   24 +
 debian/manpages/pcl_ply2obj.1                 |   46 +
 debian/manpages/pcl_ply2pcd.1                 |   20 +
 debian/manpages/pcl_ply2ply.1                 |   36 +
 debian/manpages/pcl_ply2raw.1                 |   41 +
 debian/manpages/pcl_ply2vtk.1                 |   20 +
 debian/manpages/pcl_plyheader.1               |   29 +
 debian/manpages/pcl_png2pcd.1                 |   34 +
 debian/manpages/pcl_poisson_reconstruction.1  |   30 +
 debian/manpages/pcl_ppf_object_recognition.1  |   19 +
 debian/manpages/pcl_sac_segmentation_plane.1  |   35 +
 debian/manpages/pcl_spin_estimation.1         |   35 +
 debian/manpages/pcl_test_search_speed.1       |   16 +
 debian/manpages/pcl_tiff2pcd.1                |   33 +
 debian/manpages/pcl_train_linemod_template.1  |   20 +
 .../manpages/pcl_transform_from_viewpoint.1   |   21 +
 debian/manpages/pcl_transform_point_cloud.1   |   45 +
 debian/manpages/pcl_uniform_sampling.1        |   25 +
 debian/manpages/pcl_vfh_estimation.1          |   20 +
 debian/manpages/pcl_voxel_grid.1              |   31 +
 debian/manpages/pcl_vtk2obj.1                 |   20 +
 debian/manpages/pcl_vtk2pcd.1                 |   24 +
 debian/manpages/pcl_vtk2ply.1                 |   20 +
 debian/manpages/pcl_xyz2pcd.1                 |   20 +
 debian/options                                |    0
 debian/patches/0001-Fix-PCL_ROOT-path.patch   |   25 +
 ...inst-atomic-if-needed-found-on-armel.patch |   60 +
 ...03-Use-newly-build-libs-when-testing.patch |   25 +
 .../patches/0004-Disable-failing-tests.patch  |   64 +
 .../0005-Adopt-unit-test-for-i386.patch       |  133 ++
 ...opt-unit-tests-for-arm64-and-ppc64el.patch |   48 +
 ...SOURCES_TREE-from-installation-cmake.patch |   33 +
 ...08-Don-t-require-boost-in-pkg-config.patch |   26 +
 .../0009-Repair-sparse_matrix.hpp.patch       |   61 +
 .../0010-Fix-variable-name-in-poisson4.patch  |   25 +
 debian/patches/series                         |   10 +
 debian/pcl-oneapi-test.install                |    6 +
 debian/pcl-oneapi-tutorials.install           |    1 +
 debian/pcl-tools.install                      |    1 +
 debian/pcl-tools.manpages                     |   86 +
 debian/rules                                  |   72 +
 debian/shlibs.local                           |    3 +
 debian/source/format                          |    1 +
 debian/source/options                         |    5 +
 debian/watch                                  |    5 +
 .../images/oneapi/convex_hull_3d_img.png      |  Bin 0 -> 72318 bytes
 .../content/images/oneapi/oneapi_logo.png     |  Bin 0 -> 1642 bytes
 .../images/oneapi/pcl_oneapi_segmentation.png |  Bin 0 -> 214788 bytes
 doc/tutorials/content/index.rst               |  165 +-
 .../content/oneapi_greedy_projection.rst      |  116 ++
 doc/tutorials/content/oneapi_install.rst      |   68 +
 doc/tutorials/content/oneapi_kdtree.rst       |  169 ++
 doc/tutorials/content/oneapi_mls.rst          |  123 ++
 .../content/oneapi_normal_estimation.rst      |   85 +
 doc/tutorials/content/oneapi_octree.rst       |  143 ++
 doc/tutorials/content/oneapi_passthrough.rst  |   79 +
 doc/tutorials/content/oneapi_registration.rst |  111 ++
 .../content/oneapi_sample_consensus.rst       |  104 ++
 ...api_sample_consensus_initial_alignment.rst |   77 +
 doc/tutorials/content/oneapi_segmentation.rst |  103 ++
 .../content/oneapi_statistical_outlier.rst    |   99 ++
 doc/tutorials/content/oneapi_voxel_grid.rst   |   79 +
 .../sources/oneapi/data/scia_source.pcd       |  Bin 0 -> 40730 bytes
 .../oneapi/data/scia_source_fpfh33.pcd        |  Bin 0 -> 446318 bytes
 .../sources/oneapi/data/scia_target.pcd       |  Bin 0 -> 36614 bytes
 .../oneapi/data/scia_target_fpfh33.pcd        |  Bin 0 -> 401042 bytes
 .../oneapi/greedy_projection/CMakeLists.txt   |   29 +
 .../greedy_projection/greedy_projection.cpp   |   65 +
 .../sources/oneapi/kdtree/CMakeLists.txt      |   22 +
 .../sources/oneapi/kdtree/oneapi_kdtree.cpp   |  120 ++
 .../content/sources/oneapi/mls/CMakeLists.txt |   35 +
 .../content/sources/oneapi/mls/oneapi_mls.cpp |   40 +
 .../oneapi/normal_estimation/CMakeLists.txt   |   36 +
 .../oneapi_normal_estimation.cpp              |   48 +
 .../sources/oneapi/octree/CMakeLists.txt      |   22 +
 .../oneapi/octree/oneapi_octree_search.cpp    |  173 +++
 .../sources/oneapi/passthrough/CMakeLists.txt |   36 +
 .../oneapi/passthrough/oneapi_passthrough.cpp |   34 +
 .../oneapi/registration/CMakeLists.txt        |   37 +
 .../registration/oneapi_icp_example.cpp       |   49 +
 .../oneapi/sample_consensus/CMakeLists.txt    |   36 +
 .../oneapi_sample_consensus.cpp               |   96 ++
 .../CMakeLists.txt                            |   22 +
 .../oneapi_scia.cpp                           |   60 +
 .../oneapi/segmentation/CMakeLists.txt        |   36 +
 .../segmentation/oneapi_segmentation.cpp      |   46 +
 .../CMakeLists.txt                            |   35 +
 .../oneapi_statistical_outlier_removal.cpp    |   41 +
 .../sources/oneapi/voxel_grid/CMakeLists.txt  |   36 +
 .../oneapi/voxel_grid/oneapi_voxel_grid.cpp   |   33 +
 doc/tutorials/content/statistical_outlier.rst |    2 +-
 oneapi/CMakeLists.txt                         |  216 +++
 oneapi/PCL-ONEAPIConfig.cmake.in              |  660 ++++++++
 oneapi/PCL-ONEAPIConfigVersion.cmake.in       |   13 +
 oneapi/README.md                              |    7 +
 oneapi/build_linux.md                         |  119 ++
 oneapi/build_pcl_test_func.bat                |   25 +
 oneapi/build_pcl_test_perf.bat                |   25 +
 oneapi/build_windows.md                       |  164 ++
 oneapi/cmake/cpack_options.cmake.in           |   49 +
 oneapi/cmake/dep_graph.cmake                  |   32 +
 oneapi/cmake/pcl_all_in_one_installer.cmake   |  146 ++
 oneapi/cmake/pcl_cpack.cmake                  |  146 ++
 oneapi/cmake/pcl_options.cmake                |  113 ++
 oneapi/cmake/pcl_pclconfig.cmake              |   97 ++
 oneapi/cmake/pcl_targets.cmake                |  908 +++++++++++
 oneapi/cmake/pcl_utils.cmake                  |  468 ++++++
 oneapi/cmake/pcl_verbosity.cmake              |   21 +
 oneapi/cmake/pkgconfig-headeronly.cmake.in    |   12 +
 oneapi/cmake/pkgconfig.cmake.in               |   13 +
 oneapi/cmake/uninstall_target.cmake.in        |   66 +
 oneapi/cmake/version.rc.in                    |   44 +
 oneapi/common/CMakeLists.txt                  |   88 ++
 .../include/pcl/oneapi/PCLPointCloud2.h       |  128 ++
 .../common/include/pcl/oneapi/PointIndices.h  |   57 +
 .../include/pcl/oneapi/common/centroid.h      |  125 ++
 .../common/include/pcl/oneapi/common/common.h |  314 ++++
 .../include/pcl/oneapi/common/copy_point.h    |   61 +
 .../pcl/oneapi/common/device/centroid.h       |  104 ++
 .../include/pcl/oneapi/common/device/eigen.h  |  231 +++
 .../pcl/oneapi/common/device/matrix_types.h   |  166 ++
 .../pcl/oneapi/common/device/vector_types.h   |  155 ++
 .../include/pcl/oneapi/common/impl/common.hpp |  441 ++++++
 .../pcl/oneapi/common/impl/copy_point.hpp     |  152 ++
 .../include/pcl/oneapi/common/impl/io.hpp     |  499 ++++++
 oneapi/common/include/pcl/oneapi/common/io.h  |  566 +++++++
 .../pcl/oneapi/containers/device_array.h      |  587 +++++++
 .../pcl/oneapi/containers/device_memory.h     |  404 +++++
 .../oneapi/containers/gpu_memory_manager.h    |   84 +
 .../oneapi/containers/impl/device_array.hpp   |  450 ++++++
 .../oneapi/containers/impl/device_memory.hpp  |  134 ++
 .../pcl/oneapi/containers/initialization.h    |   85 +
 .../pcl/oneapi/containers/kernel_containers.h |  142 ++
 .../include/pcl/oneapi/impl/pcl_base.hpp      |  228 +++
 oneapi/common/include/pcl/oneapi/pcl_base.h   |  310 ++++
 .../common/include/pcl/oneapi/point_cloud.h   |  226 +++
 .../include/pcl/oneapi/point_type_rgb.h       |  115 ++
 .../common/include/pcl/oneapi/point_types.h   |  109 ++
 oneapi/common/include/pcl/oneapi/types.h      |  141 ++
 oneapi/common/src/PCLPointCloud2.cpp          |  177 +++
 oneapi/common/src/common.cpp                  |   88 ++
 oneapi/common/src/device_memory.cpp.dp.cpp    |  573 +++++++
 oneapi/common/src/error.cpp                   |   50 +
 oneapi/common/src/gpu_memory_manager.dp.cpp   |  271 ++++
 oneapi/common/src/io.cpp                      |  407 +++++
 oneapi/common/src/pcl_base.cpp                |  173 +++
 oneapi/common/src/point_types.cpp             |   38 +
 oneapi/features/CMakeLists.txt                |   43 +
 .../include/pcl/oneapi/features/feature.h     |  267 ++++
 .../pcl/oneapi/features/impl/feature.hpp      |  197 +++
 .../pcl/oneapi/features/impl/normal_3d.hpp    |  433 ++++++
 .../include/pcl/oneapi/features/normal_3d.h   |  262 ++++
 oneapi/features/src/normal_3d.cpp             |   51 +
 oneapi/filters/CMakeLists.txt                 |   54 +
 .../pcl/oneapi/filters/extract_indices.h      |  208 +++
 .../include/pcl/oneapi/filters/filter.h       |  295 ++++
 .../pcl/oneapi/filters/filter_indices.h       |  311 ++++
 .../oneapi/filters/impl/extract_indices.hpp   |  187 +++
 .../pcl/oneapi/filters/impl/filter.hpp        |  144 ++
 .../oneapi/filters/impl/filter_indices.hpp    |  115 ++
 .../pcl/oneapi/filters/impl/passthrough.hpp   |  267 ++++
 .../impl/statistical_outlier_removal.hpp      |  160 ++
 .../pcl/oneapi/filters/impl/voxel_grid.hpp    |  417 +++++
 .../include/pcl/oneapi/filters/passthrough.h  |  245 +++
 .../filters/statistical_outlier_removal.h     |  206 +++
 .../include/pcl/oneapi/filters/voxel_grid.h   |  423 +++++
 oneapi/filters/src/extract_indices.cpp        |  221 +++
 oneapi/filters/src/filter.cpp                 |   82 +
 oneapi/filters/src/filter_indices.cpp         |   68 +
 oneapi/filters/src/passthrough.cpp            |   50 +
 .../src/statistical_outlier_removal.cpp       |   52 +
 oneapi/filters/src/voxel_grid.cpp             |   46 +
 oneapi/flann_dp_modification.png              |  Bin 0 -> 105360 bytes
 oneapi/kdtree/CMakeLists.txt                  |   52 +
 .../pcl/oneapi/kdtree/fixed_radius_index.h    |  110 ++
 .../oneapi/kdtree/impl/fixed_radius_index.hpp |  361 +++++
 .../kdtree/impl/fixed_radius_search.hpp       |  797 ++++++++++
 .../pcl/oneapi/kdtree/impl/kdtree_flann.hpp   | 1042 +++++++++++++
 .../include/pcl/oneapi/kdtree/kdtree_flann.h  |  524 +++++++
 .../pcl/oneapi/kdtree/memory_allocation.h     |  207 +++
 oneapi/kdtree/src/kdtree_flann.cpp            |   49 +
 oneapi/octree/CMakeLists.txt                  |   41 +
 .../pcl/oneapi/octree/device_format.hpp       |   89 ++
 .../include/pcl/oneapi/octree/octree.hpp      |  196 +++
 oneapi/octree/octree.doxy                     |   34 +
 oneapi/octree/src/dpcpp/approx_nsearch.cpp    |  286 ++++
 oneapi/octree/src/dpcpp/knn_search.cpp        |  332 ++++
 oneapi/octree/src/dpcpp/octree_builder.cpp    |  458 ++++++
 oneapi/octree/src/dpcpp/octree_host.cpp       |  257 +++
 oneapi/octree/src/dpcpp/octree_iterator.hpp   |  169 ++
 oneapi/octree/src/dpcpp/radius_search.cpp     |  514 ++++++
 oneapi/octree/src/internal.hpp                |  150 ++
 oneapi/octree/src/octree.cpp                  |  217 +++
 .../octree/src/utils/approx_nearest_utils.hpp |  135 ++
 oneapi/octree/src/utils/boxutils.hpp          |  133 ++
 oneapi/octree/src/utils/copygen.hpp           |   97 ++
 oneapi/octree/src/utils/morton.hpp            |  176 +++
 oneapi/octree/src/utils/scan_block.hpp        |  146 ++
 oneapi/pcl_config.h.in                        |   88 ++
 oneapi/registration/CMakeLists.txt            |   48 +
 .../registration/correspondence_estimation.h  |  454 ++++++
 .../pcl/oneapi/registration/ia_ransac.h       |  377 +++++
 .../include/pcl/oneapi/registration/icp.h     |  418 +++++
 .../impl/correspondence_estimation.hpp        |  191 +++
 .../oneapi/registration/impl/ia_ransac.hpp    |  607 ++++++++
 .../pcl/oneapi/registration/impl/icp.hpp      |  320 ++++
 .../oneapi/registration/impl/registration.hpp |  223 +++
 .../pcl/oneapi/registration/registration.h    |  717 +++++++++
 .../src/correspondence_estimation.cpp         |   51 +
 oneapi/registration/src/ia_ransac.cpp         |   49 +
 oneapi/registration/src/icp.cpp               |   48 +
 oneapi/registration/src/registration.cpp      |   48 +
 oneapi/sample_consensus/CMakeLists.txt        |   39 +
 .../oneapi/sample_consensus/impl/ransac.hpp   |  154 ++
 .../sample_consensus/impl/sac_model_plane.hpp |  543 +++++++
 .../oneapi/sample_consensus/method_types.h    |   58 +
 .../pcl/oneapi/sample_consensus/model_types.h |   72 +
 .../pcl/oneapi/sample_consensus/ransac.h      |  114 ++
 .../include/pcl/oneapi/sample_consensus/sac.h |  366 +++++
 .../pcl/oneapi/sample_consensus/sac_model.h   |  693 +++++++++
 .../oneapi/sample_consensus/sac_model_plane.h |  225 +++
 oneapi/sample_consensus/src/sac.cpp           |   50 +
 .../sample_consensus/src/sac_model_plane.cpp  |   51 +
 oneapi/search/CMakeLists.txt                  |   40 +
 .../include/pcl/oneapi/search/impl/kdtree.hpp |  225 +++
 .../search/include/pcl/oneapi/search/kdtree.h |  241 +++
 .../search/include/pcl/oneapi/search/search.h |  453 ++++++
 oneapi/search/src/kdtree.cpp                  |   46 +
 oneapi/segmentation/CMakeLists.txt            |   33 +
 .../segmentation/impl/sac_segmentation.hpp    |  206 +++
 .../oneapi/segmentation/sac_segmentation.h    |  302 ++++
 oneapi/segmentation/src/sac_segmentation.cpp  |   50 +
 oneapi/surface/CMakeLists.txt                 |   44 +
 .../include/pcl/oneapi/surface/convex_hull.h  |   76 +
 .../include/pcl/oneapi/surface/device/mls.hpp |  280 ++++
 .../include/pcl/oneapi/surface/impl/mls.hpp   | 1379 +++++++++++++++++
 .../pcl/oneapi/surface/impl/processing.hpp    |   69 +
 .../surface/include/pcl/oneapi/surface/mls.h  |  625 ++++++++
 .../include/pcl/oneapi/surface/processing.h   |   92 ++
 oneapi/surface/src/convex_hull.cpp            |  141 ++
 oneapi/surface/src/dpcpp/convex_hull.dp.cpp   | 1075 +++++++++++++
 oneapi/surface/src/dpcpp/device.h             |  115 ++
 oneapi/surface/src/internal.h                 |  123 ++
 oneapi/surface/src/mls.cpp                    |   55 +
 oneapi/surface_omp/CMakeLists.txt             |   58 +
 .../include/pcl/oneapi/surface_omp/gp3.h      |  338 ++++
 .../pcl/oneapi/surface_omp/impl/gp3.hpp       |  501 ++++++
 oneapi/surface_omp/src/gp3.cpp                |   45 +
 .../utils/include/pcl/oneapi/utils/common.h   |  120 ++
 .../pcl/oneapi/utils/device/algorithm.hpp     |   82 +
 .../pcl/oneapi/utils/device/funcattrib.hpp    |   73 +
 .../sort/agent_radix_sort_downsweep.hpp       |  661 ++++++++
 .../device/sort/agent_radix_sort_upsweep.hpp  |  508 ++++++
 .../sort/agent_segmented_radix_sort.hpp       |  271 ++++
 .../utils/device/sort/block_exchange.hpp      |  445 ++++++
 .../oneapi/utils/device/sort/block_load.hpp   |  635 ++++++++
 .../utils/device/sort/block_radix_rank.hpp    |  778 ++++++++++
 .../utils/device/sort/block_radix_sort.hpp    |  486 ++++++
 .../utils/device/sort/block_raking_layout.hpp |  138 ++
 .../oneapi/utils/device/sort/block_scan.hpp   |  382 +++++
 .../utils/device/sort/block_scan_raking.hpp   |  344 ++++
 .../oneapi/utils/device/sort/block_store.hpp  |  409 +++++
 .../device/sort/device_double_buffer.hpp      |   77 +
 .../sort/radix_rank_sort_operations.hpp       |  136 ++
 .../utils/device/sort/thread_reduce.hpp       |  131 ++
 .../oneapi/utils/device/sort/thread_scan.hpp  |  200 +++
 .../oneapi/utils/device/sort/util_type.hpp    |  539 +++++++
 .../pcl/oneapi/utils/device/static_check.hpp  |   71 +
 .../pcl/oneapi/utils/device/vector_math.hpp   |  123 ++
 .../include/pcl/oneapi/utils/device/warp.hpp  |  250 +++
 .../pcl/oneapi/utils/double_buffer.hpp        |   90 ++
 .../include/pcl/oneapi/utils/safe_call.hpp    |   81 +
 .../include/pcl/oneapi/utils/segmented_sort.h |  293 ++++
 oneapi/utils/src/internal.hpp                 |   51 +
 oneapi/utils/src/repacks.cpp                  |   41 +
 387 files changed, 50450 insertions(+), 23 deletions(-)
 create mode 100644 cmake/pcl_win_dir.cmake
 create mode 100644 debian/README.source
 create mode 100644 debian/changelog
 create mode 100644 debian/clean
 create mode 100644 debian/control
 create mode 100644 debian/copyright
 create mode 100644 debian/gbp.conf
 create mode 100644 debian/libpcl-apps1.12.install
 create mode 100644 debian/libpcl-common1.12.install
 create mode 100644 debian/libpcl-dev.install
 create mode 100644 debian/libpcl-doc.doc-base
 create mode 100644 debian/libpcl-doc.docs
 create mode 100644 debian/libpcl-doc.examples
 create mode 100644 debian/libpcl-doc.links
 create mode 100644 debian/libpcl-features1.12.install
 create mode 100644 debian/libpcl-filters1.12.install
 create mode 100644 debian/libpcl-io1.12.install
 create mode 100644 debian/libpcl-kdtree1.12.install
 create mode 100644 debian/libpcl-keypoints1.12.install
 create mode 100644 debian/libpcl-ml1.12.install
 create mode 100644 debian/libpcl-octree1.12.install
 create mode 100644 debian/libpcl-oneapi-common1.12.install
 create mode 100644 debian/libpcl-oneapi-features1.12.install
 create mode 100644 debian/libpcl-oneapi-filters1.12.install
 create mode 100644 debian/libpcl-oneapi-kdtree1.12.install
 create mode 100644 debian/libpcl-oneapi-octree1.12.install
 create mode 100644 debian/libpcl-oneapi-registration1.12.install
 create mode 100644 debian/libpcl-oneapi-sample-consensus1.12.install
 create mode 100644 debian/libpcl-oneapi-search1.12.install
 create mode 100644 debian/libpcl-oneapi-segmentation1.12.install
 create mode 100644 debian/libpcl-oneapi-surface1.12.install
 create mode 100644 debian/libpcl-oneapi.install
 create mode 100644 debian/libpcl-outofcore1.12.install
 create mode 100644 debian/libpcl-people1.12.install
 create mode 100644 debian/libpcl-recognition1.12.install
 create mode 100644 debian/libpcl-registration1.12.install
 create mode 100644 debian/libpcl-sample-consensus1.12.install
 create mode 100644 debian/libpcl-search1.12.install
 create mode 100644 debian/libpcl-segmentation1.12.install
 create mode 100644 debian/libpcl-stereo1.12.install
 create mode 100644 debian/libpcl-surface1.12.install
 create mode 100644 debian/libpcl-tracking1.12.install
 create mode 100644 debian/libpcl-visualization1.12.install
 create mode 100644 debian/manpages/pcl_add_gaussian_noise.1
 create mode 100644 debian/manpages/pcl_boundary_estimation.1
 create mode 100644 debian/manpages/pcl_cluster_extraction.1
 create mode 100644 debian/manpages/pcl_compute_cloud_error.1
 create mode 100644 debian/manpages/pcl_compute_hull.1
 create mode 100644 debian/manpages/pcl_convert_pcd_ascii_binary.1
 create mode 100644 debian/manpages/pcl_convolve.1
 create mode 100644 debian/manpages/pcl_crop_to_hull.1
 create mode 100644 debian/manpages/pcl_demean_cloud.1
 create mode 100644 debian/manpages/pcl_extract_feature.1
 create mode 100644 debian/manpages/pcl_fast_bilateral_filter.1
 create mode 100644 debian/manpages/pcl_feature_matching.1
 create mode 100644 debian/manpages/pcl_fpfh_estimation.1
 create mode 100644 debian/manpages/pcl_gp3_surface.1
 create mode 100644 debian/manpages/pcl_ground_based_rgbd_people_detector.1
 create mode 100644 debian/manpages/pcl_hdl_viewer_simple.1
 create mode 100644 debian/manpages/pcl_image_grabber_saver.1
 create mode 100644 debian/manpages/pcl_image_grabber_viewer.1
 create mode 100644 debian/manpages/pcl_linemod_detection.1
 create mode 100644 debian/manpages/pcl_marching_cubes_reconstruction.1
 create mode 100644 debian/manpages/pcl_mesh2pcd.1
 create mode 100644 debian/manpages/pcl_mesh_sampling.1
 create mode 100644 debian/manpages/pcl_mls_smoothing.1
 create mode 100644 debian/manpages/pcl_normal_estimation.1
 create mode 100644 debian/manpages/pcl_obj2vtk.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_accepted_hypotheses.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_model_opps.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_orr_octree.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_orr_octree_zprojection.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_result.1
 create mode 100644 debian/manpages/pcl_obj_rec_ransac_scene_opps.1
 create mode 100644 debian/manpages/pcl_octree_viewer.1
 create mode 100644 debian/manpages/pcl_oni2pcd.1
 create mode 100644 debian/manpages/pcl_oni_viewer.1
 create mode 100644 debian/manpages/pcl_openni_3d_concave_hull.1
 create mode 100644 debian/manpages/pcl_openni_3d_convex_hull.1
 create mode 100644 debian/manpages/pcl_openni_boundary_estimation.1
 create mode 100644 debian/manpages/pcl_openni_change_viewer.1
 create mode 100644 debian/manpages/pcl_openni_fast_mesh.1
 create mode 100644 debian/manpages/pcl_openni_feature_persistence.1
 create mode 100644 debian/manpages/pcl_openni_ii_normal_estimation.1
 create mode 100644 debian/manpages/pcl_openni_image.1
 create mode 100644 debian/manpages/pcl_openni_mls_smoothing.1
 create mode 100644 debian/manpages/pcl_openni_octree_compression.1
 create mode 100644 debian/manpages/pcl_openni_organized_compression.1
 create mode 100644 debian/manpages/pcl_openni_pcd_recorder.1
 create mode 100644 debian/manpages/pcl_openni_planar_convex_hull.1
 create mode 100644 debian/manpages/pcl_openni_planar_segmentation.1
 create mode 100644 debian/manpages/pcl_openni_save_image.1
 create mode 100644 debian/manpages/pcl_openni_tracking.1
 create mode 100644 debian/manpages/pcl_openni_uniform_sampling.1
 create mode 100644 debian/manpages/pcl_openni_viewer.1
 create mode 100644 debian/manpages/pcl_outlier_removal.1
 create mode 100644 debian/manpages/pcl_passthrough_filter.1
 create mode 100644 debian/manpages/pcl_pcd2ply.1
 create mode 100644 debian/manpages/pcl_pcd2png.1
 create mode 100644 debian/manpages/pcl_pcd2vtk.1
 create mode 100644 debian/manpages/pcl_pcd_change_viewpoint.1
 create mode 100644 debian/manpages/pcl_pcd_convert_NaN_nan.1
 create mode 100644 debian/manpages/pcl_pcd_grabber_viewer.1
 create mode 100644 debian/manpages/pcl_pcd_select_object_plane.1
 create mode 100644 debian/manpages/pcl_pclzf2pcd.1
 create mode 100644 debian/manpages/pcl_plane_projection.1
 create mode 100644 debian/manpages/pcl_ply2obj.1
 create mode 100644 debian/manpages/pcl_ply2pcd.1
 create mode 100644 debian/manpages/pcl_ply2ply.1
 create mode 100644 debian/manpages/pcl_ply2raw.1
 create mode 100644 debian/manpages/pcl_ply2vtk.1
 create mode 100644 debian/manpages/pcl_plyheader.1
 create mode 100644 debian/manpages/pcl_png2pcd.1
 create mode 100644 debian/manpages/pcl_poisson_reconstruction.1
 create mode 100644 debian/manpages/pcl_ppf_object_recognition.1
 create mode 100644 debian/manpages/pcl_sac_segmentation_plane.1
 create mode 100644 debian/manpages/pcl_spin_estimation.1
 create mode 100644 debian/manpages/pcl_test_search_speed.1
 create mode 100644 debian/manpages/pcl_tiff2pcd.1
 create mode 100644 debian/manpages/pcl_train_linemod_template.1
 create mode 100644 debian/manpages/pcl_transform_from_viewpoint.1
 create mode 100644 debian/manpages/pcl_transform_point_cloud.1
 create mode 100644 debian/manpages/pcl_uniform_sampling.1
 create mode 100644 debian/manpages/pcl_vfh_estimation.1
 create mode 100644 debian/manpages/pcl_voxel_grid.1
 create mode 100644 debian/manpages/pcl_vtk2obj.1
 create mode 100644 debian/manpages/pcl_vtk2pcd.1
 create mode 100644 debian/manpages/pcl_vtk2ply.1
 create mode 100644 debian/manpages/pcl_xyz2pcd.1
 create mode 100644 debian/options
 create mode 100644 debian/patches/0001-Fix-PCL_ROOT-path.patch
 create mode 100644 debian/patches/0002-Link-against-atomic-if-needed-found-on-armel.patch
 create mode 100644 debian/patches/0003-Use-newly-build-libs-when-testing.patch
 create mode 100644 debian/patches/0004-Disable-failing-tests.patch
 create mode 100644 debian/patches/0005-Adopt-unit-test-for-i386.patch
 create mode 100644 debian/patches/0007-Adopt-unit-tests-for-arm64-and-ppc64el.patch
 create mode 100644 debian/patches/0007-Drop-PCL_SOURCES_TREE-from-installation-cmake.patch
 create mode 100644 debian/patches/0008-Don-t-require-boost-in-pkg-config.patch
 create mode 100644 debian/patches/0009-Repair-sparse_matrix.hpp.patch
 create mode 100644 debian/patches/0010-Fix-variable-name-in-poisson4.patch
 create mode 100644 debian/patches/series
 create mode 100644 debian/pcl-oneapi-test.install
 create mode 100644 debian/pcl-oneapi-tutorials.install
 create mode 100644 debian/pcl-tools.install
 create mode 100644 debian/pcl-tools.manpages
 create mode 100755 debian/rules
 create mode 100644 debian/shlibs.local
 create mode 100644 debian/source/format
 create mode 100644 debian/source/options
 create mode 100644 debian/watch
 create mode 100644 doc/tutorials/content/images/oneapi/convex_hull_3d_img.png
 create mode 100755 doc/tutorials/content/images/oneapi/oneapi_logo.png
 create mode 100644 doc/tutorials/content/images/oneapi/pcl_oneapi_segmentation.png
 create mode 100644 doc/tutorials/content/oneapi_greedy_projection.rst
 create mode 100644 doc/tutorials/content/oneapi_install.rst
 create mode 100644 doc/tutorials/content/oneapi_kdtree.rst
 create mode 100644 doc/tutorials/content/oneapi_mls.rst
 create mode 100644 doc/tutorials/content/oneapi_normal_estimation.rst
 create mode 100644 doc/tutorials/content/oneapi_octree.rst
 create mode 100644 doc/tutorials/content/oneapi_passthrough.rst
 create mode 100644 doc/tutorials/content/oneapi_registration.rst
 create mode 100644 doc/tutorials/content/oneapi_sample_consensus.rst
 create mode 100644 doc/tutorials/content/oneapi_sample_consensus_initial_alignment.rst
 create mode 100644 doc/tutorials/content/oneapi_segmentation.rst
 create mode 100644 doc/tutorials/content/oneapi_statistical_outlier.rst
 create mode 100644 doc/tutorials/content/oneapi_voxel_grid.rst
 create mode 100644 doc/tutorials/content/sources/oneapi/data/scia_source.pcd
 create mode 100644 doc/tutorials/content/sources/oneapi/data/scia_source_fpfh33.pcd
 create mode 100644 doc/tutorials/content/sources/oneapi/data/scia_target.pcd
 create mode 100644 doc/tutorials/content/sources/oneapi/data/scia_target_fpfh33.pcd
 create mode 100644 doc/tutorials/content/sources/oneapi/greedy_projection/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/greedy_projection/greedy_projection.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/kdtree/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/kdtree/oneapi_kdtree.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/mls/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/mls/oneapi_mls.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/normal_estimation/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/octree/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/octree/oneapi_octree_search.cpp
 create mode 100755 doc/tutorials/content/sources/oneapi/passthrough/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/passthrough/oneapi_passthrough.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/registration/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/registration/oneapi_icp_example.cpp
 create mode 100755 doc/tutorials/content/sources/oneapi/sample_consensus/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
 create mode 100755 doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/segmentation/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/segmentation/oneapi_segmentation.cpp
 create mode 100644 doc/tutorials/content/sources/oneapi/statistical_outlier_removal/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
 create mode 100755 doc/tutorials/content/sources/oneapi/voxel_grid/CMakeLists.txt
 create mode 100644 doc/tutorials/content/sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
 create mode 100644 oneapi/CMakeLists.txt
 create mode 100644 oneapi/PCL-ONEAPIConfig.cmake.in
 create mode 100644 oneapi/PCL-ONEAPIConfigVersion.cmake.in
 create mode 100644 oneapi/README.md
 create mode 100644 oneapi/build_linux.md
 create mode 100644 oneapi/build_pcl_test_func.bat
 create mode 100644 oneapi/build_pcl_test_perf.bat
 create mode 100644 oneapi/build_windows.md
 create mode 100644 oneapi/cmake/cpack_options.cmake.in
 create mode 100644 oneapi/cmake/dep_graph.cmake
 create mode 100644 oneapi/cmake/pcl_all_in_one_installer.cmake
 create mode 100644 oneapi/cmake/pcl_cpack.cmake
 create mode 100644 oneapi/cmake/pcl_options.cmake
 create mode 100644 oneapi/cmake/pcl_pclconfig.cmake
 create mode 100644 oneapi/cmake/pcl_targets.cmake
 create mode 100644 oneapi/cmake/pcl_utils.cmake
 create mode 100644 oneapi/cmake/pcl_verbosity.cmake
 create mode 100644 oneapi/cmake/pkgconfig-headeronly.cmake.in
 create mode 100644 oneapi/cmake/pkgconfig.cmake.in
 create mode 100644 oneapi/cmake/uninstall_target.cmake.in
 create mode 100644 oneapi/cmake/version.rc.in
 create mode 100644 oneapi/common/CMakeLists.txt
 create mode 100644 oneapi/common/include/pcl/oneapi/PCLPointCloud2.h
 create mode 100644 oneapi/common/include/pcl/oneapi/PointIndices.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/centroid.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/common.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/copy_point.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/device/centroid.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/device/eigen.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/device/matrix_types.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/device/vector_types.h
 create mode 100644 oneapi/common/include/pcl/oneapi/common/impl/common.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/common/impl/copy_point.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/common/impl/io.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/common/io.h
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/device_array.h
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/device_memory.h
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/gpu_memory_manager.h
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/impl/device_array.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/impl/device_memory.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/initialization.h
 create mode 100644 oneapi/common/include/pcl/oneapi/containers/kernel_containers.h
 create mode 100644 oneapi/common/include/pcl/oneapi/impl/pcl_base.hpp
 create mode 100644 oneapi/common/include/pcl/oneapi/pcl_base.h
 create mode 100644 oneapi/common/include/pcl/oneapi/point_cloud.h
 create mode 100644 oneapi/common/include/pcl/oneapi/point_type_rgb.h
 create mode 100644 oneapi/common/include/pcl/oneapi/point_types.h
 create mode 100644 oneapi/common/include/pcl/oneapi/types.h
 create mode 100644 oneapi/common/src/PCLPointCloud2.cpp
 create mode 100644 oneapi/common/src/common.cpp
 create mode 100644 oneapi/common/src/device_memory.cpp.dp.cpp
 create mode 100644 oneapi/common/src/error.cpp
 create mode 100644 oneapi/common/src/gpu_memory_manager.dp.cpp
 create mode 100644 oneapi/common/src/io.cpp
 create mode 100644 oneapi/common/src/pcl_base.cpp
 create mode 100644 oneapi/common/src/point_types.cpp
 create mode 100755 oneapi/features/CMakeLists.txt
 create mode 100644 oneapi/features/include/pcl/oneapi/features/feature.h
 create mode 100644 oneapi/features/include/pcl/oneapi/features/impl/feature.hpp
 create mode 100644 oneapi/features/include/pcl/oneapi/features/impl/normal_3d.hpp
 create mode 100644 oneapi/features/include/pcl/oneapi/features/normal_3d.h
 create mode 100644 oneapi/features/src/normal_3d.cpp
 create mode 100644 oneapi/filters/CMakeLists.txt
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/extract_indices.h
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/filter.h
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/filter_indices.h
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/extract_indices.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/filter.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/filter_indices.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/passthrough.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/statistical_outlier_removal.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/impl/voxel_grid.hpp
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/passthrough.h
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/statistical_outlier_removal.h
 create mode 100644 oneapi/filters/include/pcl/oneapi/filters/voxel_grid.h
 create mode 100644 oneapi/filters/src/extract_indices.cpp
 create mode 100644 oneapi/filters/src/filter.cpp
 create mode 100644 oneapi/filters/src/filter_indices.cpp
 create mode 100644 oneapi/filters/src/passthrough.cpp
 create mode 100644 oneapi/filters/src/statistical_outlier_removal.cpp
 create mode 100644 oneapi/filters/src/voxel_grid.cpp
 create mode 100644 oneapi/flann_dp_modification.png
 create mode 100755 oneapi/kdtree/CMakeLists.txt
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/fixed_radius_index.h
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_index.hpp
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_search.hpp
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/impl/kdtree_flann.hpp
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/kdtree_flann.h
 create mode 100644 oneapi/kdtree/include/pcl/oneapi/kdtree/memory_allocation.h
 create mode 100644 oneapi/kdtree/src/kdtree_flann.cpp
 create mode 100755 oneapi/octree/CMakeLists.txt
 create mode 100755 oneapi/octree/include/pcl/oneapi/octree/device_format.hpp
 create mode 100755 oneapi/octree/include/pcl/oneapi/octree/octree.hpp
 create mode 100755 oneapi/octree/octree.doxy
 create mode 100644 oneapi/octree/src/dpcpp/approx_nsearch.cpp
 create mode 100644 oneapi/octree/src/dpcpp/knn_search.cpp
 create mode 100755 oneapi/octree/src/dpcpp/octree_builder.cpp
 create mode 100755 oneapi/octree/src/dpcpp/octree_host.cpp
 create mode 100755 oneapi/octree/src/dpcpp/octree_iterator.hpp
 create mode 100755 oneapi/octree/src/dpcpp/radius_search.cpp
 create mode 100755 oneapi/octree/src/internal.hpp
 create mode 100755 oneapi/octree/src/octree.cpp
 create mode 100755 oneapi/octree/src/utils/approx_nearest_utils.hpp
 create mode 100755 oneapi/octree/src/utils/boxutils.hpp
 create mode 100755 oneapi/octree/src/utils/copygen.hpp
 create mode 100755 oneapi/octree/src/utils/morton.hpp
 create mode 100755 oneapi/octree/src/utils/scan_block.hpp
 create mode 100644 oneapi/pcl_config.h.in
 create mode 100755 oneapi/registration/CMakeLists.txt
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/correspondence_estimation.h
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/ia_ransac.h
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/icp.h
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/impl/correspondence_estimation.hpp
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/impl/ia_ransac.hpp
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/impl/icp.hpp
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/impl/registration.hpp
 create mode 100644 oneapi/registration/include/pcl/oneapi/registration/registration.h
 create mode 100644 oneapi/registration/src/correspondence_estimation.cpp
 create mode 100644 oneapi/registration/src/ia_ransac.cpp
 create mode 100644 oneapi/registration/src/icp.cpp
 create mode 100644 oneapi/registration/src/registration.cpp
 create mode 100644 oneapi/sample_consensus/CMakeLists.txt
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/ransac.hpp
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/sac_model_plane.hpp
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/method_types.h
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/model_types.h
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/ransac.h
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac.h
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model.h
 create mode 100644 oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model_plane.h
 create mode 100644 oneapi/sample_consensus/src/sac.cpp
 create mode 100644 oneapi/sample_consensus/src/sac_model_plane.cpp
 create mode 100755 oneapi/search/CMakeLists.txt
 create mode 100644 oneapi/search/include/pcl/oneapi/search/impl/kdtree.hpp
 create mode 100644 oneapi/search/include/pcl/oneapi/search/kdtree.h
 create mode 100644 oneapi/search/include/pcl/oneapi/search/search.h
 create mode 100644 oneapi/search/src/kdtree.cpp
 create mode 100644 oneapi/segmentation/CMakeLists.txt
 create mode 100644 oneapi/segmentation/include/pcl/oneapi/segmentation/impl/sac_segmentation.hpp
 create mode 100644 oneapi/segmentation/include/pcl/oneapi/segmentation/sac_segmentation.h
 create mode 100644 oneapi/segmentation/src/sac_segmentation.cpp
 create mode 100644 oneapi/surface/CMakeLists.txt
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/convex_hull.h
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/device/mls.hpp
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/impl/mls.hpp
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/impl/processing.hpp
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/mls.h
 create mode 100644 oneapi/surface/include/pcl/oneapi/surface/processing.h
 create mode 100644 oneapi/surface/src/convex_hull.cpp
 create mode 100644 oneapi/surface/src/dpcpp/convex_hull.dp.cpp
 create mode 100644 oneapi/surface/src/dpcpp/device.h
 create mode 100644 oneapi/surface/src/internal.h
 create mode 100644 oneapi/surface/src/mls.cpp
 create mode 100644 oneapi/surface_omp/CMakeLists.txt
 create mode 100644 oneapi/surface_omp/include/pcl/oneapi/surface_omp/gp3.h
 create mode 100644 oneapi/surface_omp/include/pcl/oneapi/surface_omp/impl/gp3.hpp
 create mode 100644 oneapi/surface_omp/src/gp3.cpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/common.h
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/algorithm.hpp
 create mode 100755 oneapi/utils/include/pcl/oneapi/utils/device/funcattrib.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_downsweep.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_upsweep.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_segmented_radix_sort.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_exchange.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_load.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_rank.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_sort.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_raking_layout.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan_raking.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/block_store.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/device_double_buffer.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/radix_rank_sort_operations.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_reduce.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_scan.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/sort/util_type.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/static_check.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/vector_math.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/device/warp.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/double_buffer.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/safe_call.hpp
 create mode 100644 oneapi/utils/include/pcl/oneapi/utils/segmented_sort.h
 create mode 100755 oneapi/utils/src/internal.hpp
 create mode 100755 oneapi/utils/src/repacks.cpp

diff --git a/CHANGES.md b/CHANGES.md
index 375412caf..cc30b2480 100644
--- a/CHANGES.md
+++ b/CHANGES.md
@@ -1,5 +1,18 @@
 # ChangeList
 
+## = rp-0.2 (Nov. 2021) =
+* enabled OpenMP offload for surface/MLS
+* enabled OpenMP offload for registration/SAC-IA
+* enabled OpenMP offload for registration/ICP
+* enabled OpenMP offload for registration/PPF
+* upgraded to oneAPI 2021.4 (SYCL 2.0 compliant)
+* fixed INFINITY issue by adding "-fhonor-nans" for dpcpp compilation
+
+## = rp-0.1 (Jun. 2021) =
+* initial enabling oneAPI acceleration for PCL (derived from 1.11.1)
+* enabled the usage of FLANN-DPCPP for knn search at 3-dimentional space
+* enabled threading for moving least squares
+
 ## = 1.12.1 (2021.12.21) =
 
 This minor release brings in a lot of enhancements in CMake thanks to @larshg and @SunBlack.
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1e61bfdb5..0c309f3f5 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -83,19 +83,19 @@ endif()
 
 # check for SSE flags
 include("${PCL_SOURCE_DIR}/cmake/pcl_find_sse.cmake")
-if(PCL_ENABLE_SSE AND "${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+if((PCL_ENABLE_SSE) AND (("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK)))
   PCL_CHECK_FOR_SSE()
 endif()
 
 # check for AVX flags
-if(PCL_ENABLE_AVX AND "${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+if((PCL_ENABLE_AVX) AND (("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK)))
   include("${PCL_SOURCE_DIR}/cmake/pcl_find_avx.cmake")
   PCL_CHECK_FOR_AVX()
 endif()
 
 # ---[ Unix/Darwin/Windows specific flags
 if(CMAKE_COMPILER_IS_GNUCXX)
-  if("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+  if(("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK))
     if (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 7)
       string(APPEND CMAKE_CXX_FLAGS " -Wabi=11")
     else()
@@ -128,7 +128,7 @@ endif()
 if(CMAKE_COMPILER_IS_MSVC)
   add_definitions("-DBOOST_ALL_NO_LIB -D_SCL_SECURE_NO_WARNINGS -D_CRT_SECURE_NO_WARNINGS -DNOMINMAX -DPCL_ONLY_CORE_POINT_TYPES ${SSE_DEFINITIONS}")
   
-  if("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+  if(("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK))
     string(APPEND CMAKE_CXX_FLAGS " /fp:precise /wd4800 /wd4521 /wd4251 /wd4275 /wd4305 /wd4355 ${SSE_FLAGS} ${AVX_FLAGS} /bigobj")
 
     # Add extra code generation/link optimizations
@@ -178,7 +178,7 @@ if(CMAKE_COMPILER_IS_MSVC)
 endif()
 
 if(CMAKE_COMPILER_IS_PATHSCALE)
-  if("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+  if(("${CMAKE_CXX_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK))
     set(CMAKE_CXX_FLAGS "-Wno-uninitialized -zerouv -mp")
   endif()
   if("${CMAKE_SHARED_LINKER_FLAGS}" STREQUAL "")
@@ -187,7 +187,7 @@ if(CMAKE_COMPILER_IS_PATHSCALE)
 endif()
 
 if(CMAKE_COMPILER_IS_CLANG)
-  if("${CMAKE_C_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}")
+  if(("${CMAKE_C_FLAGS}" STREQUAL "${CMAKE_CXX_FLAGS_DEFAULT}") OR (CMAKE_BYPASS_CXX_FLAGS_CHECK))
     set(CMAKE_C_FLAGS "-Qunused-arguments")
   endif()
   if("${CMAKE_CXX_FLAGS}" STREQUAL "")
@@ -197,6 +197,8 @@ if(CMAKE_COMPILER_IS_CLANG)
     endif()
   endif()
   set(CLANG_LIBRARIES "stdc++")
+  # Clang has different default policy on NAN optimization. Please add option -fhonor-nans.
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fhonor-nans")
 endif()
 
 if(CMAKE_COMPILER_IS_MINGW)
@@ -301,6 +303,9 @@ endif()
 find_package(Threads REQUIRED)
 
 # Eigen (required)
+if(WIN32)
+include("${PCL_SOURCE_DIR}/cmake/pcl_win_dir.cmake")
+endif()
 find_package(Eigen 3.1 REQUIRED)
 include_directories(SYSTEM ${EIGEN_INCLUDE_DIRS})
 
diff --git a/PCLConfig.cmake.in b/PCLConfig.cmake.in
index 27ef98072..aa1d8f4d1 100644
--- a/PCLConfig.cmake.in
+++ b/PCLConfig.cmake.in
@@ -26,6 +26,14 @@ endif()
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/Modules")
 
+if(WIN32)
+set(FLANN_ROOT "@FLANN_ROOT@")
+set(EIGEN_ROOT "@EIGEN_ROOT@")
+set(Qhull_ROOT "@Qhull_ROOT@")
+set(VTK_ROOT "@VTK_ROOT@")
+set(BOOST_ROOT "@BOOST_ROOT@")
+endif()
+
 ### ---[ some useful macros
 macro(pcl_report_not_found _reason)
   unset(PCL_FOUND)
@@ -497,12 +505,14 @@ foreach(component ${PCL_TO_FIND_COMPONENTS})
 
   string(REGEX REPLACE "^cuda_(.*)$" "\\1" cuda_component "${component}")
   string(REGEX REPLACE "^gpu_(.*)$" "\\1" gpu_component "${component}")
+  string(REGEX REPLACE "^oneapi_(.*)$" "\\1" oneapi_component "${component}")
 
   find_path(PCL_${COMPONENT}_INCLUDE_DIR
     NAMES pcl/${component}
           pcl/apps/${component}
           pcl/cuda/${cuda_component} pcl/cuda/${component}
-          pcl/gpu/${gpu_component} pcl/gpu/${component}
+          pcl/gpu/${gpu_component} pcl/gpu/${component} 
+          pcl/oneapi/${oneapi_component} pcl/oneapi/${component}
     HINTS ${PCL_INCLUDE_DIRS}
           "${PCL_SOURCES_TREE}"
     PATH_SUFFIXES
@@ -510,6 +520,7 @@ foreach(component ${PCL_TO_FIND_COMPONENTS})
           apps/${component}/include
           cuda/${cuda_component}/include
           gpu/${gpu_component}/include
+          oneapi/${oneapi_component}/include
     DOC "path to ${component} headers"
     NO_DEFAULT_PATH)
   mark_as_advanced(PCL_${COMPONENT}_INCLUDE_DIR)
diff --git a/README.md b/README.md
index a895f50af..f938d10cf 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,7 @@
-# Point Cloud Library
+Point Cloud Library
+===================
 
-<p align="center"><img src="pcl.png" height="100"></p>
+<p align="center"><img src="pcl.png" alt="Alternative text" height="100"></p>
 
 [![Release][release-image]][releases]
 [![License][license-image]][license]
@@ -14,7 +15,7 @@
 Website
 -------
 
-The new website is now online at https://pointclouds.org and is open to [contributions](https://github.com/PointCloudLibrary/PointCloudLibrary.github.io) :hammer_and_wrench:.
+The new website is now online at <https://pointclouds.org> and is open to [contributions](https://github.com/PointCloudLibrary/PointCloudLibrary.github.io) :hammer_and_wrench:.
 
 If you really need access to the old website, please use [the copy made by the internet archive](https://web.archive.org/web/20191017164724/http://www.pointclouds.org/). Please be aware that the website was hacked before and could still be hosting some malicious code.
 
@@ -32,11 +33,11 @@ Continuous integration
 [ci-latest-docs]: https://dev.azure.com/PointCloudLibrary/pcl/_build/latest?definitionId=14&branchName=master
 
 Build Platform           | Status
------------------------- | ------------------------------------------------------------------------------------------------- |
-Ubuntu                   | [![Status][ci-ubuntu-18.04]][ci-latest-build] <br> [![Status][ci-ubuntu-20.04]][ci-latest-build]                              <br> [![Status][ci-ubuntu-20.10]][ci-latest-build]                                                |
-Windows                  | [![Status][ci-windows-x86]][ci-latest-build]  <br> [![Status][ci-windows-x64]][ci-latest-build]   |
-macOS                    | [![Status][ci-macos-10.15]][ci-latest-build]  <br> [![Status][ci-macos-11]][ci-latest-build]   |
-Documentation            | [![Status][ci-docs]][ci-latest-docs] |
+------------------------ | -------------------------------------------------------------------------------------------------
+Ubuntu                   | [![Status][ci-ubuntu-18.04]][ci-latest-build] <br> [![Status][ci-ubuntu-20.04]][ci-latest-build]                              <br> [![Status][ci-ubuntu-20.10]][ci-latest-build]
+Windows                  | [![Status][ci-windows-x86]][ci-latest-build]  <br> [![Status][ci-windows-x64]][ci-latest-build]
+macOS                    | [![Status][ci-macos-10.15]][ci-latest-build]  <br> [![Status][ci-macos-11]][ci-latest-build]
+Documentation            | [![Status][ci-docs]][ci-latest-docs]
 
 Community
 ---------
@@ -77,9 +78,9 @@ PCL is released under the terms of the BSD license, and thus free for commercial
 Compiling
 ---------
 Please refer to the platform specific tutorials:
- - [Linux](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_posix.html)
- - [Mac OS X](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_macosx.html)
- - [Microsoft Windows](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_windows.html)
+- [Linux](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_posix.html)
+- [Mac OS X](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_macosx.html)
+- [Microsoft Windows](https://pcl-tutorials.readthedocs.io/en/latest/compiling_pcl_windows.html)
 
 Documentation
 -------------
@@ -104,7 +105,7 @@ other members of the PCL community and casual discussions
 Citation
 --------
 We encourage other researchers to cite PCL if they use PCL or its components for their work or baselines. The bibtex entry for the same is
-```
+```bash
 @InProceedings{Rusu_ICRA2011_PCL,
   author    = {Radu Bogdan Rusu and Steve Cousins},
   title     = {{3D is here: Point Cloud Library (PCL)}},
diff --git a/cmake/pcl_options.cmake b/cmake/pcl_options.cmake
index e4ca97785..4248659d6 100644
--- a/cmake/pcl_options.cmake
+++ b/cmake/pcl_options.cmake
@@ -111,3 +111,6 @@ option(PCL_DISABLE_GPU_TESTS "Disable running GPU tests. If disabled, tests will
 # Set whether visualizations tests should be run
 # (Used to prevent visualizations tests from executing in CI where visualization is unavailable)
 option(PCL_DISABLE_VISUALIZATION_TESTS "Disable running visualizations tests. If disabled, tests will still be built." OFF)
+
+# Set if need to use CMAKE_CXX_FLAGS and also other pcl_options
+option(CMAKE_BYPASS_CXX_FLAGS_CHECK  "Disable comparison of CMAKE_CXX_FALGS." OFF)
diff --git a/cmake/pcl_win_dir.cmake b/cmake/pcl_win_dir.cmake
new file mode 100644
index 000000000..a4b44fe29
--- /dev/null
+++ b/cmake/pcl_win_dir.cmake
@@ -0,0 +1,25 @@
+
+if(WIN32)
+
+set(FLANN_ROOT "C:/Program Files (x86)/flann")
+set(EIGEN_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/Eigen")
+set(Qhull_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/Qhull")
+set(VTK_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/VTK")
+set(OPENNI2_BIN "C:/Program Files/OpenNI2/Redist")
+set(BOOST_ROOT "C:/local/boost_1_81_0")
+set(BOOST_LIBRARYDIR "C:/local/boost_1_81_0/stage/lib")
+set(Boost_LIB_PREFIX "lib")
+set(FLANN_INCLUDE "C:/Program Files (x86)/flann/include")
+set(PCL_ROOT "C:/Program Files (x86)/PCL")
+set(PCL_BIN "C:/Program Files (x86)/PCL/bin")
+set(PCL_ONEAPI_ROOT "C:/Program Files (x86)/PCL-ONEAPI")
+set(GTEST_ROOT "C:/Program Files (x86)/googletest-distribution")
+set(GTEST_SRC_DIR "C:/Users/intel/Downloads/googletest/googletest")
+set(SYCL_PATH "C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/ocloc;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/bin/intel64;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/redist/intel64_win/compiler;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/host/windows64/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/llvm/aocl-bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/windows64/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/../../../tbb/latest/redist/intel64/vc_mt;")
+set(INTEL_CPP_COMPILER "Intel C++ Compiler 2024")
+set(INTEL_DPCPP_COMPILER "Intel(R) oneAPI DPC++ Compiler 2024")
+set(yaml-cpp_DIR "C:/Program Files (x86)/YAML_CPP/lib/cmake/yaml-cpp")
+set(YAML_CPP_INCLUDE_DIRS "C:/Program Files (x86)/YAML_CPP/include")
+set(YAML_CPP_LIBRARIES "C:/Program Files (x86)/YAML_CPP/lib")
+set(YAML_CPP_BIN "C:/Program Files (x86)/YAML_CPP/bin")
+endif()
diff --git a/common/include/pcl/for_each_type.h b/common/include/pcl/for_each_type.h
index 9e0a6af0f..fc5ca3502 100644
--- a/common/include/pcl/for_each_type.h
+++ b/common/include/pcl/for_each_type.h
@@ -74,7 +74,7 @@ namespace pcl
     {
       using arg = typename boost::mpl::deref<Iterator>::type;
 
-#if (defined _WIN32 && defined _MSC_VER)
+#if (defined _WIN32 && defined _MSC_VER && !defined(__clang__))
       boost::mpl::aux::unwrap (f, 0).operator()<arg> ();
 #else
       boost::mpl::aux::unwrap (f, 0).template operator()<arg> ();
diff --git a/common/include/pcl/impl/instantiate.hpp b/common/include/pcl/impl/instantiate.hpp
index ea73a0c3d..dec50a0bc 100644
--- a/common/include/pcl/impl/instantiate.hpp
+++ b/common/include/pcl/impl/instantiate.hpp
@@ -95,7 +95,7 @@
 //
 //    ((x)(y)(z))((1)(2)(3))((dracula)(radu))
 //
-#ifdef _MSC_VER
+#if (defined _WIN32 && defined _MSC_VER && !defined(__clang__))
 #define PCL_INSTANTIATE_PRODUCT_IMPL(r, product) \
   BOOST_PP_CAT(PCL_INSTANTIATE_, BOOST_PP_SEQ_HEAD(product)) \
           BOOST_PP_EXPAND(BOOST_PP_SEQ_TO_TUPLE(BOOST_PP_SEQ_TAIL(product))) 
diff --git a/debian/README.source b/debian/README.source
new file mode 100644
index 000000000..28b522e65
--- /dev/null
+++ b/debian/README.source
@@ -0,0 +1,10 @@
+BinNMU after new upload
+-----------------------
+
+PCL is often used as a header only library, so dependent packages don't get a
+binary dependency on it. Please request a BinNMU for all dependent package [1]
+with every new upload, so they get updated as well.
+
+[1] grep-dctrl -FBuild-Depends libpcl-dev -sPackage /var/lib/apt/lists/*Sources
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Mon, 22 Aug 2016 07:54:51 +0200
diff --git a/debian/changelog b/debian/changelog
new file mode 100644
index 000000000..b385ad573
--- /dev/null
+++ b/debian/changelog
@@ -0,0 +1,510 @@
+pcl (1.12.1+dfsg-6eci5-oneapi2024.0.0) UNRELEASED; urgency=low
+
+  * Update metapackage
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Wed, 8 Jan 2024 10:42:43 +0000
+
+pcl (1.12.1+dfsg-6eci4-oneapi2023.2.0) UNRELEASED; urgency=low
+
+  * Update metapackage
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Wed, 20 Sep 2023 10:42:43 +0000
+
+pcl (1.12.1+dfsg-6eci3-oneapi2023.2.0) UNRELEASED; urgency=low
+
+  * Add metapackage
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Wed, 20 Sep 2023 10:42:43 +0000
+
+pcl (1.12.1+dfsg-6unstable3-oneapi2023.2.0) UNRELEASED; urgency=low
+
+  * PCL datafile updates
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Sun, 25 Sep 2022 10:42:43 +0000
+
+pcl (1.12.1+dfsg-6eci2-oneapi2023.2.0) UNRELEASED; urgency=low
+
+  * generated by Isar
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Sun, 25 Sep 2022 10:42:43 +0000
+
+pcl (1.12.1+dfsg-6eci1-oneapi2022.2.1) UNRELEASED; urgency=low
+
+  * initial Point Cloud Library Using Intel(R) oneAPI Toolkits
+
+ -- ECI Maintainer <eci.maintainer@intel.com>  Sun, 25 Sep 2022 10:42:01 +0000
+
+pcl (1.12.1+dfsg-6) unstable; urgency=medium
+
+  * Disable dh_dwz for clang builds
+  * Revert "Temporary add depends for #1013316"
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 25 Sep 2022 12:41:19 +0200
+
+pcl (1.12.1+dfsg-5) unstable; urgency=medium
+
+  * Add upstream patch to fix build on armhf
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 19 Aug 2022 13:41:49 +0200
+
+pcl (1.12.1+dfsg-4) unstable; urgency=medium
+
+  * Add upstream source
+  * Temporary add depends for #1013316
+  * Bump policy version (no changes)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Wed, 13 Jul 2022 15:20:25 +0200
+
+pcl (1.12.1+dfsg-3) unstable; urgency=medium
+
+  * Add missing dependency (Closes: #1002786)
+  * Add patch for wrong boost pkg-config dependency (Closes: #1002753)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Wed, 29 Dec 2021 10:52:53 +0100
+
+pcl (1.12.1+dfsg-2) unstable; urgency=medium
+
+  * Fix more unit tests on i386
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 25 Dec 2021 15:01:23 +0100
+
+pcl (1.12.1+dfsg-1) unstable; urgency=medium
+
+  * New upstream version 1.12.1+dfsg
+  * Rebase patches
+  * Update copyright
+  * Drop empty documentation
+  * Add patch to drop build path in cmake file
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 24 Dec 2021 23:58:00 +0100
+
+pcl (1.12.0+dfsg-6) unstable; urgency=medium
+
+  * Fix ppc64 in d/rules
+  * Fix double space
+  * Add patch for failing tests
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Mon, 13 Dec 2021 22:14:52 +0100
+
+pcl (1.12.0+dfsg-5) unstable; urgency=medium
+
+  * upload to unstable
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Mon, 11 Oct 2021 21:43:17 +0200
+
+pcl (1.12.0+dfsg-4) experimental; urgency=medium
+
+  * Only run tests if they are enabled
+  * Fix tests on armel
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 10 Oct 2021 11:23:52 +0200
+
+pcl (1.12.0+dfsg-3) experimental; urgency=medium
+
+  * Fix preprocessor syntax
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 09 Oct 2021 17:38:10 +0200
+
+pcl (1.12.0+dfsg-2) experimental; urgency=medium
+
+  * Fix build and disable failing tests
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 09 Oct 2021 16:59:23 +0200
+
+pcl (1.12.0+dfsg-1) experimental; urgency=medium
+
+  * New upstream version 1.12.0+dfsg
+    - Switch to Qhull reentrant (Closes: #990399)
+    - Fix PCLConfig.cmake (LP: #1928819)
+  * Switch to VTK9
+  * Update copyright
+  * Rebase patches
+  * Use /tags in d/watch
+  * Bump policy version (no changes)
+  * Remove unused manpages
+  * Rename binary package due to Soversion bump
+  * Install examples
+  * Simplify rules, run tests
+  * Add patch to set LD_LIBRARY_PATH for tests
+  * Add patch to disable failing tests
+  * Add d/clean
+  * Cleanup
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 02 Oct 2021 12:29:30 +0200
+
+pcl (1.11.1+dfsg-1) unstable; urgency=medium
+
+  * New upstream version 1.11.1+dfsg
+  * Drop dev link (transition is done)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Tue, 18 Aug 2020 20:22:29 +0200
+
+pcl (1.11.0+dfsg-5) unstable; urgency=medium
+
+  * Fix link creation
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Thu, 30 Jul 2020 10:50:15 +0200
+
+pcl (1.11.0+dfsg-4) unstable; urgency=medium
+
+  * Symlink old include path for libpcl-ros-dev transition
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Thu, 30 Jul 2020 08:58:57 +0200
+
+pcl (1.11.0+dfsg-3) unstable; urgency=medium
+
+  * Really remove old manpages
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 19 Jul 2020 14:49:42 +0200
+
+pcl (1.11.0+dfsg-2) unstable; urgency=medium
+
+  * Remove Thomas from Uploaders, thanks for working on this
+  * Drop old manpages
+  * Remove trailing whitespaces
+  * Upload to unstable
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 19 Jul 2020 07:11:54 +0200
+
+pcl (1.11.0+dfsg-1) experimental; urgency=medium
+
+  * New upstream version 1.11.0+dfsg
+  * Rebase patches
+  * Rename packages due to soVersion bump
+  * bump debhelper version
+  * Drop broken pcl_modeler.1 manpage (Closes: #815964)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 22 May 2020 19:49:38 +0200
+
+pcl (1.10.1+dfsg-1) unstable; urgency=medium
+
+  * Simplify flags, drop as-needed
+  * New upstream version 1.10.1+dfsg
+  * update copyright
+  * rebase patches
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 11 Apr 2020 01:10:57 +0200
+
+pcl (1.10.0+dfsg-5) unstable; urgency=medium
+
+  * Add patch to link against atomic (for armel)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 02 Feb 2020 00:35:04 +0100
+
+pcl (1.10.0+dfsg-4) unstable; urgency=medium
+
+  * Use clang where gcc fails due to virtual memory exhaustion
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 31 Jan 2020 23:12:44 +0100
+
+pcl (1.10.0+dfsg-3) unstable; urgency=medium
+
+  * Upload to unstable
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Thu, 30 Jan 2020 22:08:04 +0100
+
+pcl (1.10.0+dfsg-2) experimental; urgency=medium
+
+  * Reduce parallel jobs on armhf/el
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Wed, 29 Jan 2020 23:50:58 +0100
+
+pcl (1.10.0+dfsg-1) experimental; urgency=medium
+
+  * Update watch and copyright
+  * New upstream version 1.10.0+dfsg
+  * Update d/copyright
+  * update patch
+  * Rename packages due to soVersion bump
+  * switch to debhelper-compat and debhelper 12
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 25 Jan 2020 09:53:21 +0100
+
+pcl (1.9.1+dfsg1-10) unstable; urgency=medium
+
+  [ Andreas Beckmann ]
+  * libpcl-dev: Add Breaks against several vtk6 packages (Closes: #928198)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Mon, 29 Apr 2019 20:44:32 +0200
+
+pcl (1.9.1+dfsg1-3) unstable; urgency=medium
+
+  * Install cmake modules (Closes: #916913)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Thu, 20 Dec 2018 22:35:03 +0100
+
+pcl (1.9.1+dfsg1-2) unstable; urgency=medium
+
+  * Upload to unstable
+  * Support visualization on arml*
+    Thanks to Adrian Bunk
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Wed, 19 Dec 2018 11:27:27 +0100
+
+pcl (1.9.1+dfsg1-1) experimental; urgency=medium
+
+  * New upstream version 1.9.1+dfsg1
+  * Rebase patch
+  * Reduce parallel on mips* as they go OOM
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 08 Dec 2018 10:43:49 +0100
+
+pcl (1.9.0+dfsg1-1) experimental; urgency=medium
+
+  * New upstream version 1.9.0+dfsg1
+  * Update copyright
+  * Drop patches merged upstream
+  * Update packaging
+  * Fix packaging
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 10 Nov 2018 15:50:55 +0100
+
+pcl (1.8.1+dfsg1-8) unstable; urgency=medium
+
+  * Add comment regarding the inpoly copyright (cf. #909785)
+  * Add patch for new flann
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 14 Oct 2018 22:19:09 +0200
+
+pcl (1.8.1+dfsg1-7) unstable; urgency=medium
+
+  [ Gianfranco Costamagna ]
+  * simplify rules
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 15 Sep 2018 13:21:39 +0200
+
+pcl (1.8.1+dfsg1-6) unstable; urgency=medium
+
+  [ Jochen Sprickerhof ]
+  * use --max-parallel=2 for Ubuntu
+  * Add patch for pcl_2d-1.8.pc
+
+  [ Adrian Bunk ]
+  * Reduce the amount of debug information when building for 32bit architectures
+    (Closes: #908820)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 14 Sep 2018 21:27:30 +0200
+
+pcl (1.8.1+dfsg1-5) unstable; urgency=medium
+
+  [ Gianfranco Costamagna ]
+  * Limit parallel builds on Ubuntu
+
+  [ Jochen Sprickerhof ]
+  * Add patches for Boost 1.67
+  * Bump policy version (no changes)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Tue, 11 Sep 2018 21:56:53 +0200
+
+pcl (1.8.1+dfsg1-4) unstable; urgency=medium
+
+  * Disable automatic SSE detection (LP: #1771124)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 23 Jun 2018 18:59:00 +0200
+
+pcl (1.8.1+dfsg1-3) unstable; urgency=medium
+
+  * remove list-missing (now done by dh_missing)
+  * Fix priority
+  * Update Vcs URLs to salsa.d.o
+  * Add R
+  * http -> https
+  * Add patch for GCC8 (Closes: #897833)
+  * Bump policy and debhelper versions
+  * Fix documentation location
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 06 May 2018 12:15:00 +0200
+
+pcl (1.8.1+dfsg1-2) unstable; urgency=medium
+
+  * Add patch for PCL_ROOT
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Fri, 18 Aug 2017 11:31:07 +0200
+
+pcl (1.8.1+dfsg1-1) unstable; urgency=medium
+
+  * Update watch file
+  * Remove excluded files with fixed license
+  * New upstream version 1.8.1+dfsg1
+  * Update copyright
+  * Remove patches, applied upstream
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 13 Aug 2017 17:59:39 +0200
+
+pcl (1.8.0+dfsg1-6) unstable; urgency=medium
+
+  * Upload to unstable.
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Wed, 28 Jun 2017 05:59:17 +0200
+
+pcl (1.8.0+dfsg1-5) experimental; urgency=medium
+
+  * Disable QT on arm again
+  * Enable parallel on all architectures again (Closes: #846520)
+  * Enable PIE.
+    Thanks to Adrian Bunk (Closes: #865652)
+  * Bump policy and debhelper versions
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 24 Jun 2017 11:12:20 +0200
+
+pcl (1.8.0+dfsg1-4) experimental; urgency=medium
+
+  * Add patch for arm build failures.
+    Thanks to Gianfranco Costamagna
+  * Enable QT on arm again
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sat, 17 Sep 2016 12:37:25 +0200
+
+pcl (1.8.0+dfsg1-3) unstable; urgency=medium
+
+  * Disable QT on arm (Closes: #835292)
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Sun, 04 Sep 2016 09:30:23 +0200
+
+pcl (1.8.0+dfsg1-2) unstable; urgency=medium
+
+  * Remove superfluous libpcl1.8 package
+  * Add patch for empty 2d lib
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Mon, 22 Aug 2016 07:46:30 +0200
+
+pcl (1.8.0+dfsg1-1) experimental; urgency=medium
+
+  * Imported Upstream version 1.8.0+dfsg1
+  * Rebase patches
+  * Add patch for removed non free code
+  * Reworked debian/ files
+  * Add patch for privacy-breach-logo
+
+ -- Jochen Sprickerhof <jspricke@debian.org>  Tue, 16 Aug 2016 19:25:49 +0200
+
+pcl (1.7.2-14) unstable; urgency=medium
+
+  * Add patch for gcc6 (Closes: #812015)
+  * Move pcl-tools to section science.
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Sat, 23 Jan 2016 19:30:45 +0100
+
+pcl (1.7.2-13) unstable; urgency=medium
+
+  * Fix dependencies
+  * Add patch to fix compilation error if no QVTK is found
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Fri, 16 Oct 2015 17:07:50 +0200
+
+pcl (1.7.2-12) unstable; urgency=medium
+
+  * Fix syntax in rules file
+  * libvtk6-qt-dev is not available on arm
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Sun, 11 Oct 2015 16:56:06 +0200
+
+pcl (1.7.2-11) unstable; urgency=medium
+
+  [ Leopold Palomo-Avellaneda ]
+  * Add parallel build in some Archs (!=32 bits).
+    Closes: #799218
+
+  [ Jochen Sprickerhof ]
+  * Add patch for Eigen build error
+  * Switch to VTK6 (Closes: #798171).
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Sat, 10 Oct 2015 23:51:16 +0200
+
+pcl (1.7.2-10) unstable; urgency=medium
+
+  * Fix an other FTBFS on ppc64el
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Tue, 01 Sep 2015 09:41:28 +0200
+
+pcl (1.7.2-9) unstable; urgency=medium
+
+  * Add patches for FTBFS with gcc5 (closes #795525)
+  * Fix FTBFS on ppc64el, thanks to ChriSopht in #eigen
+  * Add mips* as supported OpenNI architectures
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Mon, 17 Aug 2015 12:05:12 +0200
+
+pcl (1.7.2-8) unstable; urgency=medium
+
+  * Appy ggc-min-expand+disable-WITH_DOCS.diff (Closes: #780582), Thanks Dejan
+    Latinovic.
+  * Update architectures on libopenni-dev dependency
+
+ -- Jochen Sprickerhof <debian@jochen.sprickerhof.de>  Tue, 09 Jun 2015 10:55:56 +0200
+
+pcl (1.7.2-7) unstable; urgency=medium
+
+  * Added patch to solve sometimes FTBFS. Patch proposed by
+    James Cowgill (thanks!!!). Closes: #779183
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Wed, 25 Feb 2015 23:12:50 +0100
+
+pcl (1.7.2-6) unstable; urgency=medium
+
+  [ Jochen Sprickerhof ]
+  * Remove --parallel from dh to fix build on i386 buildd.
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Tue, 02 Dec 2014 08:29:43 +0100
+
+pcl (1.7.2-5) unstable; urgency=medium
+
+  [Leopold Palomo-Avellaneda]
+  * Reverted Multi-arch field for libpcl-apps1.7.
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Thu, 27 Nov 2014 18:14:40 +0100
+
+pcl (1.7.2-4) unstable; urgency=medium
+
+  [Leopold Palomo-Avellaneda]
+  * Added missing Multi-arch field for libpcl-apps1.7.
+  * Removing Multi-Arch of libpcl-dev. Closes: #770503
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Mon, 24 Nov 2014 12:27:06 +0100
+
+pcl (1.7.2-3) unstable; urgency=medium
+
+  [ Jochen Sprickerhof ]
+  * Change openni-dev to libopenni, Closes: #768953
+  * Build without OpenNI when it's not available. It opens
+    the number of architectures where it could be built. Closes: #769883
+  * Fix PCLConfig.cmake (patch taken from Fedora). Closes: #770029
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Tue, 11 Nov 2014 15:34:43 +0100
+
+pcl (1.7.2-2) unstable; urgency=medium
+
+  [Leopold Palomo-Avellaneda]
+  * Change install place for cmake files. Closes: #766685
+  * Added dh-exec (>=0.3) dependecy.
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Sun, 26 Oct 2014 09:46:18 +0100
+
+pcl (1.7.2-1) unstable; urgency=medium
+
+  [Thomas Moulard]
+  * Initial debianization.
+
+  [Leopold Palomo-Avellaneda]
+  * Initial release. (Closes: #703579)
+  * Worked from the initial debianization from Thomas Moulard.
+    Jochen Sprickerhof and myself added as uploaders.
+  * Added libvtk5-qt4-dev, libopenni-sensor-primesense-dev, python-vtk,
+    libvtk5-qt4-dev, libqt4-opengl-dev, python-sphinx, libusb-1.0-0-dev build
+    dependencies.
+  * Deleted pkg-kde-tools dependency.
+  * Relaxed boost dependencies.
+  * Added some applications to be build: app_modeler, app_point_cloud_editor,
+    in_hand_scanner in rules.
+  * Renamed libpcl-tools to pcl-tools.
+  * Added manpages ...
+  * Added libjs-jquery dependency to calm lintian.
+
+  [Jochen Sprickerhof]
+  * Fix license file.
+  * Clean up debian/rules.
+  * Update Standards-Version (no changes).
+  * Fix hidden dependencies with glut and OpenGL of pcl-tools.
+  * Cosmetic changes.
+
+ -- Leopold Palomo-Avellaneda <leo@alaxarxa.net>  Mon, 06 Oct 2014 09:30:55 +0200
diff --git a/debian/clean b/debian/clean
new file mode 100644
index 000000000..5b83d523c
--- /dev/null
+++ b/debian/clean
@@ -0,0 +1 @@
+doc/doxygen/pcl.tag
diff --git a/debian/control b/debian/control
new file mode 100644
index 000000000..121bb85dc
--- /dev/null
+++ b/debian/control
@@ -0,0 +1,656 @@
+Source: pcl
+Maintainer: Debian Science Maintainers <debian-science-maintainers@lists.alioth.debian.org>
+Uploaders: Jochen Sprickerhof <jspricke@debian.org>,
+	   Leopold Palomo-Avellaneda <leo@alaxarxa.net>
+Section: libs
+Priority: optional
+Build-Depends: debhelper-compat (= 13),
+               cmake,
+	       clang [mipsel armel armhf],
+	       python3-sphinx,
+	       libboost-system-dev,
+	       libboost-filesystem-dev,
+	       libboost-thread-dev,
+	       libboost-date-time-dev,
+	       libboost-iostreams-dev,
+	       libeigen3-dev (>= 3.4.0),  libflann-dpcpp-dev (>= 1.9.1), intel-oneapi-dpcpp-cpp-2024.0, intel-oneapi-compiler-dpcpp-cpp-2024.0, intel-oneapi-mkl-2024.0, intel-oneapi-dpcpp-ct-2024.0, libyaml-cpp-dev,
+	       libvtk9-dev,
+	       libqhull-dev,
+	       libopenni-dev [!s390x !alpha !hppa !hurd-i386 !ia64 !kfreebsd-any !m68k !riscv64 !sh4 !sparc64],
+	       libopenni2-dev [!hurd-i386 !hppa !kfreebsd-any],
+	       libqt5opengl5-dev,
+	       libusb-1.0-0-dev,
+	       freeglut3-dev,
+	       libxmu-dev,
+	       libxi-dev,
+	       libpcap-dev,
+	       libvtk9-qt-dev,
+	       libglew-dev,
+	       libgtest-dev
+Build-Depends-Indep: doxygen,
+		     doxygen-latex
+Standards-Version: 4.6.1
+Vcs-Browser: https://salsa.debian.org/science-team/pcl
+Vcs-Git: https://salsa.debian.org/science-team/pcl.git
+Rules-Requires-Root: no
+Homepage: http://www.pointclouds.org/
+
+Package: libpcl-dev
+Architecture: any
+Section: libdevel
+Depends: libboost-all-dev,
+	 libeigen3-dev (>= 3.4.0),  libflann-dpcpp-dev (>= 1.9.1), 
+	 libvtk9-dev,
+	 libqhull-dev,
+	 libvtk9-qt-dev,
+	 libusb-1.0-0-dev,
+	 libopenni-dev [!s390x !alpha !hppa !hurd-i386 !ia64 !kfreebsd-any !m68k !riscv64 !sh4 !sparc64],
+	 libopenni2-dev [!hurd-i386 !hppa !kfreebsd-any],
+	 libpcl-apps1.12 (= ${binary:Version}),
+	 libpcl-common1.12 (= ${binary:Version}),
+	 libpcl-features1.12 (= ${binary:Version}),
+	 libpcl-filters1.12 (= ${binary:Version}),
+	 libpcl-io1.12 (= ${binary:Version}),
+	 libpcl-kdtree1.12 (= ${binary:Version}),
+	 libpcl-keypoints1.12 (= ${binary:Version}),
+	 libpcl-ml1.12 (= ${binary:Version}),
+	 libpcl-octree1.12 (= ${binary:Version}),
+	 libpcl-outofcore1.12 (= ${binary:Version}),
+	 libpcl-people1.12 (= ${binary:Version}),
+	 libpcl-recognition1.12 (= ${binary:Version}),
+	 libpcl-registration1.12 (= ${binary:Version}),
+	 libpcl-sample-consensus1.12 (= ${binary:Version}),
+	 libpcl-search1.12 (= ${binary:Version}),
+	 libpcl-segmentation1.12 (= ${binary:Version}),
+	 libpcl-stereo1.12 (= ${binary:Version}),
+	 libpcl-surface1.12 (= ${binary:Version}),
+	 libpcl-tracking1.12 (= ${binary:Version}),
+	 libpcl-visualization1.12 (= ${binary:Version}),
+	 libpcl-oneapi-common1.12 (= ${binary:Version}),
+	 libpcl-oneapi-features1.12 (= ${binary:Version}),
+	 libpcl-oneapi-filters1.12 (= ${binary:Version}),
+	 libpcl-oneapi-kdtree1.12 (= ${binary:Version}),
+	 libpcl-oneapi-octree1.12 (= ${binary:Version}),
+	 libpcl-oneapi-registration1.12 (= ${binary:Version}),
+	 libpcl-oneapi-sample-consensus1.12 (= ${binary:Version}),
+	 libpcl-oneapi-search1.12 (= ${binary:Version}),
+	 libpcl-oneapi-segmentation1.12 (= ${binary:Version}),
+	 libpcl-oneapi-surface1.12 (= ${binary:Version}),
+	 ${misc:Depends}
+Suggests: libpcl-doc
+Breaks: libvtk6-dev,
+        libvtk6-java,
+        libvtk6-jni,
+        libvtk6-qt-dev,
+Description: Point Cloud Library - development files
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains development files (headers and shared library
+ symbolic link).
+
+Package: libpcl-apps1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - apps library
+ The PCL framework contains numerous state-of-the art algorithms including
+ filtering, feature estimation, surface reconstruction, registration, model
+ fitting and segmentation.
+ .
+ This package contains the libraries needed to run applications depending
+ on PCL apps.
+
+Package: libpcl-common1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - common library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL common library.
+
+Package: libpcl-features1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - features library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL features library.
+
+Package: libpcl-filters1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - filters library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL filters library.
+
+Package: libpcl-io1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - I/O library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the libraries needed to run applications
+ depending on PCL io.
+
+Package: libpcl-kdtree1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - kdtree library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL kdtree library.
+
+Package: libpcl-keypoints1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - keypoints library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL keypoints library.
+
+Package: libpcl-ml1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - ml library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL ml library.
+
+Package: libpcl-octree1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - octree library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL octree library.
+
+Package: libpcl-outofcore1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+	 ${misc:Depends}
+Description: Point Cloud Library - outofcore library
+ The PCL framework contains numerous state-of-the art algorithms including
+ filtering, feature estimation, surface reconstruction, registration, model
+ fitting and segmentation.
+ .
+ This package contains the libraries needed to run applications
+ depending on PCL outofcore.
+
+Package: libpcl-people1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+	 ${misc:Depends}
+Description: Point Cloud Library - people library
+ The PCL framework contains numerous state-of-the art algorithms including
+ filtering, feature estimation, surface reconstruction, registration, model
+ fitting and segmentation.
+ .
+ This package contains the libraries needed to run applications
+ depending on PCL people.
+
+Package: libpcl-recognition1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+    	 ${misc:Depends}
+Description: Point Cloud Library - recognition library
+ The PCL framework contains numerous state-of-the art algorithms including
+ filtering, feature estimation, surface reconstruction, registration, model
+ fitting and segmentation.
+ .
+ This package contains the libraries needed to run applications
+ depending on PCL recognition.
+
+Package: libpcl-registration1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - registration library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL registration library.
+
+Package: libpcl-sample-consensus1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - sample consensus library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL sample consensus library.
+
+Package: libpcl-search1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - search library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL search library.
+
+Package: libpcl-segmentation1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - segmentation library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL segmentation library.
+
+Package: libpcl-stereo1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - stereo library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL stereo library.
+
+Package: libpcl-surface1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - surface library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL surface library.
+
+Package: libpcl-tracking1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - tracking library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL tracking library.
+
+Package: libpcl-visualization1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}
+Description: Point Cloud Library - visualization library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the PCL visualization library.
+
+Package: pcl-tools
+Architecture: any
+Section: science
+Depends: ${misc:Depends}, ${shlibs:Depends}
+Multi-Arch: foreign
+Description: Point Cloud Library - point cloud processing tools
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package gathers tools bundled with PCL to process point clouds.
+
+Package: libpcl-doc
+Architecture: all
+Section: doc
+Depends: ${misc:Depends}, libjs-jquery
+Multi-Arch: foreign
+Description: Point Cloud Library - documentation
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package contains the Doxygen generated documentation.
+
+Package: libpcl-oneapi-common1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - common library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-features1.12
+Architecture: any
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Point Cloud Library - features library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+ .
+ This package contains the PCL features library.
+
+Package: libpcl-oneapi-filters1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - filters library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-registration1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - registration library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-sample-consensus1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - sample consensus library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-kdtree1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends}, libflann1.9-dpcpp (>= 1.9.1)
+Description: Data Parallel C++ enabled Point Cloud Library - kdtree library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-octree1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - octree library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-segmentation1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - segmentation library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-surface1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024,
+Description: Data Parallel C++ enabled Point Cloud Library - surface library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi-search1.12
+Architecture: amd64
+Multi-Arch: same
+Pre-Depends: ${misc:Pre-Depends}
+Depends: ${shlibs:Depends},
+         ${misc:Depends},  libze1 | level-zero, intel-opencl-icd, libze-intel-gpu1,
+ intel-oneapi-runtime-dpcpp-cpp-2024, intel-oneapi-runtime-compilers-2024, intel-oneapi-runtime-openmp-2024
+Description: Data Parallel C++ enabled Point Cloud Library - search library
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation optimized using Intel(R) oneAPI.
+
+Package: libpcl-oneapi
+Architecture: any
+Depends:
+	 libpcl-apps1.12 (= ${binary:Version}),
+	 libpcl-common1.12 (= ${binary:Version}),
+	 libpcl-features1.12 (= ${binary:Version}),
+	 libpcl-filters1.12 (= ${binary:Version}),
+	 libpcl-io1.12 (= ${binary:Version}),
+	 libpcl-kdtree1.12 (= ${binary:Version}),
+	 libpcl-keypoints1.12 (= ${binary:Version}),
+	 libpcl-ml1.12 (= ${binary:Version}),
+	 libpcl-octree1.12 (= ${binary:Version}),
+	 libpcl-outofcore1.12 (= ${binary:Version}),
+	 libpcl-people1.12 (= ${binary:Version}),
+	 libpcl-recognition1.12 (= ${binary:Version}),
+	 libpcl-registration1.12 (= ${binary:Version}),
+	 libpcl-sample-consensus1.12 (= ${binary:Version}),
+	 libpcl-search1.12 (= ${binary:Version}),
+	 libpcl-segmentation1.12 (= ${binary:Version}),
+	 libpcl-stereo1.12 (= ${binary:Version}),
+	 libpcl-surface1.12 (= ${binary:Version}),
+	 libpcl-tracking1.12 (= ${binary:Version}),
+	 libpcl-visualization1.12 (= ${binary:Version}),
+	 libpcl-oneapi-common1.12 (= ${binary:Version}),
+	 libpcl-oneapi-features1.12 (= ${binary:Version}),
+	 libpcl-oneapi-filters1.12 (= ${binary:Version}),
+	 libpcl-oneapi-kdtree1.12 (= ${binary:Version}),
+	 libpcl-oneapi-octree1.12 (= ${binary:Version}),
+	 libpcl-oneapi-registration1.12 (= ${binary:Version}),
+	 libpcl-oneapi-sample-consensus1.12 (= ${binary:Version}),
+	 libpcl-oneapi-search1.12 (= ${binary:Version}),
+	 libpcl-oneapi-segmentation1.12 (= ${binary:Version}),
+	 libpcl-oneapi-surface1.12 (= ${binary:Version}),
+	 intel-opencl-icd, libze-intel-gpu1,
+	 libze1 | level-zero
+	 ${misc:Depends}
+Description: Point Cloud Library - Intel(R) oneapi point cloud processing meta-package
+ .
+ This meta-package gathers Standard and  Intel oneapi PCL runtime libraryto process point clouds.
+
+Package: pcl-oneapi-test
+Architecture: amd64
+Section: science
+Depends: ${misc:Depends}, ${shlibs:Depends}
+Multi-Arch: foreign
+Description: Point Cloud Library - Intel(R) oneapi point cloud processing testsuite
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package gathers googletest bundled with PCL to process point clouds.
+
+Package: pcl-oneapi-tutorials
+Architecture: any
+Depends: ${misc:Depends}, libpcl-dev (>= ${binary:Version}), intel-opencl-icd, libze-intel-gpu1, libze1 | level-zero
+Description: Point Cloud Library - Intel(R) oneapi point cloud processing tutorials
+ The Point Cloud Library (PCL) is a standalone, large scale, open
+ project for 2D/3D image and point cloud processing.
+ .
+ The PCL framework contains numerous state-of-the art algorithms
+ including filtering, feature estimation, surface reconstruction,
+ registration, model fitting and segmentation.
+ .
+ This package gathers Intel(R) oneapi tutorials bundled with PCL to process point clouds.
diff --git a/debian/copyright b/debian/copyright
new file mode 100644
index 000000000..f501909ba
--- /dev/null
+++ b/debian/copyright
@@ -0,0 +1,636 @@
+Format: https://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
+Source: https://github.com/PointCloudLibrary/pcl
+Files-Excluded: cuda/common/include/pcl/cuda/cutil*.h
+Comment: Copyright 1993-2010 NVIDIA Corporation.  All rights reserved.
+
+Files: *
+Copyright: 2001, Addison-Wesley
+           2012, Aitor Aldoma, Federico Tombari
+           2011, Alexandru-Eugen Ichim
+           2001, Andrei Alexandrescu
+           2007-2012, Ares Lagae
+           2008, Ben Gurion University of the Negev, Beer Sheva, Israel
+           1999-2007, Brian Paul
+           2014, Centrum Wiskunde Informatica
+           2000-2012, Chih-Chung Chang and Chih-Jen Lin
+           2011, Dirk Holz, University of Bonn
+           2018, Fizyr BV. - https://fizyr.com
+           2006, Frederic Heem <frederic.heem@telsey.it>
+           2010, Gael Guennebaud <gael.guennebaud@inria.fr>
+           2011, Geoffrey Biggs
+           2015, Google, Inc
+           2009, Hauke Heibel <hauke.heibel@gmail.com>
+           2000-2008, Intel Corporation
+           2013, Intelligent Robotics Lab, DLUT
+           2012, Jeremie Papon
+           2012, Jochen Sprickerhof
+           2012, KU Leuven
+           1993-2008, Ken Martin, Will Schroeder, Bill Lorensen
+           2012, Keven Ring
+           1997-2002, Makoto Matsumoto and Takuji Nishimura
+           2003-2010, Mark Borgerding
+           2013, Martin Szarski
+           2015, Michael 'v4hn' Goerner
+           2009-2010, NVIDIA Corporation
+           2012-2021, Open Perception, Inc
+           2014, RadiantBlue Technologies, Inc
+           2011 Suat Gedikli <gedikli@willowgarage.com>
+           2004, Sylvain Paris and Francois Sillion
+           2012, Texas A&M University
+           2011, The Autonomous Systems Lab (ASL), ETH Zurich,
+                 Stefan Leutenegger, Simon Lynen and Margarita Chli
+           2011-2015, The MITRE Corporation
+           2009-2012, Urban Robotics, Inc
+           2016, Voxar Labs, CIn-UFPE / DEINFO-UFRPE
+           2009-2014, Willow Garage, Inc
+           2012, Yani Ioannou <yani.ioannou@gmail.com>
+           2001, softSurfer (www.softsurfer.com)
+           2011, wwww.pointclouds.org
+           2020, ysuzuki19
+License: BSD-3-clause
+
+Files: doc/*
+Copyright: 2009-2012, Willow Garage, Inc
+           2012-2014, Open Perception, Inc
+License: CC-BY-SA-3
+
+Files: surface/include/pcl/surface/3rdparty/opennurbs/*
+       surface/src/3rdparty/opennurbs/*
+Copyright: 1993-2012, Robert McNeel & Associates
+License: OpenNURBS
+
+Files: surface/include/pcl/surface/3rdparty/poisson4/*
+       surface/src/3rdparty/poisson4/*
+Copyright: 2007, Michael Kazhdan
+           2006, Michael Kazhdan and Matthew Bolitho
+License: Open-Source
+
+Files: surface/include/pcl/surface/3rdparty/opennurbs/deflate.h
+       surface/include/pcl/surface/3rdparty/opennurbs/inffast.h
+       surface/include/pcl/surface/3rdparty/opennurbs/inflate.h
+       surface/include/pcl/surface/3rdparty/opennurbs/inftrees.h
+       surface/include/pcl/surface/3rdparty/opennurbs/opennurbs_crc.h
+       surface/include/pcl/surface/3rdparty/opennurbs/zconf.h
+       surface/include/pcl/surface/3rdparty/opennurbs/zlib.h
+       surface/include/pcl/surface/3rdparty/opennurbs/zutil.h
+       surface/src/3rdparty/opennurbs/adler32.c
+       surface/src/3rdparty/opennurbs/compress.c
+       surface/src/3rdparty/opennurbs/crc32.c
+       surface/src/3rdparty/opennurbs/deflate.c
+       surface/src/3rdparty/opennurbs/infback.c
+       surface/src/3rdparty/opennurbs/inffast.c
+       surface/src/3rdparty/opennurbs/inflate.c
+       surface/src/3rdparty/opennurbs/inftrees.c
+       surface/src/3rdparty/opennurbs/opennurbs_crc.cpp
+       surface/src/3rdparty/opennurbs/opennurbs_zlib_readme.txt
+       surface/src/3rdparty/opennurbs/readme.txt
+       surface/src/3rdparty/opennurbs/trees.c
+       surface/src/3rdparty/opennurbs/uncompr.c
+       surface/src/3rdparty/opennurbs/zutil.c
+Copyright: 1995-2005, Jean-loup Gailly
+           1995-2005, Mark Adler
+License: Zlib
+
+Files: common/include/pcl/sse.h
+       gpu/kinfu_large_scale/tools/record_maps_rgb.cpp
+       io/include/pcl/io/lzf.h
+       io/src/lzf.cpp
+       io/tools/openni_pcd_recorder.cpp
+       people/include/pcl/people/hog.h
+       people/src/hog.cpp
+       recognition/include/pcl/recognition/3rdparty/*
+Copyright: 2000-2010, Marc Alexander Lehmann <schmorp@schmorp.de>
+           2006-2012, Mirko Maischberger <mirko.maischberger@gmail.com>
+           2012-2013, Open Perception, Inc
+           2012, Piotr Dollar & Ron Appel. [pdollar-at-caltech.edu
+           2012, Sudarshan Srinivasan <sudarshan85@gmail.com>
+           2010-2011, Willow Garage, Inc
+License: BSD-2-clause
+
+Files: apps/cloud_composer/resources/insert_from_OpenNi.png
+Copyright: 2008-2010, Martin Sourada <mso@fedoraproject.org>
+           2008-2010, Luya Tshimbalanga <luya@muamba.benashima>
+License: CC-BY-SA-3
+Comment: Echo Icon Theme (https://fedorahosted.org/echo-icon-theme)
+
+Files: apps/cloud_composer/resources/insert_from_file.png
+       apps/cloud_composer/resources/new_project.png
+       apps/cloud_composer/resources/save_project.png
+Copyright: 2009-2010, David Vignoni <hello@davidvignoni.info>
+           2009-2010, Nuno Pinheiro <nuno@nuno-icons.com>
+License: CC-BY-SA-3
+Comment: Oxygen Icons (http://www.oxygen-icons.org)
+
+Files: outofcore/include/pcl/outofcore/cJSON.h
+       outofcore/src/cJSON.cpp
+Copyright: 2009, Dave Gamble
+License: Expat
+
+Files: cmake/pcl_utils.cmake
+Copyright: 2007, Douglas Gregor <doug.gregor@gmail.com>
+           2007, Troy Straszheim
+License: BSL-1
+
+Files: segmentation/include/pcl/segmentation/extract_polygonal_prism_data.h
+       segmentation/include/pcl/segmentation/impl/extract_polygonal_prism_data.hpp
+Copyright: 2010, Willow Garage, Inc.
+           1995-1996 Galacticomm, Inc.
+License: BSD-3-clause
+Comment: These files contain the inpoly algorithm by Bob Stein and Craig Yap.
+ The license is quoted as "Freeware source code" and the original copyright
+ statement for it is:
+ Please feel free to use this source code for any purpose, commercial
+ or otherwise, as long as you don't restrict anyone else's use of
+ this source code.  Please give credit where credit is due.
+
+Files: debian/*
+Copyright: 2014-2018, Jochen Sprickerhof <jspricke@debian.org>
+           2014, Leopold Palomo-Avellaneda <leo@alaxarxa.net>
+           2013, Thomas Moulard <thomas.moulard@gmail.com>
+License: BSD-3-clause
+
+License: BSD-2-clause
+ All rights reserved.
+ .
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ .
+  1) Redistributions of source code must retain the above copyright notice,
+    this list of conditions and the following disclaimer.
+ .
+  2) Redistributions in binary form must reproduce the above copyright notice,
+    this list of conditions and the following disclaimer in the documentation
+    and/or other materials provided with the distribution.
+ .
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGE.
+
+License: BSD-3-clause
+ .
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ .
+  1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above
+    copyright notice, this list of conditions and the following
+    disclaimer in the documentation and/or other materials provided
+    with the distribution.
+  3. Neither the name of the copyright holder(s) nor the names of its
+    contributors may be used to endorse or promote products derived
+    from this software without specific prior written permission.
+ .
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGE.
+
+License: BSL-1
+ Boost Software License - Version 1.0 - August 17th, 2003
+ .
+ Permission is hereby granted, free of charge, to any person or
+ organization obtaining a copy of the software and accompanying
+ documentation covered by this license (the "Software") to use,
+ reproduce, display, distribute, execute, and transmit the
+ Software, and to prepare derivative works of the Software, and
+ to permit third-parties to whom the Software is furnished to do
+ so, all subject to the following:
+ .
+ The copyright notices in the Software and this entire statement,
+ including the above license grant, this restriction and the
+ following disclaimer, must be included in all copies of the
+ Software, in whole or in part, and all derivative works of the
+ Software, unless such copies or derivative works are solely in
+ the form of machine-executable object code generated by a source
+ language processor.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND
+ NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
+ ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR
+ OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, ARISING
+ FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ OTHER DEALINGS IN THE SOFTWARE.
+
+License: CC-BY-SA-3
+ THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE
+ COMMONS PUBLIC LICENSE ("CCPL" OR "LICENSE"). THE WORK IS PROTECTED BY
+ COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
+ AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.
+ .
+ BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO
+ BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE
+ CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED
+ HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.
+ .
+ 1. Definitions
+ .
+    "Adaptation" means a work based upon the Work, or upon the Work and
+ other pre-existing works, such as a translation, adaptation, derivative
+ work, arrangement of music or other alterations of a literary or artistic
+ work, or phonogram or performance and includes cinematographic adaptations
+ or any other form in which the Work may be recast, transformed, or adapted
+ including in any form recognizably derived from the original, except that a
+ work that constitutes a Collection will not be considered an Adaptation for
+ the purpose of this License. For the avoidance of doubt, where the Work is a
+ musical work, performance or phonogram, the synchronization of the Work in
+ timed-relation with a moving image ("synching") will be considered an
+ Adaptation for the purpose of this License.
+    "Collection" means a collection of literary or artistic works, such as
+ encyclopedias and anthologies, or performances, phonograms or broadcasts, or
+ other works or subject matter other than works listed in Section 1(f) below,
+ which, by reason of the selection and arrangement of their contents,
+ constitute intellectual creations, in which the Work is included in its
+ entirety in unmodified form along with one or more other contributions, each
+ constituting separate and independent works in themselves, which together
+ are assembled into a collective whole. A work that constitutes a Collection
+ will not be considered an Adaptation (as defined below) for the purposes of
+ this License.
+    "Creative Commons Compatible License" means a license that is listed at
+ http://creativecommons.org/compatiblelicenses that has been approved by
+ Creative Commons as being essentially equivalent to this License, including,
+ at a minimum, because that license: (i) contains terms that have the same
+ purpose, meaning and effect as the License Elements of this License; and,
+ (ii) explicitly permits the relicensing of adaptations of works made
+ available under that license under this License or a Creative Commons
+ jurisdiction license with the same License Elements as this License.
+    "Distribute" means to make available to the public the original and
+ copies of the Work or Adaptation, as appropriate, through sale or other
+ transfer of ownership.
+    "License Elements" means the following high-level license attributes as
+ selected by Licensor and indicated in the title of this License:
+ Attribution, ShareAlike.
+    "Licensor" means the individual, individuals, entity or entities that
+ offer(s) the Work under the terms of this License.
+    "Original Author" means, in the case of a literary or artistic work, the
+ individual, individuals, entity or entities who created the Work or if no
+ individual or entity can be identified, the publisher; and in addition (i)
+ in the case of a performance the actors, singers, musicians, dancers, and
+ other persons who act, sing, deliver, declaim, play in, interpret or
+ otherwise perform literary or artistic works or expressions of folklore;
+ (ii) in the case of a phonogram the producer being the person or legal
+ entity who first fixes the sounds of a performance or other sounds; and,
+ (iii) in the case of broadcasts, the organization that transmits the
+ broadcast.
+    "Work" means the literary and/or artistic work offered under the terms
+ of this License including without limitation any production in the literary,
+ scientific and artistic domain, whatever may be the mode or form of its
+ expression including digital form, such as a book, pamphlet and other
+ writing; a lecture, address, sermon or other work of the same nature; a
+ dramatic or dramatico-musical work; a choreographic work or entertainment in
+ dumb show; a musical composition with or without words; a cinematographic
+ work to which are assimilated works expressed by a process analogous to
+ cinematography; a work of drawing, painting, architecture, sculpture,
+ engraving or lithography; a photographic work to which are assimilated works
+ expressed by a process analogous to photography; a work of applied art; an
+ illustration, map, plan, sketch or three-dimensional work relative to
+ geography, topography, architecture or science; a performance; a broadcast;
+ a phonogram; a compilation of data to the extent it is protected as a
+ copyrightable work; or a work performed by a variety or circus performer to
+ the extent it is not otherwise considered a literary or artistic work.
+    "You" means an individual or entity exercising rights under this License
+ who has not previously violated the terms of this License with respect to
+ the Work, or who has received express permission from the Licensor to
+ exercise rights under this License despite a previous violation.
+    "Publicly Perform" means to perform public recitations of the Work and
+ to communicate to the public those public recitations, by any means or
+ process, including by wire or wireless means or public digital performances;
+ to make available to the public Works in such a way that members of the
+ public may access these Works from a place and at a place individually
+ chosen by them; to perform the Work to the public by any means or process
+ and the communication to the public of the performances of the Work,
+ including by public digital performance; to broadcast and rebroadcast the
+ Work by any means including signs, sounds or images.
+    "Reproduce" means to make copies of the Work by any means including
+ without limitation by sound or visual recordings and the right of fixation
+ and reproducing fixations of the Work, including storage of a protected
+ performance or phonogram in digital form or other electronic medium.
+ .
+ 2. Fair Dealing Rights. Nothing in this License is intended to reduce,
+ limit, or restrict any uses free from copyright or rights arising from
+ limitations or exceptions that are provided for in connection with the
+ copyright protection under copyright law or other applicable laws.
+ .
+ 3. License Grant. Subject to the terms and conditions of this License,
+ Licensor hereby grants You a worldwide, royalty-free, non-exclusive,
+ perpetual (for the duration of the applicable copyright) license to exercise
+ the rights in the Work as stated below:
+ .
+    to Reproduce the Work, to incorporate the Work into one or more
+ Collections, and to Reproduce the Work as incorporated in the Collections;
+    to create and Reproduce Adaptations provided that any such Adaptation,
+ including any translation in any medium, takes reasonable steps to clearly
+ label, demarcate or otherwise identify that changes were made to the
+ original Work. For example, a translation could be marked "The original work
+ was translated from English to Spanish," or a modification could indicate
+ "The original work has been modified.";
+    to Distribute and Publicly Perform the Work including as incorporated in
+ Collections; and,
+    to Distribute and Publicly Perform Adaptations.
+ .
+    For the avoidance of doubt:
+       Non-waivable Compulsory License Schemes. In those jurisdictions in
+ which the right to collect royalties through any statutory or compulsory
+ licensing scheme cannot be waived, the Licensor reserves the exclusive right
+ to collect such royalties for any exercise by You of the rights granted
+ under this License;
+       Waivable Compulsory License Schemes. In those jurisdictions in which
+ the right to collect royalties through any statutory or compulsory licensing
+ scheme can be waived, the Licensor waives the exclusive right to collect
+ such royalties for any exercise by You of the rights granted under this
+ License; and,
+       Voluntary License Schemes. The Licensor waives the right to collect
+ royalties, whether individually or, in the event that the Licensor is a
+ member of a collecting society that administers voluntary licensing schemes,
+ via that society, from any exercise by You of the rights granted under this
+ License.
+ .
+ The above rights may be exercised in all media and formats whether now known
+ or hereafter devised. The above rights include the right to make such
+ modifications as are technically necessary to exercise the rights in other
+ media and formats. Subject to Section 8(f), all rights not expressly granted
+ by Licensor are hereby reserved.
+ .
+ 4. Restrictions. The license granted in Section 3 above is expressly made
+ subject to and limited by the following restrictions:
+ .
+    You may Distribute or Publicly Perform the Work only under the terms of
+ this License. You must include a copy of, or the Uniform Resource Identifier
+ (URI) for, this License with every copy of the Work You Distribute or
+ Publicly Perform. You may not offer or impose any terms on the Work that
+ restrict the terms of this License or the ability of the recipient of the
+ Work to exercise the rights granted to that recipient under the terms of the
+ License. You may not sublicense the Work. You must keep intact all notices
+ that refer to this License and to the disclaimer of warranties with every
+ copy of the Work You Distribute or Publicly Perform. When You Distribute or
+ Publicly Perform the Work, You may not impose any effective technological
+ measures on the Work that restrict the ability of a recipient of the Work
+ from You to exercise the rights granted to that recipient under the terms of
+ the License. This Section 4(a) applies to the Work as incorporated in a
+ Collection, but this does not require the Collection apart from the Work
+ itself to be made subject to the terms of this License. If You create a
+ Collection, upon notice from any Licensor You must, to the extent
+ practicable, remove from the Collection any credit as required by Section
+ 4(c), as requested. If You create an Adaptation, upon notice from any
+ Licensor You must, to the extent practicable, remove from the Adaptation any
+ credit as required by Section 4(c), as requested.
+    You may Distribute or Publicly Perform an Adaptation only under the
+ terms of: (i) this License; (ii) a later version of this License with the
+ same License Elements as this License; (iii) a Creative Commons jurisdiction
+ license (either this or a later license version) that contains the same
+ License Elements as this License (e.g., Attribution-ShareAlike 3.0 US));
+ (iv) a Creative Commons Compatible License. If you license the Adaptation
+ under one of the licenses mentioned in (iv), you must comply with the terms
+ of that license. If you license the Adaptation under the terms of any of the
+ licenses mentioned in (i), (ii) or (iii) (the "Applicable License"), you
+ must comply with the terms of the Applicable License generally and the
+ following provisions: (I) You must include a copy of, or the URI for, the
+ Applicable License with every copy of each Adaptation You Distribute or
+ Publicly Perform; (II) You may not offer or impose any terms on the
+ Adaptation that restrict the terms of the Applicable License or the ability
+ of the recipient of the Adaptation to exercise the rights granted to that
+ recipient under the terms of the Applicable License; (III) You must keep
+ intact all notices that refer to the Applicable License and to the
+ disclaimer of warranties with every copy of the Work as included in the
+ Adaptation You Distribute or Publicly Perform; (IV) when You Distribute or
+ Publicly Perform the Adaptation, You may not impose any effective
+ technological measures on the Adaptation that restrict the ability of a
+ recipient of the Adaptation from You to exercise the rights granted to that
+ recipient under the terms of the Applicable License. This Section 4(b)
+ applies to the Adaptation as incorporated in a Collection, but this does not
+ require the Collection apart from the Adaptation itself to be made subject
+ to the terms of the Applicable License.
+    If You Distribute, or Publicly Perform the Work or any Adaptations or
+ Collections, You must, unless a request has been made pursuant to Section
+ 4(a), keep intact all copyright notices for the Work and provide, reasonable
+ to the medium or means You are utilizing: (i) the name of the Original
+ Author (or pseudonym, if applicable) if supplied, and/or if the Original
+ Author and/or Licensor designate another party or parties (e.g., a sponsor
+ institute, publishing entity, journal) for attribution ("Attribution
+ Parties") in Licensor's copyright notice, terms of service or by other
+ reasonable means, the name of such party or parties; (ii) the title of the
+ Work if supplied; (iii) to the extent reasonably practicable, the URI, if
+ any, that Licensor specifies to be associated with the Work, unless such URI
+ does not refer to the copyright notice or licensing information for the
+ Work; and (iv) , consistent with Ssection 3(b), in the case of an
+ Adaptation, a credit identifying the use of the Work in the Adaptation
+ (e.g., "French translation of the Work by Original Author," or "Screenplay
+ based on original Work by Original Author"). The credit required by this
+ Section 4(c) may be implemented in any reasonable manner; provided, however,
+ that in the case of a Adaptation or Collection, at a minimum such credit
+ will appear, if a credit for all contributing authors of the Adaptation or
+ Collection appears, then as part of these credits and in a manner at least
+ as prominent as the credits for the other contributing authors. For the
+ avoidance of doubt, You may only use the credit required by this Section for
+ the purpose of attribution in the manner set out above and, by exercising
+ Your rights under this License, You may not implicitly or explicitly assert
+ or imply any connection with, sponsorship or endorsement by the Original
+ Author, Licensor and/or Attribution Parties, as appropriate, of You or Your
+ use of the Work, without the separate, express prior written permission of
+ the Original Author, Licensor and/or Attribution Parties.
+    Except as otherwise agreed in writing by the Licensor or as may be
+ otherwise permitted by applicable law, if You Reproduce, Distribute or
+ Publicly Perform the Work either by itself or as part of any Adaptations or
+ Collections, You must not distort, mutilate, modify or take other derogatory
+ action in relation to the Work which would be prejudicial to the Original
+ Author's honor or reputation. Licensor agrees that in those jurisdictions
+ (e.g. Japan), in which any exercise of the right granted in Section 3(b) of
+ this License (the right to make Adaptations) would be deemed to be a
+ distortion, mutilation, modification or other derogatory action prejudicial
+ to the Original Author's honor and reputation, the Licensor will waive or
+ not assert, as appropriate, this Section, to the fullest extent permitted by
+ the applicable national law, to enable You to reasonably exercise Your right
+ under Section 3(b) of this License (right to make Adaptations) but not
+ otherwise.
+ .
+ 5. Representations, Warranties and Disclaimer
+ .
+ UNLESS OTHERWISE MUTUALLY AGREED TO BY THE PARTIES IN WRITING, LICENSOR
+ OFFERS THE WORK AS-IS AND MAKES NO REPRESENTATIONS OR WARRANTIES OF ANY KIND
+ CONCERNING THE WORK, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, INCLUDING,
+ WITHOUT LIMITATION, WARRANTIES OF TITLE, MERCHANTIBILITY, FITNESS FOR A
+ PARTICULAR PURPOSE, NONINFRINGEMENT, OR THE ABSENCE OF LATENT OR OTHER
+ DEFECTS, ACCURACY, OR THE PRESENCE OF ABSENCE OF ERRORS, WHETHER OR NOT
+ DISCOVERABLE. SOME JURISDICTIONS DO NOT ALLOW THE EXCLUSION OF IMPLIED
+ WARRANTIES, SO SUCH EXCLUSION MAY NOT APPLY TO YOU.
+ .
+ 6. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE LAW,
+ IN NO EVENT WILL LICENSOR BE LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY
+ SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING
+ OUT OF THIS LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN
+ ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+ .
+ 7. Termination
+ .
+    This License and the rights granted hereunder will terminate
+ automatically upon any breach by You of the terms of this License.
+ Individuals or entities who have received Adaptations or Collections from
+ You under this License, however, will not have their licenses terminated
+ provided such individuals or entities remain in full compliance with those
+ licenses. Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this
+ License.
+    Subject to the above terms and conditions, the license granted here is
+ perpetual (for the duration of the applicable copyright in the Work).
+ Notwithstanding the above, Licensor reserves the right to release the Work
+ under different license terms or to stop distributing the Work at any time;
+ provided, however that any such election will not serve to withdraw this
+ License (or any other license that has been, or is required to be, granted
+ under the terms of this License), and this License will continue in full
+ force and effect unless terminated as stated above.
+ .
+ 8. Miscellaneous
+ .
+    Each time You Distribute or Publicly Perform the Work or a Collection,
+ the Licensor offers to the recipient a license to the Work on the same terms
+ and conditions as the license granted to You under this License.
+    Each time You Distribute or Publicly Perform an Adaptation, Licensor
+ offers to the recipient a license to the original Work on the same terms and
+ conditions as the license granted to You under this License.
+    If any provision of this License is invalid or unenforceable under
+ applicable law, it shall not affect the validity or enforceability of the
+ remainder of the terms of this License, and without further action by the
+ parties to this agreement, such provision shall be reformed to the minimum
+ extent necessary to make such provision valid and enforceable.
+    No term or provision of this License shall be deemed waived and no
+ breach consented to unless such waiver or consent shall be in writing and
+ signed by the party to be charged with such waiver or consent.
+    This License constitutes the entire agreement between the parties with
+ respect to the Work licensed here. There are no understandings, agreements
+ or representations with respect to the Work not specified here. Licensor
+ shall not be bound by any additional provisions that may appear in any
+ communication from You. This License may not be modified without the mutual
+ written agreement of the Licensor and You.
+    The rights granted under, and the subject matter referenced, in this
+ License were drafted utilizing the terminology of the Berne Convention for
+ the Protection of Literary and Artistic Works (as amended on September 28,
+ 1979), the Rome Convention of 1961, the WIPO Copyright Treaty of 1996, the
+ WIPO Performances and Phonograms Treaty of 1996 and the Universal Copyright
+ Convention (as revised on July 24, 1971). These rights and subject matter
+ take effect in the relevant jurisdiction in which the License terms are
+ sought to be enforced according to the corresponding provisions of the
+ implementation of those treaty provisions in the applicable national law. If
+ the standard suite of rights granted under applicable copyright law includes
+ additional rights not granted under this License, such additional rights are
+ deemed to be included in the License; this License is not intended to
+ restrict the license of any rights under applicable law.
+ .
+    Creative Commons Notice
+ .
+    Creative Commons is not a party to this License, and makes no warranty
+ whatsoever in connection with the Work. Creative Commons will not be liable
+ to You or any party on any legal theory for any damages whatsoever,
+ including without limitation any general, special, incidental or
+ consequential damages arising in connection to this license. Notwithstanding
+ the foregoing two (2) sentences, if Creative Commons has expressly
+ identified itself as the Licensor hereunder, it shall have all rights and
+ obligations of Licensor.
+ .
+    Except for the limited purpose of indicating to the public that the Work
+ is licensed under the CCPL, Creative Commons does not authorize the use by
+ either party of the trademark "Creative Commons" or any related trademark or
+ logo of Creative Commons without the prior written consent of Creative
+ Commons. Any permitted use will be in compliance with Creative Commons'
+ then-current trademark usage guidelines, as may be published on its website
+ or otherwise made available upon request from time to time. For the
+ avoidance of doubt, this trademark restriction does not form part of the
+ License.
+ .
+ Creative Commons may be contacted at http://creativecommons.org/.
+ http://creativecommons.org/licenses/by-sa/3.0/
+
+License: Expat
+ Permission is hereby granted, free of charge, to any person obtaining
+ a copy of this software and associated documentation files (the
+ "Software"), to deal in the Software without restriction, including
+ without limitation the rights to use, copy, modify, merge, publish,
+ distribute, sublicense, and/or sell copies of the Software, and to
+ permit persons to whom the Software is furnished to do so, subject to
+ the following conditions:
+ .
+ The above copyright notice and this permission notice shall be included
+ in all copies or substantial portions of the Software.
+ .
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+License: Open-Source
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions are met:
+ .
+ Redistributions of source code must retain the above copyright notice, this
+ list of conditions and the following disclaimer. Redistributions in binary form must
+ reproduce the above copyright notice, this list of conditions and the following
+ disclaimer in the documentation and/or other materials provided with the distribution.
+ .
+ Neither the name of the Johns Hopkins University nor the names of its
+ contributors may be used to endorse or promote products derived from this software
+ without specific prior written permission.
+ .
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED
+ WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
+ NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ LIMITED TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ OF SUCH DAMAGE.
+
+License: OpenNURBS
+ .
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to
+ deal in the Software without restriction, including without limitation the
+ rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ sell copies of the Software.
+ .
+ THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. ALL
+ IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
+ MERCHANTABILITY ARE HEREBY DISCLAIMED.
+ .
+ openNURBS and Rhinoceros are a registered trademarks of Robert McNeel &
+ Associates.
+
+License: Zlib
+ This software is provided 'as-is', without any express or implied warranty.
+ In no event will the authors be held liable for any damages arising from the
+ use of this software.
+ .
+ Permission is granted to anyone to use this software for any purpose,
+ including commercial applications, and to alter it and redistribute it
+ freely, subject to the following restrictions:
+ .
+  1. The origin of this software must not be misrepresented; you must not
+   claim that you wrote the original software. If you use this software in a
+   product, an acknowledgment in the product documentation would be appreciated
+   but is not required.
+ .
+ 2. Altered source versions must be plainly marked as such, and must not be
+   misrepresented as being the original software.
+ .
+ 3. This notice may not be removed or altered from any source distribution.
+
diff --git a/debian/gbp.conf b/debian/gbp.conf
new file mode 100644
index 000000000..b039d6993
--- /dev/null
+++ b/debian/gbp.conf
@@ -0,0 +1,22 @@
+[DEFAULT]
+pristine-tar = False
+
+[buildpackage]
+export-dir  = ../
+upstream-tag=2022.3_RC2
+upstream-tree=TAG
+debian-branch=debian/1.12.1+dfsg-eci
+
+[import-orig]
+dch = False
+filter = [
+        '.github',
+        'ci'
+      ]
+filter-pristine-tar = True
+
+[import-dsc]
+filter = [
+        '.github',
+        'ci'
+      ]
diff --git a/debian/libpcl-apps1.12.install b/debian/libpcl-apps1.12.install
new file mode 100644
index 000000000..ec6bf4761
--- /dev/null
+++ b/debian/libpcl-apps1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_apps.so.*
diff --git a/debian/libpcl-common1.12.install b/debian/libpcl-common1.12.install
new file mode 100644
index 000000000..7b198a577
--- /dev/null
+++ b/debian/libpcl-common1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_common.so.*
diff --git a/debian/libpcl-dev.install b/debian/libpcl-dev.install
new file mode 100644
index 000000000..ef3256c2e
--- /dev/null
+++ b/debian/libpcl-dev.install
@@ -0,0 +1,4 @@
+usr/include/*
+usr/lib/*/pkgconfig/*
+usr/share/pcl*/* usr/lib/${DEB_HOST_MULTIARCH}/cmake/pcl/
+usr/lib/*/libpcl_*.so
diff --git a/debian/libpcl-doc.doc-base b/debian/libpcl-doc.doc-base
new file mode 100644
index 000000000..130ea5f99
--- /dev/null
+++ b/debian/libpcl-doc.doc-base
@@ -0,0 +1,9 @@
+Document: pcl
+Title: PCL C++ API reference
+Author: the PCL team
+Abstract: Describe the PCL library C++ API.
+Section: Programming/C++
+
+Format: HTML
+Index: /usr/share/doc/libpcl-dev/html/index.html
+Files: /usr/share/doc/libpcl-dev/html/*
diff --git a/debian/libpcl-doc.docs b/debian/libpcl-doc.docs
new file mode 100644
index 000000000..3d45a8534
--- /dev/null
+++ b/debian/libpcl-doc.docs
@@ -0,0 +1 @@
+usr/share/doc/pcl-*/html
diff --git a/debian/libpcl-doc.examples b/debian/libpcl-doc.examples
new file mode 100644
index 000000000..e39721e20
--- /dev/null
+++ b/debian/libpcl-doc.examples
@@ -0,0 +1 @@
+examples/*
diff --git a/debian/libpcl-doc.links b/debian/libpcl-doc.links
new file mode 100644
index 000000000..b753863c5
--- /dev/null
+++ b/debian/libpcl-doc.links
@@ -0,0 +1 @@
+usr/share/javascript/jquery/jquery.js usr/share/doc/libpcl-doc/html/jquery.js
diff --git a/debian/libpcl-features1.12.install b/debian/libpcl-features1.12.install
new file mode 100644
index 000000000..590a8e058
--- /dev/null
+++ b/debian/libpcl-features1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_features.so.*
diff --git a/debian/libpcl-filters1.12.install b/debian/libpcl-filters1.12.install
new file mode 100644
index 000000000..fef500c28
--- /dev/null
+++ b/debian/libpcl-filters1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_filters.so.*
diff --git a/debian/libpcl-io1.12.install b/debian/libpcl-io1.12.install
new file mode 100644
index 000000000..ff1711c7b
--- /dev/null
+++ b/debian/libpcl-io1.12.install
@@ -0,0 +1,2 @@
+usr/lib/*/libpcl_io.so.*
+usr/lib/*/libpcl_io_ply.so.*
diff --git a/debian/libpcl-kdtree1.12.install b/debian/libpcl-kdtree1.12.install
new file mode 100644
index 000000000..e19a2d733
--- /dev/null
+++ b/debian/libpcl-kdtree1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_kdtree.so.*
diff --git a/debian/libpcl-keypoints1.12.install b/debian/libpcl-keypoints1.12.install
new file mode 100644
index 000000000..1d9726354
--- /dev/null
+++ b/debian/libpcl-keypoints1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_keypoints.so.*
diff --git a/debian/libpcl-ml1.12.install b/debian/libpcl-ml1.12.install
new file mode 100644
index 000000000..ba9e8650c
--- /dev/null
+++ b/debian/libpcl-ml1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_ml.so.*
diff --git a/debian/libpcl-octree1.12.install b/debian/libpcl-octree1.12.install
new file mode 100644
index 000000000..e73c79858
--- /dev/null
+++ b/debian/libpcl-octree1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_octree.so.*
diff --git a/debian/libpcl-oneapi-common1.12.install b/debian/libpcl-oneapi-common1.12.install
new file mode 100644
index 000000000..8b22a5fe5
--- /dev/null
+++ b/debian/libpcl-oneapi-common1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_common.so.*
diff --git a/debian/libpcl-oneapi-features1.12.install b/debian/libpcl-oneapi-features1.12.install
new file mode 100644
index 000000000..503b171d1
--- /dev/null
+++ b/debian/libpcl-oneapi-features1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_features.so.*
diff --git a/debian/libpcl-oneapi-filters1.12.install b/debian/libpcl-oneapi-filters1.12.install
new file mode 100644
index 000000000..9dce0e0ed
--- /dev/null
+++ b/debian/libpcl-oneapi-filters1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_filters.so.*
diff --git a/debian/libpcl-oneapi-kdtree1.12.install b/debian/libpcl-oneapi-kdtree1.12.install
new file mode 100644
index 000000000..57e224d93
--- /dev/null
+++ b/debian/libpcl-oneapi-kdtree1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_kdtree.so.*
diff --git a/debian/libpcl-oneapi-octree1.12.install b/debian/libpcl-oneapi-octree1.12.install
new file mode 100644
index 000000000..cd774382b
--- /dev/null
+++ b/debian/libpcl-oneapi-octree1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_octree.so.*
diff --git a/debian/libpcl-oneapi-registration1.12.install b/debian/libpcl-oneapi-registration1.12.install
new file mode 100644
index 000000000..b68630cb5
--- /dev/null
+++ b/debian/libpcl-oneapi-registration1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_registratio*.so.*
diff --git a/debian/libpcl-oneapi-sample-consensus1.12.install b/debian/libpcl-oneapi-sample-consensus1.12.install
new file mode 100644
index 000000000..4bc5ca9d3
--- /dev/null
+++ b/debian/libpcl-oneapi-sample-consensus1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_sample_consensus.so.*
diff --git a/debian/libpcl-oneapi-search1.12.install b/debian/libpcl-oneapi-search1.12.install
new file mode 100644
index 000000000..34413a8ed
--- /dev/null
+++ b/debian/libpcl-oneapi-search1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_search.so.*
diff --git a/debian/libpcl-oneapi-segmentation1.12.install b/debian/libpcl-oneapi-segmentation1.12.install
new file mode 100644
index 000000000..a740b1db4
--- /dev/null
+++ b/debian/libpcl-oneapi-segmentation1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_segmentatio*.so.*
diff --git a/debian/libpcl-oneapi-surface1.12.install b/debian/libpcl-oneapi-surface1.12.install
new file mode 100644
index 000000000..56a3fd84a
--- /dev/null
+++ b/debian/libpcl-oneapi-surface1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_oneapi_surfac*.so.*
diff --git a/debian/libpcl-oneapi.install b/debian/libpcl-oneapi.install
new file mode 100644
index 000000000..e69de29bb
diff --git a/debian/libpcl-outofcore1.12.install b/debian/libpcl-outofcore1.12.install
new file mode 100644
index 000000000..e9f057267
--- /dev/null
+++ b/debian/libpcl-outofcore1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_outofcore.so.*
diff --git a/debian/libpcl-people1.12.install b/debian/libpcl-people1.12.install
new file mode 100644
index 000000000..9a832137c
--- /dev/null
+++ b/debian/libpcl-people1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_people.so.*
diff --git a/debian/libpcl-recognition1.12.install b/debian/libpcl-recognition1.12.install
new file mode 100644
index 000000000..d0576c948
--- /dev/null
+++ b/debian/libpcl-recognition1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_recognition.so.*
diff --git a/debian/libpcl-registration1.12.install b/debian/libpcl-registration1.12.install
new file mode 100644
index 000000000..a414bc02f
--- /dev/null
+++ b/debian/libpcl-registration1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_registration.so.*
diff --git a/debian/libpcl-sample-consensus1.12.install b/debian/libpcl-sample-consensus1.12.install
new file mode 100644
index 000000000..2c2ef2379
--- /dev/null
+++ b/debian/libpcl-sample-consensus1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_sample_consensus.so.*
diff --git a/debian/libpcl-search1.12.install b/debian/libpcl-search1.12.install
new file mode 100644
index 000000000..004431e71
--- /dev/null
+++ b/debian/libpcl-search1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_search.so.*
diff --git a/debian/libpcl-segmentation1.12.install b/debian/libpcl-segmentation1.12.install
new file mode 100644
index 000000000..0a880e28f
--- /dev/null
+++ b/debian/libpcl-segmentation1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_segmentation.so.*
diff --git a/debian/libpcl-stereo1.12.install b/debian/libpcl-stereo1.12.install
new file mode 100644
index 000000000..9923db846
--- /dev/null
+++ b/debian/libpcl-stereo1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_stereo.so.*
diff --git a/debian/libpcl-surface1.12.install b/debian/libpcl-surface1.12.install
new file mode 100644
index 000000000..16d93e4da
--- /dev/null
+++ b/debian/libpcl-surface1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_surface.so.*
diff --git a/debian/libpcl-tracking1.12.install b/debian/libpcl-tracking1.12.install
new file mode 100644
index 000000000..3166edf3e
--- /dev/null
+++ b/debian/libpcl-tracking1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_tracking.so.*
diff --git a/debian/libpcl-visualization1.12.install b/debian/libpcl-visualization1.12.install
new file mode 100644
index 000000000..65e6ef18b
--- /dev/null
+++ b/debian/libpcl-visualization1.12.install
@@ -0,0 +1 @@
+usr/lib/*/libpcl_visualization.so.*
diff --git a/debian/manpages/pcl_add_gaussian_noise.1 b/debian/manpages/pcl_add_gaussian_noise.1
new file mode 100644
index 000000000..c6a729585
--- /dev/null
+++ b/debian/manpages/pcl_add_gaussian_noise.1
@@ -0,0 +1,24 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_ADD_GAUSSIAN_NOISE "1" "May 2014" "pcl_add_gaussian_noise 1.7.1" "User Commands"
+.SH NAME
+pcl_add_gaussian_noise \- pcl_add_gaussian_noise
+.SH DESCRIPTION
+
+Syntax is: pcl_add_gaussian_noise input.pcd output.pcd <options>
+
+
+Add Gaussian noise to a point cloud. For more information, use: pcl_add_gaussian_noise \fB\-h\fR
+
+  where options are:
+
+ \fB\-sd\fR X = the standard deviation for the normal distribution (default: 0.010000)
+.SH AUTHOR
+pcl_add_gaussian_noise is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_boundary_estimation.1 b/debian/manpages/pcl_boundary_estimation.1
new file mode 100644
index 000000000..6f9b484ca
--- /dev/null
+++ b/debian/manpages/pcl_boundary_estimation.1
@@ -0,0 +1,28 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_BOUNDARY_ESTIMATION "1" "May 2014" "pcl_boundary_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_boundary_estimation \- pcl_boundary_estimation
+.SH DESCRIPTION
+
+Syntax is: pcl_boundary_estimation input.pcd output.pcd <options>
+
+
+Estimate boundary points using pcl::BoundaryEstimation. For more information, use: pcl_boundary_estimation \fB\-h\fR
+
+  where options are:
+
+   \fB\-radius\fR X = use a radius of Xm around each point to determine the neighborhood (default: 0.000000)
+
+   \fB\-k\fR X      = use a fixed number of X\-nearest neighbors around each point (default: 0)
+
+    \fB\-thresh\fR X = the decision boundary (angle threshold) that marks points as boundary or regular (default: 1.570796)
+.SH AUTHOR
+pcl_boundary_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_cluster_extraction.1 b/debian/manpages/pcl_cluster_extraction.1
new file mode 100644
index 000000000..812f1d474
--- /dev/null
+++ b/debian/manpages/pcl_cluster_extraction.1
@@ -0,0 +1,28 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_CLUSTER_EXTRACTION "1" "May 2014" "pcl_cluster_extraction 1.7.1" "User Commands"
+.SH NAME
+pcl_cluster_extraction \- pcl_cluster_extraction
+.SH DESCRIPTION
+
+Syntax is: pcl_cluster_extraction input.pcd output.pcd <options>
+
+
+Extract point clusters using pcl::EuclideanClusterExtraction. For more information, use: pcl_cluster_extraction \fB\-h\fR
+
+  where options are:
+
+ \fB\-min\fR X = use a minimum of X points peer cluster (default: 100)
+
+ \fB\-max\fR X = use a maximum of X points peer cluster (default: 25000)
+
+ \fB\-tolerance\fR X = the spacial distance between clusters (default: 0.020000)
+.SH AUTHOR
+pcl_cluster_extraction is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_compute_cloud_error.1 b/debian/manpages/pcl_compute_cloud_error.1
new file mode 100644
index 000000000..616f9efea
--- /dev/null
+++ b/debian/manpages/pcl_compute_cloud_error.1
@@ -0,0 +1,30 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_COMPUTE_CLOUD_ERROR "1" "May 2014" "pcl_compute_cloud_error 1.7.1" "User Commands"
+.SH NAME
+pcl_compute_cloud_error \- pcl_compute_cloud_error
+.SH DESCRIPTION
+
+Syntax is: pcl_compute_cloud_error source.pcd target.pcd output_intensity.pcd <options>
+
+
+  where options are:
+
+ \fB\-correspondence\fR X = the way of selecting the corresponding pair in the target cloud for the current point in the source cloud
+
+ options are: index = points with identical indices are paired together. Note: both clouds need to have the same number of points
+
+    nn = source point is paired with its nearest neighbor in the target cloud
+
+    nnplane = source point is paired with its projection on the plane determined by the nearest neighbor in the target cloud. Note: target cloud needs to contain normals
+
+ (default: index)
+.SH AUTHOR
+pcl_compute_cloud_error is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_compute_hull.1 b/debian/manpages/pcl_compute_hull.1
new file mode 100644
index 000000000..1da3b6117
--- /dev/null
+++ b/debian/manpages/pcl_compute_hull.1
@@ -0,0 +1,26 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_COMPUTE_HULL "1" "May 2014" "pcl_compute_hull 1.7.1" "User Commands"
+.SH NAME
+pcl_compute_hull \- pcl_compute_hull
+.SH DESCRIPTION
+
+Syntax is: pcl_compute_hull input.pcd output.vtk [optional_arguments]
+
+
+Compute the convex or concave hull of a point cloud. For more information, use: pcl_compute_hull \fB\-h\fR
+
+  where the optional arguments are:
+
+ \fB\-alpha\fR X = the alpha value for the ConcaveHull (Alpha Shapes) algorithm. If alpha is not specified, the tool will run the ConvexHull method (default: 0.150000
+
+)
+.SH AUTHOR
+pcl_compute_hull is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+ 
diff --git a/debian/manpages/pcl_convert_pcd_ascii_binary.1 b/debian/manpages/pcl_convert_pcd_ascii_binary.1
new file mode 100644
index 000000000..2e7ba1c75
--- /dev/null
+++ b/debian/manpages/pcl_convert_pcd_ascii_binary.1
@@ -0,0 +1,16 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_CONVERT_PCD_ASCII_BINARY "1" "May 2014" "pcl_convert_pcd_ascii_binary 1.7.1" "User Commands"
+.SH NAME
+pcl_convert_pcd_ascii_binary \- pcl_convert_pcd_ascii_binary
+.SH DESCRIPTION
+Syntax is: pcl_convert_pcd_ascii_binary <file_in.pcd> <file_out.pcd> 0/1/2 (ascii/binary/binary_compressed) [precision (ASCII)]
+.SH AUTHOR
+pcl_convert_pcd_ascii_binary is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_convolve.1 b/debian/manpages/pcl_convolve.1
new file mode 100644
index 000000000..5ddb12bb1
--- /dev/null
+++ b/debian/manpages/pcl_convolve.1
@@ -0,0 +1,38 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_CONVOLVE "1" "May 2014" "pcl_convolve 1.7.1" "User Commands"
+.SH NAME
+pcl_convolve \- pcl_convolve
+.SH DESCRIPTION
+
+usage: pcl_convolve <filename> <\-r|\-c|\-s> [\-p <borders policy>] [\-t <number of threads>] [\-d <distance>]
+.PP
+
+Where options are:
+
+    \fB\-r\fR convolve rows
+
+    \fB\-c\fR convolve columns
+
+    \fB\-s\fR convolve separate
+
+    \fB\-p\fR borders policy
+
+   Z zero padding, default
+
+   D duplicate borders
+
+   M mirror borders
+
+    \fB\-t\fR optional, number of threads, default 1
+
+    \fB\-d\fR optional, distance threshold, default 0.001
+.SH AUTHOR
+pcl_convolve is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_crop_to_hull.1 b/debian/manpages/pcl_crop_to_hull.1
new file mode 100644
index 000000000..a1d4b0461
--- /dev/null
+++ b/debian/manpages/pcl_crop_to_hull.1
@@ -0,0 +1,24 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_CROP_TO_HULL "1" "May 2014" "pcl_crop_to_hull 1.7.1" "User Commands"
+.SH NAME
+pcl_crop_to_hull \- pcl_crop_to_hull
+.SH DESCRIPTION
+
+Syntax is: pcl_crop_to_hull hull_cloud.pcd input.pcd output.pcd <options>
+
+
+Filter a point cloud using the convex hull of another point cloud. For more information, use: pcl_crop_to_hull \fB\-h\fR
+
+  where options are:
+
+ \fB\-alpha\fR X = the hull alpha value (0+) (default: 1000.000000)
+.SH AUTHOR
+pcl_crop_to_hull is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_demean_cloud.1 b/debian/manpages/pcl_demean_cloud.1
new file mode 100644
index 000000000..a2db37d11
--- /dev/null
+++ b/debian/manpages/pcl_demean_cloud.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_DEMEAN_CLOUD "1" "May 2014" "pcl_demean_cloud 1.7.1" "User Commands"
+.SH NAME
+pcl_demean_cloud \- pcl_demean_cloud
+.SH DESCRIPTION
+
+Syntax is: pcl_demean_cloud input.pcd output.pcd
+
+
+Convert a PCD file to PLY format. For more information, use: pcl_demean_cloud \fB\-h\fR
+.SH AUTHOR
+pcl_demean_cloud is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_extract_feature.1 b/debian/manpages/pcl_extract_feature.1
new file mode 100644
index 000000000..2ac8391ce
--- /dev/null
+++ b/debian/manpages/pcl_extract_feature.1
@@ -0,0 +1,33 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_EXTRACT_FEATURE "1" "May 2014" "pcl_extract_feature 1.7.1" "User Commands"
+.SH NAME
+pcl_extract_feature \- pcl_extract_feature
+.SH DESCRIPTION
+
+Syntax is: pcl_extract_feature input.pcd output.pcd <options>
+
+
+Extract features from a point cloud. For more information, use: pcl_extract_feature \fB\-h\fR
+
+  where options are:
+
+ \fB\-feature\fR X = the feature descriptor algorithm to be used (default: FPFHEstimation)
+
+ \fB\-n_radius\fR X = use a radius of Xm around each point to determine the neighborhood in normal estimation (default: 0.000000)
+
+ \fB\-n_k\fR X = use a fixed number of X\-nearest neighbors around each point in normal estimation (default: 0.000000)
+
+ \fB\-f_radius\fR X = use a radius of Xm around each point to determine the neighborhood in feature extraction (default: 0.000000)
+
+ \fB\-f_k\fR X = use a fixed number of X\-nearest neighbors around each point in feature extraction(default: 0.000000)
+
+.SH AUTHOR
+pcl_extract_feature is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_fast_bilateral_filter.1 b/debian/manpages/pcl_fast_bilateral_filter.1
new file mode 100644
index 000000000..c6e16e6ca
--- /dev/null
+++ b/debian/manpages/pcl_fast_bilateral_filter.1
@@ -0,0 +1,33 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_FAST_BILATERAL_FILTER "1" "May 2014" "pcl_fast_bilateral_filter 1.7.1" "User Commands"
+.SH NAME
+pcl_fast_bilateral_filter \- pcl_fast_bilateral_filter
+.SH DESCRIPTION
+
+Syntax is: pcl_fast_bilateral_filter input.pcd output.pcd <options> [optional_arguments]
+
+
+Smooth depth data using a FastBilateralFilter. For more information, use: pcl_fast_bilateral_filter \fB\-h\fR
+
+  where options are:
+
+ \fB\-sigma_s\fR X = use a sigma S value of X (default: 5.000000)
+
+ \fB\-sigma_r\fR X = use a sigma R value of X (default: 0.030000)
+
+
+Optional arguments are:
+
+ \fB\-input_dir\fR X  = batch process all PCD files found in input_dir
+
+ \fB\-output_dir\fR X = save the processed files from input_dir in this directory
+.SH AUTHOR
+pcl_fast_bilateral_filter is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_feature_matching.1 b/debian/manpages/pcl_feature_matching.1
new file mode 100644
index 000000000..a632aace3
--- /dev/null
+++ b/debian/manpages/pcl_feature_matching.1
@@ -0,0 +1,43 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_FEATURE_MATCHING "1" "May 2014" "pcl_feature_matching 1.7.1" "User Commands"
+.SH NAME
+pcl_feature_matching \- pcl_feature_matching
+.SH DESCRIPTION
+
+Syntax is: pcl_feature_matching <source\-pcd\-file> <target\-pcd\-file> <keypoint\-method> <descriptor\-type> <surface\-reconstruction\-method>
+
+available <keypoint\-methods>: 1 = Sift3D
+
+2 = Harris3D
+
+3 = Tomasi3D
+
+4 = Noble3D
+
+5 = Lowe3D
+
+6 = Curvature3D
+.PP
+
+available <descriptor\-types>: 1 = FPFH
+
+2 = SHOTRGB
+
+3 = PFH
+
+4 = PFHRGB
+.PP
+
+available <surface\-methods>:  1 = Greedy Projection
+
+2 = Marching Cubes
+.SH AUTHOR
+pcl_feature_matching is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_fpfh_estimation.1 b/debian/manpages/pcl_fpfh_estimation.1
new file mode 100644
index 000000000..0f9f4369e
--- /dev/null
+++ b/debian/manpages/pcl_fpfh_estimation.1
@@ -0,0 +1,26 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_FPFH_ESTIMATION "1" "May 2014" "pcl_fpfh_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_fpfh_estimation \- pcl_fpfh_estimation
+.SH DESCRIPTION
+
+Syntax is: pcl_fpfh_estimation input.pcd output.pcd <options>
+
+
+Estimate FPFH (33) descriptors using pcl::FPFHEstimation. For more information, use: pcl_fpfh_estimation \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X = use a radius of Xm around each point to determine the neighborhood (default: 0.000000)
+
+ \fB\-k\fR X = use a fixed number of X\-nearest neighbors around each point (default: 0)
+.SH AUTHOR
+pcl_fpfh_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_gp3_surface.1 b/debian/manpages/pcl_gp3_surface.1
new file mode 100644
index 000000000..224db0d17
--- /dev/null
+++ b/debian/manpages/pcl_gp3_surface.1
@@ -0,0 +1,25 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_GP3_SURFACE "1" "May 2014" "pcl_gp3_surface 1.7.1" "User Commands"
+.SH NAME
+pcl_gp3_surface \- pcl_gp3_surface
+.SH DESCRIPTION
+Syntax is: pcl_gp3_surface input.pcd output.vtk <options>
+
+Perform surface triangulation using pcl::GreedyProjectionTriangulation. For more information, use: pcl_gp3_surface \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X = use a radius of Xm around each point to determine the neighborhood (default: 0.000000)
+
+ \fB\-mu\fR X= set the multipler of the nearest neighbor distance to obtain the final search radius (default: 0.000000)
+
+.SH AUTHOR
+pcl_gp3_surface is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ground_based_rgbd_people_detector.1 b/debian/manpages/pcl_ground_based_rgbd_people_detector.1
new file mode 100644
index 000000000..738cc1c10
--- /dev/null
+++ b/debian/manpages/pcl_ground_based_rgbd_people_detector.1
@@ -0,0 +1,37 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_GROUND_BASED_RGBD_PEOPLE_DETECTOR "1" "May 2014" "pcl_ground_based_rgbd_people_detector 1.7.1" "User Commands"
+.SH NAME
+pcl_ground_based_rgbd_people_detector \- pcl_ground_based_rgbd_people_detector
+.SH DESCRIPTION
+*******************************************************
+Ground based people detection app options:
+.TP
+\fB\-\-help\fR
+<show_this_help>
+.TP
+\fB\-\-svm\fR
+<path_to_svm_file>
+.TP
+\fB\-\-conf\fR
+<minimum_HOG_confidence (default = \fB\-1\fR.5)>
+.TP
+\fB\-\-min_h\fR
+<minimum_person_height (default = 1.3)>
+.TP
+\fB\-\-max_h\fR
+<maximum_person_height (default = 2.3)>
+.TP
+\fB\-\-sample\fR
+<sampling_factor (default = 1)>
+.PP
+*******************************************************
+.SH AUTHOR
+pcl_ground_based_rgbd_people_detector is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_hdl_viewer_simple.1 b/debian/manpages/pcl_hdl_viewer_simple.1
new file mode 100644
index 000000000..cdba26f69
--- /dev/null
+++ b/debian/manpages/pcl_hdl_viewer_simple.1
@@ -0,0 +1,22 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_HDL_VIEWER_SIMPLE "1" "May 2014" "pcl_hdl_viewer_simple 1.7.1" "User Commands"
+.SH NAME
+pcl_hdl_viewer_simple \- pcl_hdl_viewer_simple
+.SH DESCRIPTION
+usage: pcl_hdl_viewer_simple [\-hdlCalibration <path\-to\-calibration\-file>] [\-pcapFile <path\-to\-pcap\-file>] [\-h |
+
+\fB\-h\fR | \fB\-\-help\fR : shows this help
+
+\fR [\-format XYZ(default)|XYZI|XYZRGB]
+
+
+.SH AUTHOR
+pcl_hdl_viewer_simple is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_image_grabber_saver.1 b/debian/manpages/pcl_image_grabber_saver.1
new file mode 100644
index 000000000..b56d6b119
--- /dev/null
+++ b/debian/manpages/pcl_image_grabber_saver.1
@@ -0,0 +1,31 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_IMAGE_GRABBER_SAVER "1" "May 2014" "pcl_image_grabber_saver 1.7.1" "User Commands"
+.SH NAME
+pcl_image_grabber_saver \- pcl_image_grabber_saver
+.SH DESCRIPTION
+
+Syntax is: pcl_image_grabber_saver <options>
+
+No correct directory was given with the \fB\-out_dir\fR flag. Setting to current dir
+
+No directory was given with the \-<rgb/depth>_dir flag.
+
+ where options are:
+
+   \fB\-rgb_dir\fR   <directory_path>   = directory path to RGB images to be read from
+
+   \fB\-depth_dir\fR <directory_path>   = directory path to Depth images to be read from
+
+   \fB\-out_dir\fR   <directory_path>   = directory path to put the pcd files
+
+
+.SH AUTHOR
+pcl_image_grabber_saver is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_image_grabber_viewer.1 b/debian/manpages/pcl_image_grabber_viewer.1
new file mode 100644
index 000000000..66cb4f4d1
--- /dev/null
+++ b/debian/manpages/pcl_image_grabber_viewer.1
@@ -0,0 +1,48 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_IMAGE_GRABBER_VIEWER "1" "May 2014" "pcl_image_grabber_viewer 1.7.1" "User Commands"
+.SH NAME
+pcl_image_grabber_viewer \- pcl_image_grabber_viewer
+.SH DESCRIPTION
+fps: 0 , repeat: 0
+path:
+No directory was given with the \fB\-dir\fR flag.
+
+Syntax is: pcl_image_grabber_viewer <options>
+
+
+ (*) [Clipping Range / Focal Point / Position / ViewUp / Distance / Window Size / Window Pos] or use a <filename.cam> that contains the same information.
+
+  where options are:
+
+   \fB\-dir\fR directory_path = directory path to image or pclzf file(s) to be read from
+
+   \fB\-fps\fR frequency = frames per second
+
+   \fB\-pclzf\fR    = Load pclzf files instead
+
+   \fB\-repeat\fR   = optional parameter that tells whether the TIFF file(s) should be "grabbed" in a endless loop.
+
+
+
+   \fB\-cam\fR (*)  = use given camera settings as initial view
+
+Additional options:
+
+   \fB\-bc\fR col1 col2 col3  = background color
+
+   \fB\-ax\fR  = use custom coordinate system
+
+   \fB\-ax_pos\fR pos1 pos2 pos3   = the axes coordinates
+
+   \fB\-focal\fR focal_length = ImageGrabber focal length
+
+.SH AUTHOR
+pcl_image_grabber_viewer is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_linemod_detection.1 b/debian/manpages/pcl_linemod_detection.1
new file mode 100644
index 000000000..917444a37
--- /dev/null
+++ b/debian/manpages/pcl_linemod_detection.1
@@ -0,0 +1,18 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_LINEMOD_DETECTION "1" "May 2014" "pcl_linemod_detection 1.7.1" "User Commands"
+.SH NAME
+pcl_linemod_detection \- pcl_linemod_detection
+.SH DESCRIPTION
+
+Train one or more linemod templates. For more information, use: pcl_linemod_detection \fB\-h\fR
+
+.SH AUTHOR
+pcl_linemod_detection is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_marching_cubes_reconstruction.1 b/debian/manpages/pcl_marching_cubes_reconstruction.1
new file mode 100644
index 000000000..225ad8f16
--- /dev/null
+++ b/debian/manpages/pcl_marching_cubes_reconstruction.1
@@ -0,0 +1,35 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_MARCHING_CUBES_RECONSTRUCTION "1" "May 2014" "pcl_marching_cubes_reconstruction 1.7.1" "User Commands"
+.SH NAME
+pcl_marching_cubes_reconstruction \- pcl_marching_cubes_reconstruction
+.SH DESCRIPTION
+
+Syntax is: pcl_marching_cubes_reconstruction input.pcd output.vtk <options>
+
+
+Compute the surface reconstruction of a point cloud using the marching cubes algorithm (pcl::surface::MarchingCubesHoppe or pcl::surface::MarchingCubesRBF. For more information, use: pcl_marching_cubes_reconstruction \fB\-h\fR
+
+  where options are:
+
+ \fB\-grid_res\fR X= the resolution of the grid (cubic grid) (default: 50)
+
+ \fB\-iso_level\fR X    = the iso level of the surface to be extracted (default: 0.000000)
+
+ \fB\-hoppe\fR X   = use the Hoppe signed distance function (MarchingCubesHoppe
+
+ \fB\-rbf\fR X= use the RBF signed distance function (MarchingCubesRBF
+
+ \fB\-extend\fR X  = the percentage of the bounding box to extend the grid by (default: 0.000000)
+
+ \fB\-displacement\fR X = the displacement value for the off\-surface points (only for RBF) (default: 0.010000)
+
+.SH AUTHOR
+pcl_marching_cubes_reconstruction is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_mesh2pcd.1 b/debian/manpages/pcl_mesh2pcd.1
new file mode 100644
index 000000000..e7e3f1f20
--- /dev/null
+++ b/debian/manpages/pcl_mesh2pcd.1
@@ -0,0 +1,28 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_MESH2PCD "1" "May 2014" "pcl_mesh2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_mesh2pcd \- pcl_mesh2pcd
+.SH DESCRIPTION
+
+Syntax is: pcl_mesh2pcd input.{ply,obj} output.pcd <options>
+
+
+Convert a CAD model to a point cloud using ray tracing operations. For more information, use: pcl_mesh2pcd \fB\-h\fR
+
+  where options are:
+
+ \fB\-level\fR X = tesselated sphere level (default: 2)
+
+ \fB\-resolution\fR X = the sphere resolution in angle increments (default: 100 deg)
+
+ \fB\-leaf_size\fR X  = the XYZ leaf size for the VoxelGrid \fB\-\-\fR for data reduction (default: 0.010000 m)
+.SH AUTHOR
+pcl_mesh2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_mesh_sampling.1 b/debian/manpages/pcl_mesh_sampling.1
new file mode 100644
index 000000000..3c546c042
--- /dev/null
+++ b/debian/manpages/pcl_mesh_sampling.1
@@ -0,0 +1,27 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_MESH_SAMPLING "1" "May 2014" "pcl_mesh_sampling 1.7.1" "User Commands"
+.SH NAME
+pcl_mesh_sampling \- pcl_mesh_sampling
+.SH DESCRIPTION
+
+Syntax is: pcl_mesh_sampling input.{ply,obj} output.pcd <options>
+
+
+Convert a CAD model to a point cloud using uniform sampling. For more information, use: pcl_mesh_sampling \fB\-h\fR
+
+  where options are:
+
+ \fB\-n_samples\fR X = number of samples (default: 100000)
+
+ \fB\-leaf_size\fR X  = the XYZ leaf size for the VoxelGrid \fB\-\-\fR for data reduction (default: 0.010000 m)
+
+.SH AUTHOR
+pcl_mesh_sampling is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_mls_smoothing.1 b/debian/manpages/pcl_mls_smoothing.1
new file mode 100644
index 000000000..b1217972f
--- /dev/null
+++ b/debian/manpages/pcl_mls_smoothing.1
@@ -0,0 +1,31 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_MLS_SMOOTHING "1" "May 2014" "pcl_mls_smoothing 1.7.1" "User Commands"
+.SH NAME
+pcl_mls_smoothing \- pcl_mls_smoothing
+.SH DESCRIPTION
+
+Syntax is: pcl_mls_smoothing input.pcd output.pcd <options>
+
+
+Moving Least Squares smoothing of a point cloud. For more information, use: pcl_mls_smoothing \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X= sphere radius to be used for finding the k\-nearest neighbors used for fitting (default: 0.000000)
+
+ \fB\-sqr_gauss_param\fR X = parameter used for the distance based weighting of neighbors (recommended = search_radius^2) (default: 0.000000)
+
+ \fB\-use_polynomial_fit\fR X = decides whether the surface and normal are approximated using a polynomial or only via tangent estimation (default: 0)
+
+ \fB\-polynomial_order\fR X = order of the polynomial to be fit (implicitly, use_polynomial_fit = 1) (default: 2)
+
+.SH AUTHOR
+pcl_mls_smoothing is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_normal_estimation.1 b/debian/manpages/pcl_normal_estimation.1
new file mode 100644
index 000000000..7dd35f74b
--- /dev/null
+++ b/debian/manpages/pcl_normal_estimation.1
@@ -0,0 +1,35 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_NORMAL_ESTIMATION "1" "May 2014" "pcl_normal_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_normal_estimation \- pcl_normal_estimation
+.SH DESCRIPTION
+
+Syntax is: pcl_normal_estimation input.pcd output.pcd <options> [optional_arguments]
+
+
+Estimate surface normals using NormalEstimation. For more information, use: pcl_normal_estimation \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X = use a radius of Xm around each point to determine the neighborhood (default: 0.000000)
+
+ \fB\-k\fR X = use a fixed number of X\-nearest neighbors around each point (default: 0.000000)
+
+ For organized datasets, an IntegralImageNormalEstimation approach will be used, with the RADIUS given value as SMOOTHING SIZE.
+
+
+Optional arguments are:
+
+ \fB\-input_dir\fR X  = batch process all PCD files found in input_dir
+
+ \fB\-output_dir\fR X = save the processed files from input_dir in this directory
+.SH AUTHOR
+pcl_normal_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj2vtk.1 b/debian/manpages/pcl_obj2vtk.1
new file mode 100644
index 000000000..ec6d85ca9
--- /dev/null
+++ b/debian/manpages/pcl_obj2vtk.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ2VTK "1" "May 2014" "pcl_obj2vtk 1.7.1" "User Commands"
+.SH NAME
+pcl_obj2vtk \- pcl_obj2vtk
+.SH DESCRIPTION
+
+Syntax is: pcl_obj2vtk input.obj output.vtk
+
+
+Convert a OBJ file to VTK format. For more information, use: pcl_obj2vtk \fB\-h\fR
+.SH AUTHOR
+pcl_obj2vtk is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_accepted_hypotheses.1 b/debian/manpages/pcl_obj_rec_ransac_accepted_hypotheses.1
new file mode 100644
index 000000000..027da9b24
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_accepted_hypotheses.1
@@ -0,0 +1,25 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_ACCEPTED_HYPOTHESES "1" "May 2014" "pcl_obj_rec_ransac_accepted_hypotheses 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_accepted_hypotheses \- pcl_obj_rec_ransac_accepted_hypotheses
+.SH SYNOPSIS
+obj_rec_ransac_accepted_hypotheses \fI<pair_width> <voxel_size> <max_coplanarity_angle> <n_hypotheses_to_show> <show_hypotheses_as_coordinate_frames>\fR
+
+.SH DESCRIPTION
+.SS "The following parameter values will be used:"
+.IP
+pair_width = 0
+voxel_size = 5
+max_coplanarity_angle = 15
+n_hypotheses_to_show = 1
+
+.SH AUTHOR
+pcl_obj_rec_ransac_accepted_hypotheses is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_model_opps.1 b/debian/manpages/pcl_obj_rec_ransac_model_opps.1
new file mode 100644
index 000000000..ee9d94578
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_model_opps.1
@@ -0,0 +1,19 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_MODEL_OPPS "1" "May 2014" "pcl_obj_rec_ransac_model_opps 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_model_opps \- pcl_obj_rec_ransac_model_opps
+.SH SYNOPSIS
+.B pcl_obj_rec_ransac_model_opps \fI<pair_width> <voxel_size> <max_coplanarity_angle>\fR
+
+the 1\-th parameter has to be positive and not 0.000000
+
+.SH AUTHOR
+pcl_obj_rec_ransac_model_opps is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_orr_octree.1 b/debian/manpages/pcl_obj_rec_ransac_orr_octree.1
new file mode 100644
index 000000000..b8d6f550f
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_orr_octree.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_ORR_OCTREE "1" "May 2014" "pcl_obj_rec_ransac_orr_octree 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_orr_octree \- pcl_obj_rec_ransac_orr_octree
+.SH DESCRIPTION
+Syntax is pcl_obj_rec_ransac_orr_octree <vtk file> <leaf_size>
+
+.SH EXAMPLE:
+pcl_obj_rec_ransac_orr_octree ../../test/tum_rabbit.vtk 6
+
+.SH AUTHOR
+pcl_obj_rec_ransac_orr_octree is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_orr_octree_zprojection.1 b/debian/manpages/pcl_obj_rec_ransac_orr_octree_zprojection.1
new file mode 100644
index 000000000..c1da1908c
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_orr_octree_zprojection.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_ORR_OCTREE_ZPROJECTION "1" "May 2014" "pcl_obj_rec_ransac_orr_octree_zprojection 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_orr_octree_zprojection \- pcl_obj_rec_ransac_orr_octree_zprojection
+.SH DESCRIPTION
+Syntax is ./pcl_obj_rec_ransac_orr_octree_zprojection <vtk file> <leaf_size>
+
+EXAMPLE:
+   ./pcl_obj_rec_ransac_orr_octree_zprojection ../../test/tum_table_scene.vtk 6
+
+.SH AUTHOR
+pcl_obj_rec_ransac_orr_octree_zprojection is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_result.1 b/debian/manpages/pcl_obj_rec_ransac_result.1
new file mode 100644
index 000000000..7fda07f4b
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_result.1
@@ -0,0 +1,19 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_RESULT "1" "May 2014" "pcl_obj_rec_ransac_result 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_result \- pcl_obj_rec_ransac_result
+.SH SYNOPSIS
+pcl_obj_rec_ransac_scene_opps \fI<pair_width> <voxel_size> <max_coplanarity_angle>\fR
+
+the 1\-th parameter has to be positive and not 0.000000
+
+.SH AUTHOR
+pcl_obj_rec_ransac_result is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_obj_rec_ransac_scene_opps.1 b/debian/manpages/pcl_obj_rec_ransac_scene_opps.1
new file mode 100644
index 000000000..cf71a2ad7
--- /dev/null
+++ b/debian/manpages/pcl_obj_rec_ransac_scene_opps.1
@@ -0,0 +1,19 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OBJ_REC_RANSAC_SCENE_OPPS "1" "May 2014" "pcl_obj_rec_ransac_scene_opps 1.7.1" "User Commands"
+.SH NAME
+pcl_obj_rec_ransac_scene_opps \- pcl_obj_rec_ransac_scene_opps
+.SH SYNOPSIS
+pcl_obj_rec_ransac_scene_opps \fR<pair_width> <voxel_size> <max_coplanarity_angle>\fR
+
+the 1\-th parameter has to be positive and not 0.000000
+
+.SH AUTHOR
+pcl_obj_rec_ransac_scene_opps is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_octree_viewer.1 b/debian/manpages/pcl_octree_viewer.1
new file mode 100644
index 000000000..886873fbd
--- /dev/null
+++ b/debian/manpages/pcl_octree_viewer.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OCTREE_VIEWER "1" "May 2014" "pcl_octree_viewer 1.7.1" "User Commands"
+.SH NAME
+pcl_octree_viewer \- pcl_octree_viewer
+.SH DESCRIPTION
+Syntax is octreeVisu <pcd file> <resolution>
+
+.SH EXAMPLE
+   ./octreeVisu bun0.pcd 0.001
+
+.SH AUTHOR
+pcl_octree_viewer is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_oni2pcd.1 b/debian/manpages/pcl_oni2pcd.1
new file mode 100644
index 000000000..6c9735729
--- /dev/null
+++ b/debian/manpages/pcl_oni2pcd.1
@@ -0,0 +1,17 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_ONI2PCD "1" "May 2014" "pcl_oni2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_oni2pcd \- pcl_oni2pcd
+.SH DESCRIPTION
+Convert an ONI file to PCD format. For more information, use: pcl_oni2pcd \fB\-h\fR
+
+.SH AUTHOR
+pcl_oni2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_oni_viewer.1 b/debian/manpages/pcl_oni_viewer.1
new file mode 100644
index 000000000..d41f21b91
--- /dev/null
+++ b/debian/manpages/pcl_oni_viewer.1
@@ -0,0 +1,21 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_ONI_VIEWER "1" "May 2014" "pcl_oni_viewer 1.7.1" "User Commands"
+.SH NAME
+pcl_oni_viewer \- pcl_oni_viewer
+.SH DESCRIPTION
+usage: pcl_oni_viewer <path\-to\-oni\-file> [framerate]
+
+\fB\-h\fR | \fB\-\-help\fR : shows this help
+
+\fB\-xyz\fR   : enable just XYZ data display
+
+.SH AUTHOR
+pcl_oni_viewer is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_3d_concave_hull.1 b/debian/manpages/pcl_openni_3d_concave_hull.1
new file mode 100644
index 000000000..304f7a7f8
--- /dev/null
+++ b/debian/manpages/pcl_openni_3d_concave_hull.1
@@ -0,0 +1,17 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_3D_CONCAVE_HULL "1" "May 2014" "pcl_openni_3d_concave_hull 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_3d_concave_hull \- pcl_openni_3d_concave_hull
+.SH DESCRIPTION
+usage: pcl_openni_3d_concave_hull <device_id> <options>
+
+.SH AUTHOR
+pcl_openni_3d_concave_hull is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_3d_convex_hull.1 b/debian/manpages/pcl_openni_3d_convex_hull.1
new file mode 100644
index 000000000..83bc92bc7
--- /dev/null
+++ b/debian/manpages/pcl_openni_3d_convex_hull.1
@@ -0,0 +1,17 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_3D_CONVEX_HULL "1" "May 2014" "pcl_openni_3d_convex_hull 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_3d_convex_hull \- pcl_openni_3d_convex_hull
+.SH DESCRIPTION
+usage: pcl_openni_3d_convex_hull <device_id> <options>
+
+.SH AUTHOR
+pcl_openni_3d_convex_hull is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_boundary_estimation.1 b/debian/manpages/pcl_openni_boundary_estimation.1
new file mode 100644
index 000000000..850ce909b
--- /dev/null
+++ b/debian/manpages/pcl_openni_boundary_estimation.1
@@ -0,0 +1,17 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_BOUNDARY_ESTIMATION "1" "May 2014" "pcl_openni_boundary_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_boundary_estimation \- pcl_openni_boundary_estimation
+.SH DESCRIPTION
+usage: pcl_openni_boundary_estimation <device_id> <options>
+
+.SH AUTHOR
+pcl_openni_boundary_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_change_viewer.1 b/debian/manpages/pcl_openni_change_viewer.1
new file mode 100644
index 000000000..a40f8de6c
--- /dev/null
+++ b/debian/manpages/pcl_openni_change_viewer.1
@@ -0,0 +1,23 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_CHANGE_VIEWER "1" "May 2014" "pcl_openni_change_viewer 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_change_viewer \- pcl_openni_change_viewer
+.SH DESCRIPTION
+Syntax is pcl_openni_change_viewer [\-r octree resolution] [\-d] [\-n noise_filter intensity]
+
+\fB\-r\fR octree resolution
+
+\fB\-d\fR Undocumented
+
+\fB\-n\fR noise_filter intensity
+
+.SH AUTHOR
+pcl_openni_change_viewer is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_fast_mesh.1 b/debian/manpages/pcl_openni_fast_mesh.1
new file mode 100644
index 000000000..e897bfe9c
--- /dev/null
+++ b/debian/manpages/pcl_openni_fast_mesh.1
@@ -0,0 +1,17 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_FAST_MESH "1" "May 2014" "pcl_openni_fast_mesh 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_fast_mesh \- pcl_openni_fast_mesh
+.SH DESCRIPTION
+usage: pcl_openni_fast_mesh <device_id> <options>
+
+.SH AUTHOR
+pcl_openni_fast_mesh is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_feature_persistence.1 b/debian/manpages/pcl_openni_feature_persistence.1
new file mode 100644
index 000000000..3cdf4487a
--- /dev/null
+++ b/debian/manpages/pcl_openni_feature_persistence.1
@@ -0,0 +1,30 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_FEATURE_PERSISTENCE "1" "May 2014" "pcl_openni_feature_persistence 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_feature_persistence \- pcl_openni_feature_persistence
+.SH DESCRIPTION
+OpenNIFeaturePersistence \- show persistent features based on the MultiscaleFeaturePersistence class using the FPFH features
+
+usage: pcl_openni_feature_persistence <device_id> <options>
+
+.B "where options are:"
+.HP
+\fB\-octree_leaf_size\fR X = size of the leaf for the octree\-based subsampling filter (default: 0.02
+.HP
+\fB\-normal_search_radius\fR X = size of the neighborhood to consider for calculating the local plane and extracting the normals (default: 0.041
+.HP
+\fB\-persistence_alpha\fR X = value of alpha for the multiscale feature persistence (default: 1.2
+.HP
+\fB\-scales\fR X1 X2 ... = values for the multiple scales for extracting features (default: 0.21 0.32
+
+
+.SH AUTHOR
+pcl_openni_feature_persistence is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_ii_normal_estimation.1 b/debian/manpages/pcl_openni_ii_normal_estimation.1
new file mode 100644
index 000000000..bc861a928
--- /dev/null
+++ b/debian/manpages/pcl_openni_ii_normal_estimation.1
@@ -0,0 +1,16 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_II_NORMAL_ESTIMATION "1" "May 2014" "pcl_openni_ii_normal_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_ii_normal_estimation \- pcl_openni_ii_normal_estimation
+.SH DESCRIPTION
+usage: pcl_openni_ii_normal_estimation [<device_id>]
+.SH AUTHOR
+pcl_openni_ii_normal_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_image.1 b/debian/manpages/pcl_openni_image.1
new file mode 100644
index 000000000..163898e5c
--- /dev/null
+++ b/debian/manpages/pcl_openni_image.1
@@ -0,0 +1,54 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_IMAGE "1" "May 2014" "pcl_openni_image 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_image \- pcl_openni_image
+.SH DESCRIPTION
+PCL OpenNI Image Viewer/Recorder.
+.SH SYNOPSIS
+usage: pcl_openni_image [(<device_id> [\-visualize | \fB\-imagemode\fR <mode>] | [\-depthmode <mode>] | [\-depthformat <format>] | \fB\-l\fR [<device_id>]| \fB\-h\fR | \fB\-\-help\fR)]
+
+ \fB\-h\fR | \fB\-\-help\fR : shows this help
+
+ \fB\-l\fR : list all available devices
+
+ \fB\-buf\fR X    : use a buffer size of X frames (default: 322)
+
+ \fB\-visualize\fR 0/1 : turn the visualization off/on (WARNING: when visualization is disabled, data writing is enabled by default!)
+
+ \fB\-l\fR <device\-id> : list all available modes for specified device
+
+.IP
+device_id may be #1, #2, ... for the first, second etc device in the list or
+bus@address for the device connected to a specific usb\-bus / address combination or
+<serial\-number>
+.PP
+.SH EXAMPLES
+pcl_openni_image "#1"
+.IP
+uses the first device.
+.PP
+pcl_openni_image \fB\-l\fR
+.IP
+lists all available devices.
+.PP
+pcl_openni_image \fB\-l\fR "#2"
+.IP
+lists all available modes for the second device
+.PP
+pcl_openni_image A00361800903049A
+.IP
+uses the device with the serial number 'A00361800903049A'.
+.PP
+pcl_openni_image 1@16
+.IP
+uses the device on address 16 at USB bus 1.
+.SH AUTHOR
+pcl_openni_image is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_mls_smoothing.1 b/debian/manpages/pcl_openni_mls_smoothing.1
new file mode 100644
index 000000000..f62955ee5
--- /dev/null
+++ b/debian/manpages/pcl_openni_mls_smoothing.1
@@ -0,0 +1,28 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_MLS_SMOOTHING "1" "May 2014" "pcl_openni_mls_smoothing 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_mls_smoothing \- pcl_openni_mls_smoothing
+.SH DESCRIPTION
+usage: pcl_openni_mls_smoothing <device_id> <options>
+
+.B "where options are:"
+
+\fB\-search_radius\fR X = sphere radius to be used for finding the k\-nearest neighbors used for fitting (default: 0)
+
+\fB\-sqr_gauss_param\fR X = parameter used for the distance based weighting of neighbors (recommended = search_radius^2) (default: 0)
+
+\fB\-use_polynomial_fit\fR X = decides whether the surface and normal are approximated using a polynomial or only via tangent estimation (default: 0)
+
+\fB\-polynomial_order\fR X = order of the polynomial to be fit (implicitly, use_polynomial_fit = 1) (default: 2)
+
+
+.SH AUTHOR
+pcl_openni_mls_smoothing is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_octree_compression.1 b/debian/manpages/pcl_openni_octree_compression.1
new file mode 100644
index 000000000..7a1d7db3a
--- /dev/null
+++ b/debian/manpages/pcl_openni_octree_compression.1
@@ -0,0 +1,85 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_OCTREE_COMPRESSION "1" "May 2014" "pcl_openni_octree_compression 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_octree_compression \- pcl_openni_octree_compression
+.SH DESCRIPTION
+Please specify compression mode..
+.IP
+PCL octree point cloud compression
+.IP
+usage: ./pcl_openni_octree_compression [mode] [profile] [parameters]
+.IP
+I/O:
+.TP
+\fB\-f\fR file
+: file name
+.IP
+file compression mode:
+.HP
+\fB\-x\fR: encode point cloud stream to file
+.HP
+\fB\-d\fR: decode from file and display point cloud stream
+.IP
+network streaming mode:
+.TP
+\fB\-s\fR
+: start server on localhost
+.TP
+\fB\-c\fR host
+: connect to server and display decoded cloud stream
+.IP
+optional compression profile:
+.TP
+\fB\-p\fR profile : select compression profile:
+\-"lowC"  Low resolution with color
+\-"lowNC" Low resolution without color
+\-"medC" Medium resolution with color
+\-"medNC" Medium resolution without color
+\-"highC" High resolution with color
+\-"highNC" High resolution without color
+.IP
+optional compression parameters:
+.TP
+\fB\-r\fR prec
+: point precision Hz
+.TP
+\fB\-o\fR prec
+: octree voxel size
+.TP
+\fB\-v\fR
+: enable voxel\-grid downsampling
+.TP
+\fB\-a\fR
+: enable color coding
+.TP
+\fB\-i\fR rate
+: i\-frame rate
+.TP
+\fB\-b\fR bits
+: bits/color component
+.TP
+\fB\-t\fR
+: output statistics
+.TP
+\fB\-e\fR
+: show input cloud during encoding
+.TP
+\fB\-minmax\fR min\-max
+:: set the PassThrough min\-max cutting values (default: 0\-3.0)
+.TP
+\fB\-field\fR
+X   :: set the PassThrough field/dimension 'X' to filter data on (default: 'z')
+.IP
+example:
+.IP
+\&./pcl_openni_octree_compression \fB\-x\fR \fB\-p\fR highC \fB\-t\fR \fB\-f\fR pc_compressed.pcc
+.SH AUTHOR
+pcl_openni_octree_compression is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_organized_compression.1 b/debian/manpages/pcl_openni_organized_compression.1
new file mode 100644
index 000000000..dc8835155
--- /dev/null
+++ b/debian/manpages/pcl_openni_organized_compression.1
@@ -0,0 +1,60 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_ORGANIZED_COMPRESSION "1" "May 2014" "pcl_openni_organized_compression 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_organized_compression \- pcl_openni_organized_compression
+.SH DESCRIPTION
+Please specify compression mode..
+.IP
+PCL organized point cloud stream compression
+.IP
+usage: ./pcl_openni_organized_compression [mode] [parameters]
+.IP
+I/O:
+.TP
+\fB\-f\fR file
+: file name
+.IP
+file compression mode:
+.HP
+\fB\-x\fR: encode point cloud stream to file
+.HP
+\fB\-d\fR: decode from file and display point cloud stream
+.IP
+network streaming mode:
+.TP
+\fB\-s\fR
+: start server on localhost
+.TP
+\fB\-c\fR host
+: connect to server and display decoded cloud stream
+.IP
+optional compression parameters:
+.TP
+\fB\-a\fR
+: enable color coding
+.TP
+\fB\-t\fR
+: output statistics
+.TP
+\fB\-e\fR
+: show input cloud during encoding
+.TP
+\fB\-r\fR
+: raw encoding of disparity maps
+.TP
+\fB\-g\fR
+: gray scale conversion
+.IP
+example:
+.IP
+\&./pcl_openni_organized_compression \fB\-x\fR \fB\-t\fR \fB\-f\fR pc_compressed.pcc
+.SH AUTHOR
+pcl_openni_organized_compression is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_pcd_recorder.1 b/debian/manpages/pcl_openni_pcd_recorder.1
new file mode 100644
index 000000000..ce2be5fe3
--- /dev/null
+++ b/debian/manpages/pcl_openni_pcd_recorder.1
@@ -0,0 +1,31 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_PCD_RECORDER "1" "May 2014" "pcl_openni_pcd_recorder 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_pcd_recorder \- pcl_openni_pcd_recorder
+.SH DESCRIPTION
+
+Total available memory size: 201MB.
+^[[1;32m>
+PCL OpenNI Recorder for saving buffered PCD (binary compressed to disk). See pcl_openni_pcd_recorder \fB\-h\fR for options.
+
+Options are:
+.TP
+\fB\-xyz\fR
+= save only XYZ data, even if the device is RGB capable
+.TP
+\fB\-shift\fR
+= use OpenNI shift values rather than 12\-bit depth
+.TP
+\fB\-buf\fR X
+= use a buffer size of X frames (default: 687)
+
+.SH AUTHOR
+pcl_openni_pcd_recorder is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_planar_convex_hull.1 b/debian/manpages/pcl_openni_planar_convex_hull.1
new file mode 100644
index 000000000..6751a00ff
--- /dev/null
+++ b/debian/manpages/pcl_openni_planar_convex_hull.1
@@ -0,0 +1,22 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_PLANAR_CONVEX_HULL "1" "May 2014" "pcl_openni_planar_convex_hull 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_planar_convex_hull \- pcl_openni_planar_convex_hull
+.SH DESCRIPTION
+usage: pcl_openni_planar_convex_hull <device_id> <options>
+.SS "where options are:"
+.TP
+\fB\-thresh\fR X
+:: set the planar segmentation threshold (default: 0.5)
+.PP
+No devices connected.
+.SH AUTHOR
+pcl_openni_planar_convex_hull is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_planar_segmentation.1 b/debian/manpages/pcl_openni_planar_segmentation.1
new file mode 100644
index 000000000..c05c1abd9
--- /dev/null
+++ b/debian/manpages/pcl_openni_planar_segmentation.1
@@ -0,0 +1,22 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_PLANAR_SEGMENTATION "1" "May 2014" "pcl_openni_planar_segmentation 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_planar_segmentation \- pcl_openni_planar_segmentation
+.SH DESCRIPTION
+usage: pcl_openni_planar_segmentation <device_id> <options>
+.SS "where options are:"
+.TP
+\fB\-thresh\fR X
+:: set the planar segmentation threshold (default: 0.5)
+.PP
+No devices connected.
+.SH AUTHOR
+pcl_openni_planar_segmentation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_save_image.1 b/debian/manpages/pcl_openni_save_image.1
new file mode 100644
index 000000000..8ac9df6c9
--- /dev/null
+++ b/debian/manpages/pcl_openni_save_image.1
@@ -0,0 +1,48 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_SAVE_IMAGE "1" "May 2014" "pcl_openni_save_image 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_save_image \- pcl_openni_save_image
+.SH DESCRIPTION
+usage: pcl_openni_save_image [((<device_id> | <path\-to\-oni\-file>) [\-imagemode <mode>] | \fB\-l\fR [<device_id>]| \fB\-h\fR | \fB\-\-help\fR)]
+pcl_openni_save_image \fB\-h\fR | \fB\-\-help\fR : shows this help
+pcl_openni_save_image \fB\-l\fR : list all available devices
+pcl_openni_save_image \fB\-l\fR <device\-id> : list all available modes for specified device
+.IP
+device_id may be #1, #2, ... for the first, second etc device in the list or
+bus@address for the device connected to a specific usb\-bus / address combination or
+<serial\-number>
+.PP
+examples:
+pcl_openni_save_image "#1"
+.IP
+uses the first device.
+.PP
+pcl_openni_save_image "./temp/test.oni"
+.IP
+uses the oni\-player device to play back oni file given by path.
+.PP
+pcl_openni_save_image \fB\-l\fR
+.IP
+lists all available devices.
+.PP
+pcl_openni_save_image \fB\-l\fR "#2"
+.IP
+lists all available modes for the second device
+.PP
+pcl_openni_save_image A00361800903049A
+.IP
+uses the device with the serial number 'A00361800903049A'.
+.PP
+pcl_openni_save_image 1@16
+.IP
+uses the device on address 16 at USB bus 1.
+.SH AUTHOR
+pcl_openni_save_image is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_tracking.1 b/debian/manpages/pcl_openni_tracking.1
new file mode 100644
index 000000000..026393981
--- /dev/null
+++ b/debian/manpages/pcl_openni_tracking.1
@@ -0,0 +1,27 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_TRACKING "1" "May 2014" "pcl_openni_tracking 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_tracking \- pcl_openni_tracking
+.SH DESCRIPTION
+usage: pcl_openni_tracking <device_id> [\-C] [\-g]
+.TP
+\fB\-C\fR:
+initialize the pointcloud to track without plane segmentation
+.HP
+\fB\-D\fR: visualizing with non\-downsampled pointclouds.
+.HP
+\fB\-P\fR: not visualizing particle cloud.
+.HP
+\fB\-fixed\fR: use the fixed number of the particles.
+.HP
+\fB\-d\fR <value>: specify the grid size of downsampling (defaults to 0.01).
+.SH AUTHOR
+pcl_openni_tracking is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_uniform_sampling.1 b/debian/manpages/pcl_openni_uniform_sampling.1
new file mode 100644
index 000000000..6b153b86c
--- /dev/null
+++ b/debian/manpages/pcl_openni_uniform_sampling.1
@@ -0,0 +1,22 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_UNIFORM_SAMPLING "1" "May 2014" "pcl_openni_uniform_sampling 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_uniform_sampling \- pcl_openni_uniform_sampling
+.SH DESCRIPTION
+usage: pcl_openni_uniform_sampling <device_id> <options>
+.SS "where options are:"
+.TP
+\fB\-leaf\fR X
+:: set the UniformSampling leaf size (default: 0.01)
+.PP
+No devices connected.
+.SH AUTHOR
+pcl_openni_uniform_sampling is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_openni_viewer.1 b/debian/manpages/pcl_openni_viewer.1
new file mode 100644
index 000000000..a65abdcad
--- /dev/null
+++ b/debian/manpages/pcl_openni_viewer.1
@@ -0,0 +1,59 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OPENNI_VIEWER "1" "May 2014" "pcl_openni_viewer 1.7.1" "User Commands"
+.SH NAME
+pcl_openni_viewer \- pcl_openni_viewer
+.SH DESCRIPTION
+
+Syntax is: pcl_openni_viewer [((<device_id> | <path\-to\-oni\-file>) [\-depthmode <mode>] [\-imagemode <mode>] [\-xyz] | \fB\-l\fR [<device_id>]| \fB\-h\fR | \fB\-\-help\fR)]
+
+
+pcl_openni_viewer \fB\-h\fR | \fB\-\-help\fR : shows this help
+
+pcl_openni_viewer \fB\-xyz\fR : use only XYZ values and ignore RGB components (this flag is required for use with ASUS Xtion Pro)
+
+pcl_openni_viewer \fB\-l\fR : list all available devices
+
+pcl_openni_viewer \fB\-l\fR <device\-id> :list all available modes for specified device
+
+ <device_id> may be "#1", "#2", ... for the first, second etc device in the list
+
+bus@address for the device connected to a specific usb\-bus / address combination
+
+<serial\-number>
+
+
+.SH EXAMPLES
+
+pcl_openni_viewer "#1"
+
+  uses the first device.
+
+pcl_openni_viewer  "./temp/test.oni"
+
+  uses the oni\-player device to play back oni file given by path.
+
+pcl_openni_viewer \fB\-l\fR
+
+  list all available devices.
+
+pcl_openni_viewer \fB\-l\fR "#2"
+
+  list all available modes for the second device.
+
+pcl_openni_viewer A00361800903049A
+
+  uses the device with the serial number 'A00361800903049A'.
+
+pcl_openni_viewer 1@16
+
+  uses the device on address 16 at USB bus 1.
+.SH AUTHOR
+pcl_openni_viewer is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_outlier_removal.1 b/debian/manpages/pcl_outlier_removal.1
new file mode 100644
index 000000000..0947fc245
--- /dev/null
+++ b/debian/manpages/pcl_outlier_removal.1
@@ -0,0 +1,37 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_OUTLIER_REMOVAL "1" "May 2014" "pcl_outlier_removal 1.7.1" "User Commands"
+.SH NAME
+pcl_outlier_removal \- pcl_outlier_removal
+.SH DESCRIPTION
+
+Syntax is: pcl_outlier_removal input.pcd output.pcd <options>
+
+
+Statistical Outlier Removal filtering of a point cloud. For more information, use: pcl_outlier_removal \fB\-h\fR
+
+  where options are:
+
+ \fB\-method\fR X = the outlier removal method to be used (options: radius / statistical) (default: radius)
+
+ \fB\-radius\fR X = (RadiusOutlierRemoval) the sphere radius used for determining the k\-nearest neighbors (default: 0)
+
+ \fB\-min_pts\fR X = (RadiusOutlierRemoval) the minimum number of neighbors that a point needs to have in the given search radius in order to be considered an inlier (default: 0)
+
+ \fB\-mean_k\fR X = (StatisticalOutlierRemoval only) the number of points to use for mean distance estimation (default: 2)
+
+ \fB\-std_dev_mul\fR X = (StatisticalOutlierRemoval only) the standard deviation multiplier threshold (default: 0.000000)
+
+ \fB\-negative\fR X = decides whether the inliers should be returned (1), or the outliers (0). (default: 0)
+
+ \fB\-keep_organized\fR = keep the filtered points in organized format.
+
+.SH AUTHOR
+pcl_outlier_removal is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_passthrough_filter.1 b/debian/manpages/pcl_passthrough_filter.1
new file mode 100644
index 000000000..d545d2474
--- /dev/null
+++ b/debian/manpages/pcl_passthrough_filter.1
@@ -0,0 +1,33 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PASSTHROUGH_FILTER "1" "May 2014" "pcl_passthrough_filter 1.7.1" "User Commands"
+.SH NAME
+pcl_passthrough_filter \- pcl_passthrough_filter
+.SH DESCRIPTION
+
+Syntax is: pcl_passthrough_filter input.pcd output.pcd <options>
+
+
+Filter a point cloud using the pcl::PassThroughFilterEstimate. For more information, use: pcl_passthrough_filter \fB\-h\fR
+
+  where options are:
+
+ \fB\-field\fR X = the field of the point cloud we want to apply the filter to (default: z)
+
+ \fB\-min\fR X = lower limit of the filter (default: 0.000000)
+
+ \fB\-max\fR X = upper limit of the filter (default: 1.000000)
+
+ \fB\-inside\fR X = keep the points inside the [min, max] interval or not (default: 1)
+
+ \fB\-keep\fR 0/1 = keep the points organized (1) or not (default: 1)
+
+.SH AUTHOR
+pcl_passthrough_filter is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd2ply.1 b/debian/manpages/pcl_pcd2ply.1
new file mode 100644
index 000000000..9051321d7
--- /dev/null
+++ b/debian/manpages/pcl_pcd2ply.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD2PLY "1" "May 2014" "pcl_pcd2ply 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd2ply \- pcl_pcd2ply
+.SH DESCRIPTION
+
+Syntax is: pcl_pcd2ply [\-format 0|1] [\-use_camera 0|1] input.pcd output.ply
+
+
+Convert a PCD file to PLY format. For more information, use: pcl_pcd2ply \fB\-h\fR
+.SH AUTHOR
+pcl_pcd2ply is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd2png.1 b/debian/manpages/pcl_pcd2png.1
new file mode 100644
index 000000000..36e6c3dca
--- /dev/null
+++ b/debian/manpages/pcl_pcd2png.1
@@ -0,0 +1,54 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD2PNG "1" "May 2014" "pcl_pcd2png 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd2png \- pcl_pcd2png
+.SH SYNOPSIS
+.B pcl_pcd2png
+[\fIOptions\fR] \fIinput.pcd output.png\fR
+.SH DESCRIPTION
+
+Convert a PCD file to PNG format.
+.SH OPTIONS
+.TP
+\fB\-\-help\fR
+: Show this help
+.TP
+\fB\-\-field\fR
+: Set the field to extract data from. Supported fields:
+.IP
+\- normal
+* rgb (default)
+\- label
+\- z
+\- curvature
+\- intensity
+.TP
+\fB\-\-scale\fR
+: Apply scaling to extracted data (only for z, curvature, and
+.IP
+intensity fields). Supported options:
+\- <float> : Scale by a fixed number
+\- auto    : Auto\-scale to the full range
+\- no : No scaling
+If the option is omitted then default scaling (depends on
+the field type) will be used.
+.HP
+\fB\-\-colors\fR : Choose color mapping mode for labels (only for label
+.IP
+field). Supported options:
+* mono    : Use shades of gray (default)
+\- rgb: Use randomly generated RGB colors
+.PP
+Note: The converter will try to use RGB field if '\-\-field' option is not
+.IP
+supplied.
+.SH AUTHOR
+pcl_pcd2png is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd2vtk.1 b/debian/manpages/pcl_pcd2vtk.1
new file mode 100644
index 000000000..35a1e5488
--- /dev/null
+++ b/debian/manpages/pcl_pcd2vtk.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD2VTK "1" "May 2014" "pcl_pcd2vtk 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd2vtk \- pcl_pcd2vtk
+.SH DESCRIPTION
+
+Syntax is: pcl_pcd2vtk input.pcd output.vtk
+
+
+Convert a PCD file to VTK format. For more information, use: pcl_pcd2vtk \fB\-h\fR
+.SH AUTHOR
+pcl_pcd2vtk is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd_change_viewpoint.1 b/debian/manpages/pcl_pcd_change_viewpoint.1
new file mode 100644
index 000000000..925d44a5a
--- /dev/null
+++ b/debian/manpages/pcl_pcd_change_viewpoint.1
@@ -0,0 +1,24 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD_CHANGE_VIEWPOINT "1" "May 2014" "pcl_pcd_change_viewpoint 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd_change_viewpoint \- pcl_pcd_change_viewpoint
+.SH DESCRIPTION
+
+Syntax is: pcl_pcd_change_viewpoint input.pcd output.pcd <options>
+
+
+Change viewpoint information in a PCD file. For more information, use: pcl_pcd_change_viewpoint \fB\-h\fR
+
+  where options are:
+
+ \fB\-viewpoint\fR Tx,Ty,Tz,Qw,Qx,Qy,Qz
+.SH AUTHOR
+pcl_pcd_change_viewpoint is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd_convert_NaN_nan.1 b/debian/manpages/pcl_pcd_convert_NaN_nan.1
new file mode 100644
index 000000000..80d6beb60
--- /dev/null
+++ b/debian/manpages/pcl_pcd_convert_NaN_nan.1
@@ -0,0 +1,16 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD_CONVERT_NAN_NAN "1" "May 2014" "pcl_pcd_convert_NaN_nan 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd_convert_NaN_nan \- pcl_pcd_convert_NaN_nan
+.SH DESCRIPTION
+call with pcl_pcd_convert_NaN_nan input.pcd output.pcd
+.SH AUTHOR
+pcl_pcd_convert_NaN_nan is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pcd_grabber_viewer.1 b/debian/manpages/pcl_pcd_grabber_viewer.1
new file mode 100644
index 000000000..6dcc3db0e
--- /dev/null
+++ b/debian/manpages/pcl_pcd_grabber_viewer.1
@@ -0,0 +1,53 @@
+.TH PCL 1
+
+.SH NAME
+
+pcd_grabber_viewer \- Grab point cloud data from PCD file.
+
+.SH SYNOPSIS
+
+.B pcd_grabber_viewer [OPTIONS]
+
+.SH DESCRIPTION
+
+Grab point cloud data from PCD file.
+
+.SH OPTIONS
+
+.TP 5
+\-file file_name
+PCD file to be read from
+
+.TP 5
+\-dir directory_path
+directory path to PCD file(s) to be read from
+
+.TP 5
+\-fps frequency
+frames per second
+
+.TP 5
+\-repeat
+optional parameter that tells whether the PCD file(s) should be "grabbed" in a endless loop.
+
+.TP 5
+\-cam (*)
+use given camera settings as initial view
+ (*) [Clipping Range / Focal Point / Position / ViewUp / Distance /
+ Window Size / Window Pos] or use a <filename.cam> that contains the
+ same information.
+
+.TP 5
+\-h
+display help message
+
+
+.SH SEE ALSO
+
+.TP
+.B Home Page
+http://www.pointclouds.org/
+
+.SH AUTHOR
+
+Willow Garage, Inc. and Open Perception, Inc.
diff --git a/debian/manpages/pcl_pcd_select_object_plane.1 b/debian/manpages/pcl_pcd_select_object_plane.1
new file mode 100644
index 000000000..10a5f1d52
--- /dev/null
+++ b/debian/manpages/pcl_pcd_select_object_plane.1
@@ -0,0 +1,19 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCD_SELECT_OBJECT_PLANE "1" "May 2014" "pcl_pcd_select_object_plane 1.7.1" "User Commands"
+.SH NAME
+pcl_pcd_select_object_plane \- pcl_pcd_select_object_plane
+.SH DESCRIPTION
+Ideally, need an input file, and three output PCD files, e.g., object.pcd, plane.pcd, rest.pcd.
+Need at least an input PCD file (e.g. scene.pcd).
+
+
+.SH AUTHOR
+pcl_pcd_select_object_plane is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_pclzf2pcd.1 b/debian/manpages/pcl_pclzf2pcd.1
new file mode 100644
index 000000000..b1c8b25d7
--- /dev/null
+++ b/debian/manpages/pcl_pclzf2pcd.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PCLZF2PCD "1" "May 2014" "pcl_pclzf2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_pclzf2pcd \- pcl_pclzf2pcd
+.SH DESCRIPTION
+
+Syntax is: pcl_pclzf2pcd depth.pclzf rgb.pclzf parameters.xml output.pcd
+
+
+Convert a pair of PCLZF files (depth, rgb) to PCD format. For more information, use: pcl_pclzf2pcd \fB\-h\fR
+.SH AUTHOR
+pcl_pclzf2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_plane_projection.1 b/debian/manpages/pcl_plane_projection.1
new file mode 100644
index 000000000..2428fc200
--- /dev/null
+++ b/debian/manpages/pcl_plane_projection.1
@@ -0,0 +1,24 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLANE_PROJECTION "1" "May 2014" "pcl_plane_projection 1.7.1" "User Commands"
+.SH NAME
+pcl_plane_projection \- pcl_plane_projection
+.SH DESCRIPTION
+
+Syntax is: pcl_plane_projection input.pcd output.pcd A B C D
+
+
+Estimate surface normals using pcl::NormalEstimation. For more information, use: pcl_plane_projection \fB\-h\fR
+
+  where the plane is represented by the following equation:
+
+ Ax + By + Cz + D = 0
+.SH AUTHOR
+pcl_plane_projection is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ply2obj.1 b/debian/manpages/pcl_ply2obj.1
new file mode 100644
index 000000000..8e6cceb05
--- /dev/null
+++ b/debian/manpages/pcl_ply2obj.1
@@ -0,0 +1,46 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLY2OBJ "1" "May 2014" "pcl_ply2obj 1.7.1" "User Commands"
+.SH NAME
+pcl_ply2obj \- pcl_ply2obj
+.SH SYNOPSIS
+.B ply2obj
+[\fIOPTION\fR] [[\fIINFILE\fR] \fIOUTFILE\fR]
+.SH DESCRIPTION
+Convert a PLY file to an OBJ file.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.TP
+\fB\-f\fR, \fB\-\-flag\fR=\fIFLAG\fR
+set flag
+.PP
+FLAG may be one of the following: triangulate.
+.PP
+With no INFILE/OUTFILE, or when INFILE/OUTFILE is \-, read standard input/output.
+.PP
+The following PLY elements and properties are supported.
+.IP
+element vertex
+.IP
+property float32 x
+property float32 y
+property float32 z
+.IP
+element face
+.IP
+property list uint8 int32 vertex_indices.
+.SH "REPORTING BUGS"
+Report bugs to <www.pointclouds.org/issues>.
+.SH AUTHOR
+pcl_ply2obj is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ply2pcd.1 b/debian/manpages/pcl_ply2pcd.1
new file mode 100644
index 000000000..07824151f
--- /dev/null
+++ b/debian/manpages/pcl_ply2pcd.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLY2PCD "1" "May 2014" "pcl_ply2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_ply2pcd \- pcl_ply2pcd
+.SH DESCRIPTION
+
+Syntax is: pcl_ply2pcd input.ply output.pcd
+
+
+Convert a PLY file to PCD format. For more information, use: pcl_ply2pcd \fB\-h\fR
+.SH AUTHOR
+pcl_ply2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ply2ply.1 b/debian/manpages/pcl_ply2ply.1
new file mode 100644
index 000000000..ecdca8520
--- /dev/null
+++ b/debian/manpages/pcl_ply2ply.1
@@ -0,0 +1,36 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLY2PLY "1" "May 2014" "pcl_ply2ply 1.7.1" "User Commands"
+.SH NAME
+pcl_ply2ply \- pcl_ply2ply
+.SH SYNOPSIS
+.B ply2ply
+[\fIOPTION\fR] [[\fIINFILE\fR] \fIOUTFILE\fR]
+.SH DESCRIPTION
+Parse an PLY file.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.TP
+\fB\-f\fR, \fB\-\-format\fR=\fIFORMAT\fR
+set format
+.PP
+FORMAT may be one of the following: ascii, binary, binary_big_endian,
+binary_little_endian.
+If no format is given, the format of INFILE is kept.
+.PP
+With no INFILE/OUTFILE, or when INFILE/OUTFILE is \-, read standard input/output.
+.SH "REPORTING BUGS"
+Report bugs to <www.pointclouds.org/issues>.
+.SH AUTHOR
+pcl_ply2ply is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ply2raw.1 b/debian/manpages/pcl_ply2raw.1
new file mode 100644
index 000000000..6edd7aaea
--- /dev/null
+++ b/debian/manpages/pcl_ply2raw.1
@@ -0,0 +1,41 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLY2RAW "1" "May 2014" "pcl_ply2raw 1.7.1" "User Commands"
+.SH NAME
+pcl_ply2raw \- pcl_ply2raw
+.SH SYNOPSIS
+.B ply2raw
+[\fIOPTION\fR] [[\fIINFILE\fR] \fIOUTFILE\fR]
+.SH DESCRIPTION
+Convert from PLY to POV\-Ray RAW triangle format.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.PP
+With no INFILE/OUTFILE, or when INFILE/OUTFILE is \-, read standard input/output.
+.PP
+The following PLY elements and properties are supported.
+.IP
+element vertex
+.IP
+property float32 x
+property float32 y
+property float32 z
+.IP
+element face
+.IP
+property list uint8 int32 vertex_indices.
+.SH "REPORTING BUGS"
+Report bugs to <www.pointclouds.org/issues>.
+.SH AUTHOR
+pcl_ply2raw is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ply2vtk.1 b/debian/manpages/pcl_ply2vtk.1
new file mode 100644
index 000000000..dc4423d99
--- /dev/null
+++ b/debian/manpages/pcl_ply2vtk.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLY2VTK "1" "May 2014" "pcl_ply2vtk 1.7.1" "User Commands"
+.SH NAME
+pcl_ply2vtk \- pcl_ply2vtk
+.SH DESCRIPTION
+
+Syntax is: pcl_ply2vtk input.ply output.vtk
+
+
+Convert a PLY file to VTK format. For more information, use: pcl_ply2vtk \fB\-h\fR
+.SH AUTHOR
+pcl_ply2vtk is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_plyheader.1 b/debian/manpages/pcl_plyheader.1
new file mode 100644
index 000000000..f8296ac5e
--- /dev/null
+++ b/debian/manpages/pcl_plyheader.1
@@ -0,0 +1,29 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PLYHEADER "1" "May 2014" "pcl_plyheader 1.7.1" "User Commands"
+.SH NAME
+pcl_plyheader \- pcl_plyheader
+.SH SYNOPSIS
+.B plyheader
+[\fIOPTION\fR] [[\fIINFILE\fR] \fIOUTFILE\fR]
+.SH DESCRIPTION
+Extract the header from a PLY file.
+.TP
+\fB\-h\fR, \fB\-\-help\fR
+display this help and exit
+.TP
+\fB\-v\fR, \fB\-\-version\fR
+output version information and exit
+.PP
+With no INFILE/OUTFILE, or when INFILE/OUTFILE is \-, read standard input/output.
+.SH "REPORTING BUGS"
+Report bugs to <www.pointclouds.org/issues>.
+.SH AUTHOR
+pcl_plyheader is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_png2pcd.1 b/debian/manpages/pcl_png2pcd.1
new file mode 100644
index 000000000..5878332d5
--- /dev/null
+++ b/debian/manpages/pcl_png2pcd.1
@@ -0,0 +1,34 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PNG2PCD "1" "May 2014" "pcl_png2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_png2pcd \- pcl_png2pcd
+.SH SYNOPSIS
+.B pcl_png2pcd
+[\fIOptions\fR] \fIinput.png output.pcd\fR
+.SH DESCRIPTION
+
+Convert a PNG file to PCD format. For more information, use: pcl_png2pcd \fB\-h\fR
+.PP
+.SH OPTIONS
+.TP
+\fB\-h\fR:
+Show this help.
+.TP
+\fB\-format\fR 0 | 1:
+Set the format of the output pcd file.
+.TP
+\fB\-mode\fR DEFAULT | FORCE_COLOR | FORCE_GRAYSCALE:
+Set the working mode of the converter.
+.TP
+\fB\-\-intensity_type\fR: FLOAT | UINT_8
+Set the desired intensity type
+.SH AUTHOR
+pcl_png2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_poisson_reconstruction.1 b/debian/manpages/pcl_poisson_reconstruction.1
new file mode 100644
index 000000000..547e98bcd
--- /dev/null
+++ b/debian/manpages/pcl_poisson_reconstruction.1
@@ -0,0 +1,30 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_POISSON_RECONSTRUCTION "1" "May 2014" "pcl_poisson_reconstruction 1.7.1" "User Commands"
+.SH NAME
+pcl_poisson_reconstruction \- pcl_poisson_reconstruction
+.SH DESCRIPTION
+
+Syntax is: pcl_poisson_reconstruction input.pcd output.vtk <options>
+
+
+Compute the surface reconstruction of a point cloud using the Poisson surface reconstruction (pcl::surface::Poisson). For more information, use: pcl_poisson_reconstruction \fB\-h\fR
+
+  where options are:
+
+ \fB\-depth\fR X= set the maximum depth of the tree that will be used for surface reconstruction (default: 8)
+
+ \fB\-solver_divide\fR X  = set the the depth at which a block Gauss\-Seidel solver is used to solve the Laplacian equation (default: 8)
+
+ \fB\-iso_divide\fR X= Set the depth at which a block iso\-surface extractor should be used to extract the iso\-surface (default: 8)
+
+ \fB\-point_weight\fR X   = Specifies the importance that interpolation of the point samples is given in the formulation of the screened Poisson equation. The results of the original (unscreened) Poisson Reconstruction can be obtained by setting this value to 0. (default: 4.000000)
+.SH AUTHOR
+pcl_poisson_reconstruction is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_ppf_object_recognition.1 b/debian/manpages/pcl_ppf_object_recognition.1
new file mode 100644
index 000000000..e2f04b144
--- /dev/null
+++ b/debian/manpages/pcl_ppf_object_recognition.1
@@ -0,0 +1,19 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_PPF_OBJECT_RECOGNITION "1" "May 2014" "pcl_ppf_object_recognition 1.7.1" "User Commands"
+.SH NAME
+pcl_ppf_object_recognition \- pcl_ppf_object_recognition
+.SH DESCRIPTION
+
+Syntax: ./ppf_object_recognition pcd_model_list pcd_scene
+
+
+.SH AUTHOR
+pcl_ppf_object_recognition is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_sac_segmentation_plane.1 b/debian/manpages/pcl_sac_segmentation_plane.1
new file mode 100644
index 000000000..ac15e5ff7
--- /dev/null
+++ b/debian/manpages/pcl_sac_segmentation_plane.1
@@ -0,0 +1,35 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_SAC_SEGMENTATION_PLANE "1" "May 2014" "pcl_sac_segmentation_plane 1.7.1" "User Commands"
+.SH NAME
+pcl_sac_segmentation_plane \- pcl_sac_segmentation_plane
+.SH DESCRIPTION
+
+Syntax is: pcl_sac_segmentation_plane input.pcd output.pcd <options> [optional_arguments]
+
+
+Estimate the largest planar component using SACSegmentation. For more information, use: pcl_sac_segmentation_plane \fB\-h\fR
+
+  where options are:
+
+ \fB\-thresh\fR X = set the inlier threshold from the plane to (default: 0.05)
+
+ \fB\-max_it\fR X = set the maximum number of RANSAC iterations to X (default: 1000)
+
+ \fB\-neg\fR 0/1  = if true (1), instead of the plane, it returns the largest cluster on top of the plane (default: false)
+
+
+Optional arguments are:
+
+ \fB\-input_dir\fR X  = batch process all PCD files found in input_dir
+
+ \fB\-output_dir\fR X = save the processed files from input_dir in this directory
+.SH AUTHOR
+pcl_sac_segmentation_plane is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_spin_estimation.1 b/debian/manpages/pcl_spin_estimation.1
new file mode 100644
index 000000000..85ac130be
--- /dev/null
+++ b/debian/manpages/pcl_spin_estimation.1
@@ -0,0 +1,35 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_SPIN_ESTIMATION "1" "May 2014" "pcl_spin_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_spin_estimation \- pcl_spin_estimation
+.SH DESCRIPTION
+
+Syntax is: pcl_spin_estimation input.pcd output.pcd <options>
+
+
+Estimate spin\-image descriptors using pcl::SpinEstimation. For more information, use: pcl_spin_estimation \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X= use a radius of Xm around each point to determine the neighborhood (default: 0.000000)
+
+ \fB\-width\fR X = resolution (width) of a spin\-image (default: 8)
+
+ \fB\-suppangle\fR X  = min cosine of support angle for filtering points by normals (default: 0.500000)
+
+ \fB\-neigh\fR X = min number of neighbours to compute a spin\-image (default: 1)
+
+ \fB\-radial\fR   = toggles radial structure of a spin\-image (default: false)
+
+ \fB\-angular\fR  = toggles angular domain of a spin\-image (default: false)
+
+.SH AUTHOR
+pcl_spin_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_test_search_speed.1 b/debian/manpages/pcl_test_search_speed.1
new file mode 100644
index 000000000..31eb1c58e
--- /dev/null
+++ b/debian/manpages/pcl_test_search_speed.1
@@ -0,0 +1,16 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_TEST_SEARCH_SPEED "1" "May 2014" "pcl_test_search_speed 1.7.1" "User Commands"
+.SH NAME
+pcl_test_search_speed \- pcl_test_search_speed
+.SH DESCRIPTION
+please specify at least one of the options \fB\-radius\fR and \fB\-knn\fR
+.SH AUTHOR
+pcl_test_search_speed is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_tiff2pcd.1 b/debian/manpages/pcl_tiff2pcd.1
new file mode 100644
index 000000000..d6c413ac7
--- /dev/null
+++ b/debian/manpages/pcl_tiff2pcd.1
@@ -0,0 +1,33 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_TIFF2PCD "1" "May 2014" "pcl_tiff2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_tiff2pcd \- pcl_tiff2pcd
+.SH DESCRIPTION
+usage: convert \fB\-rgb\fR <rgb_path> \fB\-depth\fR <depth_path> \fB\-out\fR <output_path> options
+
+This program converts rgb and depth tiff files to pcd files
+Options:
+
+    \fB\-v\fR Set verbose output
+
+    \fB\-c\fR Create color pcd output
+
+    \fB\-d\fR Create depth output
+
+    \fB\-b\fR Set to save pcd binary, otherwise ascii
+
+    \fB\-f\fR Focal length, default 525
+
+    \fB\-h\fR This help
+
+
+.SH AUTHOR
+pcl_tiff2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_train_linemod_template.1 b/debian/manpages/pcl_train_linemod_template.1
new file mode 100644
index 000000000..9445b0eb2
--- /dev/null
+++ b/debian/manpages/pcl_train_linemod_template.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_TRAIN_LINEMOD_TEMPLATE "1" "May 2014" "pcl_train_linemod_template 1.7.1" "User Commands"
+.SH NAME
+pcl_train_linemod_template \- pcl_train_linemod_template
+.SH DESCRIPTION
+
+Need at least one input PCD file.
+
+
+Train one or more linemod templates. For more information, use: pcl_train_linemod_template \fB\-h\fR
+.SH AUTHOR
+pcl_train_linemod_template is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_transform_from_viewpoint.1 b/debian/manpages/pcl_transform_from_viewpoint.1
new file mode 100644
index 000000000..1cac38bac
--- /dev/null
+++ b/debian/manpages/pcl_transform_from_viewpoint.1
@@ -0,0 +1,21 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_TRANSFORM_FROM_VIEWPOINT "1" "May 2014" "pcl_transform_from_viewpoint 1.7.1" "User Commands"
+.SH NAME
+pcl_transform_from_viewpoint \- pcl_transform_from_viewpoint
+.SH DESCRIPTION
+
+Syntax is: pcl_transform_from_viewpoint input.pcd output.pcd
+
+
+Take the input point cloud and transform it according to its stored VIEWPOINT information. For more information, use pcl_transform_from_viewpoint \fB\-h\fR
+
+.SH AUTHOR
+pcl_transform_from_viewpoint is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_transform_point_cloud.1 b/debian/manpages/pcl_transform_point_cloud.1
new file mode 100644
index 000000000..f530ae91e
--- /dev/null
+++ b/debian/manpages/pcl_transform_point_cloud.1
@@ -0,0 +1,45 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_TRANSFORM_POINT_CLOUD "1" "May 2014" "pcl_transform_point_cloud 1.7.1" "User Commands"
+.SH NAME
+pcl_transform_point_cloud \- pcl_transform_point_cloud
+.SH DESCRIPTION
+
+Syntax is: pcl_transform_point_cloud input.pcd output.pcd <options>
+
+
+Transform a cloud. For more information, use: pcl_transform_point_cloud \fB\-h\fR
+
+  where options are:
+
+ \fB\-trans\fR dx,dy,dz = the translation (default: 0.0, 0.0, 0.0)
+
+ \fB\-quat\fR w,x,y,z   = rotation as quaternion
+
+ \fB\-axisangle\fR ax,ay,az,theta = rotation in axis\-angle form
+
+ \fB\-scale\fR x,y,z    = scale each dimension with these values
+
+ \fB\-matrix\fR v1,v2,...,v8,v9   = a 3x3 affine transform
+
+ \fB\-matrix\fR v1,v2,...,v15,v16 = a 4x4 transformation matrix
+
+   Note: If a rotation is not specified, it will default to no rotation.
+
+    If redundant or conflicting transforms are specified, then:
+
+ \fB\-axisangle\fR will override \fB\-quat\fR
+
+ \fB\-matrix\fR (3x3) will take override \fB\-axisangle\fR and \fB\-quat\fR
+
+ \fB\-matrix\fR (4x4) will take override all other arguments
+
+.SH AUTHOR
+pcl_transform_point_cloud is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_uniform_sampling.1 b/debian/manpages/pcl_uniform_sampling.1
new file mode 100644
index 000000000..51e41d00f
--- /dev/null
+++ b/debian/manpages/pcl_uniform_sampling.1
@@ -0,0 +1,25 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_UNIFORM_SAMPLING "1" "May 2014" "pcl_uniform_sampling 1.7.1" "User Commands"
+.SH NAME
+pcl_uniform_sampling \- pcl_uniform_sampling
+.SH DESCRIPTION
+
+Syntax is: pcl_uniform_sampling input.pcd output.pcd <options>
+
+
+Uniform subsampling using UniformSampling. For more information, use: pcl_uniform_sampling \fB\-h\fR
+
+  where options are:
+
+ \fB\-radius\fR X = use a leaf size of X,X,X to uniformly select 1 point per leaf (default: 0.010000)
+
+.SH AUTHOR
+pcl_uniform_sampling is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_vfh_estimation.1 b/debian/manpages/pcl_vfh_estimation.1
new file mode 100644
index 000000000..c03aa1a18
--- /dev/null
+++ b/debian/manpages/pcl_vfh_estimation.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_VFH_ESTIMATION "1" "May 2014" "pcl_vfh_estimation 1.7.1" "User Commands"
+.SH NAME
+pcl_vfh_estimation \- pcl_vfh_estimation
+.SH DESCRIPTION
+
+Syntax is: pcl_vfh_estimation input.pcd output.pcd
+
+
+Estimate VFH (308) descriptors using pcl::VFHEstimation. For more information, use: pcl_vfh_estimation \fB\-h\fR
+.SH AUTHOR
+pcl_vfh_estimation is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_voxel_grid.1 b/debian/manpages/pcl_voxel_grid.1
new file mode 100644
index 000000000..65a9978ae
--- /dev/null
+++ b/debian/manpages/pcl_voxel_grid.1
@@ -0,0 +1,31 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_VOXEL_GRID "1" "May 2014" "pcl_voxel_grid 1.7.1" "User Commands"
+.SH NAME
+pcl_voxel_grid \- pcl_voxel_grid
+.SH DESCRIPTION
+
+Syntax is: pcl_voxel_grid input.pcd output.pcd <options>
+
+
+Downsample a cloud using pcl::VoxelGrid. For more information, use: pcl_voxel_grid \fB\-h\fR
+
+  where options are:
+
+ \fB\-leaf\fR x,y,z   = the VoxelGrid leaf size (default: 0.010000, 0.010000, 0.010000)
+
+ \fB\-field\fR X = filter data along this field name (default: z)
+
+ \fB\-fmin\fR  X = filter all data with values along the specified field smaller than this value (default: \-inf)
+
+ \fB\-fmax\fR  X = filter all data with values along the specified field larger than this value (default: inf)
+
+.SH AUTHOR
+pcl_voxel_grid is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_vtk2obj.1 b/debian/manpages/pcl_vtk2obj.1
new file mode 100644
index 000000000..e622fccff
--- /dev/null
+++ b/debian/manpages/pcl_vtk2obj.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_VTK2OBJ "1" "May 2014" "pcl_vtk2obj 1.7.1" "User Commands"
+.SH NAME
+pcl_vtk2obj \- pcl_vtk2obj
+.SH DESCRIPTION
+
+Syntax is: pcl_vtk2obj input.vtk output.obj
+
+
+Convert a VTK file to OBJ format. For more information, use: pcl_vtk2obj \fB\-h\fR
+.SH AUTHOR
+pcl_vtk2obj is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_vtk2pcd.1 b/debian/manpages/pcl_vtk2pcd.1
new file mode 100644
index 000000000..05a9836b6
--- /dev/null
+++ b/debian/manpages/pcl_vtk2pcd.1
@@ -0,0 +1,24 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_VTK2PCD "1" "May 2014" "pcl_vtk2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_vtk2pcd \- pcl_vtk2pcd
+.SH DESCRIPTION
+
+Syntax is: pcl_vtk2pcd input.vtk output.pcd [options]
+
+
+Convert a VTK file to PCD format. For more information, use: pcl_vtk2pcd \fB\-h\fR
+
+where options are:
+
+\fB\-copy_normals\fR 0/1 : set to true (1) or false (0) if the output PointCloud should contain normals or not.
+.SH AUTHOR
+pcl_vtk2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_vtk2ply.1 b/debian/manpages/pcl_vtk2ply.1
new file mode 100644
index 000000000..6bee36d5f
--- /dev/null
+++ b/debian/manpages/pcl_vtk2ply.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_VTK2PLY "1" "May 2014" "pcl_vtk2ply 1.7.1" "User Commands"
+.SH NAME
+pcl_vtk2ply \- pcl_vtk2ply
+.SH DESCRIPTION
+
+Syntax is: pcl_vtk2ply input.vtk output.ply
+
+
+Convert a VTK file to PLY format. For more information, use: pcl_vtk2ply \fB\-h\fR
+.SH AUTHOR
+pcl_vtk2ply is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/manpages/pcl_xyz2pcd.1 b/debian/manpages/pcl_xyz2pcd.1
new file mode 100644
index 000000000..5e7f8e083
--- /dev/null
+++ b/debian/manpages/pcl_xyz2pcd.1
@@ -0,0 +1,20 @@
+.\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.40.10.
+.TH PCL_XYZ2PCD "1" "May 2014" "pcl_xyz2pcd 1.7.1" "User Commands"
+.SH NAME
+pcl_xyz2pcd \- pcl_xyz2pcd
+.SH DESCRIPTION
+
+Syntax is: pcl_xyz2pcd input.xyz output.pcd
+
+
+Convert a simple XYZ file to PCD format. For more information, use: pcl_xyz2pcd \fB\-h\fR
+.SH AUTHOR
+pcl_xyz2pcd is part of Point Cloud Library (PCL) - www.pointclouds.org
+
+The Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D
+image and point cloud processing.
+.PP
+This manual page was written by Leopold Palomo-Avellaneda <leo@alaxarxa.net> with
+the help of help2man tool and some handmade arrangement for the Debian project
+(and may be used by others).
+
diff --git a/debian/options b/debian/options
new file mode 100644
index 000000000..e69de29bb
diff --git a/debian/patches/0001-Fix-PCL_ROOT-path.patch b/debian/patches/0001-Fix-PCL_ROOT-path.patch
new file mode 100644
index 000000000..e2b4753a3
--- /dev/null
+++ b/debian/patches/0001-Fix-PCL_ROOT-path.patch
@@ -0,0 +1,25 @@
+From 6181270f6e190cbb6085b2feed7b2b4ba55d6e58 Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Fri, 18 Aug 2017 11:30:38 +0200
+Subject: [PATCH 01/10] Fix PCL_ROOT path
+
+---
+ PCLConfig.cmake.in | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/PCLConfig.cmake.in b/PCLConfig.cmake.in
+index 8e9198bda..fe396b642 100644
+--- a/PCLConfig.cmake.in
++++ b/PCLConfig.cmake.in
+@@ -390,7 +390,7 @@ if(WIN32 AND NOT MINGW)
+   endif()
+ else()
+ # PCLConfig.cmake is installed to PCL_ROOT/share/pcl-x.y
+-  get_filename_component(PCL_ROOT "${CMAKE_CURRENT_LIST_DIR}/../.." ABSOLUTE)
++  get_filename_component(PCL_ROOT "${CMAKE_CURRENT_LIST_DIR}/../../../.." ABSOLUTE)
+ endif()
+ 
+ # check whether PCLConfig.cmake is found into a PCL installation or in a build tree
+-- 
+2.17.1
+
diff --git a/debian/patches/0002-Link-against-atomic-if-needed-found-on-armel.patch b/debian/patches/0002-Link-against-atomic-if-needed-found-on-armel.patch
new file mode 100644
index 000000000..59e1f40fc
--- /dev/null
+++ b/debian/patches/0002-Link-against-atomic-if-needed-found-on-armel.patch
@@ -0,0 +1,60 @@
+From 928c44a780fc50905fba00a768040e4ec5ba08c5 Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Sun, 2 Feb 2020 00:22:36 +0100
+Subject: [PATCH 02/10] Link against atomic if needed (found on armel)
+
+---
+ CMakeLists.txt          | 14 ++++++++++++++
+ cmake/pcl_targets.cmake |  4 ++--
+ 2 files changed, 16 insertions(+), 2 deletions(-)
+
+diff --git a/CMakeLists.txt b/CMakeLists.txt
+index 00700a83c..06df69d1c 100644
+--- a/CMakeLists.txt
++++ b/CMakeLists.txt
+@@ -57,6 +57,20 @@ elseif(MINGW)
+   set(CMAKE_COMPILER_IS_MINGW 1)
+ endif()
+ 
++# https://github.com/fish-shell/fish-shell/issues/5865
++include(CheckCXXSourceCompiles)
++CHECK_CXX_SOURCE_COMPILES("
++#include <atomic>
++struct big { int foo[64]; };
++std::atomic<big> x;
++int main() {
++   return x.load().foo[13];
++}"
++LIBATOMIC_NOT_NEEDED)
++IF (NOT LIBATOMIC_NOT_NEEDED)
++    SET(ATOMIC_LIBRARY "atomic")
++ENDIF()
++
+ # Create a variable with expected default CXX flags
+ # This will be used further down the road to check if the user explicitly provided CXX flags
+ if(CMAKE_COMPILER_IS_MSVC)
+diff --git a/cmake/pcl_targets.cmake b/cmake/pcl_targets.cmake
+index ff79c2076..f12a47237 100644
+--- a/cmake/pcl_targets.cmake
++++ b/cmake/pcl_targets.cmake
+@@ -230,7 +230,7 @@ function(PCL_ADD_LIBRARY _name)
+   endif()
+ 
+   if((UNIX AND NOT ANDROID) OR MINGW)
+-    target_link_libraries(${_name} m)
++    target_link_libraries(${_name} m ${ATOMIC_LIBRARY})
+   endif()
+ 
+   if(MINGW)
+@@ -391,7 +391,7 @@ macro(PCL_ADD_TEST _name _exename)
+   #target_link_libraries(${_exename} ${GTEST_BOTH_LIBRARIES} ${PCL_ADD_TEST_LINK_WITH})
+   target_link_libraries(${_exename} ${PCL_ADD_TEST_LINK_WITH} ${CLANG_LIBRARIES})
+ 
+-  target_link_libraries(${_exename} Threads::Threads)
++  target_link_libraries(${_exename} Threads::Threads ${ATOMIC_LIBRARY})
+ 
+   #Only applies to MSVC
+   if(MSVC)
+-- 
+2.17.1
+
diff --git a/debian/patches/0003-Use-newly-build-libs-when-testing.patch b/debian/patches/0003-Use-newly-build-libs-when-testing.patch
new file mode 100644
index 000000000..9e81b4105
--- /dev/null
+++ b/debian/patches/0003-Use-newly-build-libs-when-testing.patch
@@ -0,0 +1,25 @@
+From bb6f5182caae34c60918bacc7107203cb84b1d7c Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Sun, 7 Apr 2019 12:51:12 +0200
+Subject: [PATCH 03/10] Use newly build libs when testing
+
+This exports the LD_LIBRARY_PATH so the newly build libs will be used.
+---
+ cmake/pcl_targets.cmake | 1 +
+ 1 file changed, 1 insertion(+)
+
+diff --git a/cmake/pcl_targets.cmake b/cmake/pcl_targets.cmake
+index f12a47237..ff71d78d3 100644
+--- a/cmake/pcl_targets.cmake
++++ b/cmake/pcl_targets.cmake
+@@ -410,6 +410,7 @@ macro(PCL_ADD_TEST _name _exename)
+ 
+   set_target_properties(${_exename} PROPERTIES FOLDER "Tests")
+   add_test(NAME ${_name} COMMAND ${_exename} ${PCL_ADD_TEST_ARGUMENTS})
++  set_tests_properties(${_name} PROPERTIES ENVIRONMENT "LD_LIBRARY_PATH=${CMAKE_BINARY_DIR}/${LIB_INSTALL_DIR}")
+ 
+   add_dependencies(tests ${_exename})
+ endmacro()
+-- 
+2.17.1
+
diff --git a/debian/patches/0004-Disable-failing-tests.patch b/debian/patches/0004-Disable-failing-tests.patch
new file mode 100644
index 000000000..9147f8317
--- /dev/null
+++ b/debian/patches/0004-Disable-failing-tests.patch
@@ -0,0 +1,64 @@
+From c9be1385216f0ab9aaaae8daf18b8dab0bfaab80 Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Wed, 29 Sep 2021 22:19:25 +0200
+Subject: [PATCH 04/10] Disable failing tests
+
+---
+ test/features/CMakeLists.txt             | 4 ----
+ test/features/test_normal_estimation.cpp | 2 +-
+ test/octree/test_octree.cpp              | 4 ++--
+ 3 files changed, 3 insertions(+), 7 deletions(-)
+
+diff --git a/test/features/CMakeLists.txt b/test/features/CMakeLists.txt
+index d89d80c1c..d05945fa4 100644
+--- a/test/features/CMakeLists.txt
++++ b/test/features/CMakeLists.txt
+@@ -92,10 +92,6 @@ if(BUILD_io)
+   PCL_ADD_TEST(features_narf test_narf
+                FILES test_narf.cpp
+                LINK_WITH pcl_gtest pcl_features FLANN::FLANN)
+-  PCL_ADD_TEST(a_ii_normals_test test_ii_normals
+-               FILES test_ii_normals.cpp
+-               LINK_WITH pcl_gtest pcl_io pcl_features
+-               ARGUMENTS "${PCL_SOURCE_DIR}/test/table_scene_mug_stereo_textured.pcd")
+   PCL_ADD_TEST(feature_moment_of_inertia_estimation test_moment_of_inertia_estimation
+                FILES test_moment_of_inertia_estimation.cpp
+                LINK_WITH pcl_gtest pcl_io pcl_features
+diff --git a/test/features/test_normal_estimation.cpp b/test/features/test_normal_estimation.cpp
+index 5211a2c19..e1976446c 100644
+--- a/test/features/test_normal_estimation.cpp
++++ b/test/features/test_normal_estimation.cpp
+@@ -409,7 +409,7 @@ TEST (PCL, NormalEstimationOpenMP)
+ // IntegralImageNormalEstimation could crash or produce
+ // incorrect normals.
+ // This test reproduces the issue.
+-TEST (PCL, IntegralImageNormalEstimationIndexingIssue)
++TEST (PCL, DISABLED_IntegralImageNormalEstimationIndexingIssue)
+ {
+   PointCloud<PointXYZ>::Ptr cloudptr(new PointCloud<PointXYZ>());
+ 
+diff --git a/test/octree/test_octree.cpp b/test/octree/test_octree.cpp
+index 0a4df9e6e..fc37ad14c 100644
+--- a/test/octree/test_octree.cpp
++++ b/test/octree/test_octree.cpp
+@@ -1121,7 +1121,7 @@ public:
+ 
+ };
+ 
+-TEST (PCL, Octree_Pointcloud_Nearest_K_Neighbour_Search)
++TEST (PCL, DISABLED_Octree_Pointcloud_Nearest_K_Neighbour_Search)
+ {
+   constexpr unsigned int test_runs = 10;
+ 
+@@ -1224,7 +1224,7 @@ TEST (PCL, Octree_Pointcloud_Nearest_K_Neighbour_Search)
+   }
+ }
+ 
+-TEST (PCL, Octree_Pointcloud_Box_Search)
++TEST (PCL, DISABLED_Octree_Pointcloud_Box_Search)
+ {
+   constexpr unsigned int test_runs = 30;
+ 
+-- 
+2.17.1
+
diff --git a/debian/patches/0005-Adopt-unit-test-for-i386.patch b/debian/patches/0005-Adopt-unit-test-for-i386.patch
new file mode 100644
index 000000000..21d5c9953
--- /dev/null
+++ b/debian/patches/0005-Adopt-unit-test-for-i386.patch
@@ -0,0 +1,133 @@
+From 460cfe8a6642cb547e08dbc57882e5a219cb84ac Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Fri, 8 Oct 2021 19:09:12 +0200
+Subject: [PATCH 05/10] Adopt unit test for i386
+
+---
+ test/features/test_curvatures_estimation.cpp         | 12 ++++++------
+ test/features/test_gasd_estimation.cpp               |  2 +-
+ test/filters/test_convolution.cpp                    |  2 ++
+ test/io/test_tim_grabber.cpp                         |  2 +-
+ test/octree/test_octree.cpp                          |  2 +-
+ .../test_sample_consensus_plane_models.cpp           |  6 +++---
+ 6 files changed, 14 insertions(+), 12 deletions(-)
+
+diff --git a/test/features/test_curvatures_estimation.cpp b/test/features/test_curvatures_estimation.cpp
+index 11e858f3f..51e5ba370 100644
+--- a/test/features/test_curvatures_estimation.cpp
++++ b/test/features/test_curvatures_estimation.cpp
+@@ -90,14 +90,14 @@ TEST (PCL, PrincipalCurvaturesEstimation)
+ 
+   int indices_size = static_cast<int> (indices.size ());
+   pc.computePointPrincipalCurvatures (*normals, indices_size - 3, indices, pcx, pcy, pcz, pc1, pc2);
+-  EXPECT_NEAR (pcx, 0.86725, 1e-4);
+-  EXPECT_NEAR (pcy, -0.37599, 1e-4);
++  EXPECT_NEAR (pcx, 0.86725, 1e-3);
++  EXPECT_NEAR (pcy, -0.37599, 1e-3);
+   EXPECT_NEAR (pcz, 0.32635, 1e-4);
+   EXPECT_NEAR (pc1, 0.25900053977966309, 1e-4);
+   EXPECT_NEAR (pc2, 0.17906945943832397, 1e-4);
+ 
+   pc.computePointPrincipalCurvatures (*normals, indices_size - 1, indices, pcx, pcy, pcz, pc1, pc2);
+-  EXPECT_NEAR (pcx, 0.86725, 1e-4);
++  EXPECT_NEAR (pcx, 0.86725, 1e-3);
+   EXPECT_NEAR (pcy, -0.375851, 1e-3);
+   EXPECT_NEAR (pcz, 0.32636, 1e-4);
+   EXPECT_NEAR (pc1, 0.2590005099773407,  1e-4);
+@@ -129,13 +129,13 @@ TEST (PCL, PrincipalCurvaturesEstimation)
+   EXPECT_NEAR ((*pcs)[2].pc1, 0.27207502722740173, 1e-4);
+   EXPECT_NEAR ((*pcs)[2].pc2, 0.1946497857570648,  1e-4);
+ 
+-  EXPECT_NEAR ((*pcs)[indices.size () - 3].principal_curvature[0], 0.86725, 1e-4);
+-  EXPECT_NEAR ((*pcs)[indices.size () - 3].principal_curvature[1], -0.37599, 1e-4);
++  EXPECT_NEAR ((*pcs)[indices.size () - 3].principal_curvature[0], 0.86725, 1e-3);
++  EXPECT_NEAR ((*pcs)[indices.size () - 3].principal_curvature[1], -0.37599, 1e-3);
+   EXPECT_NEAR ((*pcs)[indices.size () - 3].principal_curvature[2], 0.32636, 1e-4);
+   EXPECT_NEAR ((*pcs)[indices.size () - 3].pc1, 0.2590007483959198,  1e-4);
+   EXPECT_NEAR ((*pcs)[indices.size () - 3].pc2, 0.17906941473484039, 1e-4);
+ 
+-  EXPECT_NEAR ((*pcs)[indices.size () - 1].principal_curvature[0], 0.86725, 1e-4);
++  EXPECT_NEAR ((*pcs)[indices.size () - 1].principal_curvature[0], 0.86725, 1e-3);
+   EXPECT_NEAR ((*pcs)[indices.size () - 1].principal_curvature[1], -0.375851, 1e-3);
+   EXPECT_NEAR ((*pcs)[indices.size () - 1].principal_curvature[2], 0.32636, 1e-4);
+   EXPECT_NEAR ((*pcs)[indices.size () - 1].pc1, 0.25900065898895264, 1e-4);
+diff --git a/test/features/test_gasd_estimation.cpp b/test/features/test_gasd_estimation.cpp
+index 0b000cbca..c8f85988c 100644
+--- a/test/features/test_gasd_estimation.cpp
++++ b/test/features/test_gasd_estimation.cpp
+@@ -160,7 +160,7 @@ TEST(PCL, GASDShapeEstimationTrilinearInterp)
+   EXPECT_EQ (descriptor.size (), 1);
+   for (std::size_t i = 0; i < std::size_t (descriptor[0].descriptorSize ()); ++i)
+   {
+-    EXPECT_NEAR (descriptor[0].histogram[i], ref_values[i], 1e-5);
++    EXPECT_NEAR (descriptor[0].histogram[i], ref_values[i], 1e-4);
+   }
+ }
+ 
+diff --git a/test/filters/test_convolution.cpp b/test/filters/test_convolution.cpp
+index 26e5cbe9f..f61a8f497 100644
+--- a/test/filters/test_convolution.cpp
++++ b/test/filters/test_convolution.cpp
+@@ -393,6 +393,7 @@ TEST (Convolution, convolveRowsXYZRGB)
+     RGB(0, 0, 0),        RGB(0, 0, 0),
+   };
+ 
++#ifndef __i386__
+   // check result
+   for (std::uint32_t i = 0; i < output->width ; ++i)
+   {
+@@ -403,6 +404,7 @@ TEST (Convolution, convolveRowsXYZRGB)
+     EXPECT_EQ ((*output) (i, 47).g, output_results[i * 2 + 1].g);
+     EXPECT_EQ ((*output) (i, 47).b, output_results[i * 2 + 1].b);
+   }
++#endif
+ }
+ 
+ int
+diff --git a/test/io/test_tim_grabber.cpp b/test/io/test_tim_grabber.cpp
+index 8897af526..ed979589a 100644
+--- a/test/io/test_tim_grabber.cpp
++++ b/test/io/test_tim_grabber.cpp
+@@ -89,7 +89,7 @@ TEST_F (TimGrabberTest, Test1)
+     for (std::size_t j = 0; j < correct_clouds_.at(i).size (); j++) {
+       PointT const& correct_point = correct_clouds_.at(i).at(j);
+       PointT const& answer_point = answer_cloud->at(j);
+-      EXPECT_NEAR (correct_point.x, answer_point.x, 1.0e-3);
++      EXPECT_NEAR (correct_point.x, answer_point.x, 5.0e-3);
+       EXPECT_NEAR (correct_point.y, answer_point.y, 1.0e-3);
+       EXPECT_NEAR (correct_point.z, answer_point.z, 1.0e-3);
+     }
+diff --git a/test/octree/test_octree.cpp b/test/octree/test_octree.cpp
+index fc37ad14c..210a3c27d 100644
+--- a/test/octree/test_octree.cpp
++++ b/test/octree/test_octree.cpp
+@@ -1538,7 +1538,7 @@ TEST (PCL, Octree_Pointcloud_Ray_Traversal)
+     {
+       pt = (*cloudIn)[i];
+       d = Eigen::Vector3f (pt.x, pt.y, pt.z) - o;
+-      ASSERT_GE (d.norm (), min_dist);
++      ASSERT_GE (d.norm (), min_dist - 1e-4);
+     }
+   }
+ }
+diff --git a/test/sample_consensus/test_sample_consensus_plane_models.cpp b/test/sample_consensus/test_sample_consensus_plane_models.cpp
+index 48a001179..27aba916e 100644
+--- a/test/sample_consensus/test_sample_consensus_plane_models.cpp
++++ b/test/sample_consensus/test_sample_consensus_plane_models.cpp
+@@ -465,10 +465,10 @@ TEST (SampleConsensusModelPlane, OptimizeFarFromOrigin)
+   Eigen::VectorXf coeffs(4); // Doesn't have to be initialized, the function doesn't use them
+   Eigen::VectorXf optimized_coeffs(4);
+   model.optimizeModelCoefficients(inliers, coeffs, optimized_coeffs);
+-  EXPECT_NEAR(optimized_coeffs[0], z[0], 5e-6);
+-  EXPECT_NEAR(optimized_coeffs[1], z[1], 5e-6);
++  EXPECT_NEAR(optimized_coeffs[0], z[0], 5e-5);
++  EXPECT_NEAR(optimized_coeffs[1], z[1], 5e-5);
+   EXPECT_NEAR(optimized_coeffs[2], z[2], 5e-6);
+-  EXPECT_NEAR(optimized_coeffs[3], -z.dot(center), 5e-2);
++  EXPECT_NEAR(optimized_coeffs[3], -z.dot(center), 5e-1);
+ }
+ 
+ int
+-- 
+2.17.1
+
diff --git a/debian/patches/0007-Adopt-unit-tests-for-arm64-and-ppc64el.patch b/debian/patches/0007-Adopt-unit-tests-for-arm64-and-ppc64el.patch
new file mode 100644
index 000000000..a990af775
--- /dev/null
+++ b/debian/patches/0007-Adopt-unit-tests-for-arm64-and-ppc64el.patch
@@ -0,0 +1,48 @@
+From 650399604a0f6ac3100f9e72c7486ea0f496093f Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Mon, 13 Dec 2021 22:14:08 +0100
+Subject: [PATCH 06/10] Adopt unit tests for arm64 and ppc64el
+
+---
+ test/common/test_pca.cpp              | 4 ++--
+ test/segmentation/test_non_linear.cpp | 2 +-
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+diff --git a/test/common/test_pca.cpp b/test/common/test_pca.cpp
+index 9c3a64e4d..8143a6b62 100644
+--- a/test/common/test_pca.cpp
++++ b/test/common/test_pca.cpp
+@@ -53,7 +53,7 @@ TEST(PCA, projection)
+   {
+     pca.project (point, projected);
+     pca.reconstruct (projected, reconstructed);
+-    EXPECT_NEAR_VECTORS (reconstructed.getVector3fMap (), point.getVector3fMap (), 2.5e-4);
++    EXPECT_NEAR_VECTORS (reconstructed.getVector3fMap (), point.getVector3fMap (), 5e-4);
+   }
+ }
+ 
+@@ -87,7 +87,7 @@ TEST(PCA, cloud_projection)
+     for(std::size_t i = 0; i < cloud.size(); i++)
+       EXPECT_NEAR_VECTORS (cloud[i].getVector3fMap (),
+                            cloud_reconstructed[i].getVector3fMap (),
+-                           2.5e-4);
++                           5e-4);
+   }
+   catch (pcl::InitFailedException &/*e*/)
+   {
+diff --git a/test/segmentation/test_non_linear.cpp b/test/segmentation/test_non_linear.cpp
+index 141018279..823070ff0 100644
+--- a/test/segmentation/test_non_linear.cpp
++++ b/test/segmentation/test_non_linear.cpp
+@@ -73,7 +73,7 @@ TEST (SACSegmentation, Segmentation)
+   EXPECT_NEAR (sphere_coefficients->values[2], 1.24558,   1e-2);
+   EXPECT_NEAR (sphere_coefficients->values[3], 0.0536238, 1e-2);
+ 
+-  EXPECT_NEAR (static_cast<int> (inliers->indices.size ()), 3516, 15);
++  EXPECT_NEAR (static_cast<int> (inliers->indices.size ()), 3516, 18);
+ }
+ 
+ //* ---[ */
+-- 
+2.17.1
+
diff --git a/debian/patches/0007-Drop-PCL_SOURCES_TREE-from-installation-cmake.patch b/debian/patches/0007-Drop-PCL_SOURCES_TREE-from-installation-cmake.patch
new file mode 100644
index 000000000..7edea49e3
--- /dev/null
+++ b/debian/patches/0007-Drop-PCL_SOURCES_TREE-from-installation-cmake.patch
@@ -0,0 +1,33 @@
+From d86771bb99508b9fbd59d0b5dfc0846cd8543f66 Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Sat, 25 Dec 2021 09:30:57 +0100
+Subject: [PATCH 07/10] Drop $PCL_SOURCES_TREE from installation cmake
+
+It is not used elsewhere and makes the build unreproducible.
+---
+ PCLConfig.cmake.in | 2 --
+ 1 file changed, 2 deletions(-)
+
+diff --git a/PCLConfig.cmake.in b/PCLConfig.cmake.in
+index fe396b642..8e53d2a65 100644
+--- a/PCLConfig.cmake.in
++++ b/PCLConfig.cmake.in
+@@ -409,7 +409,6 @@ elseif(EXISTS "${PCL_DIR}/include/pcl/pcl_config.h")
+   # pcl_message("PCL found into a build tree.")
+   set(PCL_CONF_INCLUDE_DIR "${PCL_DIR}/include") # for pcl_config.h
+   set(PCL_LIBRARY_DIRS "${PCL_DIR}/@LIB_INSTALL_DIR@")
+-  set(PCL_SOURCES_TREE "@CMAKE_SOURCE_DIR@")
+ else()
+   pcl_report_not_found("PCL can not be found on this machine")
+ endif()
+@@ -506,7 +505,6 @@ foreach(component ${PCL_TO_FIND_COMPONENTS})
+           pcl/gpu/${gpu_component} pcl/gpu/${component} 
+           pcl/oneapi/${oneapi_component} pcl/oneapi/${component}
+     HINTS ${PCL_INCLUDE_DIRS}
+-          "${PCL_SOURCES_TREE}"
+     PATH_SUFFIXES
+           ${component}/include
+           apps/${component}/include
+-- 
+2.17.1
+
diff --git a/debian/patches/0008-Don-t-require-boost-in-pkg-config.patch b/debian/patches/0008-Don-t-require-boost-in-pkg-config.patch
new file mode 100644
index 000000000..27ab14d2d
--- /dev/null
+++ b/debian/patches/0008-Don-t-require-boost-in-pkg-config.patch
@@ -0,0 +1,26 @@
+From 3fc5e129bd8a6755acc29216bd4842e389cc9678 Mon Sep 17 00:00:00 2001
+From: Jochen Sprickerhof <git@jochen.sprickerhof.de>
+Date: Wed, 29 Dec 2021 10:42:28 +0100
+Subject: [PATCH 08/10] Don't require boost in pkg-config
+
+There is no boost.pc. Regression of 87e12d1c8.
+---
+ io/CMakeLists.txt | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/io/CMakeLists.txt b/io/CMakeLists.txt
+index 163639b02..460b3d52e 100644
+--- a/io/CMakeLists.txt
++++ b/io/CMakeLists.txt
+@@ -415,7 +415,7 @@ if(PCAP_FOUND)
+   target_link_libraries("${LIB_NAME}" ${PCAP_LIBRARIES})
+ endif()
+ 
+-set(EXT_DEPS boost eigen3)
++set(EXT_DEPS eigen3)
+ 
+ if(WITH_OPENNI)
+   list(APPEND EXT_DEPS libopenni)
+-- 
+2.17.1
+
diff --git a/debian/patches/0009-Repair-sparse_matrix.hpp.patch b/debian/patches/0009-Repair-sparse_matrix.hpp.patch
new file mode 100644
index 000000000..150d9acdd
--- /dev/null
+++ b/debian/patches/0009-Repair-sparse_matrix.hpp.patch
@@ -0,0 +1,61 @@
+From 1b1cddf1f9dc698764fee5dac45d42971d63f2a9 Mon Sep 17 00:00:00 2001
+From: Thomas Dickerson <elfprince13@gmail.com>
+Date: Thu, 12 May 2022 14:28:41 -0400
+Subject: [PATCH 09/10] Repair sparse_matrix.hpp
+
+Unclear why nobody has noticed for a decade that this code was just totally uncompilable. `SparseMatrix` does not have methods `Columns()` or `Rows()`, and `m_ppElements[i]` is a pointer so can't possibly have anything called with `.`.
+---
+ .../3rdparty/poisson4/sparse_matrix.hpp        | 18 +++++++++---------
+ 1 file changed, 9 insertions(+), 9 deletions(-)
+
+diff --git a/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp b/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
+index e6564cdc5..02c2db5bd 100644
+--- a/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
++++ b/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
+@@ -250,9 +250,9 @@ namespace pcl
+     template<class T>
+     SparseMatrix<T>& SparseMatrix<T>::operator *= (const T& V)
+     {
+-      for (int i=0; i<this->Rows(); i++)
++      for (int i=0; i<rows; i++)
+       {
+-        for(int ii=0;ii<m_ppElements[i].size();i++){m_ppElements[i][ii].Value*=V;}
++        for(int ii=0;ii<rowSizes[i];i++){m_ppElements[i][ii].Value*=V;}
+       }
+       return *this;
+     }
+@@ -260,12 +260,12 @@ namespace pcl
+     template<class T>
+     SparseMatrix<T> SparseMatrix<T>::Multiply( const SparseMatrix<T>& M ) const
+     {
+-      SparseMatrix<T> R( this->Rows(), M.Columns() );
+-      for(int i=0; i<R.Rows(); i++){
+-        for(int ii=0;ii<m_ppElements[i].size();ii++){
++      SparseMatrix<T> R( rows, M._maxEntriesPerRow );
++      for(int i=0; i<R.rows; i++){
++        for(int ii=0;ii<rowSizes[i];ii++){
+           int N=m_ppElements[i][ii].N;
+           T Value=m_ppElements[i][ii].Value;
+-          for(int jj=0;jj<M.m_ppElements[N].size();jj++){
++          for(int jj=0;jj<M.rowSizes[N];jj++){
+             R(i,M.m_ppElements[N][jj].N) += Value * M.m_ppElements[N][jj].Value;
+           }
+         }
+@@ -319,11 +319,11 @@ namespace pcl
+     template<class T>
+     SparseMatrix<T> SparseMatrix<T>::Transpose() const
+     {
+-      SparseMatrix<T> M( this->Columns(), this->Rows() );
++      SparseMatrix<T> M( _maxEntriesPerRow, rows );
+ 
+-      for (int i=0; i<this->Rows(); i++)
++      for (int i=0; i<rows; i++)
+       {
+-        for(int ii=0;ii<m_ppElements[i].size();ii++){
++        for(int ii=0;ii<rowSizes[i];ii++){
+           M(m_ppElements[i][ii].N,i) = m_ppElements[i][ii].Value;
+         }
+       }
+-- 
+2.17.1
+
diff --git a/debian/patches/0010-Fix-variable-name-in-poisson4.patch b/debian/patches/0010-Fix-variable-name-in-poisson4.patch
new file mode 100644
index 000000000..31313de42
--- /dev/null
+++ b/debian/patches/0010-Fix-variable-name-in-poisson4.patch
@@ -0,0 +1,25 @@
+From 29b06c94a26bf288be960c3e727808f078c82568 Mon Sep 17 00:00:00 2001
+From: Markus Vieth <39675748+mvieth@users.noreply.github.com>
+Date: Fri, 20 May 2022 14:47:52 +0200
+Subject: [PATCH 10/10] Fix variable name in poisson4
+
+---
+ surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp b/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
+index 02c2db5bd..24f0a5402 100644
+--- a/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
++++ b/surface/include/pcl/surface/3rdparty/poisson4/sparse_matrix.hpp
+@@ -252,7 +252,7 @@ namespace pcl
+     {
+       for (int i=0; i<rows; i++)
+       {
+-        for(int ii=0;ii<rowSizes[i];i++){m_ppElements[i][ii].Value*=V;}
++        for(int ii=0;ii<rowSizes[i];ii++){m_ppElements[i][ii].Value*=V;}
+       }
+       return *this;
+     }
+-- 
+2.17.1
+
diff --git a/debian/patches/series b/debian/patches/series
new file mode 100644
index 000000000..474450b7e
--- /dev/null
+++ b/debian/patches/series
@@ -0,0 +1,10 @@
+0001-Fix-PCL_ROOT-path.patch
+0002-Link-against-atomic-if-needed-found-on-armel.patch
+0003-Use-newly-build-libs-when-testing.patch
+0004-Disable-failing-tests.patch
+0005-Adopt-unit-test-for-i386.patch
+0007-Adopt-unit-tests-for-arm64-and-ppc64el.patch
+0007-Drop-PCL_SOURCES_TREE-from-installation-cmake.patch
+0008-Don-t-require-boost-in-pkg-config.patch
+0009-Repair-sparse_matrix.hpp.patch
+0010-Fix-variable-name-in-poisson4.patch
diff --git a/debian/pcl-oneapi-test.install b/debian/pcl-oneapi-test.install
new file mode 100644
index 000000000..f34ebc1ff
--- /dev/null
+++ b/debian/pcl-oneapi-test.install
@@ -0,0 +1,6 @@
+obj-x86_64-linux-gnu/test/oneapi/*/test_oneapi_* opt/intel/pcl/oneapi/tests/
+obj-x86_64-linux-gnu/test/oneapi/fuzzer/oneapi_fuzzer* opt/intel/pcl/oneapi/tests
+test/*.pcd opt/intel/pcl/oneapi/data/
+test/oneapi/data/*.pcd opt/intel/pcl/oneapi/data/
+test/oneapi/*/*.yaml opt/intel/pcl/oneapi/configs/
+test/oneapi/README.md opt/intel/pcl/oneapi/
diff --git a/debian/pcl-oneapi-tutorials.install b/debian/pcl-oneapi-tutorials.install
new file mode 100644
index 000000000..0dc5d48b3
--- /dev/null
+++ b/debian/pcl-oneapi-tutorials.install
@@ -0,0 +1 @@
+doc/tutorials/content/sources/oneapi/* opt/intel/pcl/oneapi/tutorials
diff --git a/debian/pcl-tools.install b/debian/pcl-tools.install
new file mode 100644
index 000000000..ce587c7a5
--- /dev/null
+++ b/debian/pcl-tools.install
@@ -0,0 +1 @@
+usr/bin/pcl_*
diff --git a/debian/pcl-tools.manpages b/debian/pcl-tools.manpages
new file mode 100644
index 000000000..8c012ba46
--- /dev/null
+++ b/debian/pcl-tools.manpages
@@ -0,0 +1,86 @@
+debian/manpages/pcl_add_gaussian_noise.1
+debian/manpages/pcl_boundary_estimation.1
+debian/manpages/pcl_cluster_extraction.1
+debian/manpages/pcl_compute_cloud_error.1
+debian/manpages/pcl_compute_hull.1
+debian/manpages/pcl_convert_pcd_ascii_binary.1
+debian/manpages/pcl_convolve.1
+debian/manpages/pcl_crop_to_hull.1
+debian/manpages/pcl_demean_cloud.1
+debian/manpages/pcl_extract_feature.1
+debian/manpages/pcl_fast_bilateral_filter.1
+debian/manpages/pcl_feature_matching.1
+debian/manpages/pcl_fpfh_estimation.1
+debian/manpages/pcl_gp3_surface.1
+debian/manpages/pcl_ground_based_rgbd_people_detector.1
+debian/manpages/pcl_hdl_viewer_simple.1
+debian/manpages/pcl_image_grabber_saver.1
+debian/manpages/pcl_image_grabber_viewer.1
+debian/manpages/pcl_linemod_detection.1
+debian/manpages/pcl_marching_cubes_reconstruction.1
+debian/manpages/pcl_mesh2pcd.1
+debian/manpages/pcl_mesh_sampling.1
+debian/manpages/pcl_mls_smoothing.1
+debian/manpages/pcl_normal_estimation.1
+debian/manpages/pcl_obj2vtk.1
+debian/manpages/pcl_obj_rec_ransac_accepted_hypotheses.1
+debian/manpages/pcl_obj_rec_ransac_model_opps.1
+debian/manpages/pcl_obj_rec_ransac_orr_octree.1
+debian/manpages/pcl_obj_rec_ransac_orr_octree_zprojection.1
+debian/manpages/pcl_obj_rec_ransac_result.1
+debian/manpages/pcl_obj_rec_ransac_scene_opps.1
+debian/manpages/pcl_octree_viewer.1
+debian/manpages/pcl_oni2pcd.1
+debian/manpages/pcl_oni_viewer.1
+debian/manpages/pcl_openni_3d_concave_hull.1
+debian/manpages/pcl_openni_3d_convex_hull.1
+debian/manpages/pcl_openni_boundary_estimation.1
+debian/manpages/pcl_openni_change_viewer.1
+debian/manpages/pcl_openni_fast_mesh.1
+debian/manpages/pcl_openni_feature_persistence.1
+debian/manpages/pcl_openni_ii_normal_estimation.1
+debian/manpages/pcl_openni_image.1
+debian/manpages/pcl_openni_mls_smoothing.1
+debian/manpages/pcl_openni_octree_compression.1
+debian/manpages/pcl_openni_organized_compression.1
+debian/manpages/pcl_openni_pcd_recorder.1
+debian/manpages/pcl_openni_planar_convex_hull.1
+debian/manpages/pcl_openni_planar_segmentation.1
+debian/manpages/pcl_openni_save_image.1
+debian/manpages/pcl_openni_tracking.1
+debian/manpages/pcl_openni_uniform_sampling.1
+debian/manpages/pcl_openni_viewer.1
+debian/manpages/pcl_outlier_removal.1
+debian/manpages/pcl_passthrough_filter.1
+debian/manpages/pcl_pcd2ply.1
+debian/manpages/pcl_pcd2png.1
+debian/manpages/pcl_pcd2vtk.1
+debian/manpages/pcl_pcd_change_viewpoint.1
+debian/manpages/pcl_pcd_convert_NaN_nan.1
+debian/manpages/pcl_pcd_select_object_plane.1
+debian/manpages/pcl_pcd_grabber_viewer.1
+debian/manpages/pcl_pclzf2pcd.1
+debian/manpages/pcl_plane_projection.1
+debian/manpages/pcl_ply2obj.1
+debian/manpages/pcl_ply2pcd.1
+debian/manpages/pcl_ply2ply.1
+debian/manpages/pcl_ply2raw.1
+debian/manpages/pcl_ply2vtk.1
+debian/manpages/pcl_plyheader.1
+debian/manpages/pcl_png2pcd.1
+debian/manpages/pcl_poisson_reconstruction.1
+debian/manpages/pcl_ppf_object_recognition.1
+debian/manpages/pcl_sac_segmentation_plane.1
+debian/manpages/pcl_spin_estimation.1
+debian/manpages/pcl_test_search_speed.1
+debian/manpages/pcl_tiff2pcd.1
+debian/manpages/pcl_train_linemod_template.1
+debian/manpages/pcl_transform_from_viewpoint.1
+debian/manpages/pcl_transform_point_cloud.1
+debian/manpages/pcl_uniform_sampling.1
+debian/manpages/pcl_vfh_estimation.1
+debian/manpages/pcl_voxel_grid.1
+debian/manpages/pcl_vtk2obj.1
+debian/manpages/pcl_vtk2pcd.1
+debian/manpages/pcl_vtk2ply.1
+debian/manpages/pcl_xyz2pcd.1
diff --git a/debian/rules b/debian/rules
new file mode 100755
index 000000000..17ad71030
--- /dev/null
+++ b/debian/rules
@@ -0,0 +1,72 @@
+#!/usr/bin/make -f
+
+# Uncomment this to turn on verbose mode.
+export DH_VERBOSE=1
+
+# Hardening.
+export DEB_BUILD_MAINT_OPTIONS=hardening=+all
+export DEB_CXXFLAGS_MAINT_APPEND = -g1
+
+# Explicitly enable -DNDEBUG, see:
+# 	https://github.com/ros-infrastructure/bloom/issues/327
+export DEB_CXXFLAGS_MAINT_APPEND +=-DNDEBUG
+
+BUILD_DOC = $(if $(shell dh_listpackages | grep libpcl-doc),-DWITH_DOCS=ON)
+
+# use clang on some archs as gcc is running into "virtual memory exhausted"
+ifneq (,$(filter $(DEB_BUILD_ARCH),mipsel armhf armel))
+  PARALLEL=--max-parallel=2
+  export CC=/usr/bin/clang
+  export CXX=/usr/bin/clang++
+
+# fails with "Unknown debugging section .debug_addr"
+override_dh_dwz:
+
+else
+  PARALLEL=--parallel
+endif
+
+ifneq (,$(filter $(DEB_BUILD_ARCH),s390x powerpc ppc64 riscv64))
+  RUN_TESTS=
+else
+  RUN_TESTS=-DBUILD_global_tests=ON -DBUILD_TESTS=ON
+
+override_dh_auto_test:
+	true
+
+endif
+
+override_dh_auto_configure:
+	# In case we're installing to a non-standard location, look for a setup.sh
+	# in the install tree and source it.  It will set things like
+	# CMAKE_PREFIX_PATH, PKG_CONFIG_PATH, and PYTHONPATH.
+	if [ -f "/opt/intel/oneapi/setvars.sh" ]; then . "/opt/intel/oneapi/setvars.sh"; fi && \
+	dh_auto_configure -- 						\
+	-DLIB_INSTALL_DIR:STRING="lib/$(DEB_HOST_MULTIARCH)"		\
+	-DCMAKE_SKIP_RPATH=ON \
+	-DBUILD_apps_in_hand_scanner=ON \
+	-DBUILD_apps_modeler=ON \
+	-DBUILD_apps=ON \
+	-DBUILD_apps_point_cloud_editor=ON \
+	-DCMAKE_BYPASS_CXX_FLAGS_CHECK=ON \
+	-DPCL_ENABLE_SSE=ON \
+	-DPCL_ENABLE_AVX=OFF \
+	-DPCL_ENABLE_MARCHNATIVE=OFF \
+	-DBUILD_ONEAPI=ON \
+	-DPCL_DISABLE_GPU_TESTS=ON \
+	$(BUILD_DOC) $(RUN_TESTS)
+
+override_dh_auto_build:
+	if [ -f "/opt/intel/oneapi/setvars.sh" ]; then . "/opt/intel/oneapi/setvars.sh"; fi && \
+	dh_auto_build
+
+override_dh_shlibdeps:
+	if [ -f "/opt/intel/oneapi/setvars.sh" ]; then . "/opt/intel/oneapi/setvars.sh"; fi && \
+	dh_shlibdeps --dpkg-shlibdeps-params=--ignore-missing-info
+
+override_dh_auto_install:
+	if [ -f "/opt/intel/oneapi/setvars.sh" ]; then . "/opt/intel/oneapi/setvars.sh"; fi && \
+	dh_auto_install
+
+%:
+	dh $@ -v --buildsystem=cmake $(PARALLEL)
diff --git a/debian/shlibs.local b/debian/shlibs.local
new file mode 100644
index 000000000..7ca5faf39
--- /dev/null
+++ b/debian/shlibs.local
@@ -0,0 +1,3 @@
+libsycl 7 intel-oneapi-runtime-dpcpp-cpp-2024
+libintlc 5 intel-oneapi-runtime-compilers-2024
+libtbb 12 intel-oneapi-runtime-tbb-2021
diff --git a/debian/source/format b/debian/source/format
new file mode 100644
index 000000000..163aaf8d8
--- /dev/null
+++ b/debian/source/format
@@ -0,0 +1 @@
+3.0 (quilt)
diff --git a/debian/source/options b/debian/source/options
new file mode 100644
index 000000000..143569252
--- /dev/null
+++ b/debian/source/options
@@ -0,0 +1,5 @@
+tar-ignore=.git
+tar-ignore=.gitignore
+tar-ignore=.github
+tar-ignore=.ci
+tar-ignore=ci
diff --git a/debian/watch b/debian/watch
new file mode 100644
index 000000000..0a7211340
--- /dev/null
+++ b/debian/watch
@@ -0,0 +1,5 @@
+version=4
+opts="dversionmangle=auto,repacksuffix=+dfsg,\
+    filenamemangle=s%(?:.*?)?v?(\d[\d.]*)\.tar\.gz%pcl-$1.tar.gz%" \
+    https://github.com/PointCloudLibrary/pcl/tags \
+    (?:.*?/)?v?pcl-(\d[\d.]*)\.tar\.gz
diff --git a/doc/tutorials/content/images/oneapi/convex_hull_3d_img.png b/doc/tutorials/content/images/oneapi/convex_hull_3d_img.png
new file mode 100644
index 0000000000000000000000000000000000000000..1df5dd197429bfb829653ab92eb50f80ced824bd
GIT binary patch
literal 72318
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
z%0A-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

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/images/oneapi/oneapi_logo.png b/doc/tutorials/content/images/oneapi/oneapi_logo.png
new file mode 100755
index 0000000000000000000000000000000000000000..fe3db735f02dea88c74facb8a32313d661b17007
GIT binary patch
literal 1642
zcmchXSyYk<6vscuYEsiCMoK%CmRgNsj%03>C5ih!D15mqs7<+)V3wIvo?IKlNGWqm
zFch#77t~xDja(=bGE0pl6~hHoEYnGJY#w@;GY|7L_u-!Z?|;v|=iZl_;py(6uDV?n
z004C-M>}r-P=c-L@{P)CIqH+%k+0zCibk!jt^$#@YXo#CfbbevLK6^HO)Tz_NF;-U
zgTNC-O-)TsP7W4}?e6Zzkvse3E3MNj8c`hBGX>!HkilSl{-Ov83CYOFSXfv<B9S7I
zh|lMbkB`gc^48YYl9CcA6l!K>W?*0t8yicdQUd}4Xe~kj`@qf3Ejc-vLZN7DYa<Yd
zu7RnxK8epYZY5VVB%aHv>|?eM1FlRM3`QgpBl{bI0APKRlbtO(p+H(NadyaD(;ok{
zwk*?o&`z!5YM;#UtN>Q2Sc&ls)jI%qlM&CcxKD*T8Y(}S&8WmGkq*iTU(fs&W@I`)
zg%|VsQt3EcTPS>V%-1+bN9M1~%%k&n;uQKpHcR()nb{`AvfWermY8i&oX@;wwrwXP
zTz;riO7dyve4qRr01sXK@-xE`LxRc`9Z8jjoov^ZRYk(l3+0&gpaD7Ap5kVkhxb0B
zg!F}yxBy%0*jDAvPypPdo27&^{SCI^Z_{;`P5rU0DIK%wy0}+L|0w=z$NyuB_^V;F
zi;1%a$&1SgI`RZ5{q)9}OP?3#2R-_NZCc_kv(*06B05RBYEA2T(VQttS%8Z#<}S8H
zNDeGUp<@?RJGS7-&kC6V0*gzcQ|up=9yGVL#Eg~XzO7@SQBAQf%Agl5bux-4P>%kP
zrwUecJp~^9atN3+0rx7=NW&yZPE}=;j#hhl?ZIuDo(QbB%K0-|)2u;h9MyZ?e_0E`
zErQ{*u5pHL=BAfit$N{JWx~`O8(XL`W((fixR1=0HkwZrlk0U@NrH>H`pm;>_c0Tb
zWs4E+S;`>2RJV>UCDmHqtnTeGbRuN;+-sCcU<cD2UWWI^#Za;iSK5O}o-$~34ib5l
zb<*yq(Jb*qlf$H=gLbdEOdeMf+Ozyd84MK^48Gjj>CAZt>3BlLiQNMRBBgbA>)>I_
zqI)#Y{)YVtwRB_BCo4H$?|9dRc*e7j3nQG}dUK~6gJoSRIH~{h=agDFHRcU3=u_1R
z$W!|#73KLA?O|!Yg_-L(HxYLt!)LIB#^0?WP<;iaCl$9ea1lI_p6N7$K(p-g^7lmG
zc1#LggM_vNhUC?@_+zF+mD3O8c!Q#Xr@YBuc8hIL*?Wv#u9J7?7-GoyUuD+H=*E{u
zZl)F_Va>iNJ6UwhM;GcB?zAHYvfseyOgVnyaW3T5<qf!p`R3undoBq7=sT^~cqcEh
zy~zZu2wFxKm(8)!D|JTgDN?hl(VT8U^O^gehwMp`J7P`A0a_bJ!|#I_If}O$pi}45
z;WXUsGskgdw!LGG>gtxnw#_(x0D->5CcKSz_9jzZ&8nohoesVn=R6sB)<J7u{^IQw
zk9xL7VsbG7!TvY`S2@)!tZ|;LpiPG4A28BN)%SYU-A$mHh740b$C=)t1s96>5HS9`
z;Q>=0BNq$C<jzq33S2LJsdw7k&%`CF^t#w82V-(-oam5+MO#)x+ODe!?7w9xDKFYG
zQR~&rsy_TS^&D@<9HeTr-zB4;=Uk}IdeO&t6qx6JVnLb-Vhh_fw)q{eq~Py8h$<q&
z=b>os+Te(~$RkDcLKbKE)=rW2wRr7Zy=n#9aNI<(;r$g>ENEEW?C6PDT^WJ)I`4Yb
z?VJc{P@vPA8NBU}1=kZR=?!Y^vB8(NfqSj}XSp7P*AeH@Mog3r_(;YSz-@zWh%LP5
z>6RO#O%m@Gn67MQKQr3a)jzz~cUnEgo=-UGTwtP^S>g5W`jrN6z9GmREjrgRDk6Fu
z4Itv>`(4`n1%AyM*&QcuOm&W<l2D}ECn@|PFG5f0@`v<qzw)cNxvUmU3z<Nc&=6nI
M3FU5g9~pe*FB-HHp8x;=

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/images/oneapi/pcl_oneapi_segmentation.png b/doc/tutorials/content/images/oneapi/pcl_oneapi_segmentation.png
new file mode 100644
index 0000000000000000000000000000000000000000..8de880e61b18041f67e8e6848535f2a99ba71323
GIT binary patch
literal 214788
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
Y-C2d>ON#l>L-By2tziIt4Y7^<KL$aZV*mgE

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/index.rst b/doc/tutorials/content/index.rst
index 43795791a..289733256 100644
--- a/doc/tutorials/content/index.rst
+++ b/doc/tutorials/content/index.rst
@@ -429,7 +429,7 @@ Filtering
                :height: 100px
     
 
-  * :ref:`statistical_outlier_removal` 
+  * :ref:`statistical_removal`
     
      ======  ======
      |fi_3|  Title: **Removing sparse outliers using StatisticalOutlierRemoval**
@@ -1414,6 +1414,169 @@ GPU
      .. |gp_2| image:: images/gpu/people/c2_100.jpg
                :height: 100px
 
+
+.. _oneapi:
+
+OneAPI Optimization
+-------------------
+
+  * :ref:`oneapi_install`
+     
+     ======  ======
+     |op_1|  Title: **Intel oneAPI Installation**
+
+             Author: *Larry Wu*
+
+             Compatibility: PCL git master
+
+             This tutorial explains how to install Intel oneAPI toolkits to build PCL optimized for Intel CPU/GPU/FPGA.
+     ======  ======
+     
+     .. |op_1| image:: images/oneapi/oneapi_logo.png
+               :height: 100px
+
+  * :ref:`oneapi_octree_search`
+    
+     ======  ======
+     |op_2|  Title: **Intel optimized version of Octree search**
+
+             Author: *Larry Wu, Lina Sun*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized octree radius search API.
+     ======  ======
+ 
+     
+     .. |op_2| image:: images/octree_img.png
+               :height: 100px
+
+  * :ref:`oneapi_statistical_outlier_removal`
+
+     ======  ======
+     |op_3|  Title: **Intel optimized version of statistical outlier removal**
+
+             Author: *Larry Wu, Lee Chon Ming*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized statistical outlier removal API.
+     ======  ======
+
+
+     .. |op_3| image:: images/statistical_removal.jpg
+               :height: 100px
+
+  * :ref:`oneapi_sample_consensus`
+
+     ======  ======
+     |op_4|  Title: **Intel optimized version of sample consensus**
+
+             Author: *Bo Peng*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized sample consensus API.
+     ======  ======
+
+
+     .. |op_4| image:: images/sample_consensus_planes_cylinders.jpg
+               :height: 100px
+               
+  * :ref:`oneapi_segmentation`
+
+     ======  ======
+     |op_5|  Title: **Intel optimized version of segmentation**
+
+             Author: *Pravin Patil*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized sgmentation API.
+     ======  ======
+
+
+     .. |op_5| image:: images/oneapi/pcl_oneapi_segmentation.png
+               :height: 100px
+
+  * :ref:`oneapi_sample_mls`
+
+     ======  ======
+     |op_6|  Title: **Intel optimized version of smoothing surface using Moving Least Squares (MLS)**
+
+             Author: *Lee Chon Ming*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to construct and run Intel optimized Moving Least Squares (MLS) algorithm.
+     ======  ======
+
+     .. |op_6| image:: images/resampling.jpg
+               :height: 100px
+
+  * :ref:`oneapi_registration`
+
+     ======  ======
+     |op_7|  Title: **Intel optimized version of Iterative Closest Point (ICP)**
+
+             Author: *Sarat Poluri*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized Iterative Closest Point.
+     ======  ======
+
+
+     .. |op_7| image:: images/iterative_closest_point.gif
+               :height: 100px
+
+  * :ref:`oneapi_kdtree`
+
+     ======  ======
+     |op_8|  Title: **Intel optimized version of KdTree**
+
+             Author: *Sarat Poluri, Lee Chon Ming*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized KdTree.
+     ======  ======
+
+
+     .. |op_8| image:: images/kdtree_search.png
+               :height: 100px
+
+  * :ref:`oneapi_normal_estimation`
+
+     ======  ======
+     |op_9|  Title: **Intel optimized version of Normal Estimation**
+
+             Author: *Lina Sun, Lee Chon Ming*
+
+             Compatibility: >= PCL 1.12.1
+
+             In this tutorial, we will learn how to use Intel optimized Normal Estimation.
+     ======  ======
+
+     .. |op_9| image:: images/normal_estimation.png
+               :height: 100px
+
+  * :ref:`greedy_triangulation_openmp`
+
+     =======  ======
+     |op_10|  Title: **Intel optimized version of Greedy Projection Triangulation**
+
+              Author: *Lee Chon Ming*
+
+              Compatibility: >= PCL 1.12.1
+
+              In this tutorial, we will learn how to use Intel optimized Greedy Projection Triangulation.
+     =======  ======
+
+
+     .. |op_10| image:: images/normal_estimation.png
+               :height: 100px
+
  ..
   * :ref:`normal_estimation_integral_images`
     Surface normal estimation
diff --git a/doc/tutorials/content/oneapi_greedy_projection.rst b/doc/tutorials/content/oneapi_greedy_projection.rst
new file mode 100644
index 000000000..cd87bc7c2
--- /dev/null
+++ b/doc/tutorials/content/oneapi_greedy_projection.rst
@@ -0,0 +1,116 @@
+.. _greedy_triangulation_openmp:
+
+Fast triangulation of unordered point clouds (OpenMP version)
+-------------------------------------------------------------
+
+This tutorial explains how to run a greedy surface triangulation algorithm (OpenMP version) on a
+PointCloud with normals, to obtain a triangle mesh based on projections of the
+local neighborhoods. The OpenMP version will break point cloud into multiple segments and call
+original version of greedy surface triangulation based on the segments count.  By running the
+segments independently and concurrently, there will be disjoint between each segments.  To overcome
+the disjoint issue, additional overlap segments will be created to go through greedy surface
+triangulation and combine with other processed segments.
+
+Please note the output of OpenMP version may differ from serial version of greedy projection
+triangulation.  
+
+Background: algorithm and parameters
+------------------------------------
+
+Refer to original :ref:`greedy_triangulation` for more detail original greedy triangulation
+parameters.  All greedy triangulation parameters are supported except getPointStates(),
+getPartIDs(), getSFN() and getFFN().
+
+Additional parameters are defined to provide control segments and overlap.
+
+* *setNumberofThreads(unsigned)* controls how many segments are created out of input point cloud.
+  Each segment size is using point cloud (maximum x - minimum x)/number of thread and all segment size is equal.
+  Each segment will send to a CPU thread/core.  It is recommended to get number of thread/cores from omp_get_max_threads().
+
+* *setBlockOverlapPercentage(double)* controls how wide to create the overlap region among two
+  segments.  The overlap region is this parameter percentage multiply the size of segment.  If there
+  is still gap between segments, can overcome by increase the overlap percentage.
+
+* *setRemoveDuplicateMesh(bool)* controls whether to clean up the duplicate point cloud and polygons
+  after combining all the segments output from GP3.
+
+
+The code
+--------
+
+
+First, create a file, let's say, ``greedy_projection.cpp`` in your favorite
+editor, and place the following code inside it:
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :linenos:
+
+The input file you can find at pcl/test/bun0.pcd
+
+The explanation
+---------------
+Now, let's break down the code piece by piece.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 11-15
+
+as the example PCD has only XYZ coordinates, we load it into a
+PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 17-26
+
+
+the method requires normals, so they are estimated using the standard method
+from PCL.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 28-31
+
+Since coordinates and normals need to be in the same PointCloud, we create a PointNormal type point cloud.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 33-39
+
+The above lines deal with the initialization of the required objects.  OpenMP version need to
+include <pcl/oneapi/surface_omp/gp3.h> and declare by append "OMP" to original class.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 41-54
+
+The above lines set the parameters, as explained above.
+
+.. literalinclude:: sources/oneapi/greedy_projection/greedy_projection.cpp
+   :language: cpp
+   :lines: 57-59
+
+The lines above set the input objects and perform the actual triangulation.
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/greedy_projection/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./greedy_projection
+
+Saving and viewing the result
+-----------------------------
+
+You can view the smoothed cloud for example by saving into a VTK file by::
+
+    #include <pcl/io/vtk_io.h>
+    ...
+    pcl::io::saveVTKFile ("mesh.vtk", triangles);
+
diff --git a/doc/tutorials/content/oneapi_install.rst b/doc/tutorials/content/oneapi_install.rst
new file mode 100644
index 000000000..e245787c3
--- /dev/null
+++ b/doc/tutorials/content/oneapi_install.rst
@@ -0,0 +1,68 @@
+.. _oneapi_install:
+
+Install Intel oneAPI Toolkits to build PCL optimized for Intel CPU/GPU/FPGA
+----------------------------------------------------------------------------
+
+In this tutorial you will learn how to configure your system to make it compatible to build oneAPI optimized PCL codes.
+This tutorial is for Ubuntu, other Linux distrubutions can follow a similar process to set it up.  
+
+Windows is currently  **not** officially supported for the oneAPI methods.
+
+Download Intel oneAPI Toolkits installer
+-----------------------------------------
+
+You can download Intel oneAPI Toolkits installer using the following command::
+
+  $ wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18487/l_BaseKit_p_2022.1.2.146_offline.sh
+  $ sudo sh ./l_BaseKit_p_2022.1.2.146_offline.sh
+
+`Command Line Installation Parameters <https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top/installation/install-with-command-line.html>`_ 
+ 
+Installation Instructions
+-------------------------
+
+Step 1: From the console, locate the downloaded install file.
+
+Step 2: Use $ sudo sh ./<installer>.sh to launch the GUI Installer as the root.
+
+Step 3: Follow the instructions in the installer.
+
+Step 4: Explore the `Get Started Guide <https://software.intel.com/content/www/us/en/develop/documentation/get-started-with-intel-oneapi-base-linux/top.html>`_.
+ 
+ 
+Installing GCC
+--------------
+
+To install GCC 10 run the following commands::
+ 
+ $ sudo apt update -y
+ $ sudo apt upgrade -y
+ $ sudo apt install -y build-essential
+ $ sudo apt install -y gcc-10 g++-10 cpp-10
+ 
+Set it as the default version::
+ 
+ $ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10
+
+It is a good idea to install cmake package, in addition to the above, because cmake is not included in build-essential::
+
+ $ sudo apt install -y cmake
+
+
+Building PCL
+------------
+
+Now you can get the latest git master (or another one) of PCL and build both 
+PCL_native and PCL_oneAPI.
+
+To build PCL_native library, go to your PCL root folder and do::
+
+ $ source /opt/intel/oneapi/setvars.sh
+ $ cd oneapi
+ $ ./build_pcl_native.sh
+
+To build PCL_oneAPI library::
+
+ $ ./build_pcl_oneapi.sh
+ 
+Now your installation is finished!
diff --git a/doc/tutorials/content/oneapi_kdtree.rst b/doc/tutorials/content/oneapi_kdtree.rst
new file mode 100644
index 000000000..df0969a6e
--- /dev/null
+++ b/doc/tutorials/content/oneapi_kdtree.rst
@@ -0,0 +1,169 @@
+.. _oneapi_kdtree:
+
+KdTree search using oneapi KdTree FLANN
+---------------------------------------------------------------------
+
+Oneapi KdTree is similar to pcl::KdTreeFLANN except oneapi kdtree is able to search entire point
+cloud in single call while pcl::KdTreeFLANN perform search for one point at a time.  Oneapi version
+return two-dimensional vector of indices and distances for entire point cloud search.  Both
+nearestKSearch and radiusSearch are supported.
+
+Oneapi includes additional higher performance fixed radius search which perform radius search from hash table.
+Unlike pcl::KdTreeFLANN radius search which supports to search different radius value once a Kdtree
+has built, fixed radius search need to specific a radius to build the hash table.  The hash table
+only able to search for a fixed radius.  Time to build a fixed radius hash table is much shorter
+than FLANN kdtree.  Another different is only FLANN kdtree supports return K elements from radius search but
+fixed radius search always return all elements.  For the same radius value, both FLANN and fixed
+radius search result should match.
+
+
+This document will not describe KdTree in detail, and please refer to original :ref:`kdtree_search` for more detail KdTree.
+
+
+The code:
+--------------
+
+Create a file, let's say, ``oneapi_kdtree.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Compare to original version, oneapi version requires to use oneapi kdtree header.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 1
+
+The following code first seeds rand() with the system time and then creates and fills a PointCloud with random data.  We will create another a set of search point with random coordinates as well.  In here, we want to search 3 coordinates using single call.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 10-40
+
+This next bit of code creates our kdtree object and sets our randomly created cloud as the input.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 42-43
+
+Now we create an integer (and set it equal to 5) and two two-dimensional vectors for storing our K nearest neighbors from the search.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 45-51
+
+Assuming that our KdTree returns more than 0 closest neighbors it then prints out the locations of all 5 closest neighbors to our random searchPoints which have been stored in our previously created vectors.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 53-65
+
+Now our code demonstrates finding all neighbors to our given searchPoints with a given radius. It again creates 2 vectors for storing information about our neighbors.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 67-73
+
+Again, like before if our KdTree returns more than 0 neighbors within the specified radius it prints out the coordinates of these points which have been stored in our vectors.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 75-87
+
+We provide another fixed radius search method through hash table.  As this is fixed radius search, need to provide the radius to build the table.
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 89-96
+
+Fixed radius search returns one dimension vector for both indices and squared distances for the neighbors. To correctly access for respective "searchPoints", use the return splits vector.  The example below show how to access for each "searchPoints".
+
+.. literalinclude:: sources/oneapi/kdtree/oneapi_kdtree.cpp
+   :language: cpp
+   :lines: 98-117
+
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/kdtree/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_kdtree
+
+Once you have run it you should see something similar to this::
+
+  K=5 neighbors from (911.933,321.699,128.681)
+    870.884 350.103 160.644 (squared distance: 3513.43)
+    856.565 374.562 132.514 (squared distance: 5874.84)
+    960.284 267.917 173.756 (squared distance: 7262)
+    987.681 359.434 104.805 (squared distance: 7731.77)
+    929.787 396.96 84.1415 (squared distance: 7966.85)
+  K=5 neighbors from (39.0119,923.789,113.278)
+    36.4024 943.423 84.1814 (squared distance: 1238.91)
+    68.2891 927.112 150.885 (squared distance: 2282.5)
+    79.0735 887.262 63.1519 (squared distance: 5451.72)
+    119.306 1021.4 127.402 (squared distance: 16175.4)
+    116.103 800.647 145.881 (squared distance: 22169.9)
+  K=5 neighbors from (542.853,566.777,4.23339)
+    481.511 597.7 27.2575 (squared distance: 5249.24)
+    570.652 585.804 69.9711 (squared distance: 5456.25)
+    574.454 498.665 37.4542 (squared distance: 6741.42)
+    569.49 480.913 6.70625 (squared distance: 8088.2)
+    649.963 597.5 25.601 (squared distance: 12872.9)
+  Kdtree Radius Search Radius=100 neighbors from (911.933,321.699,128.681)
+    870.884 350.103 160.644 (squared distance: 3513.43)
+    856.565 374.562 132.514 (squared distance: 5874.84)
+    960.284 267.917 173.756 (squared distance: 7262)
+    987.681 359.434 104.805 (squared distance: 7731.77)
+    929.787 396.96 84.1415 (squared distance: 7966.85)
+    967.947 352.763 64.8979 (squared distance: 8170.85)
+    974.103 248.606 116.676 (squared distance: 9351.69)
+    842.968 389.302 109.632 (squared distance: 9689.34)
+  Kdtree Radius Search Radius=100 neighbors from (39.0119,923.789,113.278)
+    36.4024 943.423 84.1814 (squared distance: 1238.91)
+    68.2891 927.112 150.885 (squared distance: 2282.5)
+    79.0735 887.262 63.1519 (squared distance: 5451.72)
+  Kdtree Radius Search Radius=100 neighbors from (542.853,566.777,4.23339)
+    481.511 597.7 27.2575 (squared distance: 5249.24)
+    570.652 585.804 69.9711 (squared distance: 5456.25)
+    574.454 498.665 37.4542 (squared distance: 6741.42)
+    569.49 480.913 6.70625 (squared distance: 8088.2)
+  Fixed Radius Search Radius=100 neighbors from (911.933,321.699,128.681)
+    870.884 350.103 160.644 (squared distance: 3513.43)
+    856.565 374.562 132.514 (squared distance: 5874.84)
+    960.284 267.917 173.756 (squared distance: 7262)
+    987.681 359.434 104.805 (squared distance: 7731.77)
+    929.787 396.96 84.1415 (squared distance: 7966.85)
+    967.947 352.763 64.8979 (squared distance: 8170.85)
+    974.103 248.606 116.676 (squared distance: 9351.69)
+    842.968 389.302 109.632 (squared distance: 9689.34)
+  Fixed Radius Search Radius=100 neighbors from (39.0119,923.789,113.278)
+    36.4024 943.423 84.1814 (squared distance: 1238.91)
+    68.2891 927.112 150.885 (squared distance: 2282.49)
+    79.0735 887.262 63.1519 (squared distance: 5451.72)
+  Fixed Radius Search Radius=100 neighbors from (542.853,566.777,4.23339)
+    481.511 597.7 27.2575 (squared distance: 5249.24)
+    570.652 585.804 69.9711 (squared distance: 5456.25)
+    574.454 498.665 37.4542 (squared distance: 6741.42)
+    569.49 480.913 6.70625 (squared distance: 8088.2)
diff --git a/doc/tutorials/content/oneapi_mls.rst b/doc/tutorials/content/oneapi_mls.rst
new file mode 100644
index 000000000..7957f84d6
--- /dev/null
+++ b/doc/tutorials/content/oneapi_mls.rst
@@ -0,0 +1,123 @@
+.. _oneapi_sample_mls:
+
+Surface reconstruction method using oneapi Moving Least Squares (MLS)
+---------------------------------------------------------------------
+
+Oneapi Moving Least Squares (MLS) is based on original MLS API.  All the APIs remain the same and
+only need to add oneapi namespace prior to existing namespace.
+
+The differences compare to original version are below.
+
+  #. Calculations are performed using 32bit float instead of 64bit double.
+
+  #. MLS surface is constructed by grouping set of indices into multiple blocks.  As a result, it consumes more system memory compare to original version.  Block size can control through setSearchBlockSize.
+
+  #. Original version use OpenMP to improve the performance, but various upsampling methods like DISTINCT_CLOUD and VOXEL_GRID_DILATION don't get OpenMP support.  Oneapi version improve performance for all upsampling methods.
+
+
+
+Refer to original :ref:`moving_least_squares` for more detail MLS.
+
+
+
+The code:
+--------------
+
+First, download the dataset `bun0.pcd
+<https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bun0.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_mls.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+Compare to original version, oneapi version requires to use oneapi mls header.
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 1-2
+
+
+We first load the example PCD into a PointCloud<PointXYZ>.  As the example PCD has only XYZ coordinates, we load it into a
+PointCloud<PointXYZ>. These fields are mandatory for the method, other ones are
+allowed and will be preserved.
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 13-16
+
+
+Compare to original version, append oneapi namespace to original MovingLeastSquares class. 
+The first template type is used for the input and output cloud. Only the XYZ
+dimensions of the input are smoothed in the output.
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 23-24
+
+
+if normal estimation is not required, this step can be skipped.
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 26
+
+Maximum polynomial order supported are 5 (future release may increase it). Please consult
+the code API (pcl:MovingLeastSquares) for default values and additional parameters to 
+control the smoothing process. Oneapi version support all parameters from original version
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 28-32
+
+
+Perform reconstruction
+
+.. literalinclude:: sources/oneapi/mls/oneapi_mls.cpp
+   :language: cpp
+   :lines: 34-35
+
+
+if the normals and the original dimensions need to be in the same cloud, the
+fields have to be concatenated.
+
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/mls/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_mls
+
+You can view the smoothed cloud for example by executing::
+
+  $ pcl_viewer bun0-mls.pcd
+
+
+
+
+
diff --git a/doc/tutorials/content/oneapi_normal_estimation.rst b/doc/tutorials/content/oneapi_normal_estimation.rst
new file mode 100644
index 000000000..22412482d
--- /dev/null
+++ b/doc/tutorials/content/oneapi_normal_estimation.rst
@@ -0,0 +1,85 @@
+.. _oneapi_normal_estimation:
+
+Estimating Surface Normals in a PointCloud
+------------------------------------------
+
+In this tutorial we will learn how to get the surface normals of each point in the cloud.
+
+
+The code:
+--------------
+
+First, download the dataset `bun0.pcd
+<https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bun0.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_normal_estimation.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's take a look at the code in detail.
+
+We first load the example PCD into a PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :lines: 13-21
+
+In this tutorial we will perform normal estimations two times, one is KNN search and the other is radius search.
+We first change parameters for normal estimation for KNN search.
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :lines: 23-27
+
+Then we perform normal estimation.
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :lines: 30-31
+
+Change normal estimation parameters for radius search.
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :lines: 35-39
+
+Then we perform normal estimation.
+
+.. literalinclude:: sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
+   :language: cpp
+   :lines: 41-43
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/normal_estimation/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_normal_estimation
+
+You will see something similar to::
+
+  normals_knn.size (): 397
+  normals_radius.size (): 397
diff --git a/doc/tutorials/content/oneapi_octree.rst b/doc/tutorials/content/oneapi_octree.rst
new file mode 100644
index 000000000..b216500d7
--- /dev/null
+++ b/doc/tutorials/content/oneapi_octree.rst
@@ -0,0 +1,143 @@
+.. _oneapi_octree_search:
+
+Spatial Partitioning and Search Operations with Octrees
+-------------------------------------------------------
+
+An octree is a tree data structure in which each internal node has exactly eight children. Octrees are most often used to partition a three-dimensional space by recursively subdividing it into eight octants. Octrees are the three-dimensional analog of quadtrees. The word is derived from oct (Greek root meaning "eight") + tree. Octrees are often used in 3D graphics and 3D game engines.
+In this tutorial we will learn how to use the octree for spatial partitioning and neighbor search within pointcloud data. We will explain how to perform "Neighbors within Radius Search", "Approximate Nearest Neighbor (ANN) Search" and "K-Nearest Neighbors (KNN) Search".
+
+
+The code:
+--------------
+First, create a file, let's say, ``oneapi_octree_search.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's take a look at the code in detail.
+
+We first generate point cloud data, queries, radiuses, indices with random number.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 31-55
+
+
+Then we create and build the oneAPI point cloud, upload the queries and radiuses to oneAPI device.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 57-70
+
+Then we create output buffers where we can download output from oneAPI device.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 72-79
+
+The fist radius search method used here is "search with shared radius". It means all queries use the same radius to find the neighbors.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 81-85
+
+The second radius search method used here is "search with individual radius". It means every query uses its specific radius to find the neighbors.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 84-85
+
+The third radius search method used here is "search with shared radius using indices". It means all queries use the same radius and we use indcies to specify the queries.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 87-91
+
+Then we perform ANN search.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 93-96
+
+Then we perform KNN search.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 98-101
+
+After the search, we can download the result from oneAPI device. The size vector contains the size of found neighbors for each query. The downloaded_buffer vector contains the index of all the found neighbors for each query.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 103-114
+
+Print out the query, radius, and found neighbors to verify the result is correct.
+
+.. literalinclude:: sources/oneapi/octree/oneapi_octree_search.cpp
+   :language: cpp
+   :lines: 116-172
+   
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/octree/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../ 
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_octree_search
+
+You will see something similar to::
+
+    Neighbors within shared radius search at (671.675 733.78 466.178) with radius=34.1333
+        660.296 725.957 439.677 (distance: 29.8829)
+        665.768 721.884 442.919 (distance: 26.7846)
+        683.988 714.608 445.164 (distance: 30.9962)
+        677.927 725.08 446.531 (distance: 22.3788)
+        695.066 723.509 445.762 (distance: 32.7028)
+    Neighbors within individual radius search at (671.675 733.78 466.178) with radius=19.3623
+        672.71 736.679 447.835 (distance: 18.6)
+        664.46 731.504 452.074 (distance: 16.0048)
+        671.238 725.881 461.408 (distance: 9.23819)
+        667.707 718.527 466.622 (distance: 15.7669)
+        654.552 733.636 467.795 (distance: 17.1993)
+    Neighbors within indices radius search at (671.675 733.78 466.178) with radius=34.1333
+        660.296 725.957 439.677 (distance: 29.8829)
+        665.768 721.884 442.919 (distance: 26.7846)
+        683.988 714.608 445.164 (distance: 30.9962)
+        677.927 725.08 446.531 (distance: 22.3788)
+        695.066 723.509 445.762 (distance: 32.7028)
+    Approximate nearest neighbor at (671.675 733.78 466.178)
+        668.259 730.64 465.101 (distance: 4.76329)
+    K-nearest neighbors (k = 5) at (671.675 733.78 466.178)
+        676.614 728.005 464.148 (distance: 7.86563)
+        671.238 725.881 461.408 (distance: 9.23819)
+        676.369 732.902 475.262 (distance: 10.263)
+        665.557 739.096 463.869 (distance: 8.42724)
+        668.259 730.64 465.101 (distance: 4.76329)
+
+The radius search only finds the first 5 neighbors (as specified in max_answers), so different radius finds different points.
+
+Conclusion
+----------
+
+The oneAPI PCL octree implementation is a powerful tools for spatial partitioning and search operation. 
+
diff --git a/doc/tutorials/content/oneapi_passthrough.rst b/doc/tutorials/content/oneapi_passthrough.rst
new file mode 100644
index 000000000..676d953e3
--- /dev/null
+++ b/doc/tutorials/content/oneapi_passthrough.rst
@@ -0,0 +1,79 @@
+.. _oneapi_passthrough:
+
+Filtering a point clouds using a PassThrough filter
+----------------------------------------------------
+
+In this tutorial we will learn how to perform passthrough filtering.
+
+
+The code:
+--------------
+
+First, download the dataset `using_kinfu_large_scale_output.pcd
+<https://github.com/PointCloudLibrary/data/tree/master/tutorials/kinfu_large_scale/using_kinfu_large_scale_output.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_passthrough.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/passthrough/oneapi_passthrough.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+We first load the example PCD into a PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/passthrough/oneapi_passthrough.cpp
+   :language: cpp
+   :lines: 12-19
+
+Then prepare output buffer for filtered result.
+
+.. literalinclude:: sources/oneapi/passthrough/oneapi_passthrough.cpp
+   :language: cpp
+   :lines: 21-22
+
+Next starts to compute the result.
+
+.. literalinclude:: sources/oneapi/passthrough/oneapi_passthrough.cpp
+   :language: cpp
+   :lines: 24-29
+
+Result(output log).
+
+.. literalinclude:: sources/oneapi/passthrough/oneapi_passthrough.cpp
+   :language: cpp
+   :lines: 32-33
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/passthrough/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_passthrough
+
+You will see something similar to::
+
+   [oneapi passthrough] PointCloud before filtering: 993419
+   [oneapi passthrough] PointCloud after filtering: 328598
+
diff --git a/doc/tutorials/content/oneapi_registration.rst b/doc/tutorials/content/oneapi_registration.rst
new file mode 100644
index 000000000..d6ddedb80
--- /dev/null
+++ b/doc/tutorials/content/oneapi_registration.rst
@@ -0,0 +1,111 @@
+.. _oneapi_registration:
+
+The PCL Registration API
+------------------------
+For details regarding the PCL Registration module and it's internal algorithmic
+details, please refer to the registration documentation under:
+doc/tutorials/content/registration_api.rst
+
+In this implementation, only the standard Iterative Closest Point has been
+optimized using Intel :sup:`` OneAPI. Joint ICP and Generalized ICP
+are not currently optmized with OneAPI.
+
+Iterative Closest Point
+-----------------------
+
+Iterative closest point (ICP) is an algorithm employed to minimize the
+difference between two clouds of points.
+
+The ICP steps are:
+
+1. For each point in the source point cloud, match the closest point in the
+   reference/target point cloud.
+2. Estimate the combination of rotation and translation using a
+   root mean square point to point distance metric minimization technique which
+   will best align each source point to its match found in the previous step.
+3. Transform the source points using the obtained transformation.
+4. Iterate (re-associate the points, and so on).
+
+The code
+--------
+
+First, create a file, let's say, ``oneapi_icp_example.cpp`` in your favorite editor, and
+place the following code inside it:
+
+.. literalinclude:: sources/oneapi/registration/oneapi_icp_example.cpp
+   :language: cpp
+   :linenos:
+
+The explanation
+---------------
+
+Now, let's break down the code piece by piece.
+
+In lines:
+
+.. literalinclude:: sources/oneapi/registration/oneapi_icp_example.cpp
+   :language: cpp
+   :lines: 19-27
+
+we define two input Point Clouds (src, tgt) and declare the output point cloud.
+Then, fill in the data for the input point clouds.
+
+Then, lines:
+
+.. literalinclude:: sources/oneapi/registration/oneapi_icp_example.cpp
+   :language: cpp
+   :lines: 30-34
+
+declare the OneAPI optimized version of ICP and set the input configuration
+parameters.
+
+In line:
+
+.. literalinclude:: sources/oneapi/registration/oneapi_icp_example.cpp
+   :language: cpp
+   :lines: 36-40
+
+we set the two input point clouds for the ICP module and finally call the
+method to align the two point clouds. The align method populates the output
+point cloud, passed as a parameter, with src point cloud transformed using the
+computed transformation matrix.
+
+Finally:
+
+.. literalinclude:: sources/oneapi/registration/oneapi_icp_example.cpp
+   :language: cpp
+   :lines: 42-44
+
+get the computed matrix transformation, print it and save transformed
+point cloud.
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/registration/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../ 
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_icp_example
+
+You will see an output similar to::
+
+  Transform Matrix:
+  0.998886  0.0107214  0.0457269  0.0791018
+  -0.0095072    0.99959 -0.0266714  0.0252342
+  -0.0459948  0.0262073   0.998591  0.0676732
+         0          0          0          1
diff --git a/doc/tutorials/content/oneapi_sample_consensus.rst b/doc/tutorials/content/oneapi_sample_consensus.rst
new file mode 100644
index 000000000..9d5efacbe
--- /dev/null
+++ b/doc/tutorials/content/oneapi_sample_consensus.rst
@@ -0,0 +1,104 @@
+.. _oneapi_sample_consensus:
+
+Detect specific models and their parameters in point clouds
+----------------------------------------------------
+
+In this tutorial we will learn how to detect a plane model in a 3D point cloud.
+
+
+The code:
+--------------
+
+First, download the dataset `test59.pcd
+<https://github.com/PointCloudLibrary/data/tree/master/segmentation/mOSD/test/test59.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_sample_consensus.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+We first load the example PCD into a PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 49-57
+
+Then input and output device arrays are created and point cloud data is uploaded to input device array.
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 59-62
+
+Next start to compute the model.
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 65-69
+
+Result(Best model).
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 72-73
+
+Result(model Coefficient).
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 76-77
+
+Result(model inliers).
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 80-85
+
+Result(refined model Coefficient).
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 88-89
+
+Result(output log).
+
+.. literalinclude:: sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
+   :language: cpp
+   :lines: 92-95
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/sample_consensus/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_sample_consensus ./test59.pcd
+
+You will see something similar to::
+
+   input cloud size: 307200
+   inliers size    : 77316
+   plane model coefficient: -0.0789502, -0.816661, -0.571692, 0.546386
+   Optimized coefficient  : -0.0722213, -0.818286, -0.570256, 0.547587
diff --git a/doc/tutorials/content/oneapi_sample_consensus_initial_alignment.rst b/doc/tutorials/content/oneapi_sample_consensus_initial_alignment.rst
new file mode 100644
index 000000000..69883fdf9
--- /dev/null
+++ b/doc/tutorials/content/oneapi_sample_consensus_initial_alignment.rst
@@ -0,0 +1,77 @@
+.. _oneapi_voxel_grid:
+
+Using SampleConsensusInitialAligment to initial align two point clouds
+----------------------------------------------------
+
+In this tutorial we will learn how to initial align two point clouds, using SCIA, given the transformation 4x4 matrix.
+
+
+The code:
+--------------
+
+Create a file, let's say, ``oneapi_scia.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+Load source/target/fpfh_source/fpfh_target PCD file
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
+   :language: cpp
+   :lines: 18-27
+
+Then, load the example source/target/fpfh_source/fpfh_target PCD into a PointCloud<PointXYZ/FPFHSignature33>.
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
+   :language: cpp
+   :lines: 28-37
+
+Next start to compute the model.
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
+   :language: cpp
+   :lines: 39-56
+
+Result(output log).
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
+   :language: cpp
+   :lines: 58-59
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/sample_consensus_initial_alignment/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_scia
+
+You will see something similar to::
+
+   [oneapi SCIA] Transformation Matrix 4x4 = 
+    0.268113 -0.734448 -0.623458  0.289958
+    0.748389 -0.248733  0.614853 -0.208532
+   -0.606653  -0.63144  0.482965  0.229585
+           0         0         0         1
diff --git a/doc/tutorials/content/oneapi_segmentation.rst b/doc/tutorials/content/oneapi_segmentation.rst
new file mode 100644
index 000000000..f407b716a
--- /dev/null
+++ b/doc/tutorials/content/oneapi_segmentation.rst
@@ -0,0 +1,103 @@
+.. _oneapi_segmentation:
+
+Plane model segmentation
+----------------------------------------------------
+
+In this tutorial we will learn how to do a simple plane segmentation of a set of points, that is to find all the points within a point cloud that support a plane model
+
+
+The code:
+--------------
+
+First, download the dataset `test59.pcd
+<https://github.com/PointCloudLibrary/data/tree/master/segmentation/mOSD/test/test59.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_segmentation.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+We first load the example PCD into a PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 9-11
+
+Then create oneapi_segmentation object.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 21 
+
+Configure oneapi_segmentation class.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 24-32
+
+Set to true if a coefficient refinement is required..
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 29
+
+Set algorithm method and model type.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 31-32
+
+Out parameter declaration for getting inliers and model coefficients.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 35-36
+
+Getting inliers and model coefficients by calling segment() API.
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 39
+
+Result(output log).
+
+.. literalinclude:: sources/oneapi/segmentation/oneapi_segmentation.cpp
+   :language: cpp
+   :lines: 41-43
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/segmentation/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_segmentation ./test59.pcd
+
+You will see something similar to::
+
+   input cloud size   : 307200
+   inliers size       : 25332
+   model coefficients : -0.176599, -1.87228, -1.08408, 1
diff --git a/doc/tutorials/content/oneapi_statistical_outlier.rst b/doc/tutorials/content/oneapi_statistical_outlier.rst
new file mode 100644
index 000000000..bbe61854d
--- /dev/null
+++ b/doc/tutorials/content/oneapi_statistical_outlier.rst
@@ -0,0 +1,99 @@
+.. _oneapi_statistical_outlier_removal:
+
+Removing outliers using a StatisticalOutlierRemoval filter
+----------------------------------------------------------
+
+In this tutorial we will learn how to remove noisy measurements, e.g. outliers,
+from a point cloud dataset using statistical analysis techniques.  This is oneapi optimization
+version of pcl::StatisticalOutlierRemoval.
+
+For more info of StatusticalOutlierRemoval filter, refer to `this page.
+<https://pointclouds.org/documentation/tutorials/statistical_outlier.html>`_
+
+The code
+--------
+
+Create a file, let's say, ``oneapi_statistical_outlier_removal.cpp`` in your favorite
+editor, and place the following inside it:
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :linenos:
+
+The explanation
+---------------
+
+Now, let's break down the code piece by piece.
+
+The following lines of code will read the point cloud data from disk.
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :lines: 12-15
+
+Then, a *pcl::StatisticalOutlierRemoval* filter is created. The number of
+neighbors to analyze for each point is set to 50, and the standard deviation
+multiplier to 1. What this means is that all points who have a distance larger
+than 1 standard deviation of the mean distance to the query point will be
+marked as outliers and removed. The output is computed and stored in
+*cloud_filtered*.
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :lines: 22-27
+
+The remaining data (inliers) is written to disk for later inspection.
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :lines: 32-32
+
+
+Then, the filter is called with the same parameters, but with the output
+negated, to obtain the outliers (e.g., the points that were filtered).
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :lines: 35-36
+
+
+And the data is written back to disk.
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
+   :language: cpp
+   :lines: 37
+
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/statistical_outlier_removal/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_statistical_outlier_removal
+
+You will see something similar to::
+
+  Cloud before filtering:
+  header: seq: 0 stamp: 0 frame_id:
+
+  points[]: 460400
+  width: 460400
+  height: 1
+  is_dense: 1
+  sensor origin (xyz): [0, 0, 0] / orientation (xyzw): [0, 0, 0, 1]
+
+  Cloud after filtering:
+  header: seq: 0 stamp: 0 frame_id:
+
+  points[]: 451410
+  width: 451410
+  height: 1
+  is_dense: 1
+  sensor origin (xyz): [0, 0, 0] / orientation (xyzw): [0, 0, 0, 1]
+
diff --git a/doc/tutorials/content/oneapi_voxel_grid.rst b/doc/tutorials/content/oneapi_voxel_grid.rst
new file mode 100644
index 000000000..93abf2f8f
--- /dev/null
+++ b/doc/tutorials/content/oneapi_voxel_grid.rst
@@ -0,0 +1,79 @@
+.. _oneapi_voxel_grid:
+
+Using a voxelized grid approach to downsample the point clouds
+----------------------------------------------------
+
+In this tutorial we will learn how to downsample/reduce the number of points in a 3D point cloud, using a voxelized grid approach.
+
+
+The code:
+--------------
+
+First, download the dataset `table_scene_lms400.pcd
+<https://github.com/PointCloudLibrary/data/tree/master/tutorials/table_scene_lms400.pcd>`_
+and save it somewhere to disk.
+
+Then, create a file, let's say, ``oneapi_voxel_grid.cpp`` and place the following inside it:
+
+.. literalinclude:: sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
+   :language: cpp
+   :linenos:
+
+
+The explanation
+---------------
+
+Now, let's explain the code in detail.
+
+We first load the example PCD into a PointCloud<PointXYZ>.
+
+.. literalinclude:: sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
+   :language: cpp
+   :lines: 11-18
+
+Then prepare output buffer for filtered result.
+
+.. literalinclude:: sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
+   :language: cpp
+   :lines: 20-21
+
+Next starts to compute the result.
+
+.. literalinclude:: sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
+   :language: cpp
+   :lines: 23-28
+
+Result(output log).
+
+.. literalinclude:: sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
+   :language: cpp
+   :lines: 30-32
+
+Compiling and running the program
+---------------------------------
+
+Add the following lines to your CMakeLists.txt file:
+
+.. literalinclude:: sources/oneapi/voxel_grid/CMakeLists.txt
+   :language: cmake
+   :linenos:
+
+Source the oneAPI environment::
+
+  $ source /opt/intel/oneapi/setvars.sh
+
+Build the code::
+
+  $ mkdir build && cd build
+  $ cmake ../
+  $ make -j
+
+After you have made the executable, you can run it. Simply do::
+
+  $ ./oneapi_voxel_grid
+
+You will see something similar to::
+
+   [oneapi voxel grid] PointCloud before filtering: 460400
+   [oneapi voxel grid] PointCloud after filtering: 141525
+
diff --git a/doc/tutorials/content/sources/oneapi/data/scia_source.pcd b/doc/tutorials/content/sources/oneapi/data/scia_source.pcd
new file mode 100644
index 0000000000000000000000000000000000000000..993494fb3e8c83312823bb85590f19d6ac18d41a
GIT binary patch
literal 40730
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
AT>t<8

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/sources/oneapi/data/scia_source_fpfh33.pcd b/doc/tutorials/content/sources/oneapi/data/scia_source_fpfh33.pcd
new file mode 100644
index 0000000000000000000000000000000000000000..467b500bf107010be2c26b77d8940dbccd98de0f
GIT binary patch
literal 446318
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%0DNh`C!L&
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%0DK%LeW$PX$^gz#iUofpOoegAc?Hz}hRf
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
CX_%M*

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/sources/oneapi/data/scia_target.pcd b/doc/tutorials/content/sources/oneapi/data/scia_target.pcd
new file mode 100644
index 0000000000000000000000000000000000000000..f19f195333ca9ef2349dfdb56b2af54c8ed61396
GIT binary patch
literal 36614
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

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/sources/oneapi/data/scia_target_fpfh33.pcd b/doc/tutorials/content/sources/oneapi/data/scia_target_fpfh33.pcd
new file mode 100644
index 0000000000000000000000000000000000000000..c67040af0b0bd47bb63999857342ca0c1178f78e
GIT binary patch
literal 401042
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%0AV)R%qx~}RUVBNINkmBRa
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
YO6u189aiJy>>jQVN}}(kVO7lk0DJ)3GXMYp

literal 0
HcmV?d00001

diff --git a/doc/tutorials/content/sources/oneapi/greedy_projection/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/greedy_projection/CMakeLists.txt
new file mode 100644
index 000000000..886cffd50
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/greedy_projection/CMakeLists.txt
@@ -0,0 +1,29 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+
+project(greedy_projection)
+
+find_package(PCL 1.2 REQUIRED)
+
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+
+add_executable (greedy_projection greedy_projection.cpp)
+target_link_libraries (greedy_projection ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bun0.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/greedy_projection/greedy_projection.cpp b/doc/tutorials/content/sources/oneapi/greedy_projection/greedy_projection.cpp
new file mode 100644
index 000000000..6a8810625
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/greedy_projection/greedy_projection.cpp
@@ -0,0 +1,65 @@
+#include <pcl/point_types.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/io/vtk_io.h>
+#include <pcl/search/kdtree.h> // for KdTree
+#include <pcl/features/normal_3d.h>
+#include <pcl/oneapi/surface_omp/gp3.h>
+
+int
+main ()
+{
+  // Load input file into a PointCloud<T> with an appropriate type
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
+  pcl::PCLPointCloud2 cloud_blob;
+  pcl::io::loadPCDFile ("bun0.pcd", cloud_blob);
+  pcl::fromPCLPointCloud2 (cloud_blob, *cloud);
+  //* the data should be available in cloud
+
+  // Normal estimation*
+  pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> n;
+  pcl::PointCloud<pcl::Normal>::Ptr normals (new pcl::PointCloud<pcl::Normal>);
+  pcl::search::KdTree<pcl::PointXYZ>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZ>);
+  tree->setInputCloud (cloud);
+  n.setInputCloud (cloud);
+  n.setSearchMethod (tree);
+  n.setKSearch (20);
+  n.compute (*normals);
+  //* normals should not contain the point normals + surface curvatures
+
+  // Concatenate the XYZ and normal fields*
+  pcl::PointCloud<pcl::PointNormal>::Ptr cloud_with_normals (new pcl::PointCloud<pcl::PointNormal>);
+  pcl::concatenateFields (*cloud, *normals, *cloud_with_normals);
+  //* cloud_with_normals = cloud + normals
+
+  // Create search tree*
+  pcl::search::KdTree<pcl::PointNormal>::Ptr tree2 (new pcl::search::KdTree<pcl::PointNormal>);
+  tree2->setInputCloud (cloud_with_normals);
+
+  // Initialize objects
+  pcl::GreedyProjectionTriangulationOMP<pcl::PointNormal> gp3;
+  pcl::PolygonMesh triangles;
+
+  // Set the maximum distance between connected points (maximum edge length)
+  gp3.setSearchRadius (0.025);
+
+  // Set typical values for the parameters
+  gp3.setMu (2.5);
+  gp3.setMaximumNearestNeighbors (100);
+  gp3.setMaximumSurfaceAngle(M_PI/4); // 45 degrees
+  gp3.setMinimumAngle(M_PI/18); // 10 degrees
+  gp3.setMaximumAngle(2*M_PI/3); // 120 degrees
+  gp3.setNormalConsistency(false);
+  gp3.setNumberOfThreads(3);
+  gp3.setBlockOverlapPercentage(0.04);
+  gp3.setRemoveDuplicateMesh(true);
+
+  // Get result
+  gp3.setInputCloud (cloud_with_normals);
+  gp3.setSearchMethod (tree2);
+  gp3.reconstruct (triangles);
+
+  pcl::io::saveVTKFile("mesh.vtk", triangles);
+
+  // Finish
+  return (0);
+}
diff --git a/doc/tutorials/content/sources/oneapi/kdtree/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/kdtree/CMakeLists.txt
new file mode 100644
index 000000000..10c462bc0
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/kdtree/CMakeLists.txt
@@ -0,0 +1,22 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_kdtree)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_kdtree.cpp)
+target_link_libraries (${target} pcl_oneapi_search ${PCL_LIBRARIES})
diff --git a/doc/tutorials/content/sources/oneapi/kdtree/oneapi_kdtree.cpp b/doc/tutorials/content/sources/oneapi/kdtree/oneapi_kdtree.cpp
new file mode 100644
index 000000000..06f806a18
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/kdtree/oneapi_kdtree.cpp
@@ -0,0 +1,120 @@
+#include <pcl/oneapi/search/kdtree.h> // for KdTree
+#include <pcl/point_cloud.h>
+
+#include <vector>
+#include <iostream>
+
+int
+main (int argc, char** argv)
+{
+  srand (time (NULL));
+
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
+
+  // Generate pointcloud data
+  cloud->width = 1000;
+  cloud->height = 1;
+  cloud->points.resize (cloud->width * cloud->height);
+
+  for (std::size_t i = 0; i < cloud->size (); ++i)
+  {
+    (*cloud)[i].x = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+    (*cloud)[i].y = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+    (*cloud)[i].z = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+  }
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr searchPoints (new pcl::PointCloud<pcl::PointXYZ>);
+
+  // Generate pointcloud data
+  searchPoints->width = 3;
+  searchPoints->height = 1;
+  searchPoints->points.resize (searchPoints->width * searchPoints->height);
+
+  for (std::size_t i = 0; i < searchPoints->size (); ++i)
+  {
+    (*searchPoints)[i].x = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+    (*searchPoints)[i].y = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+    (*searchPoints)[i].z = static_cast<float>(1024.0f * rand () / (RAND_MAX + 1.0));
+  }
+
+  pcl::oneapi::search::KdTree<pcl::PointXYZ> kdtree;
+  kdtree.setInputCloud (cloud);
+
+  // K nearest neighbor search
+  int K = 5;
+
+  std::vector< std::vector< float > > pointsSquaredDistance (searchPoints->size()) ;
+  std::vector< pcl::Indices > pointsIdxKnnSearch (searchPoints->size());
+
+  kdtree.nearestKSearch(*searchPoints, K, pointsIdxKnnSearch, pointsSquaredDistance);
+
+  for (std::size_t j = 0; j < pointsIdxKnnSearch.size(); ++j)
+  {
+    std::cout << "K=" << K << " neighbors from (" << (*searchPoints)[j].x << ","
+                                                 << (*searchPoints)[j].y << ","
+                                                 << (*searchPoints)[j].z << ")" << std::endl;
+    for (std::size_t i = 0; i < pointsIdxKnnSearch.at(j).size(); ++i)
+    {
+      std::cout << "    "  <<   (*cloud)[ pointsIdxKnnSearch.at(j)[i] ].x
+                << " " <<  (*cloud)[ pointsIdxKnnSearch.at(j)[i] ].y
+                << " " <<  (*cloud)[ pointsIdxKnnSearch.at(j)[i] ].z
+                << " (squared distance: " << pointsSquaredDistance.at(j)[i] << ")" << std::endl;
+    }
+  }
+
+  // Neighbors within radius search
+  float radius = 100.f;
+
+  std::vector< std::vector< float > > pointsRadiusSquaredDistance (searchPoints->size()) ;
+  std::vector< pcl::Indices > pointsIdxRadiusSearch (searchPoints->size());
+
+  kdtree.radiusSearch(*searchPoints, radius, pointsIdxRadiusSearch,  pointsRadiusSquaredDistance, 10);
+
+  for (std::size_t j = 0; j < pointsIdxRadiusSearch.size(); ++j)
+  {
+    std::cout << "Kdtree Radius Search Radius=" << radius << " neighbors from (" << (*searchPoints)[j].x << ","
+                                                 << (*searchPoints)[j].y << ","
+                                                 << (*searchPoints)[j].z << ")" << std::endl;
+    for (std::size_t i = 0; i < pointsIdxRadiusSearch.at(j).size(); ++i)
+    {
+      std::cout << "    "  <<   (*cloud)[ pointsIdxRadiusSearch.at(j)[i] ].x
+                << " " <<  (*cloud)[ pointsIdxRadiusSearch.at(j)[i] ].y
+                << " " <<  (*cloud)[ pointsIdxRadiusSearch.at(j)[i] ].z
+                << " (squared distance: " << pointsRadiusSquaredDistance.at(j)[i] << ")" << std::endl;
+    }
+  }
+
+  // Fixed radius search
+  // Only support radius use to build the table
+
+  std::vector<int> pointsFixedRadiusIdx;
+  std::vector<float> pointsFixedRadiusSquaredDistance;
+  std::vector<int> pointsFixedRadiusSplit;
+
+  kdtree.setInputCloud(cloud, radius);
+
+  kdtree.fixedRadiusSearch(searchPoints, pointsFixedRadiusIdx, pointsFixedRadiusSquaredDistance,
+      pointsFixedRadiusSplit);
+
+  for (std::size_t j = 0; j < pointsFixedRadiusSplit.size() - 1; ++j)
+  {
+    std::cout << "Fixed Radius Search Radius=" << radius << " neighbors from (" << (*searchPoints)[j].x << ","
+                                                 << (*searchPoints)[j].y << ","
+                                                 << (*searchPoints)[j].z << ")" << std::endl;
+
+    std::size_t cur_idx = pointsFixedRadiusSplit[j];
+    std::size_t elements = pointsFixedRadiusSplit[j+1] - cur_idx;
+    for (std::size_t i = 0; i < elements; ++i)
+    {
+      std::cout << "    "  <<   (*cloud)[pointsFixedRadiusIdx.at(cur_idx+i)].x
+                << " " <<  (*cloud)[ pointsFixedRadiusIdx.at(cur_idx+i)].y
+                << " " <<  (*cloud)[ pointsFixedRadiusIdx.at(cur_idx+i)].z
+                << " (squared distance: " << pointsFixedRadiusSquaredDistance.at(cur_idx+i) << ")" << std::endl;
+
+    }
+  }
+
+  return 0;
+}
diff --git a/doc/tutorials/content/sources/oneapi/mls/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/mls/CMakeLists.txt
new file mode 100644
index 000000000..83dc01cef
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/mls/CMakeLists.txt
@@ -0,0 +1,35 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_mls)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_mls.cpp)
+target_link_libraries (${target}  pcl_oneapi_surface pcl_oneapi_kdtree ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bun0.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/mls/oneapi_mls.cpp b/doc/tutorials/content/sources/oneapi/mls/oneapi_mls.cpp
new file mode 100644
index 000000000..f1505df8d
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/mls/oneapi_mls.cpp
@@ -0,0 +1,40 @@
+#include <pcl/oneapi/surface/mls.h>
+#include <pcl/oneapi/search/kdtree.h>
+#include <pcl/point_types.h>
+#include <pcl/io/pcd_io.h>
+
+
+using namespace pcl::oneapi;
+
+int main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr( new pcl::PointCloud<pcl::PointXYZ>() );
+
+  // Load bun0.pcd
+  pcl::io::loadPCDFile ("bun0.pcd", *cloud_ptr);
+
+  pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>::Ptr tree (new pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>);
+
+  // Output has the PointNormal type in order to store the normals calculated by MLS
+  pcl::PointCloud<pcl::PointNormal> mls_points;
+
+  // Init object (second point type is for the normals, even if unused)
+  pcl::oneapi::MovingLeastSquares<pcl::PointXYZ, pcl::PointNormal> mls;
+
+  mls.setComputeNormals (true);
+
+  // Set parameters
+  mls.setInputCloud (cloud_ptr);
+  mls.setPolynomialOrder (2);
+  mls.setSearchMethod (tree);
+  mls.setSearchRadius (0.03);
+
+  // Reconstruct
+  mls.process (mls_points);
+
+  // Save output
+  pcl::io::savePCDFile ("bun0-mls.pcd", mls_points);
+}
+
diff --git a/doc/tutorials/content/sources/oneapi/normal_estimation/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/normal_estimation/CMakeLists.txt
new file mode 100644
index 000000000..273593b68
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/normal_estimation/CMakeLists.txt
@@ -0,0 +1,36 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_normal_estimation)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_normal_estimation.cpp)
+target_link_libraries (${target} pcl_io pcl_oneapi_features)
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/pcl/master/test/bun0.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp b/doc/tutorials/content/sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
new file mode 100644
index 000000000..45fca7215
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/normal_estimation/oneapi_normal_estimation.cpp
@@ -0,0 +1,48 @@
+#include <pcl/io/pcd_io.h>
+#include <pcl/oneapi/features/normal_3d.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+#include <pcl/oneapi/point_cloud.h>
+
+int main (int argc, char** argv)
+{
+  int k = 10;
+  float radius = 0.01;
+
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  // load point cloud
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr( new pcl::PointCloud<pcl::PointXYZ>() );
+
+  int result = pcl::io::loadPCDFile("bun0.pcd", *cloud_ptr);
+  if (result != 0)
+  {
+    pcl::console::print_info ("Load pcd file failed.\n");
+    return result;
+  }
+
+  // estimate normals with knn search
+  pcl::oneapi::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
+  ne.setSearchMethod (pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>::Ptr (new pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>));
+  ne.setInputCloud(cloud_ptr);
+  ne.setKSearch(k);
+
+  // save normal estimation to CPU memory point cloud
+  pcl::PointCloud<pcl::Normal>::Ptr normals_knn(new pcl::PointCloud<pcl::Normal>);
+  ne.compute(*normals_knn);
+
+  std::cout << "normals_knn.size (): " << normals_knn->size () << std::endl;
+
+  // estimate normals with radius search
+  ne.setSearchMethod (pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>::Ptr (new pcl::oneapi::KdTreeFLANN<pcl::PointXYZ>));
+  ne.setInputCloud(cloud_ptr);
+  ne.setRadiusSearch(radius);
+  ne.setKSearch(0);
+
+  // save normal estimation output to device shared memory point cloud
+  pcl::oneapi::PointCloudDev<pcl::Normal>::Ptr normals_radius(new pcl::oneapi::PointCloudDev<pcl::Normal>) ;
+  ne.compute(*normals_radius);
+
+  std::cout << "normals_radius.size (): " << normals_radius->size () << std::endl;
+
+  return 0;
+}
diff --git a/doc/tutorials/content/sources/oneapi/octree/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/octree/CMakeLists.txt
new file mode 100644
index 000000000..384ac86ba
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/octree/CMakeLists.txt
@@ -0,0 +1,22 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_octree_search)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_octree_search.cpp)
+target_link_libraries (${target} pcl_oneapi_octree ${PCL_LIBRARIES})
diff --git a/doc/tutorials/content/sources/oneapi/octree/oneapi_octree_search.cpp b/doc/tutorials/content/sources/oneapi/octree/oneapi_octree_search.cpp
new file mode 100644
index 000000000..4c0039344
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/octree/oneapi_octree_search.cpp
@@ -0,0 +1,173 @@
+#include <iostream>
+#include <fstream>
+#include <numeric>
+#include <pcl/oneapi/octree/octree.hpp>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/point_cloud.h>
+
+using namespace pcl::oneapi;
+
+float dist(Octree::PointType p, Octree::PointType q) {
+    return std::sqrt((p.x-q.x)*(p.x-q.x) + (p.y-q.y)*(p.y-q.y) + (p.z-q.z)*(p.z-q.z));
+}
+
+int main (int argc, char** argv)
+{
+    std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+    std::size_t data_size = 871000;
+    std::size_t query_size = 10000;
+    float cube_size = 1024.f;
+    float max_radius    = cube_size / 30.f;
+    float shared_radius = cube_size / 30.f;
+    const int max_answers = 5;
+    const int k = 5;
+    std::size_t i;
+    std::vector<Octree::PointType> points;
+    std::vector<Octree::PointType> queries;
+    std::vector<float> radiuses;
+    std::vector<int> indices;
+
+    //Generate point cloud data, queries, radiuses, indices
+    srand (0);
+    points.resize(data_size);
+    for(i = 0; i < data_size; ++i)
+    {
+        points[i].x = ((float)rand())/(float)RAND_MAX * cube_size;
+        points[i].y = ((float)rand())/(float)RAND_MAX * cube_size;
+        points[i].z = ((float)rand())/(float)RAND_MAX * cube_size;
+    }
+
+    queries.resize(query_size);
+    radiuses.resize(query_size);
+    for (i = 0; i < query_size; ++i)
+    {
+        queries[i].x = ((float)rand())/(float)RAND_MAX * cube_size;
+        queries[i].y = ((float)rand())/(float)RAND_MAX * cube_size;
+        queries[i].z = ((float)rand())/(float)RAND_MAX * cube_size;
+        radiuses[i]  = ((float)rand())/(float)RAND_MAX * max_radius;
+    };
+
+    indices.resize(query_size / 2);
+    for(i = 0; i < query_size / 2; ++i)
+    {
+        indices[i] = i * 2;
+    }
+
+    //Prepare oneAPI cloud
+    pcl::oneapi::Octree::PointCloud cloud_device;
+    cloud_device.upload(points);
+
+    //oneAPI build 
+    pcl::oneapi::Octree octree_device;
+    octree_device.setCloud(cloud_device);
+    octree_device.build();
+
+    //Upload queries and radiuses
+    pcl::oneapi::Octree::Queries queries_device;
+    pcl::oneapi::Octree::Radiuses radiuses_device;
+    queries_device.upload(queries);
+    radiuses_device.upload(radiuses);
+
+    //Prepare output buffers on device
+    pcl::oneapi::NeighborIndices result_device1(queries_device.size(), max_answers);
+    pcl::oneapi::NeighborIndices result_device2(queries_device.size(), max_answers);
+    pcl::oneapi::NeighborIndices result_device3(indices.size(), max_answers);
+    pcl::oneapi::NeighborIndices result_device_ann(queries_device.size(), 1);
+    pcl::oneapi::Octree::ResultSqrDists dists_device_ann;
+    pcl::oneapi::NeighborIndices result_device_knn(queries_device.size(), k);
+    pcl::oneapi::Octree::ResultSqrDists dists_device_knn;
+
+    //oneAPI octree radius search with shared radius
+    octree_device.radiusSearch(queries_device, shared_radius, max_answers, result_device1);
+
+    //oneAPI octree radius search with individual radius
+    octree_device.radiusSearch(queries_device, radiuses_device, max_answers, result_device2);
+
+    //oneAPI octree radius search with shared radius using indices to specify 
+    //the queries.
+    pcl::oneapi::Octree::Indices cloud_indices;
+    cloud_indices.upload(indices);
+    octree_device.radiusSearch(queries_device, cloud_indices, shared_radius, max_answers, result_device3);
+
+    //oneAPI octree ANN search
+    //if neighbor points distances results are not required, can just call
+    //octree_device.approxNearestSearch(queries_device, result_device_ann)
+    octree_device.approxNearestSearch(queries_device, result_device_ann, dists_device_ann);
+
+    //oneAPI octree KNN search
+    //if neighbor points distances results are not required, can just call
+    //octree_device.nearestKSearchBatch(queries_device, k, result_device_knn)
+    octree_device.nearestKSearchBatch(queries_device, k, result_device_knn, dists_device_knn);
+
+    //Download results
+    std::vector<int> sizes1;
+    std::vector<int> sizes2;
+    std::vector<int> sizes3;
+    result_device1.sizes.download(sizes1);
+    result_device2.sizes.download(sizes2);
+    result_device3.sizes.download(sizes3);
+
+    std::vector<int> downloaded_buffer1, downloaded_buffer2, downloaded_buffer3, results_batch;
+    result_device1.data.download(downloaded_buffer1);
+    result_device2.data.download(downloaded_buffer2);
+    result_device3.data.download(downloaded_buffer3);
+
+    int query_idx = 2;
+    std::cout << "Neighbors within shared radius search at ("
+              << queries[query_idx].x << " "
+              << queries[query_idx].y << " "
+              << queries[query_idx].z << ") with radius=" << shared_radius << std::endl;
+    for (i = 0; i < sizes1[query_idx]; ++i)
+    {
+        std::cout << "    "  << points[downloaded_buffer1[max_answers * query_idx + i]].x
+                  << " "     << points[downloaded_buffer1[max_answers * query_idx + i]].y
+                  << " "     << points[downloaded_buffer1[max_answers * query_idx + i]].z
+                  << " (distance: " << dist(points[downloaded_buffer1[max_answers * query_idx + i]], queries[query_idx])  << ")" << std::endl;
+    }
+
+    std::cout << "Neighbors within individual radius search at ("
+              << queries[query_idx].x << " "
+              << queries[query_idx].y << " "
+              << queries[query_idx].z << ") with radius=" << radiuses[query_idx] << std::endl;
+    for (i = 0; i < sizes2[query_idx]; ++i)
+    {
+        std::cout << "    "  << points[downloaded_buffer2[max_answers * query_idx + i]].x
+                  << " "     << points[downloaded_buffer2[max_answers * query_idx + i]].y
+                  << " "     << points[downloaded_buffer2[max_answers * query_idx + i]].z
+                  << " (distance: " << dist(points[downloaded_buffer2[max_answers * query_idx + i]], queries[query_idx])  << ")" << std::endl;
+    }
+
+    std::cout << "Neighbors within indices radius search at ("
+              << queries[query_idx].x << " "
+              << queries[query_idx].y << " "
+              << queries[query_idx].z << ") with radius=" << shared_radius << std::endl;
+    for (i = 0; i < sizes3[query_idx/2]; ++i)
+    {
+        std::cout << "    "  << points[downloaded_buffer3[max_answers * query_idx / 2 + i]].x
+                  << " "     << points[downloaded_buffer3[max_answers * query_idx / 2 + i]].y
+                  << " "     << points[downloaded_buffer3[max_answers * query_idx / 2 + i]].z
+                  << " (distance: " << dist(points[downloaded_buffer3[max_answers * query_idx / 2 + i]], queries[2])  << ")" << std::endl;
+    }
+
+    std::cout << "Approximate nearest neighbor at ("
+              << queries[query_idx].x << " "
+              << queries[query_idx].y << " "
+              << queries[query_idx].z << ")" << std::endl;
+    std::cout << "    "  << points[result_device_ann.data[query_idx]].x
+              << " "     << points[result_device_ann.data[query_idx]].y
+              << " "     << points[result_device_ann.data[query_idx]].z
+              << " (distance: " << std::sqrt(dists_device_ann[query_idx])  << ")" << std::endl;
+
+    std::cout << "K-nearest neighbors (k = " << k << ") at ("
+              << queries[query_idx].x << " "
+              << queries[query_idx].y << " "
+              << queries[query_idx].z << ")" << std::endl;
+    for (i = query_idx * k; i < (query_idx + 1) * k; ++i)
+    {
+        std::cout << "    "  << points[result_device_knn.data[i]].x
+                  << " "     << points[result_device_knn.data[i]].y
+                  << " "     << points[result_device_knn.data[i]].z
+                  << " (distance: " << std::sqrt(dists_device_knn[i])  << ")" << std::endl;
+    }
+}
diff --git a/doc/tutorials/content/sources/oneapi/passthrough/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/passthrough/CMakeLists.txt
new file mode 100755
index 000000000..a3d7720cd
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/passthrough/CMakeLists.txt
@@ -0,0 +1,36 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_passthrough)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_passthrough.cpp)
+target_link_libraries (${target} pcl_oneapi_filters ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/data/master/tutorials/kinfu_large_scale/using_kinfu_large_scale_output.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/passthrough/oneapi_passthrough.cpp b/doc/tutorials/content/sources/oneapi/passthrough/oneapi_passthrough.cpp
new file mode 100644
index 000000000..caf3155f6
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/passthrough/oneapi_passthrough.cpp
@@ -0,0 +1,34 @@
+#include <pcl/oneapi/filters/passthrough.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+
+
+int main (int argc, char** argv)
+{
+
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  // Read Point Cloud
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_( new pcl::PointCloud<pcl::PointXYZ>() );
+  int result = pcl::io::loadPCDFile("using_kinfu_large_scale_output.pcd", *cloud_);
+  if (result != 0)
+  {
+    pcl::console::print_info ("Load pcd file failed.\n");
+    return result;
+  }
+
+  // Prepare Point Cloud Memory (output)
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_( new pcl::PointCloud<pcl::PointXYZ>() );
+
+  // GPU calculate
+  pcl::oneapi::PassThrough<pcl::PointXYZ> ps;
+  ps.setInputCloud(cloud_);
+  ps.setFilterFieldName ("z");
+  ps.setFilterLimits (0.0, 1.0);
+  ps.filter(*cloud_filtered_);
+
+  // print log
+  std::cout << "[oneapi passthrough] PointCloud before filtering: " << cloud_->size() << std::endl;
+  std::cout << "[oneapi passthrough] PointCloud after filtering: " << cloud_filtered_->size() << std::endl;
+}
diff --git a/doc/tutorials/content/sources/oneapi/registration/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/registration/CMakeLists.txt
new file mode 100644
index 000000000..57c7881ca
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/registration/CMakeLists.txt
@@ -0,0 +1,37 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_icp_example)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(registration)
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_icp_example.cpp)
+target_link_libraries (${target} pcl_oneapi_registration pcl_oneapi_search pcl_oneapi_kdtree pcl_io)
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/NVIDIA-AI-IOT/cuPCL/main/cuOctree/test_P.pcd"
+  "https://raw.githubusercontent.com/NVIDIA-AI-IOT/cuPCL/main/cuOctree/test_Q.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/registration/oneapi_icp_example.cpp b/doc/tutorials/content/sources/oneapi/registration/oneapi_icp_example.cpp
new file mode 100644
index 000000000..4ab3822c8
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/registration/oneapi_icp_example.cpp
@@ -0,0 +1,49 @@
+#include <pcl/oneapi/registration/icp.h>
+#include <pcl/console/parse.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+#include <pcl/point_representation.h>
+#include <pcl/io/pcd_io.h>
+
+
+using namespace pcl;
+using namespace pcl::io;
+using namespace pcl::console;
+
+/* ---[ */
+int
+main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  // Load the files
+  PointCloud<PointXYZ>::Ptr src, tgt;
+  src.reset (new PointCloud<PointXYZ>);
+  tgt.reset (new PointCloud<PointXYZ>);
+  if (loadPCDFile ("test_P.pcd", *src) == -1 || loadPCDFile ("test_Q.pcd", *tgt) == -1)
+  {
+    print_error ("Error reading the input files!\n");
+    return (-1);
+  }
+
+  PointCloud<PointXYZ> output;
+  // Compute the best transformtion
+  pcl::oneapi::IterativeClosestPoint<PointXYZ, PointXYZ> reg;
+  reg.setMaximumIterations(20);
+  reg.setTransformationEpsilon(1e-12);
+  reg.setMaxCorrespondenceDistance(2);
+
+  reg.setInputSource(src);
+  reg.setInputTarget(tgt);
+
+  // Register
+  reg.align(output); //point cloud output of alignment i.e source cloud after transformation is applied.
+
+  Eigen::Matrix4f transform = reg.getFinalTransformation();
+
+  std::cerr << "Transform Matrix:" << std::endl;
+  std::cerr << transform << std::endl;
+  // Write transformed data to disk
+  savePCDFileBinary ("source_transformed.pcd", output);
+}
+/* ]--- */
diff --git a/doc/tutorials/content/sources/oneapi/sample_consensus/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/sample_consensus/CMakeLists.txt
new file mode 100755
index 000000000..0d8a8b51b
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/sample_consensus/CMakeLists.txt
@@ -0,0 +1,36 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_sample_consensus)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_sample_consensus.cpp)
+target_link_libraries (${target} pcl_oneapi_sample_consensus ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/data/master/segmentation/mOSD/test/test59.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp b/doc/tutorials/content/sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
new file mode 100644
index 000000000..cd9204cfa
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/sample_consensus/oneapi_sample_consensus.cpp
@@ -0,0 +1,96 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2014-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/sample_consensus/sac_model_plane.h>
+#include <pcl/oneapi/sample_consensus/ransac.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+
+
+int main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+  // Read Point Cloud
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_ptr( new pcl::PointCloud<pcl::PointXYZ>() );
+  pcl::PointCloud<pcl::PointXYZ>::Ptr convex_ptr;
+  int result = pcl::io::loadPCDFile("test59.pcd", *cloud_ptr);
+  if (result != 0)
+  {
+    pcl::console::print_info ("Load pcd file failed.\n");
+    return result;
+  }
+
+  // Prepare Device Point Cloud Memory
+  pcl::oneapi::SampleConsensusModel::PointCloud_xyz cloud_device_xyz;
+  cloud_device_xyz.upload(cloud_ptr->points);
+  pcl::oneapi::SampleConsensusModel::PointCloud & cloud_device = (pcl::oneapi::SampleConsensusModel::PointCloud &)cloud_device_xyz;
+
+  // Algorithm tests
+  typename pcl::oneapi::SampleConsensusModelPlane::Ptr sac_model (new pcl::oneapi::SampleConsensusModelPlane (cloud_device));
+  pcl::oneapi::RandomSampleConsensus sac (sac_model);
+  sac.setMaxIterations (10000);
+  sac.setDistanceThreshold (0.03);
+  result = sac.computeModel ();
+
+  // Best model
+  pcl::oneapi::SampleConsensusModelPlane::Indices sample;
+  sac.getModel (sample);
+
+  // Coefficient
+  pcl::oneapi::SampleConsensusModelPlane::Coefficients coeffs;
+  sac.getModelCoefficients (coeffs);
+
+  // Inliers
+  pcl::Indices pcl_inliers;
+  int inliers_size = sac.getInliersSize ();
+  pcl_inliers.resize(inliers_size);
+
+  pcl::oneapi::SampleConsensusModelPlane::IndicesPtr inliers = sac.getInliers ();
+  inliers->download(pcl_inliers.data(), 0, inliers_size);
+
+  // Refined coefficient
+  pcl::oneapi::SampleConsensusModelPlane::Coefficients coeff_refined;
+  sac_model->optimizeModelCoefficients (*cloud_ptr, pcl_inliers, coeffs, coeff_refined);
+
+  // print log
+  std::cout << "input cloud size: " << cloud_ptr->points.size() << std::endl;
+  std::cout << "inliers size    : " << inliers_size << std::endl;
+  std::cout << "  plane model coefficient: " << coeffs[0] << ", " << coeffs[1] << ", " << coeffs[2] << ", " << coeffs[3] << std::endl;
+  std::cout << "  Optimized coefficient  : " << coeff_refined[0] << ", " << coeff_refined[1] << ", " << coeff_refined[2] << ", " << coeff_refined[3] << std::endl;
+}
diff --git a/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/CMakeLists.txt
new file mode 100755
index 000000000..55924c0cb
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/CMakeLists.txt
@@ -0,0 +1,22 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_scia)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_scia.cpp)
+target_link_libraries (${target} pcl_oneapi_registration ${PCL_LIBRARIES})
diff --git a/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp b/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
new file mode 100644
index 000000000..914358333
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/sample_consensus_initial_alignment/oneapi_scia.cpp
@@ -0,0 +1,60 @@
+#include <pcl/oneapi/registration/ia_ransac.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+
+
+using namespace pcl;
+using namespace pcl::io;
+
+int main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  // Read Point Cloud
+  PointCloud<PointXYZ> cloud_source, cloud_target;
+  PointCloud<FPFHSignature33> FPFH_cloud_source, FPFH_cloud_target;
+
+  if (loadPCDFile<PointXYZ>("../../data/scia_source.pcd", cloud_source) < 0)
+  {
+    std::cerr << "Failed to read alignment source point cloud, please check scia_source.pcd" << std::endl;
+    return (-1);
+  }
+  if (loadPCDFile<PointXYZ>("../../data/scia_target.pcd", cloud_target) < 0)
+  {
+    std::cerr << "Failed to read alignment target point cloud, please check scia_target.pcd" << std::endl;
+    return (-1);
+  }
+  if (loadPCDFile<FPFHSignature33>("../../data/scia_source_fpfh33.pcd", FPFH_cloud_source) < 0)
+  {
+    std::cerr << "Failed to read FPFH feature cloud of alignment source point cloud, please check scia_source_fpfh33.pcd" << std::endl;
+    return (-1);
+  }
+  if (loadPCDFile<FPFHSignature33>("../../data/scia_target_fpfh33.pcd", FPFH_cloud_target) < 0)
+  {
+    std::cerr << "Failed to read FPFH feature cloud of alignment target point cloud, please check scia_target_fpfh33.pcd" << std::endl;
+    return (-1);
+  }
+
+  // GPU calculate
+  pcl::oneapi::SampleConsensusInitialAlignment<PointXYZ, PointXYZ, FPFHSignature33> scia;
+  scia.setInputSource(cloud_source.makeShared());
+  scia.setInputTarget(cloud_target.makeShared());
+  scia.setSourceFeatures(FPFH_cloud_source.makeShared());
+  scia.setTargetFeatures(FPFH_cloud_target.makeShared());
+
+  constexpr float SACdismin = 0.02f;
+  constexpr int SCANum = 20;
+  constexpr int SCAradomn = 100;
+  scia.setMinSampleDistance(SACdismin);
+  scia.setNumberOfSamples(SCANum);
+  scia.setCorrespondenceRandomness(SCAradomn);
+
+  PointCloud<PointXYZ> cloud_result;
+  Eigen::Matrix4f sac_trans;
+  scia.align(cloud_result);
+  sac_trans = scia.getFinalTransformation();
+
+  // print log
+  std::cout << "[oneapi SCIA] Transformation Matrix 4x4 = " << std::endl << sac_trans << std::endl;
+}
diff --git a/doc/tutorials/content/sources/oneapi/segmentation/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/segmentation/CMakeLists.txt
new file mode 100644
index 000000000..fd5252093
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/segmentation/CMakeLists.txt
@@ -0,0 +1,36 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_segmentation)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_segmentation.cpp)
+target_link_libraries (${target} pcl_oneapi_segmentation ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/data/master/segmentation/mOSD/test/test59.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/segmentation/oneapi_segmentation.cpp b/doc/tutorials/content/sources/oneapi/segmentation/oneapi_segmentation.cpp
new file mode 100644
index 000000000..100aed983
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/segmentation/oneapi_segmentation.cpp
@@ -0,0 +1,46 @@
+#include <pcl/oneapi/segmentation/segmentation.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/point_types.h>
+
+int main (int argc, char **argv)
+{
+    std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+    //Read Point Cloud
+    pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_input (new pcl::PointCloud<pcl::PointXYZ> ());
+
+    //Load a standard PCD file from disk
+    int result = pcl::io::loadPCDFile("test59.pcd", *cloud_input);
+    if (result != 0)
+    {
+        pcl::console::print_info ("Load pcd file failed.\n");
+        return result;
+    }
+
+    //Create the oneapi_segmentation object
+    pcl::oneapi::SACSegmentation seg;
+
+    //Configure oneapi_segmentation class 
+    seg.setInputCloud(cloud_input);
+    seg.setProbability(0.99);
+    seg.setMaxIterations(50);
+    seg.setDistanceThreshold(0.01);
+    //Optional  
+    seg.setOptimizeCoefficients(true);
+    //Set algorithm method and model type 
+    seg.setMethodType(pcl::oneapi::SAC_RANSAC);
+    seg.setModelType (pcl::oneapi::SACMODEL_PLANE);
+
+    //Out parameter declaration for getting inliers and model coefficients  
+    pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
+    double coeffs[4]={0,0,0,0};
+
+    //Getting inliers and model coefficients
+    seg.segment(*inliers, coeffs);
+
+    std::cout << "input cloud size   : " << seg.getCloudSize() << std::endl;
+    std::cout << "inliers size       : " << seg.getInliersSize() << std::endl;
+    std::cout << "model coefficients : " << coeffs[0] << ", " << coeffs[1] << ", " << coeffs[2] << ", " << coeffs[3] << std::endl;
+
+    return 0;
+}
diff --git a/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/CMakeLists.txt
new file mode 100644
index 000000000..f707e3ed4
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/CMakeLists.txt
@@ -0,0 +1,35 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_statistical_outlier_removal)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_statistical_outlier_removal.cpp)
+target_link_libraries (${target}  pcl_oneapi_filters ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/data/master/tutorials/table_scene_lms400.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp b/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
new file mode 100644
index 000000000..2ea0105dc
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/statistical_outlier_removal/oneapi_statistical_outlier_removal.cpp
@@ -0,0 +1,41 @@
+#include <pcl/oneapi/filters/statistical_outlier_removal.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+#include <pcl/io/pcd_io.h>
+
+
+using namespace pcl::oneapi;
+
+int main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud( new pcl::PointCloud<pcl::PointXYZ>() );
+  // Fill in the cloud data
+  pcl::io::loadPCDFile ("table_scene_lms400.pcd", *cloud);
+
+  std::cerr << "Cloud before filtering: " << std::endl;
+  std::cerr << *cloud << std::endl;
+
+  pcl::PointCloud<pcl::PointXYZ>::Ptr oneapi_cloud_filtered (new pcl::PointCloud<pcl::PointXYZ>);
+
+  // Create the filtering object
+  pcl::oneapi::StatisticalOutlierRemoval<pcl::PointXYZ> oneapi_sor;
+  oneapi_sor.setInputCloud(cloud);
+  oneapi_sor.setMeanK(50);
+  oneapi_sor.setStddevMulThresh(1.0);
+  oneapi_sor.filter(*oneapi_cloud_filtered);
+
+  std::cerr << "Cloud after filtering: " << std::endl;
+  std::cerr << *oneapi_cloud_filtered << std::endl;
+
+  pcl::PCDWriter writer;
+  writer.write<pcl::PointXYZ> ("table_scene_lms400_inliers.pcd", *oneapi_cloud_filtered, false);
+
+  oneapi_sor.setNegative (true);
+  oneapi_sor.filter (*oneapi_cloud_filtered);
+  writer.write<pcl::PointXYZ> ("table_scene_lms400_outliers.pcd", *oneapi_cloud_filtered, false);
+
+  return (0);
+}
+
diff --git a/doc/tutorials/content/sources/oneapi/voxel_grid/CMakeLists.txt b/doc/tutorials/content/sources/oneapi/voxel_grid/CMakeLists.txt
new file mode 100755
index 000000000..0b1aa1c39
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/voxel_grid/CMakeLists.txt
@@ -0,0 +1,36 @@
+cmake_minimum_required(VERSION 3.5 FATAL_ERROR)
+set(target oneapi_voxel_grid)
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_FLAGS "-fsycl")
+project(${target})
+
+find_package(PCL 1.12 REQUIRED)
+
+if (WIN32)
+find_package(PCL-ONEAPI 1.12 REQUIRED)
+include_directories(${PCL_INCLUDE_DIRS} ${PCL-ONEAPI_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS} ${PCL-ONEAPI_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS} ${PCL-ONEAPI_DEFINITIONS})
+else()
+include_directories(${PCL_INCLUDE_DIRS})
+link_directories(${PCL_LIBRARY_DIRS})
+add_definitions(${PCL_DEFINITIONS})
+endif()
+
+add_executable (${target} oneapi_voxel_grid.cpp)
+target_link_libraries (${target} pcl_oneapi_filters ${PCL_LIBRARIES})
+
+# The URL of the file
+set (pcd_url
+  "https://raw.githubusercontent.com/PointCloudLibrary/data/master/tutorials/table_scene_lms400.pcd")
+
+foreach(item ${pcd_url})
+  get_filename_component(filename ${item} NAME)
+  message(STATUS "Downloading files ${filename}")
+  if (NOT EXISTS "${filename}")
+    execute_process(
+      COMMAND wget "${item}"
+    )
+  endif()
+endforeach()
diff --git a/doc/tutorials/content/sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp b/doc/tutorials/content/sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
new file mode 100644
index 000000000..61c24cf13
--- /dev/null
+++ b/doc/tutorials/content/sources/oneapi/voxel_grid/oneapi_voxel_grid.cpp
@@ -0,0 +1,33 @@
+#include <pcl/oneapi/filters/voxel_grid.h>
+#include <pcl/io/pcd_io.h>
+#include <pcl/point_types.h>
+#include <pcl/point_cloud.h>
+
+
+int main (int argc, char** argv)
+{
+  std::cout << "Running on device: " << dpct::get_default_queue().get_device().get_info<sycl::info::device::name>() << "\n";
+
+  // Read Point Cloud
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_( new pcl::PointCloud<pcl::PointXYZ>() );
+  int result = pcl::io::loadPCDFile("table_scene_lms400.pcd", *cloud_);
+  if (result != 0)
+  {
+    pcl::console::print_info ("Load pcd file failed.\n");
+    return result;
+  }
+
+  // Prepare Point Cloud Memory (output)
+  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered_( new pcl::PointCloud<pcl::PointXYZ>() );
+
+  // GPU calculate
+  pcl::oneapi::VoxelGrid<pcl::PointXYZ> vg_oneapi;
+  vg_oneapi.setInputCloud(cloud_);
+  float leafsize= 0.005f;
+  vg_oneapi.setLeafSize (leafsize, leafsize, leafsize);
+  vg_oneapi.filter(*cloud_filtered_);
+
+  // print log
+  std::cout << "[oneapi voxel grid] PointCloud before filtering: " << cloud_->size() << std::endl;
+  std::cout << "[oneapi voxel grid] PointCloud after filtering: " << cloud_filtered_->size() << std::endl;
+}
diff --git a/doc/tutorials/content/statistical_outlier.rst b/doc/tutorials/content/statistical_outlier.rst
index e94721ed8..a453e7328 100644
--- a/doc/tutorials/content/statistical_outlier.rst
+++ b/doc/tutorials/content/statistical_outlier.rst
@@ -1,4 +1,4 @@
-.. _statistical_outlier_removal:
+.. _statistical_removal:
 
 Removing outliers using a StatisticalOutlierRemoval filter
 ----------------------------------------------------------
diff --git a/oneapi/CMakeLists.txt b/oneapi/CMakeLists.txt
new file mode 100644
index 000000000..dba8b9e98
--- /dev/null
+++ b/oneapi/CMakeLists.txt
@@ -0,0 +1,216 @@
+set(CMAKE_CXX_COMPILER icpx)
+set(CMAKE_CXX_STANDARD 17)
+set(PCL_CXX_COMPILE_FEATURES cxx_std_17)
+set(CMAKE_CXX_STANDARD_REQUIRED ON)
+set(CMAKE_CXX_EXTENSIONS OFF)
+if(WIN32)
+set(CMAKE_CXX_FLAGS_RELEASE "-O3 /EHa /QxCORE-AVX2")
+else()
+set(CMAKE_CXX_FLAGS_RELEASE "-O3")
+endif()
+if(WIN32)
+  include("${CMAKE_CURRENT_SOURCE_DIR}/../cmake/pcl_win_dir.cmake")
+  message("Windows OS, set Intel C++ Compiler ${INTEL_CPP_COMPILER}")
+  # set(CMAKE_GENERATOR_TOOLSET ${INTEL_DPCPP_COMPILER})
+  set(CMAKE_GENERATOR_TOOLSET ${INTEL_CPP_COMPILER})
+  # set(CMAKE_C_COMPILER "icx")
+  include_directories(
+  $ENV{ONEAPI_ROOT}/dpcpp-ct/latest/include
+  $ENV{ONEAPI_ROOT}/dpl/latest/windows/include
+  set (CMAKE_WINDOWS_EXPORT_ALL_SYMBOLS ON)
+)
+link_directories(
+  $ENV{ONEAPI_ROOT}/tbb/latest/lib
+)
+endif()
+
+# Temporary workaround to overcome oneTBB incompatible with GCC TBB interface
+add_definitions("-D_GLIBCXX_USE_TBB_PAR_BACKEND=0")
+add_definitions("-DPSTL_USE_PARALLEL_POLICIES=0")
+
+# If PROJECT_NAME is defined, that means this file is included by the main PCL
+# CMakeList.txt.
+if(DEFINED PROJECT_NAME)
+    set(SUBSYS_NAME oneapi)
+    set(SUBSYS_DESC "Point cloud oneAPI libraries")
+    set(SUBSYS_DEPS)
+    string(APPEND CMAKE_CXX_FLAGS " -Wall -Wpedantic -Wno-unknown-warning-option -Wno-pass-failed -Wno-unneeded-internal-declaration -Wno-unused-function -Wno-gnu-anonymous-struct -Wno-nested-anon-types -Wno-extra-semi -Wno-unused-local-typedef -fsycl -fsycl-unnamed-lambda -ferror-limit=1 -fsycl-device-code-split=per_kernel")
+    if (NOT CMAKE_BUILD_TYPE)
+        message(STATUS "No build type selected, default to Release")
+        set(CMAKE_BUILD_TYPE "Release" CACHE PATH "Build Type" FORCE)
+    endif()
+    option(BUILD_ONEAPI "Build the oneAPI-related subsystems" ${DEFAULT})
+
+
+    # if(NOT (BUILD_GPU AND ONEAPI_FOUND))
+    # TODO: Add something corresponding to CUDA_FOUND for ONEAPI in if() to make sure oneAPI tookit is installed before building oneAPI modules
+    if(NOT (BUILD_ONEAPI))
+      return()
+    endif()
+
+    collect_subproject_directory_names("${CMAKE_CURRENT_SOURCE_DIR}" "CMakeLists.txt" PCL_ONEAPI_MODULES_NAMES PCL_ONEAPI_MODULES_DIRS)
+    set(PCL_ONEAPI_MODULES_NAMES_UNSORTED ${PCL_ONEAPI_MODULES_NAMES})
+    topological_sort(PCL_ONEAPI_MODULES_NAMES PCL_ _DEPENDS)
+    sort_relative(PCL_ONEAPI_MODULES_NAMES_UNSORTED PCL_ONEAPI_MODULES_NAMES PCL_ONEAPI_MODULES_DIRS)
+    foreach(subdir ${PCL_ONEAPI_MODULES_DIRS})
+      add_subdirectory("${CMAKE_CURRENT_SOURCE_DIR}/${subdir}")
+    endforeach()
+# If PROJECT_NAME is not defined, that means user runs cmake on this directly.
+else()
+    ### ---[ PCL global CMake
+    cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
+
+    if(POLICY CMP0074)
+      # 1. Remove with 3.12.4.
+      # 2. Remove search paths with *_ROOT since they will be automatically checked
+      cmake_policy(SET CMP0074 NEW)
+    endif()
+
+    set(CMAKE_CXX_FLAGS " -Wall -Wpedantic -Wno-unknown-warning-option -Wno-unknown-pragmas -Wno-pass-failed -Wno-unneeded-internal-declaration -Wno-unused-function -Wno-gnu-anonymous-struct -Wno-nested-anon-types -Wno-extra-semi -Wno-unused-local-typedef -Wno-unused-command-line-argument -fsycl -fsycl-unnamed-lambda -ferror-limit=1 -fsycl-device-code-split=per_kernel")
+    set(CMAKE_CONFIGURATION_TYPES "Debug;Release" CACHE STRING "possible configurations" FORCE)
+
+    # In case the user does not setup CMAKE_BUILD_TYPE, assume it's RelWithDebInfo
+    if("${CMAKE_BUILD_TYPE}" STREQUAL "")
+      set(CMAKE_BUILD_TYPE Release CACHE STRING "build type default to Release" FORCE)
+    endif()
+
+    project(PCL-ONEAPI VERSION 1.12.1)
+    string(TOLOWER ${PROJECT_NAME} PROJECT_NAME_LOWER)
+
+    ### ---[ Find universal dependencies
+    set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake/Modules/" ${CMAKE_MODULE_PATH})
+
+    # ---[ Include pkgconfig
+    include(FindPkgConfig)
+
+    # Update the documentation string of CMAKE_BUILD_TYPE for GUIs
+    set(CMAKE_BUILD_TYPE "${CMAKE_BUILD_TYPE}" CACHE STRING
+        "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel."
+        FORCE)
+
+    set(CMAKE_CXX_FLAGS_DEFAULT "")
+
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_verbosity.cmake")
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_targets.cmake")
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_options.cmake")
+
+    include_directories(${FLANN_INCLUDE})
+    if(${PCL_ENABLE_CCACHE})
+      include (UseCompilerCache)
+      UseCompilerCache(ccache REQUIRED)
+    endif()
+
+    # Enable verbose timing display?
+    if(CMAKE_TIMING_VERBOSE AND UNIX)
+      set_property(GLOBAL PROPERTY RULE_MESSAGES OFF)
+      set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE "${CMAKE_SOURCE_DIR}/cmake/custom_output.sh")
+    endif()
+
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_utils.cmake")
+    DISSECT_VERSION()
+    GET_OS_INFO()
+    SET_INSTALL_DIRS()
+
+    set(PCL_OUTPUT_LIB_DIR "${PCL-ONEAPI_BINARY_DIR}/${LIB_INSTALL_DIR}")
+    set(PCL_OUTPUT_BIN_DIR "${PCL-ONEAPI_BINARY_DIR}/${BIN_INSTALL_DIR}")
+    make_directory("${PCL_OUTPUT_LIB_DIR}")
+    make_directory("${PCL_OUTPUT_BIN_DIR}")
+    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+    # set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+    # set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+    if(WIN32)
+      set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+      set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+      foreach(config ${CMAKE_CONFIGURATION_TYPES})
+        string(TOUPPER ${config} CONFIG)
+        set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${CONFIG} "${PCL_OUTPUT_LIB_DIR}")
+        set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${CONFIG} "${PCL_OUTPUT_LIB_DIR}")
+        # ---[ Windows requires DLLs (shared libraries) to be installed in the same directory as executables
+        set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${CONFIG} "${PCL_OUTPUT_LIB_DIR}")
+      endforeach()
+    else()
+      set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${PCL_OUTPUT_LIB_DIR}")
+      set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${PCL_OUTPUT_BIN_DIR}")
+    endif()
+
+    # Add an "uninstall" target
+    set(UNINSTALL_TARGET_NAME uninstall)
+    configure_file("${PCL-ONEAPI_SOURCE_DIR}/cmake/uninstall_target.cmake.in"
+                   "${PCL-ONEAPI_BINARY_DIR}/uninstall_target.cmake" IMMEDIATE @ONLY)
+    add_custom_target(${UNINSTALL_TARGET_NAME} "${CMAKE_COMMAND}" -P
+                      "${PCL-ONEAPI_BINARY_DIR}/uninstall_target.cmake")
+
+    ###
+    # this is copy paste form http://www.itk.org/Wiki/CMake_RPATH_handling
+    # in order to always make a full statement RPATH
+    ###
+    set(CMAKE_SKIP_BUILD_RPATH  FALSE)
+    set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+    set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/${LIB_INSTALL_DIR}")
+    set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
+    LIST(FIND CMAKE_PLATFORM_IMPLICIT_LINK_DIRECTORIES "${CMAKE_INSTALL_PREFIX}/${LIB_INSTALL_DIR}" is_system_dir)
+    if("${is_system_dir}" STREQUAL "-1")
+        set(CMAKE_INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/${LIB_INSTALL_DIR}")
+    endif()
+
+    # OpenMP (optional)
+    option(WITH_OPENMP "Build with parallelization using OpenMP" TRUE)
+    if(WITH_OPENMP)
+      find_package(OpenMP COMPONENTS C CXX)
+    endif()
+    if(OpenMP_FOUND)
+      string(APPEND CMAKE_C_FLAGS " ${OpenMP_C_FLAGS}")
+      string(APPEND CMAKE_CXX_FLAGS " ${OpenMP_CXX_FLAGS}")
+      if(${CMAKE_VERSION} VERSION_LESS "3.7")
+        message(STATUS "Found OpenMP")
+      else()
+        # We could use OpenMP_CXX_VERSION starting from CMake 3.9, but this value is only available on first run of CMake (see https://gitlab.kitware.com/cmake/cmake/issues/19150),
+        # so we use always OpenMP_CXX_SPEC_DATE, which is available since CMake 3.7.
+        message(STATUS "Found OpenMP, spec date ${OpenMP_CXX_SPEC_DATE}")
+      endif()
+    else()
+      message(STATUS "Not found OpenMP")
+    endif()
+
+    # Threads (required)
+    find_package(Threads REQUIRED)
+    find_package(PCL 1.12.1 REQUIRED)
+    
+    ### ---[ Create the config.h file
+    set(pcl_config_h_in "${CMAKE_CURRENT_SOURCE_DIR}/pcl_config.h.in")
+    set(pcl_config_h "${CMAKE_CURRENT_BINARY_DIR}/include/pcl/pcl_config.h")
+    configure_file("${pcl_config_h_in}" "${pcl_config_h}")
+    PCL_ADD_INCLUDES(common "" "${pcl_config_h}")
+    include_directories("${CMAKE_CURRENT_BINARY_DIR}/include" ${PCL_INCLUDE_DIRS})
+    link_directories(${PCL_LIBRARY_DIRS})
+    collect_subproject_directory_names("${PCL-ONEAPI_SOURCE_DIR}" "CMakeLists.txt" PCL_MODULES_NAMES PCL_MODULES_DIRS doc)
+    set(PCL_MODULES_NAMES_UNSORTED ${PCL_MODULES_NAMES})
+    topological_sort(PCL_MODULES_NAMES PCL_ _DEPENDS)
+    sort_relative(PCL_MODULES_NAMES_UNSORTED PCL_MODULES_NAMES PCL_MODULES_DIRS)
+    foreach(subdir ${PCL_MODULES_DIRS})
+      add_subdirectory("${PCL-ONEAPI_SOURCE_DIR}/${subdir}")
+    endforeach()
+
+
+
+    ### ---[ Configure PCLConfig.cmake
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_pclconfig.cmake")
+
+    ### ---[ Package creation
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_all_in_one_installer.cmake")
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/pcl_cpack.cmake")
+
+    if(CPACK_GENERATOR)
+      message(STATUS "Found CPack generators: ${CPACK_GENERATOR}")
+      PCL_MAKE_CPACK_INPUT()
+      set(CPACK_PROJECT_CONFIG_FILE "${PCL_CPACK_CFG_FILE}")
+      include(CPack)
+    endif()
+    ### ---[ Make a pretty picture of the dependency graph
+    include("${PCL-ONEAPI_SOURCE_DIR}/cmake/dep_graph.cmake")
+    MAKE_DEP_GRAPH()
+
+    ### ---[ Finish up
+    PCL_WRITE_STATUS_REPORT()
+    PCL_RESET_MAPS()
+endif()
diff --git a/oneapi/PCL-ONEAPIConfig.cmake.in b/oneapi/PCL-ONEAPIConfig.cmake.in
new file mode 100644
index 000000000..32c814aa6
--- /dev/null
+++ b/oneapi/PCL-ONEAPIConfig.cmake.in
@@ -0,0 +1,660 @@
+# ------------------------------------------------------------------------------------
+# Helper to use PCL from outside project
+#
+# target_link_libraries(my_fabulous_target PCL_XXX_LIBRARIES) where XXX is the
+# upper cased xxx from :
+# @PCLCONFIG_AVAILABLE_COMPONENTS_LIST@
+#
+# PCL-ONEAPI_INCLUDE_DIRS is filled with PCL and available 3rdparty headers
+# PCL-ONEAPI_LIBRARY_DIRS is filled with PCL components libraries install directory and
+# 3rdparty libraries paths
+#
+#                                   www.pointclouds.org
+#------------------------------------------------------------------------------------
+
+# Set default policy behavior similar to minimum requirement version
+cmake_policy(VERSION 3.10)
+
+# explicitly set policies we already support in newer cmake versions
+if(POLICY CMP0074)
+  # TODO: update *_ROOT variables to be PCL_*_ROOT or equivalent.
+  # CMP0074 directly affects how Find* modules work and *_ROOT variables.  Since
+  # this is a config file that will be consumed by parent projects with (likely)
+  # NEW behavior, we need to push a policy stack.
+  cmake_policy(SET CMP0074 NEW)
+endif()
+
+list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/Modules")
+
+### ---[ some useful macros
+macro(pcl_report_not_found _reason)
+  unset(PCL-ONEAPI_FOUND)
+  unset(PCL-ONEAPI_LIBRARIES)
+  unset(PCL-ONEAPI_COMPONENTS)
+  unset(PCL-ONEAPI_INCLUDE_DIRS)
+  unset(PCL-ONEAPI_LIBRARY_DIRS)
+  unset(PCL-ONEAPI_DEFINITIONS)
+  if(PCL-ONEAPI_FIND_REQUIRED)
+    message(FATAL_ERROR ${_reason})
+  elseif(NOT PCL-ONEAPI_FIND_QUIETLY)
+    message(WARNING ${_reason})
+  endif()
+  return()
+endmacro()
+
+macro(pcl_message)
+  if(NOT PCL-ONEAPI_FIND_QUIETLY)
+    message(${ARGN})
+  endif()
+endmacro()
+
+# Remove duplicate libraries
+macro(pcl_remove_duplicate_libraries _unfiltered_libraries _filtered_libraries)
+  set(${_filtered_libraries})
+  set(_debug_libraries)
+  set(_optimized_libraries)
+  set(_other_libraries)
+  set(_waiting_for_debug 0)
+  set(_waiting_for_optimized 0)
+  set(_library_position -1)
+  foreach(library ${${_unfiltered_libraries}})
+    if("${library}" STREQUAL "debug")
+      set(_waiting_for_debug 1)
+    elseif("${library}" STREQUAL "optimized")
+      set(_waiting_for_optimized 1)
+    elseif(_waiting_for_debug)
+      list(FIND _debug_libraries "${library}" library_position)
+      if(library_position EQUAL -1)
+        list(APPEND ${_filtered_libraries} debug ${library})
+        list(APPEND _debug_libraries ${library})
+      endif()
+      set(_waiting_for_debug 0)
+    elseif(_waiting_for_optimized)
+      list(FIND _optimized_libraries "${library}" library_position)
+      if(library_position EQUAL -1)
+        list(APPEND ${_filtered_libraries} optimized ${library})
+        list(APPEND _optimized_libraries ${library})
+      endif()
+      set(_waiting_for_optimized 0)
+    else()
+      list(FIND _other_libraries "${library}" library_position)
+      if(library_position EQUAL -1)
+        list(APPEND ${_filtered_libraries} ${library})
+        list(APPEND _other_libraries ${library})
+      endif()
+    endif()
+  endforeach()
+endmacro()
+
+### ---[ 3rd party libraries
+macro(find_boost)
+  if(PCL_ALL_IN_ONE_INSTALLER)
+    set(BOOST_ROOT "${PCL_ROOT}/3rdParty/Boost")
+  elseif(NOT BOOST_INCLUDEDIR)
+    set(BOOST_INCLUDEDIR "@Boost_INCLUDE_DIR@")
+  endif()
+  
+  set(Boost_ADDITIONAL_VERSIONS
+    "@Boost_MAJOR_VERSION@.@Boost_MINOR_VERSION@.@Boost_SUBMINOR_VERSION@" "@Boost_MAJOR_VERSION@.@Boost_MINOR_VERSION@"
+    "1.78.0" "1.78" "1.77.0" "1.77" "1.76.0" "1.76" "1.75.0" "1.75" 
+    "1.74.0" "1.74" "1.73.0" "1.73" "1.72.0" "1.72" "1.71.0" "1.71" "1.70.0" "1.70"
+    "1.69.0" "1.69" "1.68.0" "1.68" "1.67.0" "1.67" "1.66.0" "1.66" "1.65.1" "1.65.0" "1.65")
+  
+  find_package(Boost 1.65.0 ${QUIET_} COMPONENTS @PCLCONFIG_AVAILABLE_BOOST_MODULES@)
+
+  set(BOOST_FOUND ${Boost_FOUND})
+  set(BOOST_INCLUDE_DIRS "${Boost_INCLUDE_DIR}")
+  set(BOOST_LIBRARY_DIRS "${Boost_LIBRARY_DIRS}")
+  set(BOOST_LIBRARIES ${Boost_LIBRARIES})
+  if(WIN32 AND NOT MINGW)
+    string(APPEND BOOST_DEFINITIONS -DBOOST_ALL_NO_LIB)
+  endif()
+endmacro()
+
+#remove this as soon as eigen is shipped with FindEigen.cmake
+macro(find_eigen)
+  if(PCL_ALL_IN_ONE_INSTALLER)
+    set(EIGEN_ROOT "${PCL_ROOT}/3rdParty/Eigen")
+  elseif(NOT EIGEN_ROOT)
+    get_filename_component(EIGEN_ROOT "@EIGEN_INCLUDE_DIRS@" ABSOLUTE)
+  endif()
+  find_package(Eigen 3.1)
+endmacro()
+
+#remove this as soon as qhull is shipped with FindQhull.cmake
+macro(find_qhull)
+  if(PCL_ALL_IN_ONE_INSTALLER)
+    set(QHULL_ROOT "${PCL_ROOT}/3rdParty/Qhull")
+  elseif(NOT QHULL_ROOT)
+    get_filename_component(QHULL_ROOT "@QHULL_INCLUDE_DIRS@" PATH)
+  endif()
+
+  set(PCL_QHULL_REQUIRED_TYPE @PCL_QHULL_REQUIRED_TYPE@)
+  find_package(Qhull)
+endmacro()
+
+#remove this as soon as libopenni is shipped with FindOpenni.cmake
+macro(find_openni)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(OpenNI_FIND_QUIETLY TRUE)
+  endif()
+
+  if(NOT OPENNI_ROOT AND ("@HAVE_OPENNI@" STREQUAL "TRUE"))
+    set(OPENNI_INCLUDE_DIRS_HINT "@OPENNI_INCLUDE_DIRS@")
+    get_filename_component(OPENNI_LIBRARY_HINT "@OPENNI_LIBRARY@" PATH)
+  endif()
+
+  find_package(OpenNI)
+endmacro()
+
+#remove this as soon as libopenni2 is shipped with FindOpenni2.cmake
+macro(find_openni2)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(OpenNI2_FIND_QUIETLY TRUE)
+  endif()
+
+  if(NOT OPENNI2_ROOT AND ("@HAVE_OPENNI2@" STREQUAL "TRUE"))
+    set(OPENNI2_INCLUDE_DIRS_HINT "@OPENNI2_INCLUDE_DIRS@")
+    get_filename_component(OPENNI2_LIBRARY_HINT "@OPENNI2_LIBRARY@" PATH)
+  endif()
+
+  find_package(OpenNI2)
+endmacro()
+
+#remove this as soon as the Ensenso SDK is shipped with FindEnsenso.cmake
+macro(find_ensenso)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(ensenso_FIND_QUIETLY TRUE)
+  endif()
+
+  if(NOT ENSENSO_ROOT AND ("@HAVE_ENSENSO@" STREQUAL "TRUE"))
+    get_filename_component(ENSENSO_ABI_HINT "@ENSENSO_INCLUDE_DIR@" PATH)
+  endif()
+
+  find_package(Ensenso)
+endmacro()
+
+#remove this as soon as the davidSDK is shipped with FinddavidSDK.cmake
+macro(find_davidSDK)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(DAVIDSDK_FIND_QUIETLY TRUE)
+  endif()
+
+  if(NOT davidSDK_ROOT AND ("@HAVE_DAVIDSDK@" STREQUAL "TRUE"))
+    get_filename_component(DAVIDSDK_ABI_HINT @DAVIDSDK_INCLUDE_DIR@ PATH)
+  endif()
+
+  find_package(davidSDK)
+endmacro()
+
+macro(find_dssdk)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(DSSDK_FIND_QUIETLY TRUE)
+  endif()
+  if(NOT DSSDK_DIR AND ("@HAVE_DSSDK@" STREQUAL "TRUE"))
+    get_filename_component(DSSDK_DIR_HINT "@DSSDK_INCLUDE_DIRS@" PATH)
+  endif()
+
+  find_package(DSSDK)
+endmacro()
+
+macro(find_rssdk)
+  if(PCL-ONEAPI_FIND_QUIETLY)
+    set(RSSDK_FIND_QUIETLY TRUE)
+  endif()
+  if(NOT RSSDK_DIR AND ("@HAVE_RSSDK@" STREQUAL "TRUE"))
+    get_filename_component(RSSDK_DIR_HINT "@RSSDK_INCLUDE_DIRS@" PATH)
+  endif()
+
+  find_package(RSSDK)
+endmacro()
+
+macro(find_rssdk2)
+  if(PCL_ALL_IN_ONE_INSTALLER)
+    set(realsense2_DIR "${PCL_ROOT}/3rdParty/librealsense2/lib/cmake/realsense2" CACHE PATH "The directory containing realsense2Config.cmake")
+  elseif(NOT realsense2_DIR)
+    get_filename_component(realsense2_DIR "@REALSENSE2_INCLUDE_DIRS@" PATH)
+    set(realsense2_DIR "${realsense2_DIR}/lib/cmake/realsense2" CACHE PATH "The directory containing realsense2Config.cmake")
+  endif()
+  find_package(RSSDK2)
+endmacro()
+
+#remove this as soon as flann is shipped with FindFlann.cmake
+macro(find_flann)
+  if(PCL_ALL_IN_ONE_INSTALLER)
+    set(FLANN_ROOT "${PCL_ROOT}/3rdParty/Flann")
+  elseif(NOT FLANN_ROOT)
+    set(FLANN_ROOT "@FLANN_ROOT@")
+  endif()
+
+  set(PCL_FLANN_REQUIRED_TYPE @PCL_FLANN_REQUIRED_TYPE@)
+  find_package(FLANN)
+endmacro()
+
+macro(find_libusb)
+  find_package(libusb)
+endmacro()
+
+macro(find_glew)
+  find_package(GLEW)
+endmacro()
+
+# Finds each component external libraries if any
+# The functioning is as following
+# try to find _lib
+# |--> _lib found ==> include the headers,
+# |                   link to its library directories or include _lib_USE_FILE
+# `--> _lib not found
+#                   |--> _lib is optional ==> disable it (thanks to the guardians)
+#                   |                         and warn
+#                   `--> _lib is required
+#                                       |--> component is required explicitly ==> error
+#                                       `--> component is induced ==> warn and remove it
+#                                                                     from the list
+
+macro(find_external_library _component _lib _is_optional)
+  if("${_lib}" STREQUAL "boost")
+    find_boost()
+  elseif("${_lib}" STREQUAL "eigen")
+    find_eigen()
+  elseif("${_lib}" STREQUAL "flann")
+    find_flann()
+  elseif("${_lib}" STREQUAL "qhull")
+    find_qhull()
+  elseif("${_lib}" STREQUAL "openni")
+    find_openni()
+  elseif("${_lib}" STREQUAL "openni2")
+    find_openni2()
+  elseif("${_lib}" STREQUAL "ensenso")
+    find_ensenso()
+  elseif("${_lib}" STREQUAL "davidSDK")
+    find_davidSDK()
+  elseif("${_lib}" STREQUAL "dssdk")
+    find_dssdk()
+  elseif("${_lib}" STREQUAL "rssdk")
+    find_rssdk()
+  elseif("${_lib}" STREQUAL "rssdk2")
+    find_rssdk2()
+  elseif("${_lib}" STREQUAL "libusb")
+    find_libusb()
+  elseif("${_lib}" STREQUAL "glew")
+    find_glew()
+  elseif("${_lib}" STREQUAL "opengl")
+    find_package(OpenGL)
+  endif()
+
+  string(TOUPPER "${_component}" COMPONENT)
+  string(TOUPPER "${_lib}" LIB)
+  string(REGEX REPLACE "[.-]" "_" LIB ${LIB})
+  if(${LIB}_FOUND)
+    list(APPEND PCL_${COMPONENT}_INCLUDE_DIRS ${${LIB}_INCLUDE_DIRS})
+    
+    if(${LIB}_USE_FILE AND NOT ISVTK9ORGREATER )
+      include(${${LIB}_USE_FILE})
+    else()
+      list(APPEND PCL_${COMPONENT}_LIBRARY_DIRS "${${LIB}_LIBRARY_DIRS}")
+    endif()
+    if(${LIB}_LIBRARIES)
+      list(APPEND PCL_${COMPONENT}_LINK_LIBRARIES "${${LIB}_LIBRARIES}")
+    endif()
+    if(${LIB}_DEFINITIONS AND NOT ${LIB} STREQUAL "VTK")
+      list(APPEND PCL_${COMPONENT}_DEFINITIONS ${${LIB}_DEFINITIONS})
+    endif()
+  else()
+    if("${_is_optional}" STREQUAL "OPTIONAL")
+      list(APPEND PCL_${COMPONENT}_DEFINITIONS "-DDISABLE_${LIB}")
+      pcl_message("** WARNING ** ${_component} features related to ${_lib} will be disabled")
+    elseif("${_is_optional}" STREQUAL "REQUIRED")
+      if((NOT PCL_FIND_ALL) OR (PCL_FIND_ALL EQUAL 1))
+        pcl_report_not_found("${_component} is required but ${_lib} was not found")
+      elseif(PCL_FIND_ALL EQUAL 0)
+        # raise error and remove _component from PCL_TO_FIND_COMPONENTS
+        string(TOUPPER "${_component}" COMPONENT)
+        pcl_message("** WARNING ** ${_component} will be disabled cause ${_lib} was not found")
+        list(REMOVE_ITEM PCL_TO_FIND_COMPONENTS ${_component})
+      endif()
+    endif()
+  endif()
+endmacro()
+
+macro(pcl_check_external_dependency _component)
+endmacro()
+
+#flatten dependencies recursivity is great \o/
+macro(compute_dependencies TO_FIND_COMPONENTS)
+  foreach(component ${${TO_FIND_COMPONENTS}})
+    set(pcl_component pcl_${component})
+    if(${pcl_component}_int_dep AND (NOT PCL_FIND_ALL))
+      foreach(dependency ${${pcl_component}_int_dep})
+        list(FIND ${TO_FIND_COMPONENTS} ${component} pos)
+        list(FIND ${TO_FIND_COMPONENTS} ${dependency} found)
+        if(found EQUAL -1)
+          set(pcl_dependency pcl_${dependency})
+          if(${pcl_dependency}_int_dep)
+            list(INSERT ${TO_FIND_COMPONENTS} ${pos} ${dependency})
+            if(pcl_${dependency}_ext_dep)
+              list(APPEND pcl_${component}_ext_dep ${pcl_${dependency}_ext_dep})
+            endif()
+            if(pcl_${dependency}_opt_dep)
+              list(APPEND pcl_${component}_opt_dep ${pcl_${dependency}_opt_dep})
+            endif()
+            compute_dependencies(${TO_FIND_COMPONENTS})
+          else()
+            list(INSERT ${TO_FIND_COMPONENTS} 0 ${dependency})
+          endif()
+        endif()
+      endforeach()
+    endif()
+  endforeach()
+endmacro()
+
+### ---[ Find PCL
+
+if(PCL-ONEAPI_FIND_QUIETLY)
+  set(QUIET_ QUIET)
+else()
+  set(QUIET_)
+endif()
+
+find_package(PkgConfig QUIET)
+
+file(TO_CMAKE_PATH "${PCL_DIR}" PCL_DIR)
+if(WIN32 AND NOT MINGW)
+# PCLConfig.cmake is installed to PCL_ROOT/cmake
+  get_filename_component(PCL_ROOT "${PCL_DIR}" PATH)
+  if(EXISTS "${PCL_ROOT}/3rdParty")
+    set(PCL_ALL_IN_ONE_INSTALLER ON)
+  endif()
+else()
+# PCLConfig.cmake is installed to PCL_ROOT/share/pcl-x.y
+  get_filename_component(PCL_ROOT "${CMAKE_CURRENT_LIST_DIR}/../.." ABSOLUTE)
+endif()
+if(WIN32)
+set(PCL_ROOT "@PCL_ONEAPI_ROOT@")
+endif()
+# check whether PCLConfig.cmake is found into a PCL installation or in a build tree
+if(EXISTS "${PCL_ROOT}/include/pcl-oneapi-${PCL-ONEAPI_VERSION_MAJOR}.${PCL-ONEAPI_VERSION_MINOR}/pcl/pcl_config.h")
+  # Found a PCL installation
+  # pcl_message("Found a PCL installation")
+  set(PCL_CONF_INCLUDE_DIR "${PCL_ROOT}/include/pcl-oneapi-${PCL-ONEAPI_VERSION_MAJOR}.${PCL-ONEAPI_VERSION_MINOR}")
+  set(PCL-ONEAPI_LIBRARY_DIRS "${PCL_ROOT}/@LIB_INSTALL_DIR@")
+elseif(EXISTS "${PCL_ROOT}/include/pcl/pcl_config.h")
+  # Found a non-standard (likely ANDROID) PCL installation
+  # pcl_message("Found a PCL installation")
+  set(PCL_CONF_INCLUDE_DIR "${PCL_ROOT}/include")
+  set(PCL-ONEAPI_LIBRARY_DIRS "${PCL_ROOT}/lib")
+elseif(EXISTS "${PCL_DIR}/include/pcl/pcl_config.h")
+  # Found PCLConfig.cmake in a build tree of PCL
+  # pcl_message("PCL found into a build tree.")
+  set(PCL_CONF_INCLUDE_DIR "${PCL_DIR}/include") # for pcl_config.h
+  set(PCL-ONEAPI_LIBRARY_DIRS "${PCL_DIR}/@LIB_INSTALL_DIR@")
+  set(PCL_SOURCES_TREE "@CMAKE_SOURCE_DIR@")
+else()
+  pcl_report_not_found("PCL-ONEAPI can not be found on this machine")
+endif()
+
+set(PCL-ONEAPI_INCLUDE_DIRS "${PCL_CONF_INCLUDE_DIR}")
+
+#set a suffix for debug libraries
+set(PCL_DEBUG_SUFFIX "@CMAKE_DEBUG_POSTFIX@")
+set(PCL_RELEASE_SUFFIX "@CMAKE_RELEASE_POSTFIX@")
+
+set(PCL_SHARED_LIBS "@PCL_SHARED_LIBS@")
+
+#set SSE flags used compiling PCL
+list(APPEND PCL-ONEAPI_DEFINITIONS @PCLCONFIG_SSE_DEFINITIONS@)
+list(APPEND PCL_COMPILE_OPTIONS @PCLCONFIG_SSE_COMPILE_OPTIONS@)
+
+#set AVX flags used compiling PCL
+list(APPEND PCL_COMPILE_OPTIONS @PCLCONFIG_AVX_COMPILE_OPTIONS@)
+
+set(pcl_all_components @PCLCONFIG_AVAILABLE_COMPONENTS@)
+list(LENGTH pcl_all_components PCL_NB_COMPONENTS)
+
+#list each component dependencies IN PCL
+@PCLCONFIG_INTERNAL_DEPENDENCIES@
+
+#list each component external dependencies (ext means mandatory and opt means optional)
+@PCLCONFIG_EXTERNAL_DEPENDENCIES@
+
+@PCLCONFIG_OPTIONAL_DEPENDENCIES@
+
+set(pcl_header_only_components 2d cuda_common geometry gpu_tracking modeler in_hand_scanner point_cloud_editor cloud_composer)
+
+include(FindPackageHandleStandardArgs)
+
+#check if user provided a list of components
+#if no components at all or full list is given set PCL_FIND_ALL
+if(PCL_FIND_COMPONENTS)
+  list(LENGTH PCL_FIND_COMPONENTS PCL_FIND_COMPONENTS_LENGTH)
+  if(PCL_FIND_COMPONENTS_LENGTH EQUAL PCL_NB_COMPONENTS)
+    set(PCL_TO_FIND_COMPONENTS ${pcl_all_components})
+    set(PCL_FIND_ALL 1)
+  else()
+    set(PCL_TO_FIND_COMPONENTS ${PCL_FIND_COMPONENTS})
+  endif()
+else()
+  set(PCL_TO_FIND_COMPONENTS ${pcl_all_components})
+  set(PCL_FIND_ALL 1)
+endif()
+
+compute_dependencies(PCL_TO_FIND_COMPONENTS)
+
+# We do not need to find components that have been found already, e.g. during previous invocation
+# of find_package(PCL). Filter them out.
+foreach(component ${PCL_TO_FIND_COMPONENTS})
+  string(TOUPPER "${component}" COMPONENT)
+  if(NOT PCL_${COMPONENT}_FOUND)
+    list(APPEND _PCL_TO_FIND_COMPONENTS ${component})
+  endif()
+endforeach()
+set(PCL_TO_FIND_COMPONENTS ${_PCL_TO_FIND_COMPONENTS})
+unset(_PCL_TO_FIND_COMPONENTS)
+
+if(NOT PCL_TO_FIND_COMPONENTS)
+  return()
+endif()
+
+# compute external dependencies per component
+foreach(component ${PCL_TO_FIND_COMPONENTS})
+    foreach(opt ${pcl_${component}_opt_dep})
+      find_external_library(${component} ${opt} OPTIONAL)
+    endforeach()
+    foreach(ext ${pcl_${component}_ext_dep})
+      find_external_library(${component} ${ext} REQUIRED)
+    endforeach()
+endforeach()
+
+foreach(component ${PCL_TO_FIND_COMPONENTS})
+  set(pcl_component pcl_${component})
+  string(TOUPPER "${component}" COMPONENT)
+
+  pcl_message(STATUS "looking for PCL_${COMPONENT}")
+
+  string(REGEX REPLACE "^cuda_(.*)$" "\\1" cuda_component "${component}")
+  string(REGEX REPLACE "^gpu_(.*)$" "\\1" gpu_component "${component}")
+  string(REGEX REPLACE "^oneapi_(.*)$" "\\1" oneapi_component "${component}")
+
+  find_path(PCL_${COMPONENT}_INCLUDE_DIR
+    NAMES pcl/${component}
+          pcl/apps/${component}
+          pcl/cuda/${cuda_component} pcl/cuda/${component}
+          pcl/gpu/${gpu_component} pcl/gpu/${component} 
+          pcl/oneapi/${oneapi_component} pcl/oneapi/${component}
+    HINTS ${PCL-ONEAPI_INCLUDE_DIRS}
+          "${PCL_SOURCES_TREE}"
+    PATH_SUFFIXES
+          ${component}/include
+          apps/${component}/include
+          cuda/${cuda_component}/include
+          gpu/${gpu_component}/include
+          oneapi/${oneapi_component}/include
+    DOC "path to ${component} headers"
+    NO_DEFAULT_PATH)
+  mark_as_advanced(PCL_${COMPONENT}_INCLUDE_DIR)
+
+  if(PCL_${COMPONENT}_INCLUDE_DIR)
+    list(APPEND PCL_${COMPONENT}_INCLUDE_DIRS "${PCL_${COMPONENT}_INCLUDE_DIR}")
+  else()
+    #pcl_message("No include directory found for pcl_${component}.")
+  endif()
+
+  set(FPHSA_NAME_MISMATCHED 1) # Suppress warnings, see https://cmake.org/cmake/help/v3.17/module/FindPackageHandleStandardArgs.html
+  # Skip find_library for header only modules
+  list(FIND pcl_header_only_components ${component} _is_header_only)
+  if(_is_header_only EQUAL -1)
+    find_library(PCL_${COMPONENT}_LIBRARY ${pcl_component}${PCL_RELEASE_SUFFIX}
+      HINTS ${PCL-ONEAPI_LIBRARY_DIRS}
+      DOC "path to ${pcl_component} library"
+      NO_DEFAULT_PATH)
+    get_filename_component(${component}_library_path
+      ${PCL_${COMPONENT}_LIBRARY}
+      PATH)
+    mark_as_advanced(PCL_${COMPONENT}_LIBRARY)
+
+    find_library(PCL_${COMPONENT}_LIBRARY_DEBUG ${pcl_component}${PCL_DEBUG_SUFFIX}
+      HINTS ${PCL-ONEAPI_LIBRARY_DIRS}
+      DOC "path to ${pcl_component} library debug"
+      NO_DEFAULT_PATH)
+    mark_as_advanced(PCL_${COMPONENT}_LIBRARY_DEBUG)
+
+    if(PCL_${COMPONENT}_LIBRARY_DEBUG)
+      get_filename_component(${component}_library_path_debug
+        ${PCL_${COMPONENT}_LIBRARY_DEBUG}
+        PATH)
+    endif()
+
+    # Restrict this to Windows users
+    if(NOT PCL_${COMPONENT}_LIBRARY AND WIN32)
+      # might be debug only
+      set(PCL_${COMPONENT}_LIBRARY ${PCL_${COMPONENT}_LIBRARY_DEBUG})
+    endif()
+
+    find_package_handle_standard_args(PCL_${COMPONENT} DEFAULT_MSG
+      PCL_${COMPONENT}_LIBRARY PCL_${COMPONENT}_INCLUDE_DIR)
+  else()
+    find_package_handle_standard_args(PCL_${COMPONENT} DEFAULT_MSG
+      PCL_${COMPONENT}_INCLUDE_DIR)
+  endif()
+  unset(FPHSA_NAME_MISMATCHED)
+
+  if(PCL_${COMPONENT}_FOUND)
+    if(NOT "${PCL_${COMPONENT}_INCLUDE_DIRS}" STREQUAL "")
+      set(_filtered "")
+      foreach(_inc ${PCL_${COMPONENT}_INCLUDE_DIRS})
+        if(EXISTS ${_inc})
+          list(APPEND _filtered "${_inc}")
+        endif()
+      endforeach()
+      list(REMOVE_DUPLICATES _filtered)
+      set(PCL_${COMPONENT}_INCLUDE_DIRS ${_filtered})
+      list(APPEND PCL-ONEAPI_INCLUDE_DIRS ${_filtered})
+    endif()
+    mark_as_advanced(PCL_${COMPONENT}_INCLUDE_DIRS)
+    if(_is_header_only EQUAL -1)
+      list(APPEND PCL-ONEAPI_DEFINITIONS ${PCL_${COMPONENT}_DEFINITIONS})
+      list(APPEND PCL-ONEAPI_LIBRARY_DIRS ${component_library_path})
+      if(PCL_${COMPONENT}_LIBRARY_DEBUG)
+        list(APPEND PCL-ONEAPI_LIBRARY_DIRS ${component_library_path_debug})
+      endif()
+      list(APPEND PCL-ONEAPI_COMPONENTS ${pcl_component})
+      mark_as_advanced(PCL_${COMPONENT}_LIBRARY PCL_${COMPONENT}_LIBRARY_DEBUG)
+    endif()
+    # Append internal dependencies
+    foreach(int_dep ${pcl_${component}_int_dep})
+      string(TOUPPER "${int_dep}" INT_DEP)
+      if(PCL_${INT_DEP}_FOUND)
+        list(APPEND PCL_${COMPONENT}_INCLUDE_DIRS ${PCL_${INT_DEP}_INCLUDE_DIRS})
+        if(PCL_${INT_DEP}_LIBRARIES)
+          list(APPEND PCL_${COMPONENT}_LINK_LIBRARIES "${PCL_${INT_DEP}_LIBRARIES}")
+        endif()
+      endif()
+    endforeach()
+    if(_is_header_only EQUAL -1)
+      add_library(${pcl_component} @PCL_LIB_TYPE@ IMPORTED)
+      if(PCL_${COMPONENT}_LIBRARY_DEBUG)
+        set_target_properties(${pcl_component}
+          PROPERTIES
+            IMPORTED_CONFIGURATIONS "RELEASE;DEBUG"
+            IMPORTED_LOCATION_RELEASE "${PCL_${COMPONENT}_LIBRARY}"
+            IMPORTED_LOCATION_DEBUG "${PCL_${COMPONENT}_LIBRARY_DEBUG}"
+            IMPORTED_IMPLIB_RELEASE "${PCL_${COMPONENT}_LIBRARY}"
+            IMPORTED_IMPLIB_DEBUG "${PCL_${COMPONENT}_LIBRARY_DEBUG}"
+        )
+      else()
+        set_target_properties(${pcl_component}
+          PROPERTIES
+            IMPORTED_LOCATION "${PCL_${COMPONENT}_LIBRARY}"
+            IMPORTED_IMPLIB "${PCL_${COMPONENT}_LIBRARY}"
+        )
+      endif()
+    else() # header-only
+      add_library(${pcl_component} INTERFACE IMPORTED)
+    endif()
+
+    foreach(def ${PCL-ONEAPI_DEFINITIONS})
+      string(REPLACE " " ";" def2 ${def})
+      string(REGEX REPLACE "^-D" "" def3 "${def2}")
+      list(APPEND definitions ${def3})
+    endforeach()
+    if(CMAKE_VERSION VERSION_LESS 3.3)
+      set_target_properties(${pcl_component}
+        PROPERTIES
+          INTERFACE_COMPILE_DEFINITIONS "${definitions}"
+          INTERFACE_COMPILE_OPTIONS "${PCL_COMPILE_OPTIONS}"
+          INTERFACE_COMPILE_FEATURES "@PCL_CXX_COMPILE_FEATURES@"
+          INTERFACE_INCLUDE_DIRECTORIES "${PCL_${COMPONENT}_INCLUDE_DIRS};${PCL_CONF_INCLUDE_DIR}"
+          INTERFACE_LINK_LIBRARIES "${PCL_${COMPONENT}_LINK_LIBRARIES}"
+      )
+    elseif(CMAKE_VERSION VERSION_LESS 3.11)
+      set_target_properties(${pcl_component}
+        PROPERTIES
+          INTERFACE_COMPILE_DEFINITIONS "${definitions}"
+          INTERFACE_COMPILE_OPTIONS "$<$<COMPILE_LANGUAGE:CXX>:${PCL_COMPILE_OPTIONS}>"
+          INTERFACE_COMPILE_FEATURES "@PCL_CXX_COMPILE_FEATURES@"
+          INTERFACE_INCLUDE_DIRECTORIES "${PCL_${COMPONENT}_INCLUDE_DIRS};${PCL_CONF_INCLUDE_DIR}"
+          INTERFACE_LINK_LIBRARIES "${PCL_${COMPONENT}_LINK_LIBRARIES}"
+      )
+    else()
+      set_target_properties(${pcl_component}
+        PROPERTIES
+          INTERFACE_COMPILE_DEFINITIONS "${definitions}"
+          INTERFACE_COMPILE_OPTIONS "$<$<COMPILE_LANGUAGE:CXX>:${PCL_COMPILE_OPTIONS}>"
+          INTERFACE_COMPILE_FEATURES "@PCL_CXX_COMPILE_FEATURES@"
+          INTERFACE_INCLUDE_DIRECTORIES "${PCL_${COMPONENT}_INCLUDE_DIRS};${PCL_CONF_INCLUDE_DIR}"
+      )
+      # If possible, we use target_link_libraries to avoid problems with link-type keywords,
+      # see https://github.com/PointCloudLibrary/pcl/issues/2989
+      # target_link_libraries on imported libraries is supported only since CMake 3.11
+      target_link_libraries(${pcl_component} INTERFACE ${PCL_${COMPONENT}_LINK_LIBRARIES})
+    endif()
+    set(PCL_${COMPONENT}_LIBRARIES ${pcl_component})
+  endif()
+endforeach()
+
+if(NOT "${PCL-ONEAPI_INCLUDE_DIRS}" STREQUAL "")
+  list(REMOVE_DUPLICATES PCL-ONEAPI_INCLUDE_DIRS)
+endif()
+
+if(NOT "${PCL-ONEAPI_LIBRARY_DIRS}" STREQUAL "")
+  list(REMOVE_DUPLICATES PCL-ONEAPI_LIBRARY_DIRS)
+endif()
+
+if(NOT "${PCL-ONEAPI_DEFINITIONS}" STREQUAL "")
+  list(REMOVE_DUPLICATES PCL-ONEAPI_DEFINITIONS)
+endif()
+
+pcl_remove_duplicate_libraries(PCL-ONEAPI_COMPONENTS PCL-ONEAPI_LIBRARIES)
+
+# Add 3rd party libraries, as user code might include our .HPP implementations
+list(APPEND PCL-ONEAPI_LIBRARIES ${BOOST_LIBRARIES} ${OPENNI_LIBRARIES} ${OPENNI2_LIBRARIES} ${ENSENSO_LIBRARIES} ${davidSDK_LIBRARIES} ${DSSDK_LIBRARIES} ${RSSDK_LIBRARIES} ${RSSDK2_LIBRARIES})
+if (TARGET FLANN::FLANN)
+  list(APPEND PCL-ONEAPI_LIBRARIES FLANN::FLANN)
+endif()
+
+if(TARGET QHULL::QHULL)
+    list(APPEND PCL-ONEAPI_LIBRARIES QHULL::QHULL)
+endif()
+
+find_package_handle_standard_args(PCL-ONEAPI DEFAULT_MSG PCL-ONEAPI_LIBRARIES PCL-ONEAPI_INCLUDE_DIRS)
+mark_as_advanced(PCL-ONEAPI_LIBRARIES PCL-ONEAPI_INCLUDE_DIRS PCL-ONEAPI_LIBRARY_DIRS)
diff --git a/oneapi/PCL-ONEAPIConfigVersion.cmake.in b/oneapi/PCL-ONEAPIConfigVersion.cmake.in
new file mode 100644
index 000000000..e889ed575
--- /dev/null
+++ b/oneapi/PCL-ONEAPIConfigVersion.cmake.in
@@ -0,0 +1,13 @@
+# Check whether the requested PACKAGE_FIND_VERSION is compatible
+
+set(PACKAGE_VERSION @PCL_VERSION@)
+
+# Check whether the requested PACKAGE_FIND_VERSION is compatible
+if("${PACKAGE_VERSION}" VERSION_LESS "${PACKAGE_FIND_VERSION}")
+  set(PACKAGE_VERSION_COMPATIBLE FALSE)
+else()
+  set(PACKAGE_VERSION_COMPATIBLE TRUE)
+  if("${PACKAGE_VERSION}" VERSION_EQUAL "${PACKAGE_FIND_VERSION}")
+    set(PACKAGE_VERSION_EXACT TRUE)
+  endif()
+endif()
diff --git a/oneapi/README.md b/oneapi/README.md
new file mode 100644
index 000000000..a6a19fb09
--- /dev/null
+++ b/oneapi/README.md
@@ -0,0 +1,7 @@
+# How to build PCL and PCL-oneAPI
+
+This articles below provide the basic informations about the process of building PCL-oneAPI
+
+* [Linux](build_linux.md)
+* [Windows](build_windows.md)
+
diff --git a/oneapi/build_linux.md b/oneapi/build_linux.md
new file mode 100644
index 000000000..9e2d41fb2
--- /dev/null
+++ b/oneapi/build_linux.md
@@ -0,0 +1,119 @@
+
+# Build Point Cloud Library Using Intel oneAPI Toolkits
+In this tutorial you will learn how to configure your system to make it compatible to build oneAPI optimized PCL codes.
+This tutorial is for Ubuntu, other Linux distrubutions can follow a similar process to set it up.  
+
+Windows is currently  **not** officially supported for the oneAPI methods.
+
+Download Intel oneAPI Toolkits installer
+-----------------------------------------
+You can download Intel oneAPI Toolkits installer using the following command::
+```bash
+  $ wget https://registrationcenter-download.intel.com/akdlm/irc_nas/18487/l_BaseKit_p_2022.1.2.146_offline.sh
+  $ sudo sh ./l_BaseKit_p_2022.1.2.146_offline.sh
+```
+[Command Line Installation Parameters](https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top/installation/install-with-command-line.html)
+ 
+Installation Instructions
+-------------------------
+Step 1: From the console, locate the downloaded install file.
+
+Step 2: Use $ sudo sh ./<installer>.sh to launch the GUI Installer as the root.
+
+Step 3: Follow the instructions in the installer.
+
+Step 4: Explore the [Get Started Guide](https://software.intel.com/content/www/us/en/develop/documentation/get-started-with-intel-oneapi-base-linux/top.html).
+ 
+ 
+Installing GCC
+--------------
+To install GCC 10 run the following commands::
+ ```bash
+ $ sudo apt update -y
+ $ sudo apt upgrade -y
+ $ sudo apt install -y build-essential
+ $ sudo apt install -y gcc-10 g++-10 cpp-10
+ ```
+Set it as the default version::
+```bash
+ $ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 100 --slave /usr/bin/g++ g++ /usr/bin/g++-10 --slave /usr/bin/gcov gcov /usr/bin/gcov-10
+```
+It is a good idea to install cmake package, in addition to the above, because cmake is not included in build-essential::
+```bash
+ $ sudo apt install -y cmake
+```
+
+Installing library dependency
+--------------
+ ```bash
+ $ sudo apt install -y libgtest-dev libboost-filesystem-dev libboost-thread-dev libboost-date-time-dev libboost-iostreams-dev libvtk9-qt-dev libyaml-cpp-dev
+ ```
+
+Installing GPU driver
+-------------
+* [Ubuntu 22.04 LTS](https://dgpu-docs.intel.com/driver/client/overview.html#installing-client-gpus-on-ubuntu-desktop-22-04-lts)
+* [Ubuntu 24.04 LTS](https://dgpu-docs.intel.com/driver/client/overview.html#installing-client-gpus-on-ubuntu-desktop-24-04-lts)
+
+
+Build and Installing FLANN
+----------------
+You need to install Intel optimized FLANN library which contains the dpcpp implementation of kdtree.
+```bash
+# setup oneapi environment
+source /opt/intel/oneapi/setvars.sh
+# clone the flann repo
+git clone or download FLANN
+# build flann
+cd <path to flann repo>
+mkdir build
+cd build
+cmake -DCMAKE_BUILD_TYPE=Release -DBUILD_DPCPP_LIB=ON ..
+make -j
+sudo make install
+```
+Build PCL-oneAPI
+----------------
+Follow these steps to build the PCL-oneAPI.
+```bash
+# setup oneapi environment
+source /opt/intel/oneapi/setvars.sh
+# clone or download PCL-oneapi repo
+git clone or download PCL-onapi
+cd <path to PCL repo>
+mkdir build
+cd build
+cmake -DBUILD_TESTS:BOOL=ON -DBUILD_DPCPP_LIB:BOOL=ON -DBUILD_CUDA_LIB:BOOL=OFF -DBUILD_ONEAPI:BOOL=ON -DBUILD_global_tests:BOOL=ON -DCMAKE_BUILD_TYPE=Release ..
+make -j
+sudo make install
+```
+
+### Troubleshooting
+
+If the compilation breaks with an error message
+```
+In file included from /usr/include/boost/mpl/integral_c.hpp:32:
+/usr/include/boost/mpl/aux_/integral_wrapper.hpp:73:31: error: integer value -1 is outside the valid range of values [0, 3] for the enumeration type 'udt_builtin_mixture_en-conversion]
+   73 |     typedef AUX_WRAPPER_INST( BOOST_MPL_AUX_STATIC_CAST(AUX_WRAPPER_VALUE_TYPE, (value - 1)) ) prior;
+      |                               ^
+/usr/include/boost/mpl/aux_/static_cast.hpp:24:47: note: expanded from macro 'BOOST_MPL_AUX_STATIC_CAST'
+   24 | #   define BOOST_MPL_AUX_STATIC_CAST(T, expr) static_cast<T>(expr)
+      |                                               ^
+fatal error: too many errors emitted, stopping now [-ferror-limit=]
+```
+you can edit the file `/usr/include/boost/mpl/aux_/integral_wrapper.hpp`
+with sudo rights and apply the patch described in GitHub commit
+["Use static const for next/prior from C++17"](https://github.com/ecatmur/mpl/commit/8499ae7e4ff0cf798367ebe6ea9fb991aa43db6c).
+
+
+Test PCL-oneAPI
+---------------
+Functionality test
+```bash
+cd <pcl_path>/test/oneapi
+./run_oneapi_func_tests.sh
+```
+Performance test
+```bash
+cd <pcl_path>/test/oneapi
+./run_oneapi_func_tests.sh
+```
diff --git a/oneapi/build_pcl_test_func.bat b/oneapi/build_pcl_test_func.bat
new file mode 100644
index 000000000..866af6860
--- /dev/null
+++ b/oneapi/build_pcl_test_func.bat
@@ -0,0 +1,25 @@
+cd ../test/oneapi
+if not exist build\ (
+    mkdir build
+)
+cd build
+cmake ..
+cmake --build . --target test_oneapi_correspondence_estimation --config Release
+cmake --build . --target test_oneapi_registration --config Release
+cmake --build . --target test_oneapi_scia --config Release
+cmake --build . --target test_oneapi_kdtree_search --config Release
+cmake --build . --target test_oneapi_kdtree --config Release
+cmake --build . --target test_oneapi_octree_radius_search_function --config Release
+cmake --build . --target test_oneapi_octree_knn_search_function --config Release
+cmake --build . --target test_oneapi_octree_approx_nearest_function --config Release
+cmake --build . --target test_oneapi_sample_consensus_plane_models --config Release
+cmake --build . --target test_oneapi_segmentation  --config Release
+@REM cmake --build . --target test_oneapi_convex_hull_function  --config Release
+cmake --build . --target test_oneapi_mls  --config Release
+cmake --build . --target test_oneapi_voxel_grid  --config Release
+cmake --build . --target test_oneapi_passthrough  --config Release
+cmake --build . --target test_oneapi_statistical_outlier_removal  --config Release
+cmake --build . --target test_oneapi_features_normals_function  --config Release
+
+
+
diff --git a/oneapi/build_pcl_test_perf.bat b/oneapi/build_pcl_test_perf.bat
new file mode 100644
index 000000000..eaf2ed9ad
--- /dev/null
+++ b/oneapi/build_pcl_test_perf.bat
@@ -0,0 +1,25 @@
+cd ../test/oneapi
+if not exist build\ (
+    mkdir build
+)
+cd build
+cmake ..
+cmake --build . --target test_oneapi_registration_perf --config Release
+cmake --build . --target test_oneapi_scia_perf --config Release
+cmake --build . --target test_oneapi_kdtree_search_perf --config Release
+cmake --build . --target test_oneapi_kdtree_perf --config Release
+cmake --build . --target test_oneapi_octree_radius_search_performance --config Release
+cmake --build . --target test_oneapi_octree_knn_search_performance --config Release
+cmake --build . --target test_oneapi_octree_approx_nearest_performance --config Release
+cmake --build . --target test_oneapi_sample_consensus_plane_models_perf --config Release
+cmake --build . --target test_oneapi_segmentation_perf --config Release
+@REM cmake --build . --target test_oneapi_convex_hull_performance --config Release
+cmake --build . --target test_oneapi_mls_performance  --config Release
+cmake --build . --target test_oneapi_voxel_grid_perf --config Release
+cmake --build . --target test_oneapi_passthrough_perf --config Release
+cmake --build . --target test_oneapi_statistical_outlier_removal_perf --config Release
+cmake --build . --target test_oneapi_features_normals_performance --config Release
+cmake --build . --target test_oneapi_greedy_projection_triangulation --config Release
+
+
+
diff --git a/oneapi/build_windows.md b/oneapi/build_windows.md
new file mode 100644
index 000000000..563a9fa65
--- /dev/null
+++ b/oneapi/build_windows.md
@@ -0,0 +1,164 @@
+
+# Build PCL-oneAPI on Windows
+
+
+## Dependencies
+1. Intel oneAPI Toolkits
+  Download and Install Intel oneAPI Toolkits 2024.2.1:
+  https://www.intel.com/content/www/us/en/developer/tools/oneapi/base-toolkit-download.html?operatingsystem=window&distributions=offline
+
+2. BOOSTEIGEN,FLANN,OPENI2,Qhull,VTK (Leverage the original PCL release package to get the required library ):
+Get the `PCL-1.12.1-AllInOne-msvc2019-win64.exe` from https://github.com/PointCloudLibrary/pcl/releases (you will need to scroll down on that page until you see the version *PCL 1.12.1*.
+
+   Execute the installer. The default installation directory should be `C:\Program Files\PCL 1.12.1`. When the installer asks you to select the components to install, unselect *PCL*, so that only the *3rd Party Libraries* are installed.
+
+   We will leverage the 3rd Party Dependencies such as `BOOSTEIGEN,OPENI2,Qhull,VTK`, We will build the FLANN BOOST library in our own DPC++ version.
+
+3. GoogleTest:
+   Download GoogleTest from https://github.com/google/googletest/blob/main/googletest/README.md
+
+   To build and install GoogleTest on Windows (built as a Shared Library (DLL)), open a cmd terminal with administrator rights and run the following commands:
+   ```
+   cd <googletest>  # Main directory of the cloned repository.
+   mkdir build
+   cd build
+   cmake -DBUILD_SHARED_LIBS=SHARED ..
+   cmake --build . --target INSTALL --config Release  
+   ```
+   This will install GoogleTest in: 
+   `C:\Program Files (x86)\googletest-distribution`
+
+   Open the *Environment Variables* dialogue of your Windows installation, create an environment variable `GTEST_ROOT`, and let it point to this path.
+
+    
+4. Flann(DPC++):
+  Build & Install
+  Open the cmd terminal as administrator
+    ```
+    # setup oneapi environment
+    C:\Program Files (x86)\Intel\oneAPI\setvars.bat
+    # For Windows PowerShell*, use the following command: cmd.exe "/K" '"C:\Program Files (x86)\Intel\oneAPI\setvars.bat" && powershell'
+
+    # build flann
+    Download or glone FLANN source
+    cd <flann_path>
+    mkdir build
+    cd build
+    cmake -DBUILD_TESTS:BOOL=ON -DBUILD_DPCPP_LIB:BOOL=ON -DBUILD_CUDA_LIB:BOOL=OFF -DCMAKE_BUILD_TYPE=Release ..
+    ```
+    Finally  install all the flann components.
+    ```
+    cmake --build . --target INSTALL --config Release
+
+    FLANN will install in 
+    C:/Program Files (x86)/flann
+    ```
+5. BOOST
+  Build& Install from source
+  Download the BOOST 1.81.0 https://boostorg.jfrog.io/artifactory/main/release/1.81.0/binaries/boost_1_81_0-msvc-14.3-64.exe
+    ```
+
+    After install, go to c:\local\boost_1_81_0, run 
+
+    bootstrap
+    .\b2
+    ```
+
+    Add BOOST_ROOT to env
+
+    Oneapi may fail to detect boost.  So, update this file
+    C:\local\boost_1_81_0\stage\lib\cmake\BoostDetectToolset-1.81.0.cmake
+
+    Line 41  should be and remove the llvm
+    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
+
+6. YAML-app
+  Build & Install from source
+  Download from https://github.com/jbeder/yaml-cpp
+    ```
+    git clone https://github.com/jbeder/yaml-cpp.git
+    cd <yaml_path>
+    mkdir build
+    cd build
+    cmake -DYAML_BUILD_SHARED_LIBS=ON ..
+    cmake --build . --target INSTALL --config Release
+    ```
+## Build PCL-oneAPI
+
+#### Set correct installation path of dependencies
+Modify the installation path of dependencies in `pcl_win_dir.cmake` in path `<pcl_path>/cmake/pcl_win_dir.cmake`,the file looks like the following:
+
+  ```
+  if(WIN32)
+  set(FLANN_ROOT "C:/Program Files (x86)/flann")
+  set(EIGEN_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/Eigen")
+  set(Qhull_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/Qhull")
+  set(VTK_ROOT "C:/Program Files/PCL 1.12.1/3rdParty/VTK")
+  set(OPENNI2_BIN "C:/Program Files/OpenNI2/Redist")
+  set(BOOST_ROOT "C:/local/boost_1_81_0")
+  set(BOOST_LIBRARYDIR "C:/local/boost_1_81_0/stage/lib")
+  set(Boost_LIB_PREFIX "lib")
+  set(FLANN_INCLUDE "C:/Program Files (x86)/flann/include")
+  set(PCL_ROOT "C:/Program Files (x86)/PCL")
+  set(PCL_BIN "C:/Program Files (x86)/PCL/bin")
+  set(PCL_ONEAPI_ROOT "C:/Program Files (x86)/PCL-ONEAPI")
+  set(GTEST_ROOT "C:/Program Files (x86)/googletest-distribution")
+  set(GTEST_SRC_DIR "C:/Users/intel/Downloads/googletest/googletest")
+  set(SYCL_PATH "C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/ocloc;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/bin/intel64;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/redist/intel64_win/compiler;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/host/windows64/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/llvm/aocl-bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/windows64/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/lib/oclfpga/bin;C:/Program Files (x86)/Intel/oneAPI/compiler/latest/windows/../../../tbb/latest/redist/intel64/vc_mt;")
+  set(INTEL_CPP_COMPILER "Intel C++ Compiler 2023")
+  set(INTEL_DPCPP_COMPILER "Intel(R) oneAPI DPC++ Compiler 2023")
+  set(yaml-cpp_DIR "C:/Program Files (x86)/YAML_CPP/lib/cmake/yaml-cpp")
+  set(YAML_CPP_INCLUDE_DIRS "C:/Program Files (x86)/YAML_CPP/include")
+  set(YAML_CPP_LIBRARIES "C:/Program Files (x86)/YAML_CPP/lib")
+  set(YAML_CPP_BIN "C:/Program Files (x86)/YAML_CPP/bin")
+  endif()
+  ```
+Do **not** change the paths for `PCL_ROOT` and `PCL_BIN`. They should **not**
+point to `C:\Program Files\PCL 1.12.1`, which is the path that was created by
+the installer `PCL-1.12.1-AllInOne-msvc2019-win64.exe`. Instead, `PCL_ROOT`
+and `PCL_BIN` shall point to the destination where the PCL shall be installed
+when you execute the next steps.
+
+#### Build native PCL
+Open CMD terminal or `Intel oneAPI command prompt for Intel 64 for Visual Studio 2022` as administrator
+```
+# setup oneapi environment
+C:\Program Files(x86)\Intel\oneAPI\setvars.bat
+# For Windows PowerShell*, use the following command: cmd.exe "/K" '"C:\Program Files (x86)\Intel\oneAPI\setvars.bat" && powershell'
+
+# build native pcl
+cd <pcl_path>
+mkdir build
+cd build
+cmake ..
+cmake --build . --target INSTALL --config Release
+```
+#### Build PCL-oneAPI
+```
+# build pcl oneapi
+cd <pcl_path>/oneapi
+mkdir build
+cd build
+cmake ..
+```
+Finally install the PCL-oneAPI
+```
+cmake --build . --target INSTALL --config Release
+```
+
+
+```
+# build pcl test
+cd <pcl_path>/oneapi
+build_pcl_test_func.bat
+build_pcl_test_perf.bat
+```
+#### Test PCL-oneAPI
+```
+C:\Program Files(x86)\Intel\oneAPI\setvars.bat
+cd <pcl_path>/test/oneapi
+run_pcl_oneapi_test_func.bat
+run_pcl_oneapi_test_perf.bat
+```
+
+
diff --git a/oneapi/cmake/cpack_options.cmake.in b/oneapi/cmake/cpack_options.cmake.in
new file mode 100644
index 000000000..7787a4e90
--- /dev/null
+++ b/oneapi/cmake/cpack_options.cmake.in
@@ -0,0 +1,49 @@
+set(CPACK_PACKAGE_NAME "@PROJECT_NAME@")
+set(CPACK_PACKAGE_VENDOR "PointClouds.org")
+set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Point Cloud Library (PCL)")
+set(CPACK_PACKAGE_INSTALL_DIRECTORY "@PROJECT_NAME@ @PCL_VERSION_PRETTY@")
+set(CPACK_RESOURCE_FILE_LICENSE "@PROJECT_SOURCE_DIR@/LICENSE.txt")
+set(CPACK_RESOURCE_FILE_README "@PROJECT_SOURCE_DIR@/AUTHORS.txt")
+
+@PCL_CPACK_COMPONENTS@
+
+if((WIN32 OR UNIX) AND (CPACK_GENERATOR STREQUAL "NSIS"))
+    set(CPACK_NSIS_DISPLAY_NAME "@PROJECT_NAME@-@PCL_VERSION_PRETTY@")
+    set(CPACK_NSIS_MUI_ICON "@PROJECT_SOURCE_DIR@/cmake/images/pcl.ico")
+    set(CPACK_NSIS_MUI_UNIICON "@PROJECT_SOURCE_DIR@/cmake/images/pcl.ico")
+    set(CPACK_NSIS_HELP_LINK "http://www.pointclouds.org")
+    set(CPACK_NSIS_URL_INFO_ABOUT "http://www.pointclouds.org")
+    set(CPACK_NSIS_MODIFY_PATH ON)
+    set(CPACK_PACKAGE_EXECUTABLES @PCL_EXECUTABLES@)
+    set(CPACK_NSIS_MENU_LINKS
+            "share/doc/pcl-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@/tutorials/html/index.html" "Tutorials"
+            "share/doc/pcl-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@/tutorials/html/sources" "Tutorials sources"
+            "share/doc/pcl-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@/html/pcl-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@.chm" "Documentation"
+            "http://www.pointclouds.org" "PCL Website")
+    #set(CPACK_NSIS_MENU_LINKS "share/doc/@PROJECT_NAME@/user_guide.pdf" "User's guide")
+    #set(CPACK_NSIS_MENU_LINKS "share/doc/@PROJECT_NAME@/developer_guide.pdf" "Developer's guide")
+    if(WIN32 AND NOT UNIX)
+      # There is a bug in NSI that does not handle full unix paths properly. Make
+      # sure there is at least one set of four (4) backlasshes.
+      set(CPACK_PACKAGE_ICON "@PROJECT_SOURCE_DIR@/cmake/images\\\\pcl_horz_large_pos.bmp")
+    else()
+      set(CPACK_PACKAGE_ICON "@PROJECT_SOURCE_DIR@/cmake/images/pcl_horz_large_pos.bmp")
+    endif()
+endif()
+
+if(UNIX AND ((CPACK_GENERATOR STREQUAL "DEB") OR (CPACK_GENERATOR STREQUAL "RPM")))
+    # define stuff for the DEB/RPM packages
+    set(CPACK_PACKAGE_CONTACT "pcl-developers@pointclouds.org")
+endif()
+
+if(UNIX AND (CPACK_GENERATOR STREQUAL "DEB"))
+  set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
+endif()
+
+if(APPLE AND (CPACK_GENERATOR STREQUAL "PackageMaker"))
+    # define stuff for the PackageMaker packages
+    set(CPACK_OSX_PACKAGE_VERSION 10.5)
+    set(CPACK_PACKAGE_CONTACT "pcl-developers@pointclouds.org")
+    set(CPACK_SET_DESTDIR ON)
+    set(CPACK_PACKAGING_INSTALL_PREFIX /usr/local)
+endif()
diff --git a/oneapi/cmake/dep_graph.cmake b/oneapi/cmake/dep_graph.cmake
new file mode 100644
index 000000000..4cc62c486
--- /dev/null
+++ b/oneapi/cmake/dep_graph.cmake
@@ -0,0 +1,32 @@
+###############################################################################
+# Make a dependency graph dot file
+function(MAKE_DEP_GRAPH)
+    set(_dot_file "${PROJECT_BINARY_DIR}/pcl.dot")
+    file(WRITE ${_dot_file} "digraph pcl {\n")
+    foreach(_ss ${PCL_SUBSYSTEMS})
+      if(NOT _ss STREQUAL "global_tests" AND
+         NOT _ss STREQUAL "apps" AND
+         NOT _ss STREQUAL "tools" AND
+         NOT _ss STREQUAL "test" AND
+         NOT _ss STREQUAL "python" AND
+         NOT _ss STREQUAL "documentation")
+        PCL_GET_SUBSYS_STATUS(_status ${_ss})
+        if(_status)
+            file(APPEND ${_dot_file}
+                "  \"${_ss}\" [style=\"filled\" fillcolor=\"#008000\" shape=\"box\"];\n ")
+        else()
+            file(APPEND ${_dot_file}
+                "  \"${_ss}\" [style=\"filled\" fillcolor=\"#D40000\" shape=\"box\"];\n ")
+        endif()
+        GET_IN_MAP(_deps PCL_SUBSYS_DEPS ${_ss})
+        foreach(_dep ${_deps})
+            file(APPEND ${_dot_file} "  \"${_ss}\" -> \"${_dep}\";\n")
+        endforeach()
+      endif()
+    endforeach()
+
+    #file(APPEND ${_dot_file}
+    #    "  \"test\" [style=\"filled\" fillcolor=\"#A3A27C\" shape=\"box\"];\n ")
+    file(APPEND ${_dot_file} "}\n")
+endfunction(MAKE_DEP_GRAPH)
+
diff --git a/oneapi/cmake/pcl_all_in_one_installer.cmake b/oneapi/cmake/pcl_all_in_one_installer.cmake
new file mode 100644
index 000000000..52309dc41
--- /dev/null
+++ b/oneapi/cmake/pcl_all_in_one_installer.cmake
@@ -0,0 +1,146 @@
+
+if(WIN32)
+  option(BUILD_all_in_one_installer "Build an all-in-one NSIS installer" OFF)
+endif()
+
+if(NOT BUILD_all_in_one_installer)
+  return()
+endif()
+
+# get root directory of each dependency libraries to be copied to PCL/3rdParty
+get_filename_component(BOOST_ROOT "${Boost_INCLUDE_DIR}" PATH)  # ../Boost/include/boost-x_x/ -> ../Boost/include/
+get_filename_component(BOOST_ROOT "${BOOST_ROOT}" PATH)         # ../Boost/include/           -> ../Boost/
+get_filename_component(EIGEN_ROOT "${EIGEN_INCLUDE_DIRS}" PATH) # ../Eigen3/include/          -> ../Eigen3/
+get_filename_component(QHULL_ROOT "${Qhull_DIR}" PATH)          # ../qhull/lib/cmake/Qhull/   -> ../qhull/lib/cmake
+get_filename_component(QHULL_ROOT "${QHULL_ROOT}" PATH)         # ../qhull/lib/cmake/         -> ../qhull/lib/
+get_filename_component(QHULL_ROOT "${QHULL_ROOT}" PATH)         # ../qhull/lib/               -> ../qhull/
+get_filename_component(VTK_ROOT "${VTK_DIR}" PATH)              # ../VTK/lib/cmake/vtk-x.x/   -> ../VTK/lib/cmake/
+get_filename_component(VTK_ROOT "${VTK_ROOT}" PATH)             # ../VTK/lib/cmake/           -> ../VTK/lib/
+get_filename_component(VTK_ROOT "${VTK_ROOT}" PATH)             # ../VTK/lib/                 -> ../VTK/
+
+set(PCL_3RDPARTY_COMPONENTS)
+foreach(dep Eigen Boost Qhull FLANN VTK)
+  string(TOUPPER ${dep} DEP)
+  install(
+    DIRECTORY "${${DEP}_ROOT}/"
+    DESTINATION 3rdParty/${dep}
+    COMPONENT ${dep}
+    PATTERN "*/Uninstall.exe" EXCLUDE
+  )
+  list(APPEND PCL_3RDPARTY_COMPONENTS ${dep})
+endforeach()
+
+if(WITH_RSSDK2)
+  get_filename_component(RSSDK2_ROOT "${RSSDK2_INCLUDE_DIRS}" PATH)
+  install(
+          DIRECTORY "${RSSDK2_ROOT}/"
+          DESTINATION 3rdParty/librealsense2
+          COMPONENT rssdk2
+          PATTERN "*/Uninstall.exe" EXCLUDE
+      )
+  list(APPEND PCL_3RDPARTY_COMPONENTS rssdk2)
+endif()
+
+if(WITH_OPENNI)
+  if(CMAKE_CL_64)
+    set(OPENNI_PACKAGE "OpenNI-Win64-1.5.4-Dev.msi")
+    set(OPENNI_URL "http://sourceforge.net/projects/pointclouds/files/dependencies/${OPENNI_PACKAGE}")
+    set(OPENNI_MD5 c8f9cbe8447a16d32572a4e2c2d00af0)
+    set(OPENNI_SENSOR_PACKAGE "Sensor-Win-OpenSource64-5.1.0.msi")
+    set(OPENNI_SENSOR_URL "http://sourceforge.net/projects/pointclouds/files/dependencies/${OPENNI_SENSOR_PACKAGE}")
+    set(OPENNI_SENSOR_MD5 badb880116436870943b1b7c447dfa22)
+  else()
+    set(OPENNI_PACKAGE "OpenNI-Win32-1.5.4-Dev.msi")
+    set(OPENNI_URL "http://sourceforge.net/projects/pointclouds/files/dependencies/${OPENNI_PACKAGE}")
+    set(OPENNI_MD5 996d48f447b41a5501b7d22af27ab251)
+    set(OPENNI_SENSOR_PACKAGE "Sensor-Win-OpenSource32-5.1.0.msi")
+    set(OPENNI_SENSOR_URL "http://sourceforge.net/projects/pointclouds/files/dependencies/${OPENNI_SENSOR_PACKAGE}")
+    set(OPENNI_SENSOR_MD5 55da1f7541d7c9c98772bddf801c7e1c)
+  endif()
+
+  set(CPACK_NSIS_EXTRA_INSTALL_COMMANDS "  IntCmp $OpenNI_selected 0 noinstall_openni_packages\n")
+
+  file(DOWNLOAD ${OPENNI_URL} "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI_PACKAGE}"
+    STATUS _openni_download_status LOG _openni_download_log
+    EXPECTED_MD5 ${OPENNI_MD5}
+     )
+  list(GET _openni_download_status 0 _error_code)
+  list(GET _openni_download_status 1 _error_message)
+  if(_error_code EQUAL 0)
+    install(
+      FILES "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI_PACKAGE}"
+      DESTINATION 3rdParty/OpenNI
+      COMPONENT OpenNI
+    )
+    list(APPEND PCL_3RDPARTY_COMPONENTS OpenNI)
+    string(APPEND CPACK_NSIS_EXTRA_INSTALL_COMMANDS "\n    ExecWait 'msiexec /i \\\"$INSTDIR\\\\3rdParty\\\\OpenNI\\\\${OPENNI_PACKAGE}\\\" /quiet '")
+  else()
+    message("WARNING : Could not download ${OPENNI_URL}, error code : ${_error_code}, error message : ${_error_message}")
+  endif()
+
+  file(DOWNLOAD ${OPENNI_SENSOR_URL} "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI_SENSOR_PACKAGE}"
+    STATUS _openni_download_status LOG _openni_download_log
+    EXPECTED_MD5 ${OPENNI_SENSOR_MD5}
+     )
+  list(GET _openni_download_status 0 _error_code)
+  list(GET _openni_download_status 1 _error_message)
+  if(_error_code EQUAL 0)
+    install(
+      FILES "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI_SENSOR_PACKAGE}"
+      DESTINATION 3rdParty/OpenNI
+      COMPONENT OpenNI
+    )
+    list(APPEND PCL_3RDPARTY_COMPONENTS OpenNI)
+    string(APPEND CPACK_NSIS_EXTRA_INSTALL_COMMANDS "\n    ExecWait 'msiexec /i \\\"$INSTDIR\\\\3rdParty\\\\OpenNI\\\\${OPENNI_SENSOR_PACKAGE}\\\" /quiet '")
+  else()
+    message("WARNING : Could not download ${OPENNI_SENSOR_URL}, error code : ${_error_code}, error message : ${_error_message}")
+  endif()
+  list(REMOVE_DUPLICATES PCL_3RDPARTY_COMPONENTS)
+  string(APPEND CPACK_NSIS_EXTRA_INSTALL_COMMANDS "\n  noinstall_openni_packages:\n")
+endif()
+
+if(WITH_OPENNI2)
+  if(CMAKE_CL_64)
+    set(OPENNI2_PACKAGE "OpenNI-Windows-x64-2.2.msi")
+    set(OPENNI2_ZIP "OpenNI-Windows-x64-2.2.0.33.zip")
+    set(OPENNI2_URL "http://com.occipital.openni.s3.amazonaws.com/${OPENNI2_ZIP}")
+    set(OPENNI2_MD5 d187f1dd0b091e27cebd03216b1bfff5)
+  else()
+    set(OPENNI2_PACKAGE "OpenNI-Windows-x86-2.2.msi")
+    set(OPENNI2_ZIP "OpenNI-Windows-x86-2.2.0.33.zip")
+    set(OPENNI2_URL "http://com.occipital.openni.s3.amazonaws.com/${OPENNI2_ZIP}")
+    set(OPENNI2_MD5 59b38e23d951d59917a35f7f89efaf22)
+  endif()
+
+  set(CPACK_NSIS_EXTRA_INSTALL_COMMANDS "  IntCmp $OpenNI2_selected 0 noinstall_openni2_packages\n")
+
+  file(DOWNLOAD ${OPENNI2_URL} "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI2_ZIP}"
+    STATUS _openni2_download_status LOG _openni2_download_log
+    EXPECTED_MD5 ${OPENNI2_MD5}
+     )
+  list(GET _openni2_download_status 0 _error_code)
+  list(GET _openni2_download_status 1 _error_message)
+  if(_error_code EQUAL 0)
+    execute_process(
+      COMMAND ${CMAKE_COMMAND} -E tar -xzf ${OPENNI2_ZIP}
+      WORKING_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}"
+      RESULT_VARIABLE _error_code
+      ERROR_VARIABLE _error_message
+    )
+    if(_error_code EQUAL 0)
+      install(
+        FILES "${CMAKE_CURRENT_BINARY_DIR}/${OPENNI2_PACKAGE}"
+        DESTINATION 3rdParty/OpenNI2
+        COMPONENT OpenNI2
+      )
+      list(APPEND PCL_3RDPARTY_COMPONENTS OpenNI2)
+      string(APPEND CPACK_NSIS_EXTRA_INSTALL_COMMANDS "\n    ExecWait 'msiexec /i \\\"$INSTDIR\\\\3rdParty\\\\OpenNI2\\\\${OPENNI2_PACKAGE}\\\" /quiet '")
+    else()
+      message("WARNING : Could not unzip ${OPENNI2_ZIP}, error code : ${_error_code}, error message : ${_error_message}")
+    endif()
+  else()
+    message("WARNING : Could not download ${OPENNI2_ZIP_URL}, error code : ${_error_code}, error message : ${_error_message}")
+  endif()
+  list(REMOVE_DUPLICATES PCL_3RDPARTY_COMPONENTS)
+  string(APPEND CPACK_NSIS_EXTRA_INSTALL_COMMANDS "\n  noinstall_openni2_packages:\n")
+endif()
diff --git a/oneapi/cmake/pcl_cpack.cmake b/oneapi/cmake/pcl_cpack.cmake
new file mode 100644
index 000000000..7e00c73e0
--- /dev/null
+++ b/oneapi/cmake/pcl_cpack.cmake
@@ -0,0 +1,146 @@
+# Package creation using CPack
+
+###############################################################################
+#find available package generators
+
+# RPM (disabled until RedHat/Fedora users/developers need this)
+#find_program(RPM_PROGRAM rpm)
+#if(EXISTS ${RPM_PROGRAM})
+#  list(APPEND CPACK_GENERATOR "RPM")
+#endif()
+
+set(CPACK_PACKAGE_VERSION "${PCL_VERSION_PRETTY}")
+set(CPACK_PACKAGE_VERSION_MAJOR "${PCL_VERSION_MAJOR}")
+set(CPACK_PACKAGE_VERSION_MINOR "${PCL_VERSION_MINOR}")
+set(CPACK_PACKAGE_VERSION_PATCH "${PCL_VERSION_PATCH}")
+set(CPACK_PACKAGE_CONFIG_INSTALL_DIR ${PCLCONFIG_INSTALL_DIR})
+
+# DEB
+if("${CMAKE_SYSTEM}" MATCHES "Linux")
+  find_program(DPKG_PROGRAM dpkg)
+  if(EXISTS ${DPKG_PROGRAM})
+    list(APPEND CPACK_GENERATOR "DEB")
+  endif()
+endif()
+
+# NSIS
+if(WIN32)
+  list(APPEND CPACK_GENERATOR "NSIS")
+  if(CMAKE_CL_64)
+    set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES64")
+    set(win_system_name win64)
+  else()
+    set(CPACK_NSIS_INSTALL_ROOT "$PROGRAMFILES32")
+    set(win_system_name win32)
+  endif()
+  set(CPACK_NSIS_PACKAGE_NAME "${PROJECT_NAME}-${PCL_VERSION_PRETTY}")
+  if(BUILD_all_in_one_installer)
+    set(CPACK_NSIS_PACKAGE_NAME "${PROJECT_NAME}-${PCL_VERSION_PRETTY}-AllInOne")
+  endif()
+  if(MSVC_VERSION EQUAL 1900)
+    string(APPEND CPACK_NSIS_PACKAGE_NAME "-msvc2015-${win_system_name}")
+  elseif(MSVC_VERSION MATCHES "^191[0-9]$")
+    string(APPEND CPACK_NSIS_PACKAGE_NAME "-msvc2017-${win_system_name}")
+  elseif(MSVC_VERSION MATCHES "^192[0-9]$")
+    string(APPEND CPACK_NSIS_PACKAGE_NAME "-msvc2019-${win_system_name}")
+  elseif(MSVC_VERSION MATCHES "^193[0-9]$")
+    string(APPEND CPACK_NSIS_PACKAGE_NAME "-msvc2022-${win_system_name}")
+  else()
+    string(APPEND CPACK_NSIS_PACKAGE_NAME "-${win_system_name}")
+  endif()
+  set(CPACK_PACKAGE_FILE_NAME ${CPACK_NSIS_PACKAGE_NAME})
+  # force CPACK_PACKAGE_INSTALL_REGISTRY_KEY because of a known limitation in cmake/cpack to be fixed in next releases
+  # http://public.kitware.com/Bug/view.php?id=9094
+  # This is to allow a 32bit and a 64bit of PCL to get installed on one system
+  set(CPACK_PACKAGE_INSTALL_REGISTRY_KEY "${PROJECT_NAME} ${PCL_VERSION_PRETTY} ${win_system_name}")
+endif()
+
+# dpkg
+if(APPLE)
+  find_program(PACKAGE_MAKER_PROGRAM PackageMaker
+               HINTS /Developer/Applications/Utilities)
+  if(EXISTS ${PACKAGE_MAKER_PROGRAM})
+    list(APPEND CPACK_GENERATOR "PackageMaker")
+  endif()
+endif()
+
+# By default, do not warn when built on machines using only VS Express:
+if(NOT DEFINED CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS)
+  set(CMAKE_INSTALL_SYSTEM_RUNTIME_LIBS_NO_WARNINGS ON)
+endif()
+include(InstallRequiredSystemLibraries)
+
+set(PCL_CPACK_CFG_FILE "${PCL-ONEAPI_BINARY_DIR}/cpack_options.cmake")
+
+###############################################################################
+# Make the CPack input file.
+macro(PCL_MAKE_CPACK_INPUT)
+    set(_cpack_cfg_in "${PCL-ONEAPI_SOURCE_DIR}/cmake/cpack_options.cmake.in")
+    set(${_var} "${${_var}}\nset(CPACK_COMPONENT_GROUP_PCL_DESCRIPTION \"PCL headers and libraries\")\n")
+
+    # Prepare the components list
+    set(PCL_CPACK_COMPONENTS)
+    PCL_CPACK_MAKE_COMPS_OPTS(PCL_CPACK_COMPONENTS "${_comps}")
+
+    # add documentation
+    if(WITH_DOCS)
+        string(APPEND CPACK_COMPONENTS_ALL " doc")
+        string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_DOC_GROUP \"PCL\")\n")
+        string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_DOC_DISPLAY_NAME \"Documentation\")\n")
+        string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_DOC_DESCRIPTION \"API documentation and tutorials\")\n")
+    endif()
+    # add PCLConfig
+    string(APPEND CPACK_COMPONENTS_ALL " pclconfig")
+    string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_PCLCONFIG_GROUP \"PCL\")\n")
+    string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_PCLCONFIG_DISPLAY_NAME \"PCLConfig\")\n")
+    string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_PCLCONFIG_DESCRIPTION \"Helper cmake configuration scripts used by find_package(PCL)\")\n")
+
+    # add 3rdParty libs
+    if(BUILD_all_in_one_installer)
+        string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_GROUP_THIRDPARTY_DISPLAY_NAME \"3rd Party Libraries\")")
+        string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_GROUP_THIRDPARTY_DESCRIPTION \"3rd Party Libraries\")")
+        foreach(dep ${PCL_3RDPARTY_COMPONENTS})
+            string(TOUPPER ${dep} DEP)
+            string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENT_${DEP}_GROUP \"ThirdParty\")")
+            string(APPEND CPACK_COMPONENTS_ALL " ${dep}")
+        endforeach()
+    endif()
+
+    string(APPEND PCL_CPACK_COMPONENTS "\nset(CPACK_COMPONENTS_ALL${CPACK_COMPONENTS_ALL})\n")
+    configure_file(${_cpack_cfg_in} ${PCL_CPACK_CFG_FILE} @ONLY)
+endmacro()
+
+
+macro(PCL_CPACK_MAKE_COMPS_OPTS _var _current)
+    set(_comps_list)
+    set(PCL_CPACK_SUBSYSTEMS ${PCL_SUBSYSTEMS})
+    list(REMOVE_ITEM PCL_CPACK_SUBSYSTEMS global_tests examples)
+    foreach(_ss ${PCL_CPACK_SUBSYSTEMS})
+        PCL_GET_SUBSYS_STATUS(_status ${_ss})
+        if(_status)
+            string(APPEND _comps_list " pcl_${_ss}")
+            PCL_CPACK_ADD_COMP_INFO(${_var} ${_ss})
+        endif()
+    endforeach()
+    set(CPACK_COMPONENTS_ALL ${_comps_list})
+endmacro()
+
+
+macro(PCL_CPACK_ADD_COMP_INFO _var _ss)
+    string(TOUPPER "${_ss}" _comp_name)
+    set(${_var}
+        "${${_var}}set(CPACK_COMPONENT_PCL_${_comp_name}_DISPLAY_NAME \"${_ss}\")\n")
+    GET_IN_MAP(_desc PCL_SUBSYS_DESC ${_ss})
+    set(${_var}
+        "${${_var}}set(CPACK_COMPONENT_PCL_${_comp_name}_DESCRIPTION \"${_desc}\")\n")
+    set(_deps_str)
+    GET_IN_MAP(_deps PCL_SUBSYS_DEPS ${_ss})
+    foreach(_dep ${_deps})
+        string(APPEND _deps_str " pcl_${_dep}")
+    endforeach()
+    set(${_var}
+        "${${_var}}set(CPACK_COMPONENT_PCL_${_comp_name}_DEPENDS ${_deps_str})\n")
+    set(${_var}
+        "${${_var}}set(CPACK_COMPONENT_PCL_${_comp_name}_GROUP \"PCL\")\n")
+endmacro()
+
diff --git a/oneapi/cmake/pcl_options.cmake b/oneapi/cmake/pcl_options.cmake
new file mode 100644
index 000000000..e4ca97785
--- /dev/null
+++ b/oneapi/cmake/pcl_options.cmake
@@ -0,0 +1,113 @@
+# Options for building PCL.
+
+# By default, PCL restricts the dependency search to only shared or only static libraries,
+# depending on whether PCL itself is built as a shared or static library.
+# This restriction is undesirable when a dependency is available
+# only as a shared library while building PCL as a static library, or vice versa.
+# In such cases, the user may prefer to use the found dependency anyway.
+# For example, the user may prefer to build PCL as a static library
+# using a shared OpenGL library provided by the system.
+# This option allows to override the restriction imposed by default.
+option(PCL_ALLOW_BOTH_SHARED_AND_STATIC_DEPENDENCIES, "Do not force PCL dependencies to be all shared or all static." OFF)
+
+# Build shared libraries by default.
+option(PCL_SHARED_LIBS "Build shared libraries." ON)
+if(PCL_SHARED_LIBS)
+  set(PCL_LIB_PREFIX ${CMAKE_SHARED_LIBRARY_PREFIX})
+  set(PCL_LIB_SUFFIX ${CMAKE_SHARED_LIBRARY_SUFFIX})
+  set(PCL_LIB_TYPE "SHARED")
+  if(NOT PCL_ALLOW_BOTH_SHARED_AND_STATIC_DEPENDENCIES)
+    if(WIN32)
+      set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_IMPORT_LIBRARY_SUFFIX})
+    endif()
+  endif()
+else()
+  set(PCL_LIB_PREFIX ${CMAKE_STATIC_LIBRARY_PREFIX})
+  set(PCL_LIB_SUFFIX ${CMAKE_STATIC_LIBRARY_SUFFIX})
+  set(PCL_LIB_TYPE "STATIC")
+  if(NOT PCL_ALLOW_BOTH_SHARED_AND_STATIC_DEPENDENCIES)
+    set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_STATIC_LIBRARY_SUFFIX})
+  endif()
+endif()
+mark_as_advanced(PCL_SHARED_LIBS)
+
+# Build with dynamic linking for Boost (advanced users)
+option(PCL_BUILD_WITH_BOOST_DYNAMIC_LINKING_WIN32 "Build against a dynamically linked Boost on Win32 platforms." OFF)
+mark_as_advanced(PCL_BUILD_WITH_BOOST_DYNAMIC_LINKING_WIN32)
+
+# Build with shared/static linking for FLANN (advanced users)
+set(PCL_FLANN_REQUIRED_TYPE "DONTCARE" CACHE STRING "Select build type to use STATIC or SHARED.")
+set_property(CACHE PCL_FLANN_REQUIRED_TYPE PROPERTY STRINGS DONTCARE SHARED STATIC)
+mark_as_advanced(PCL_FLANN_REQUIRED_TYPE)
+
+# Build with dynamic linking for QHull (advanced users)
+set(PCL_QHULL_REQUIRED_TYPE "DONTCARE" CACHE STRING "Select build type to use STATIC or SHARED.")
+set_property(CACHE PCL_QHULL_REQUIRED_TYPE PROPERTY STRINGS DONTCARE SHARED STATIC)
+mark_as_advanced(PCL_QHULL_REQUIRED_TYPE)
+
+# Precompile for a minimal set of point types instead of all.
+option(PCL_ONLY_CORE_POINT_TYPES "Compile explicitly only for a small subset of point types (e.g., pcl::PointXYZ instead of PCL_XYZ_POINT_TYPES)." OFF)
+mark_as_advanced(PCL_ONLY_CORE_POINT_TYPES)
+
+# Precompile for a minimal set of point types instead of all.
+option(PCL_NO_PRECOMPILE "Do not precompile PCL code for any point types at all." OFF)
+mark_as_advanced(PCL_NO_PRECOMPILE)
+
+# Enable or Disable the check for SSE optimizations
+option(PCL_ENABLE_SSE "Enable or Disable SSE optimizations." ON)
+mark_as_advanced(PCL_ENABLE_SSE)
+
+# Enable or Disable the check for AVX optimizations
+option(PCL_ENABLE_AVX "Enable or Disable AVX optimizations." ON)
+mark_as_advanced(PCL_ENABLE_AVX)
+
+if(UNIX)
+  # Enable or Disable the check for March Native optimizations
+  option(PCL_ENABLE_MARCHNATIVE "Enable or Disable march native optimizations." ON)
+  mark_as_advanced(PCL_ENABLE_MARCHNATIVE)
+else()
+  set(PCL_ENABLE_MARCHNATIVE FALSE)
+endif()
+
+# Allow the user to enable compiler cache
+option(PCL_ENABLE_CCACHE "Enable using compiler cache for compilation" OFF)
+mark_as_advanced(PCL_ENABLE_CCACHE)
+
+# Treat compiler warnings as errors
+option(PCL_WARNINGS_ARE_ERRORS "Treat warnings as errors" OFF)
+mark_as_advanced(PCL_WARNINGS_ARE_ERRORS)
+
+# Display timing information for each compiler instance on screen
+option(CMAKE_TIMING_VERBOSE "Enable the display of timing information for each compiler instance." OFF)
+mark_as_advanced(CMAKE_TIMING_VERBOSE)
+
+# MSVC extra optimization options. Might lead to increasingly larger compile/link times.
+option(CMAKE_MSVC_CODE_LINK_OPTIMIZATION "Enable the /GL and /LTCG code and link optimization options for MSVC. Enabled by default." ON)
+mark_as_advanced(CMAKE_MSVC_CODE_LINK_OPTIMIZATION)
+
+# Project folders
+set_property(GLOBAL PROPERTY USE_FOLDERS ON)
+
+option(BUILD_tools "Useful PCL-based command line tools" ON)
+
+option(WITH_DOCS "Build doxygen documentation" OFF)
+
+# set index size
+set(PCL_INDEX_SIZE -1 CACHE STRING "Set index size. Available options are: 8 16 32 64. A negative value indicates default size (32 for PCL >= 1.12, 8*sizeof(int) i.e., the number of bits in int, otherwise)")
+set_property(CACHE PCL_INDEX_SIZE PROPERTY STRINGS -1 8 16 32 64)
+
+# Set whether indices are signed or unsigned
+set(PCL_INDEX_SIGNED true CACHE BOOL "Set whether indices need to be signed or unsigned. Signed by default.")
+if (PCL_INDEX_SIGNED)
+  set(PCL_INDEX_SIGNED_STR "true")
+else()
+  set (PCL_INDEX_SIGNED_STR "false")
+endif()
+
+# Set whether gpu tests should be run
+# (Used to prevent gpu tests from executing in CI where GPU hardware is unavailable)
+option(PCL_DISABLE_GPU_TESTS "Disable running GPU tests. If disabled, tests will still be built." OFF)
+
+# Set whether visualizations tests should be run
+# (Used to prevent visualizations tests from executing in CI where visualization is unavailable)
+option(PCL_DISABLE_VISUALIZATION_TESTS "Disable running visualizations tests. If disabled, tests will still be built." OFF)
diff --git a/oneapi/cmake/pcl_pclconfig.cmake b/oneapi/cmake/pcl_pclconfig.cmake
new file mode 100644
index 000000000..3f9f13879
--- /dev/null
+++ b/oneapi/cmake/pcl_pclconfig.cmake
@@ -0,0 +1,97 @@
+
+set(PCL_SUBSYSTEMS_MODULES ${PCL_SUBSYSTEMS})
+list(REMOVE_ITEM PCL_SUBSYSTEMS_MODULES tools cuda_apps global_tests proctor examples)
+
+
+file(GLOB PCLCONFIG_FIND_MODULES "${PCL-ONEAPI_SOURCE_DIR}/cmake/Modules/*.cmake")
+list(REMOVE_ITEM PCLCONFIG_FIND_MODULES "${PCL-ONEAPI_SOURCE_DIR}/cmake/Modules/FindGTestSource.cmake")
+install(FILES ${PCLCONFIG_FIND_MODULES} COMPONENT pclconfig DESTINATION ${PCLCONFIG_INSTALL_DIR}/Modules)
+
+set(PCLCONFIG_AVAILABLE_COMPONENTS)
+set(PCLCONFIG_AVAILABLE_COMPONENTS_LIST)
+set(PCLCONFIG_INTERNAL_DEPENDENCIES)
+set(PCLCONFIG_EXTERNAL_DEPENDENCIES)
+set(PCLCONFIG_OPTIONAL_DEPENDENCIES)
+set(PCLCONFIG_SSE_DEFINITIONS "${SSE_DEFINITIONS}")
+set(PCLCONFIG_SSE_COMPILE_OPTIONS ${SSE_FLAGS})
+set(PCLCONFIG_AVX_COMPILE_OPTIONS ${AVX_FLAGS})
+
+foreach(_ss ${PCL_SUBSYSTEMS_MODULES})
+  PCL_GET_SUBSYS_STATUS(_status ${_ss})
+
+  # do not include test targets
+  string(REGEX MATCH "^tests_" _is_test ${_ss})
+
+  if(_status AND NOT _is_test)
+    string(APPEND PCLCONFIG_AVAILABLE_COMPONENTS " ${_ss}")
+    string(APPEND PCLCONFIG_AVAILABLE_COMPONENTS_LIST "\n# - ${_ss}")
+    GET_IN_MAP(_deps PCL_SUBSYS_DEPS ${_ss})
+    if(_deps)
+      string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES "set(pcl_${_ss}_int_dep ")
+      foreach(_dep ${_deps})
+        string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES "${_dep} ")
+      endforeach()
+      string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES ")\n")
+    endif()
+    GET_IN_MAP(_ext_deps PCL_SUBSYS_EXT_DEPS ${_ss})
+    if(_ext_deps)
+      string(APPEND PCLCONFIG_EXTERNAL_DEPENDENCIES "set(pcl_${_ss}_ext_dep ")
+      foreach(_ext_dep ${_ext_deps})
+        string(APPEND PCLCONFIG_EXTERNAL_DEPENDENCIES "${_ext_dep} ")
+      endforeach()
+      string(APPEND PCLCONFIG_EXTERNAL_DEPENDENCIES ")\n")
+    endif()
+    GET_IN_MAP(_opt_deps PCL_SUBSYS_OPT_DEPS ${_ss})
+    if(_opt_deps)
+      string(APPEND PCLCONFIG_OPTIONAL_DEPENDENCIES "set(pcl_${_ss}_opt_dep ")
+      foreach(_opt_dep ${_opt_deps})
+        string(TOUPPER "WITH_${_opt_dep}" _tmp)
+        string(REGEX REPLACE "-(.*)" "" _condition ${_tmp}) #libusb-1.0 case
+        if(${_condition})
+          string(APPEND PCLCONFIG_OPTIONAL_DEPENDENCIES "${_opt_dep} ")
+        endif()
+      endforeach()
+      string(APPEND PCLCONFIG_OPTIONAL_DEPENDENCIES ")\n")
+    endif()
+
+    #look for subsystems
+    string(TOUPPER "PCL_${_ss}_SUBSYS" PCL_SUBSYS_SUBSYS)
+    if(${PCL_SUBSYS_SUBSYS})
+      string(TOUPPER "PCL_${_ss}_SUBSYS_STATUS" PCL_SUBSYS_SUBSYS_STATUS)
+      foreach(_sub ${${PCL_SUBSYS_SUBSYS}})
+        PCL_GET_SUBSUBSYS_STATUS(_sub_status ${_ss} ${_sub})
+        if(_sub_status)
+          string(APPEND PCLCONFIG_AVAILABLE_COMPONENTS " ${_sub}")
+          string(APPEND PCLCONFIG_AVAILABLE_COMPONENTS_LIST "\n# - ${_sub}")
+          GET_IN_MAP(_deps PCL_SUBSYS_DEPS ${_ss}_${sub})
+          if(_deps)
+            string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES "set(pcl_${_sub}_int_dep ")
+            foreach(_dep ${_deps})
+              string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES "${_dep} ")
+            endforeach()
+            string(APPEND PCLCONFIG_INTERNAL_DEPENDENCIES ")\n")
+          endif()
+        endif()
+      endforeach()
+    endif()
+  endif()
+endforeach()
+
+#Boost modules
+set(PCLCONFIG_AVAILABLE_BOOST_MODULES "system filesystem date_time iostreams")
+if(Boost_SERIALIZATION_FOUND)
+  string(APPEND PCLCONFIG_AVAILABLE_BOOST_MODULES " serialization")
+endif()
+if(Boost_CHRONO_FOUND)
+  string(APPEND PCLCONFIG_AVAILABLE_BOOST_MODULES " chrono")
+endif()
+
+configure_file("${PCL-ONEAPI_SOURCE_DIR}/PCL-ONEAPIConfig.cmake.in"
+               "${PCL-ONEAPI_BINARY_DIR}/PCL-ONEAPIConfig.cmake" @ONLY)
+configure_file("${PCL-ONEAPI_SOURCE_DIR}/PCL-ONEAPIConfigVersion.cmake.in"
+               "${PCL-ONEAPI_BINARY_DIR}/PCL-ONEAPIConfigVersion.cmake" @ONLY)
+install(FILES
+        "${PCL-ONEAPI_BINARY_DIR}/PCL-ONEAPIConfig.cmake"
+        "${PCL-ONEAPI_BINARY_DIR}/PCL-ONEAPIConfigVersion.cmake"
+        COMPONENT pclconfig
+        DESTINATION ${PCLCONFIG_INSTALL_DIR})
\ No newline at end of file
diff --git a/oneapi/cmake/pcl_targets.cmake b/oneapi/cmake/pcl_targets.cmake
new file mode 100644
index 000000000..d9d5593d3
--- /dev/null
+++ b/oneapi/cmake/pcl_targets.cmake
@@ -0,0 +1,908 @@
+include(${PROJECT_SOURCE_DIR}/cmake/pcl_utils.cmake)
+
+# Store location of current dir, because value of CMAKE_CURRENT_LIST_DIR is
+# set to the directory where a function is used, not where a function is defined
+set(_PCL_TARGET_CMAKE_DIR ${CMAKE_CURRENT_LIST_DIR})
+
+###############################################################################
+# Add an option to build a subsystem or not.
+# _var The name of the variable to store the option in.
+# _name The name of the option's target subsystem.
+# _desc The description of the subsystem.
+# _default The default value (TRUE or FALSE)
+# ARGV5 The reason for disabling if the default is FALSE.
+macro(PCL_SUBSYS_OPTION _var _name _desc _default)
+  set(_opt_name "BUILD_${_name}")
+  PCL_GET_SUBSYS_HYPERSTATUS(subsys_status ${_name})
+  if(NOT ("${subsys_status}" STREQUAL "AUTO_OFF"))
+    option(${_opt_name} ${_desc} ${_default})
+    if((NOT ${_default} AND NOT ${_opt_name}) OR ("${_default}" STREQUAL "AUTO_OFF"))
+      set(${_var} FALSE)
+      if(${ARGC} GREATER 4)
+        set(_reason ${ARGV4})
+      else()
+        set(_reason "Disabled by default.")
+      endif()
+      PCL_SET_SUBSYS_STATUS(${_name} FALSE ${_reason})
+      PCL_DISABLE_DEPENDIES(${_name})
+    elseif(NOT ${_opt_name})
+      set(${_var} FALSE)
+      PCL_SET_SUBSYS_STATUS(${_name} FALSE "Disabled manually.")
+      PCL_DISABLE_DEPENDIES(${_name})
+    else()
+      set(${_var} TRUE)
+      PCL_SET_SUBSYS_STATUS(${_name} TRUE)
+      PCL_ENABLE_DEPENDIES(${_name})
+    endif()
+  endif()
+  PCL_ADD_SUBSYSTEM(${_name} ${_desc})
+endmacro()
+
+###############################################################################
+# Add an option to build a subsystem or not.
+# _var The name of the variable to store the option in.
+# _parent The name of the parent subsystem
+# _name The name of the option's target subsubsystem.
+# _desc The description of the subsubsystem.
+# _default The default value (TRUE or FALSE)
+# ARGV5 The reason for disabling if the default is FALSE.
+macro(PCL_SUBSUBSYS_OPTION _var _parent _name _desc _default)
+  set(_opt_name "BUILD_${_parent}_${_name}")
+  PCL_GET_SUBSYS_HYPERSTATUS(parent_status ${_parent})
+  if(NOT ("${parent_status}" STREQUAL "AUTO_OFF") AND NOT ("${parent_status}" STREQUAL "OFF"))
+    PCL_GET_SUBSYS_HYPERSTATUS(subsys_status ${_parent}_${_name})
+    if(NOT ("${subsys_status}" STREQUAL "AUTO_OFF"))
+      option(${_opt_name} ${_desc} ${_default})
+      if((NOT ${_default} AND NOT ${_opt_name}) OR ("${_default}" STREQUAL "AUTO_OFF"))
+        set(${_var} FALSE)
+        if(${ARGC} GREATER 5)
+          set(_reason ${ARGV5})
+        else()
+          set(_reason "Disabled by default.")
+        endif()
+        PCL_SET_SUBSYS_STATUS(${_parent}_${_name} FALSE ${_reason})
+        PCL_DISABLE_DEPENDIES(${_parent}_${_name})
+      elseif(NOT ${_opt_name})
+        set(${_var} FALSE)
+        PCL_SET_SUBSYS_STATUS(${_parent}_${_name} FALSE "Disabled manually.")
+        PCL_DISABLE_DEPENDIES(${_parent}_${_name})
+      else()
+        set(${_var} TRUE)
+        PCL_SET_SUBSYS_STATUS(${_parent}_${_name} TRUE)
+        PCL_ENABLE_DEPENDIES(${_parent}_${_name})
+      endif()
+    endif()
+  endif()
+  PCL_ADD_SUBSUBSYSTEM(${_parent} ${_name} ${_desc})
+endmacro()
+
+###############################################################################
+# Make one subsystem depend on one or more other subsystems, and disable it if
+# they are not being built.
+# _var The cumulative build variable. This will be set to FALSE if the
+#   dependencies are not met.
+# _name The name of the subsystem.
+# ARGN The subsystems and external libraries to depend on.
+macro(PCL_SUBSYS_DEPEND _var _name)
+  set(options)
+  set(oneValueArgs)
+  set(multiValueArgs DEPS EXT_DEPS OPT_DEPS)
+  cmake_parse_arguments(SUBSYS "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+  if(SUBSYS_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_DEPS ${_name} "${SUBSYS_DEPS}")
+  endif()
+  if(SUBSYS_EXT_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_EXT_DEPS ${_name} "${SUBSYS_EXT_DEPS}")
+  endif()
+  if(SUBSYS_OPT_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_OPT_DEPS ${_name} "${SUBSYS_OPT_DEPS}")
+  endif()
+  GET_IN_MAP(subsys_status PCL_SUBSYS_HYPERSTATUS ${_name})
+  if(${_var} AND (NOT ("${subsys_status}" STREQUAL "AUTO_OFF")))
+    if(SUBSYS_DEPS)
+      foreach(_dep ${SUBSYS_DEPS})
+        PCL_GET_SUBSYS_STATUS(_status ${_dep})
+        string(TOUPPER "PCL_${_dep}_found" EXT_DEP_FOUND)
+        # If the dependency module is not built and not found externally, mark
+        # "build" (${_var}) as FALSE.
+        if(NOT _status AND NOT ${${EXT_DEP_FOUND}})
+          set(${_var} FALSE)
+          PCL_SET_SUBSYS_STATUS(${_name} FALSE "Requires ${_dep}.")
+        else()
+          PCL_GET_SUBSYS_INCLUDE_DIR(_include_dir ${_dep})
+          include_directories(${PROJECT_SOURCE_DIR}/${_include_dir}/include)
+        endif()
+      endforeach()
+    endif()
+    if(SUBSYS_EXT_DEPS)
+      foreach(_dep ${SUBSYS_EXT_DEPS})
+        string(TOUPPER "${_dep}_found" EXT_DEP_FOUND)
+        #Variable EXT_DEP_FOUND expands to ie. QHULL_FOUND which in turn is then used to see if the EXT_DEPS is found.
+        if(NOT ${EXT_DEP_FOUND})
+          set(${_var} FALSE)
+          PCL_SET_SUBSYS_STATUS(${_name} FALSE "Requires external library ${_dep}.")
+        endif()
+      endforeach()
+    endif()
+    if(SUBSYS_OPT_DEPS)
+      foreach(_dep ${SUBSYS_OPT_DEPS})
+        PCL_GET_SUBSYS_INCLUDE_DIR(_include_dir ${_dep})
+        include_directories(${PROJECT_SOURCE_DIR}/${_include_dir}/include)
+      endforeach()
+    endif()
+  endif()
+endmacro()
+
+###############################################################################
+# Make one subsystem depend on one or more other subsystems, and disable it if
+# they are not being built.
+# _var The cumulative build variable. This will be set to FALSE if the
+#   dependencies are not met.
+# _parent The parent subsystem name.
+# _name The name of the subsubsystem.
+# ARGN The subsystems and external libraries to depend on.
+macro(PCL_SUBSUBSYS_DEPEND _var _parent _name)
+  set(options)
+  set(parentArg)
+  set(nameArg)
+  set(multiValueArgs DEPS EXT_DEPS OPT_DEPS)
+  cmake_parse_arguments(SUBSYS "${options}" "${parentArg}" "${nameArg}" "${multiValueArgs}" ${ARGN})
+  if(SUBSUBSYS_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_DEPS ${_parent}_${_name} "${SUBSUBSYS_DEPS}")
+  endif()
+  if(SUBSUBSYS_EXT_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_EXT_DEPS ${_parent}_${_name} "${SUBSUBSYS_EXT_DEPS}")
+  endif()
+  if(SUBSUBSYS_OPT_DEPS)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_OPT_DEPS ${_parent}_${_name} "${SUBSUBSYS_OPT_DEPS}")
+  endif()
+  GET_IN_MAP(subsys_status PCL_SUBSYS_HYPERSTATUS ${_parent}_${_name})
+  if(${_var} AND (NOT ("${subsys_status}" STREQUAL "AUTO_OFF")))
+    if(SUBSUBSYS_DEPS)
+      foreach(_dep ${SUBSUBSYS_DEPS})
+        PCL_GET_SUBSYS_STATUS(_status ${_dep})
+        if(NOT _status)
+          set(${_var} FALSE)
+          PCL_SET_SUBSYS_STATUS(${_parent}_${_name} FALSE "Requires ${_dep}.")
+        else()
+          PCL_GET_SUBSYS_INCLUDE_DIR(_include_dir ${_dep})
+          include_directories(${PROJECT_SOURCE_DIR}/${_include_dir}/include)
+        endif()
+      endforeach()
+    endif()
+    if(SUBSUBSYS_EXT_DEPS)
+      foreach(_dep ${SUBSUBSYS_EXT_DEPS})
+        string(TOUPPER "${_dep}_found" EXT_DEP_FOUND)
+        if(NOT ${EXT_DEP_FOUND})
+          set(${_var} FALSE)
+          PCL_SET_SUBSYS_STATUS(${_parent}_${_name} FALSE "Requires external library ${_dep}.")
+        endif()
+      endforeach()
+    endif()
+  endif()
+endmacro()
+
+###############################################################################
+# Adds version information to executable/library in form of a version.rc. This works only with MSVC.
+#
+# _name The library name.
+##
+function(PCL_ADD_VERSION_INFO _name)
+  if(MSVC)
+    string(REPLACE "." "," VERSION_INFO_VERSION_WITH_COMMA ${PCL_VERSION})
+    if (SUBSUBSYS_DESC)
+      set(VERSION_INFO_DISPLAY_NAME ${SUBSUBSYS_DESC})
+    else()
+      set(VERSION_INFO_DISPLAY_NAME ${SUBSYS_DESC})
+    endif()
+    get_filename_component(SECOND_FOLDER_ABSOLUTE ${PROJECT_SOURCE_DIR} DIRECTORY)
+    set(VERSION_INFO_ICON_PATH "${SECOND_FOLDER_ABSOLUTE}/cmake/images/pcl.ico")
+    configure_file(${_PCL_TARGET_CMAKE_DIR}/version.rc.in ${PROJECT_BINARY_DIR}/${_name}_version.rc @ONLY)
+    target_sources(${_name} PRIVATE ${PROJECT_BINARY_DIR}/${_name}_version.rc)
+  endif()
+endfunction()
+
+###############################################################################
+# Add a set of include files to install.
+# _component The part of PCL that the install files belong to.
+# _subdir The sub-directory for these include files.
+# ARGN The include files.
+macro(PCL_ADD_INCLUDES _component _subdir)
+  install(FILES ${ARGN}
+          DESTINATION ${INCLUDE_INSTALL_DIR}/${_subdir}
+          COMPONENT pcl_${_component})
+endmacro()
+
+###############################################################################
+# Add a library target.
+# _name The library name.
+# COMPONENT The part of PCL that this library belongs to.
+# SOURCES The source files for the library.
+function(PCL_ADD_LIBRARY _name)
+  set(options)
+  set(oneValueArgs COMPONENT)
+  set(multiValueArgs SOURCES)
+  cmake_parse_arguments(ADD_LIBRARY_OPTION "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  add_library(${_name} ${PCL_LIB_TYPE} ${ADD_LIBRARY_OPTION_SOURCES})
+  PCL_ADD_VERSION_INFO(${_name})
+  target_compile_features(${_name} PUBLIC ${PCL_CXX_COMPILE_FEATURES})
+
+  target_link_libraries(${_name} Threads::Threads)
+  if(TARGET OpenMP::OpenMP_CXX)
+    target_link_libraries(${_name} OpenMP::OpenMP_CXX)
+  endif()
+
+  if((UNIX AND NOT ANDROID) OR MINGW)
+    target_link_libraries(${_name} m)
+  endif()
+
+  if(MINGW)
+    target_link_libraries(${_name} gomp)
+  endif()
+
+  if(MSVC)
+    target_link_libraries(${_name} delayimp.lib)  # because delay load is enabled for openmp.dll
+  endif()
+
+  set_target_properties(${_name} PROPERTIES
+    VERSION ${PCL_VERSION}
+    SOVERSION ${PCL_VERSION_MAJOR}.${PCL_VERSION_MINOR}
+    DEFINE_SYMBOL "PCLAPI_EXPORTS")
+  set_target_properties(${_name} PROPERTIES FOLDER "Libraries")
+  
+  if (WIN32)
+  set_target_properties(${_name} PROPERTIES VS_PLATFORM_TOOLSET ${INTEL_DPCPP_COMPILER})
+  endif()
+  install(TARGETS ${_name}
+          RUNTIME DESTINATION ${BIN_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT}
+          LIBRARY DESTINATION ${LIB_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT}
+          ARCHIVE DESTINATION ${LIB_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT})
+
+  # Copy PDB if available
+  if(MSVC AND OFF)
+    install(FILES $<TARGET_PDB_FILE:${_name}> DESTINATION ${BIN_INSTALL_DIR} OPTIONAL)
+  endif()
+endfunction()
+
+###############################################################################
+# Add a cuda library target.
+# _name The library name.
+# COMPONENT The part of PCL that this library belongs to.
+# SOURCES The source files for the library.
+function(PCL_CUDA_ADD_LIBRARY _name)
+  set(options)
+  set(oneValueArgs COMPONENT)
+  set(multiValueArgs SOURCES)
+  cmake_parse_arguments(ADD_LIBRARY_OPTION "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  REMOVE_VTK_DEFINITIONS()
+
+  add_library(${_name} ${PCL_LIB_TYPE} ${ADD_LIBRARY_OPTION_SOURCES})
+
+  PCL_ADD_VERSION_INFO(${_name})
+
+  target_compile_options(${_name} PRIVATE $<$<COMPILE_LANGUAGE:CUDA>: ${GEN_CODE} --expt-relaxed-constexpr>)
+
+  target_include_directories(${_name} PRIVATE ${CUDA_TOOLKIT_INCLUDE})
+
+  set_target_properties(${_name} PROPERTIES
+    VERSION ${PCL_VERSION}
+    SOVERSION ${PCL_VERSION_MAJOR}
+    DEFINE_SYMBOL "PCLAPI_EXPORTS")
+  set_target_properties(${_name} PROPERTIES FOLDER "Libraries")
+
+  install(TARGETS ${_name}
+          RUNTIME DESTINATION ${BIN_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT}
+          LIBRARY DESTINATION ${LIB_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT}
+          ARCHIVE DESTINATION ${LIB_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT})
+endfunction()
+
+###############################################################################
+# Add an executable target.
+# _name The executable name.
+# BUNDLE Target should be handled as bundle (APPLE and VTK_USE_COCOA only)
+# COMPONENT The part of PCL that this library belongs to.
+# SOURCES The source files for the library.
+function(PCL_ADD_EXECUTABLE _name)
+  set(options BUNDLE)
+  set(oneValueArgs COMPONENT)
+  set(multiValueArgs SOURCES)
+  cmake_parse_arguments(ADD_LIBRARY_OPTION "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  if(ADD_LIBRARY_OPTION_BUNDLE AND APPLE AND VTK_USE_COCOA)
+    add_executable(${_name} MACOSX_BUNDLE ${ADD_LIBRARY_OPTION_SOURCES})
+  else()
+    add_executable(${_name} ${ADD_LIBRARY_OPTION_SOURCES})
+  endif()
+  PCL_ADD_VERSION_INFO(${_name})
+  
+  target_link_libraries(${_name} Threads::Threads)
+
+  if(WIN32 AND MSVC)
+    set_target_properties(${_name} PROPERTIES DEBUG_OUTPUT_NAME ${_name}${CMAKE_DEBUG_POSTFIX}
+                                              RELEASE_OUTPUT_NAME ${_name}${CMAKE_RELEASE_POSTFIX})
+  endif()
+
+  # Some app targets report are defined with subsys other than apps
+  # It's simpler check for tools and assume everythin else as an app
+  if(${ADD_LIBRARY_OPTION_COMPONENT} STREQUAL "tools")
+    set_target_properties(${_name} PROPERTIES FOLDER "Tools")
+  else()
+    set_target_properties(${_name} PROPERTIES FOLDER "Apps")
+  endif()
+
+  set(PCL_EXECUTABLES ${PCL_EXECUTABLES} ${_name})
+
+  if(ADD_LIBRARY_OPTION_BUNDLE AND APPLE AND VTK_USE_COCOA)
+    install(TARGETS ${_name} BUNDLE DESTINATION ${BIN_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT})
+  else()
+    install(TARGETS ${_name} RUNTIME DESTINATION ${BIN_INSTALL_DIR} COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT})
+  endif()
+
+  string(TOUPPER ${ADD_LIBRARY_OPTION_COMPONENT} _component_upper)
+  set(PCL_${_component_upper}_ALL_TARGETS ${PCL_${_component_upper}_ALL_TARGETS} ${_name} PARENT_SCOPE)
+endfunction()
+
+###############################################################################
+# Add an executable target.
+# _name The executable name.
+# COMPONENT The part of PCL that this library belongs to.
+# SOURCES The source files for the library.
+function(PCL_CUDA_ADD_EXECUTABLE _name)
+  set(options)
+  set(oneValueArgs COMPONENT)
+  set(multiValueArgs SOURCES)
+  cmake_parse_arguments(ADD_LIBRARY_OPTION "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  REMOVE_VTK_DEFINITIONS()
+  
+  add_executable(${_name} ${ADD_LIBRARY_OPTION_SOURCES})
+  
+  PCL_ADD_VERSION_INFO(${_name})
+
+  target_compile_options(${_name} PRIVATE $<$<COMPILE_LANGUAGE:CUDA>: ${GEN_CODE} --expt-relaxed-constexpr>)
+  
+  target_include_directories(${_name} PRIVATE ${CUDA_TOOLKIT_INCLUDE})
+
+  if(WIN32 AND MSVC)
+    set_target_properties(${_name} PROPERTIES DEBUG_OUTPUT_NAME ${_name}${CMAKE_DEBUG_POSTFIX}
+                                              RELEASE_OUTPUT_NAME ${_name}${CMAKE_RELEASE_POSTFIX})
+  endif()
+
+  # There's a single app.
+  set_target_properties(${_name} PROPERTIES FOLDER "Apps")
+
+  set(PCL_EXECUTABLES ${PCL_EXECUTABLES} ${_name})
+  install(TARGETS ${_name} RUNTIME DESTINATION ${BIN_INSTALL_DIR}
+          COMPONENT pcl_${ADD_LIBRARY_OPTION_COMPONENT})
+endfunction()
+
+###############################################################################
+# Add a test target.
+# _name The test name.
+# _exename The exe name.
+# ARGN :
+#    FILES the source files for the test
+#    ARGUMENTS Arguments for test executable
+#    LINK_WITH link test executable with libraries
+macro(PCL_ADD_TEST _name _exename)
+  set(options)
+  set(oneValueArgs)
+  set(multiValueArgs FILES ARGUMENTS LINK_WITH)
+  cmake_parse_arguments(PCL_ADD_TEST "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+  add_executable(${_exename} ${PCL_ADD_TEST_FILES})
+  if(NOT WIN32)
+    set_target_properties(${_exename} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+  endif()
+  #target_link_libraries(${_exename} ${GTEST_BOTH_LIBRARIES} ${PCL_ADD_TEST_LINK_WITH})
+  target_link_libraries(${_exename} ${PCL_ADD_TEST_LINK_WITH} ${CLANG_LIBRARIES})
+
+  target_link_libraries(${_exename} Threads::Threads)
+
+  #Only applies to MSVC
+  if(MSVC)
+    #Requires CMAKE version 3.13.0
+    if(CMAKE_VERSION VERSION_LESS "3.13.0" AND (NOT ArgumentWarningShown))
+      message(WARNING "Arguments for unit test projects are not added - this requires at least CMake 3.13. Can be added manually in \"Project settings -> Debugging -> Command arguments\"")
+      SET (ArgumentWarningShown TRUE PARENT_SCOPE)
+    else()
+      #Only add if there are arguments to test
+      if(PCL_ADD_TEST_ARGUMENTS)
+        string (REPLACE ";" " " PCL_ADD_TEST_ARGUMENTS_STR "${PCL_ADD_TEST_ARGUMENTS}")
+        set_target_properties(${_exename} PROPERTIES VS_DEBUGGER_COMMAND_ARGUMENTS ${PCL_ADD_TEST_ARGUMENTS_STR})
+      endif()
+    endif()
+  endif()
+
+  set_target_properties(${_exename} PROPERTIES FOLDER "Tests")
+  add_test(NAME ${_name} COMMAND ${_exename} ${PCL_ADD_TEST_ARGUMENTS})
+
+  add_dependencies(tests ${_exename})
+endmacro()
+
+###############################################################################
+# Add a benchmark target.
+# _name The benchmark name.
+# ARGN :
+#    FILES the source files for the benchmark
+#    ARGUMENTS Arguments for benchmark executable
+#    LINK_WITH link benchmark executable with libraries
+function(PCL_ADD_BENCHMARK _name)
+  set(options)
+  set(oneValueArgs)
+  set(multiValueArgs FILES ARGUMENTS LINK_WITH)
+  cmake_parse_arguments(PCL_ADD_BENCHMARK "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  add_executable(benchmark_${_name} ${PCL_ADD_BENCHMARK_FILES})
+  set_target_properties(benchmark_${_name} PROPERTIES FOLDER "Benchmarks")
+  target_link_libraries(benchmark_${_name} benchmark::benchmark ${PCL_ADD_BENCHMARK_LINK_WITH})
+  set_target_properties(benchmark_${_name} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+  
+  #Only applies to MSVC
+  if(MSVC)
+    #Requires CMAKE version 3.13.0
+    get_target_property(BenchmarkArgumentWarningShown run_benchmarks PCL_BENCHMARK_ARGUMENTS_WARNING_SHOWN)
+    if(CMAKE_VERSION VERSION_LESS "3.13.0" AND (NOT BenchmarkArgumentWarningShown))
+      message(WARNING "Arguments for benchmark projects are not added - this requires at least CMake 3.13. Can be added manually in \"Project settings -> Debugging -> Command arguments\"")
+      set_target_properties(run_benchmarks PROPERTIES PCL_BENCHMARK_ARGUMENTS_WARNING_SHOWN TRUE)
+    else()
+      #Only add if there are arguments to test
+      if(PCL_ADD_BENCHMARK_ARGUMENTS)
+        string (REPLACE ";" " " PCL_ADD_BENCHMARK_ARGUMENTS_STR "${PCL_ADD_BENCHMARK_ARGUMENTS}")
+        set_target_properties(benchmark_${_name} PROPERTIES VS_DEBUGGER_COMMAND_ARGUMENTS ${PCL_ADD_BENCHMARK_ARGUMENTS_STR})
+      endif()
+    endif()
+  endif()
+  
+  add_custom_target(run_benchmark_${_name} benchmark_${_name} ${PCL_ADD_BENCHMARK_ARGUMENTS})
+  set_target_properties(run_benchmark_${_name} PROPERTIES FOLDER "Benchmarks")
+  
+  add_dependencies(run_benchmarks run_benchmark_${_name})
+endfunction()
+
+###############################################################################
+# Add an example target.
+# _name The example name.
+# ARGN :
+#    FILES the source files for the example
+#    LINK_WITH link example executable with libraries
+macro(PCL_ADD_EXAMPLE _name)
+  set(options)
+  set(oneValueArgs)
+  set(multiValueArgs FILES LINK_WITH)
+  cmake_parse_arguments(PCL_ADD_EXAMPLE "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+  add_executable(${_name} ${PCL_ADD_EXAMPLE_FILES})
+  target_link_libraries(${_name} ${PCL_ADD_EXAMPLE_LINK_WITH} ${CLANG_LIBRARIES})
+  if(WIN32 AND MSVC)
+    set_target_properties(${_name} PROPERTIES DEBUG_OUTPUT_NAME ${_name}${CMAKE_DEBUG_POSTFIX}
+                                              RELEASE_OUTPUT_NAME ${_name}${CMAKE_RELEASE_POSTFIX})
+  endif()
+  set_target_properties(${_name} PROPERTIES FOLDER "Examples")
+
+  # add target to list of example targets created at the parent scope
+  list(APPEND PCL_EXAMPLES_ALL_TARGETS ${_name})
+  set(PCL_EXAMPLES_ALL_TARGETS "${PCL_EXAMPLES_ALL_TARGETS}" PARENT_SCOPE)
+endmacro()
+
+###############################################################################
+# Add compile flags to a target (because CMake doesn't provide something so
+# common itself).
+# _name The target name.
+# _flags The new compile flags to be added, as a string.
+macro(PCL_ADD_CFLAGS _name _flags)
+  get_target_property(_current_flags ${_name} COMPILE_FLAGS)
+  if(NOT _current_flags)
+    set_target_properties(${_name} PROPERTIES COMPILE_FLAGS ${_flags})
+  else()
+    set_target_properties(${_name} PROPERTIES COMPILE_FLAGS "${_current_flags} ${_flags}")
+  endif()
+endmacro()
+
+###############################################################################
+# Add link flags to a target (because CMake doesn't provide something so
+# common itself).
+# _name The target name.
+# _flags The new link flags to be added, as a string.
+macro(PCL_ADD_LINKFLAGS _name _flags)
+  get_target_property(_current_flags ${_name} LINK_FLAGS)
+  if(NOT _current_flags)
+      set_target_properties(${_name} PROPERTIES LINK_FLAGS ${_flags})
+  else()
+      set_target_properties(${_name} PROPERTIES LINK_FLAGS "${_current_flags} ${_flags}")
+  endif()
+endmacro()
+
+###############################################################################
+# Make a pkg-config file for a library. Do not include general PCL stuff in the
+# arguments; they will be added automatically.
+# _name The library name. Please prepend "pcl_" to ensure no conflicts in user systems
+# COMPONENT The part of PCL that this pkg-config file belongs to.
+# DESC Description of the library.
+# PCL_DEPS External dependencies to pcl libs, as a list. (will get mangled to external pkg-config name)
+# EXT_DEPS External dependencies, as a list.
+# INT_DEPS Internal dependencies, as a list.
+# CFLAGS Compiler flags necessary to build with the library.
+# LIB_FLAGS Linker flags necessary to link to the library.
+# HEADER_ONLY Ensures that no -L or l flags will be created.
+function(PCL_MAKE_PKGCONFIG _name)
+  set(options HEADER_ONLY)
+  set(oneValueArgs COMPONENT DESC CFLAGS LIB_FLAGS)
+  set(multiValueArgs PCL_DEPS INT_DEPS EXT_DEPS)
+  cmake_parse_arguments(PKGCONFIG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})
+
+  set(PKG_NAME ${_name})
+  set(PKG_DESC ${PKGCONFIG_DESC})
+  set(PKG_CFLAGS ${PKGCONFIG_CFLAGS})
+  set(PKG_LIBFLAGS ${PKGCONFIG_LIB_FLAGS})
+  LIST_TO_STRING(PKG_EXTERNAL_DEPS "${PKGCONFIG_EXT_DEPS}")
+  foreach(_dep ${PKGCONFIG_PCL_DEPS})
+    string(APPEND PKG_EXTERNAL_DEPS " pcl_${_dep}-${PCL_VERSION_MAJOR}.${PCL_VERSION_MINOR}")
+  endforeach()
+  set(PKG_INTERNAL_DEPS "")
+  foreach(_dep ${PKGCONFIG_INT_DEPS})
+    string(APPEND PKG_INTERNAL_DEPS " -l${_dep}")
+  endforeach()
+
+  set(_pc_file ${CMAKE_CURRENT_BINARY_DIR}/${_name}-${PCL_VERSION_MAJOR}.${PCL_VERSION_MINOR}.pc)
+  if(PKGCONFIG_HEADER_ONLY)
+    configure_file(${PROJECT_SOURCE_DIR}/cmake/pkgconfig-headeronly.cmake.in ${_pc_file} @ONLY)
+  else()
+    configure_file(${PROJECT_SOURCE_DIR}/cmake/pkgconfig.cmake.in ${_pc_file} @ONLY)
+  endif()
+  install(FILES ${_pc_file}
+          DESTINATION ${PKGCFG_INSTALL_DIR}
+          COMPONENT pcl_${PKGCONFIG_COMPONENT})
+endfunction()
+
+###############################################################################
+# PRIVATE
+
+###############################################################################
+# Reset the subsystem status map.
+macro(PCL_RESET_MAPS)
+  foreach(_ss ${PCL_SUBSYSTEMS})
+    string(TOUPPER "PCL_${_ss}_SUBSYS" PCL_SUBSYS_SUBSYS)
+    if(${PCL_SUBSYS_SUBSYS})
+      string(TOUPPER "PCL_${_ss}_SUBSYS_DESC" PCL_PARENT_SUBSYS_DESC)
+      set(${PCL_SUBSYS_SUBSYS_DESC} "" CACHE INTERNAL "" FORCE)
+      set(${PCL_SUBSYS_SUBSYS} "" CACHE INTERNAL "" FORCE)
+    endif()
+  endforeach()
+
+  set(PCL_SUBSYS_HYPERSTATUS "" CACHE INTERNAL "To Build Or Not To Build, That Is The Question." FORCE)
+  set(PCL_SUBSYS_STATUS "" CACHE INTERNAL "To build or not to build, that is the question." FORCE)
+  set(PCL_SUBSYS_REASONS "" CACHE INTERNAL "But why?" FORCE)
+  set(PCL_SUBSYS_DEPS "" CACHE INTERNAL "A depends on B and C." FORCE)
+  set(PCL_SUBSYS_EXT_DEPS "" CACHE INTERNAL "A depends on B and C." FORCE)
+  set(PCL_SUBSYS_OPT_DEPS "" CACHE INTERNAL "A depends on B and C." FORCE)
+  set(PCL_SUBSYSTEMS "" CACHE INTERNAL "Internal list of subsystems" FORCE)
+  set(PCL_SUBSYS_DESC "" CACHE INTERNAL "Subsystem descriptions" FORCE)
+endmacro()
+
+###############################################################################
+# Register a subsystem.
+# _name Subsystem name.
+# _desc Description of the subsystem
+macro(PCL_ADD_SUBSYSTEM _name _desc)
+  set(_temp ${PCL_SUBSYSTEMS})
+  list(APPEND _temp ${_name})
+  set(PCL_SUBSYSTEMS ${_temp} CACHE INTERNAL "Internal list of subsystems" FORCE)
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_DESC ${_name} ${_desc})
+endmacro()
+
+###############################################################################
+# Register a subsubsystem.
+# _name Subsystem name.
+# _desc Description of the subsystem
+macro(PCL_ADD_SUBSUBSYSTEM _parent _name _desc)
+  string(TOUPPER "PCL_${_parent}_SUBSYS" PCL_PARENT_SUBSYS)
+  string(TOUPPER "PCL_${_parent}_SUBSYS_DESC" PCL_PARENT_SUBSYS_DESC)
+  set(_temp ${${PCL_PARENT_SUBSYS}})
+  list(APPEND _temp ${_name})
+  set(${PCL_PARENT_SUBSYS} ${_temp} CACHE INTERNAL "Internal list of ${_parenr} subsystems" FORCE)
+  set_in_global_map(${PCL_PARENT_SUBSYS_DESC} ${_name} ${_desc})
+endmacro()
+
+###############################################################################
+# Set the status of a subsystem.
+# _name Subsystem name.
+# _status TRUE if being built, FALSE otherwise.
+# ARGN[0] Reason for not building.
+macro(PCL_SET_SUBSYS_STATUS _name _status)
+  if(${ARGC} EQUAL 3)
+    set(_reason ${ARGV2})
+  else()
+    set(_reason "No reason provided")
+  endif()
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_STATUS ${_name} ${_status})
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_REASONS ${_name} ${_reason})
+endmacro()
+
+###############################################################################
+# Set the status of a subsystem.
+# _name Subsystem name.
+# _status TRUE if being built, FALSE otherwise.
+# ARGN[0] Reason for not building.
+macro(PCL_SET_SUBSUBSYS_STATUS _parent _name _status)
+  if(${ARGC} EQUAL 4)
+    set(_reason ${ARGV2})
+  else()
+    set(_reason "No reason provided")
+  endif()
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_STATUS ${_parent}_${_name} ${_status})
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_REASONS ${_parent}_${_name} ${_reason})
+endmacro()
+
+###############################################################################
+# Get the status of a subsystem
+# _var Destination variable.
+# _name Name of the subsystem.
+macro(PCL_GET_SUBSYS_STATUS _var _name)
+  GET_IN_MAP(${_var} PCL_SUBSYS_STATUS ${_name})
+endmacro()
+
+###############################################################################
+# Get the status of a subsystem
+# _var Destination variable.
+# _name Name of the subsystem.
+macro(PCL_GET_SUBSUBSYS_STATUS _var _parent _name)
+    GET_IN_MAP(${_var} PCL_SUBSYS_STATUS ${_parent}_${_name})
+endmacro()
+
+###############################################################################
+# Set the hyperstatus of a subsystem and its dependee
+# _name Subsystem name.
+# _dependee Dependent subsystem.
+# _status AUTO_OFF to disable AUTO_ON to enable
+# ARGN[0] Reason for not building.
+macro(PCL_SET_SUBSYS_HYPERSTATUS _name _dependee _status)
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_HYPERSTATUS ${_name}_${_dependee} ${_status})
+  if(${ARGC} EQUAL 4)
+    SET_IN_GLOBAL_MAP(PCL_SUBSYS_REASONS ${_dependee} ${ARGV3})
+  endif()
+endmacro()
+
+###############################################################################
+# Get the hyperstatus of a subsystem and its dependee
+# _name IN subsystem name.
+# _dependee IN dependent subsystem.
+# _var OUT hyperstatus
+# ARGN[0] Reason for not building.
+macro(PCL_GET_SUBSYS_HYPERSTATUS _var _name)
+  set(${_var} "AUTO_ON")
+  if(${ARGC} EQUAL 3)
+    GET_IN_MAP(${_var} PCL_SUBSYS_HYPERSTATUS ${_name}_${ARGV2})
+  else()
+    foreach(subsys ${PCL_SUBSYS_DEPS_${_name}})
+      if("${PCL_SUBSYS_HYPERSTATUS_${subsys}_${_name}}" STREQUAL "AUTO_OFF")
+        set(${_var} "AUTO_OFF")
+        break()
+      endif()
+    endforeach()
+  endif()
+endmacro()
+
+###############################################################################
+# Set the hyperstatus of a subsystem and its dependee
+macro(PCL_UNSET_SUBSYS_HYPERSTATUS _name _dependee)
+  unset(PCL_SUBSYS_HYPERSTATUS_${_name}_${dependee})
+endmacro()
+
+###############################################################################
+# Set the include directory name of a subsystem.
+# _name Subsystem name.
+# _includedir Name of subdirectory for includes
+# ARGN[0] Reason for not building.
+macro(PCL_SET_SUBSYS_INCLUDE_DIR _name _includedir)
+  #CMakeList.txt in each module sets SUBSYS_PATH as oneapi/xxxx.
+  #Remove "oneapi/" because we build the module insdie oneapi folder.
+  string(REPLACE "oneapi/" "" _includedir_new ${_includedir})
+  SET_IN_GLOBAL_MAP(PCL_SUBSYS_INCLUDE ${_name} ${_includedir_new})
+endmacro()
+
+###############################################################################
+# Get the include directory name of a subsystem - return _name if not set
+# _var Destination variable.
+# _name Name of the subsystem.
+macro(PCL_GET_SUBSYS_INCLUDE_DIR _var _name)
+  GET_IN_MAP(${_var} PCL_SUBSYS_INCLUDE ${_name})
+  if(NOT ${_var})
+    set(${_var} ${_name})
+  endif()
+endmacro()
+
+###############################################################################
+# Write a report on the build/not-build status of the subsystems
+macro(PCL_WRITE_STATUS_REPORT)
+  message(STATUS "PCL build with following flags:")
+  message(STATUS "${CMAKE_CXX_FLAGS}")
+  message(STATUS "The following subsystems will be built:")
+  foreach(_ss ${PCL_SUBSYSTEMS})
+    PCL_GET_SUBSYS_STATUS(_status ${_ss})
+    if(_status)
+      set(message_text "  ${_ss}")
+      string(TOUPPER "PCL_${_ss}_SUBSYS" PCL_SUBSYS_SUBSYS)
+      if(${PCL_SUBSYS_SUBSYS})
+        set(will_build)
+        foreach(_sub ${${PCL_SUBSYS_SUBSYS}})
+          PCL_GET_SUBSYS_STATUS(_sub_status ${_ss}_${_sub})
+          if(_sub_status)
+            string(APPEND will_build "\n       |_ ${_sub}")
+          endif()
+        endforeach()
+        if(NOT ("${will_build}" STREQUAL ""))
+          string(APPEND message_text "\n       building: ${will_build}")
+        endif()
+        set(wont_build)
+        foreach(_sub ${${PCL_SUBSYS_SUBSYS}})
+          PCL_GET_SUBSYS_STATUS(_sub_status ${_ss}_${_sub})
+          PCL_GET_SUBSYS_HYPERSTATUS(_sub_hyper_status ${_ss}_${sub})
+          if(NOT _sub_status OR ("${_sub_hyper_status}" STREQUAL "AUTO_OFF"))
+            GET_IN_MAP(_reason PCL_SUBSYS_REASONS ${_ss}_${_sub})
+            string(APPEND wont_build "\n       |_ ${_sub}: ${_reason}")
+          endif()
+        endforeach()
+        if(NOT ("${wont_build}" STREQUAL ""))
+          string(APPEND message_text "\n       not building: ${wont_build}")
+        endif()
+      endif()
+      message(STATUS "${message_text}")
+    endif()
+  endforeach()
+
+  message(STATUS "The following subsystems will not be built:")
+  foreach(_ss ${PCL_SUBSYSTEMS})
+    PCL_GET_SUBSYS_STATUS(_status ${_ss})
+    PCL_GET_SUBSYS_HYPERSTATUS(_hyper_status ${_ss})
+    if(NOT _status OR ("${_hyper_status}" STREQUAL "AUTO_OFF"))
+       GET_IN_MAP(_reason PCL_SUBSYS_REASONS ${_ss})
+       message(STATUS "  ${_ss}: ${_reason}")
+    endif()
+  endforeach()
+endmacro()
+
+##############################################################################
+# Collect subdirectories from dirname that contains filename and store them in
+#  varname.
+# WARNING If extra arguments are given then they are considered as exception
+# list and varname will contain subdirectories of dirname that contains
+# fielename but doesn't belong to exception list.
+# dirname IN parent directory
+# filename IN file name to look for in each subdirectory of parent directory
+# varname OUT list of subdirectories containing filename
+# exception_list OPTIONAL and contains list of subdirectories not to account
+macro(collect_subproject_directory_names dirname filename names dirs)
+  file(GLOB globbed RELATIVE "${dirname}" "${dirname}/*/${filename}")
+  if(${ARGC} GREATER 4)
+    set(exclusion_list ${ARGN})
+    foreach(file ${globbed})
+      get_filename_component(dir ${file} PATH)
+      list(FIND exclusion_list ${dir} excluded)
+      if(excluded EQUAL -1)
+        set(${dirs} ${${dirs}} ${dir})
+      endif()
+    endforeach()
+  else()
+    foreach(file ${globbed})
+      get_filename_component(dir ${file} PATH)
+      set(${dirs} ${${dirs}} ${dir})
+    endforeach()
+  endif()
+  foreach(subdir ${${dirs}})
+    file(STRINGS ${dirname}/${subdir}/CMakeLists.txt name REGEX "[setSET ]+\\(.*SUBSYS_NAME .*\\)$")
+    string(REGEX REPLACE "[setSET ]+\\(.*SUBSYS_NAME[ ]+([A-Za-z0-9_]+)[ ]*\\)" "\\1" name "${name}")
+    set(${names} ${${names}} ${name})
+    file(STRINGS ${dirname}/${subdir}/CMakeLists.txt DEPENDENCIES REGEX "set.*SUBSYS_DEPS .*\\)")
+    string(REGEX REPLACE "set.*SUBSYS_DEPS" "" DEPENDENCIES "${DEPENDENCIES}")
+    string(REPLACE ")" "" DEPENDENCIES "${DEPENDENCIES}")
+    string(STRIP "${DEPENDENCIES}" DEPENDENCIES)
+    string(REPLACE " " ";" DEPENDENCIES "${DEPENDENCIES}")
+    if(NOT("${DEPENDENCIES}" STREQUAL ""))
+      list(REMOVE_ITEM DEPENDENCIES "#")
+      string(TOUPPER "PCL_${name}_DEPENDS" SUBSYS_DEPENDS)
+      set(${SUBSYS_DEPENDS} ${DEPENDENCIES})
+      foreach(dependee ${DEPENDENCIES})
+        string(TOUPPER "PCL_${dependee}_DEPENDIES" SUBSYS_DEPENDIES)
+        set(${SUBSYS_DEPENDIES} ${${SUBSYS_DEPENDIES}} ${name})
+      endforeach()
+    endif()
+  endforeach()
+endmacro()
+
+########################################################################################
+# Macro to disable subsystem dependies
+# _subsys IN subsystem name
+macro(PCL_DISABLE_DEPENDIES _subsys)
+  string(TOUPPER "pcl_${_subsys}_dependies" PCL_SUBSYS_DEPENDIES)
+  if(NOT ("${${PCL_SUBSYS_DEPENDIES}}" STREQUAL ""))
+    foreach(dep ${${PCL_SUBSYS_DEPENDIES}})
+      PCL_SET_SUBSYS_HYPERSTATUS(${_subsys} ${dep} AUTO_OFF "Disabled: ${_subsys} missing.")
+      set(BUILD_${dep} OFF CACHE BOOL "Disabled: ${_subsys} missing." FORCE)
+    endforeach()
+  endif()
+endmacro()
+
+########################################################################################
+# Macro to enable subsystem dependies
+# _subsys IN subsystem name
+macro(PCL_ENABLE_DEPENDIES _subsys)
+  string(TOUPPER "pcl_${_subsys}_dependies" PCL_SUBSYS_DEPENDIES)
+  if(NOT ("${${PCL_SUBSYS_DEPENDIES}}" STREQUAL ""))
+    foreach(dep ${${PCL_SUBSYS_DEPENDIES}})
+      PCL_GET_SUBSYS_HYPERSTATUS(dependee_status ${_subsys} ${dep})
+      if("${dependee_status}" STREQUAL "AUTO_OFF")
+        PCL_SET_SUBSYS_HYPERSTATUS(${_subsys} ${dep} AUTO_ON)
+        GET_IN_MAP(desc PCL_SUBSYS_DESC ${dep})
+        set(BUILD_${dep} ON CACHE BOOL "${desc}" FORCE)
+      endif()
+    endforeach()
+  endif()
+endmacro()
+
+########################################################################################
+# Macro to build subsystem centric documentation
+# _subsys IN the name of the subsystem to generate documentation for
+macro (PCL_ADD_DOC _subsys)
+  string(TOUPPER "${_subsys}" SUBSYS)
+  set(doc_subsys "doc_${_subsys}")
+  GET_IN_MAP(dependencies PCL_SUBSYS_DEPS ${_subsys})
+  if(DOXYGEN_FOUND)
+    if(HTML_HELP_COMPILER)
+      set(DOCUMENTATION_HTML_HELP YES)
+    else()
+      set(DOCUMENTATION_HTML_HELP NO)
+    endif()
+    if(DOXYGEN_DOT_EXECUTABLE)
+      set(HAVE_DOT YES)
+    else()
+      set(HAVE_DOT NO)
+    endif()
+    if(NOT "${dependencies}" STREQUAL "")
+      set(STRIPPED_HEADERS "${PCL-ONEAPI_SOURCE_DIR}/${dependencies}/include")
+      string(REPLACE ";" "/include \\\n                         ${PCL-ONEAPI_SOURCE_DIR}/"
+             STRIPPED_HEADERS "${STRIPPED_HEADERS}")
+    endif()
+    set(DOC_SOURCE_DIR "\"${CMAKE_CURRENT_SOURCE_DIR}\"\\")
+    foreach(dep ${dependencies})
+      string(APPEND DOC_SOURCE_DIR "\n\t\t\t\t\t\t\t\t\t\t\t\t \"${PCL-ONEAPI_SOURCE_DIR}/${dep}\"\\")
+    endforeach()
+    file(MAKE_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/html")
+    set(doxyfile "${CMAKE_CURRENT_BINARY_DIR}/doxyfile")
+    configure_file("${PCL-ONEAPI_SOURCE_DIR}/doc/doxygen/doxyfile.in" ${doxyfile})
+    add_custom_target(${doc_subsys} ${DOXYGEN_EXECUTABLE} ${doxyfile})
+    set_target_properties(${doc_subsys} PROPERTIES FOLDER "Documentation")
+  endif()
+endmacro()
+
+###############################################################################
+# Add a dependency for a grabber
+# _name The dependency name.
+# _description The description text to display when dependency is not found.
+# This macro adds on option named "WITH_NAME", where NAME is the capitalized
+# dependency name. The user may use this option to control whether the
+# corresponding grabber should be built or not. Also an attempt to find a
+# package with the given name is made. If it is not successful, then the
+# "WITH_NAME" option is coerced to FALSE.
+macro(PCL_ADD_GRABBER_DEPENDENCY _name _description)
+  string(TOUPPER ${_name} _name_capitalized)
+  option(WITH_${_name_capitalized} "${_description}" TRUE)
+  if(WITH_${_name_capitalized})
+    find_package(${_name})
+    if(NOT ${_name_capitalized}_FOUND)
+      set(WITH_${_name_capitalized} FALSE CACHE BOOL "${_description}" FORCE)
+      message(STATUS "${_description}: not building because ${_name} not found")
+    else()
+      set(HAVE_${_name_capitalized} TRUE)
+      include_directories(SYSTEM "${${_name_capitalized}_INCLUDE_DIRS}")
+    endif()
+  endif()
+endmacro()
+
+###############################################################################
+# Set the dependencies for a specific test module on the provided variable
+# _var The variable to be filled with the dependencies
+# _module The module name
+macro(PCL_SET_TEST_DEPENDENCIES _var _module)
+  set(${_var} global_tests ${_module} ${PCL_SUBSYS_DEPS_${_module}})
+endmacro()
diff --git a/oneapi/cmake/pcl_utils.cmake b/oneapi/cmake/pcl_utils.cmake
new file mode 100644
index 000000000..37c382591
--- /dev/null
+++ b/oneapi/cmake/pcl_utils.cmake
@@ -0,0 +1,468 @@
+###############################################################################
+# Turn a list into a string, with each item separated by spaces.
+# _string Name of the destination variable.
+# _list List to stringify.
+macro(LIST_TO_STRING _string _list)
+    set(${_string})
+    foreach(_item ${_list})
+        set(${_string} "${${_string}} ${_item}")
+    endforeach()
+endmacro()
+
+
+###############################################################################
+# Filter a list by a pattern.
+# _list List to filter.
+# _pattern The regular expression to filter by. See the if(... MATCHES ...)
+#   expression in the CMake help.
+# _output The name of the destination variable.
+macro(FILTER_LIST _list _pattern _output)
+    set(${_output})
+    foreach(_item ${_list})
+        if("${_item}" MATCHES ${_pattern})
+            set(${_output} ${${_output}} ${_item})
+        endif()
+    endforeach()
+endmacro()
+
+
+###############################################################################
+# Prefix every item in a list.
+# _output The name of the destination variable.
+# _prefix The value to prepend.
+# _list List to prefix.
+macro(PREFIX_LIST _output _prefix _list)
+    set(${_output})
+    foreach(_item ${_list})
+        list(APPEND ${_output} "${_prefix}${_item}")
+    endforeach()
+endmacro()
+
+###############################################################################
+# Remove vtk definitions
+# This is used for CUDA targets, because nvcc does not like VTK 6+ definitions
+# style.
+macro(REMOVE_VTK_DEFINITIONS)
+    get_directory_property(_dir_defs DIRECTORY ${CMAKE_SOURCE_DIR} COMPILE_DEFINITIONS)
+    set(_vtk_definitions)
+    foreach(_item ${_dir_defs})
+        if(_item MATCHES "vtk*")
+            list(APPEND _vtk_definitions -D${_item})
+        endif()
+    endforeach()
+    remove_definitions(${_vtk_definitions})
+endmacro()
+
+###############################################################################
+# Pull the component parts out of the version number.
+macro(DISSECT_VERSION)
+    # Detect if we're in a developlment version and generate pretty version string
+    if(PCL_VERSION_TWEAK EQUAL 99)
+        set(PCL_DEV_VERSION 1)
+        set(PCL_VERSION_PRETTY "${PCL_VERSION_MAJOR}.${PCL_VERSION_MINOR}.${PCL_VERSION_PATCH}-dev")
+    else()
+        set(PCL_DEV_VERSION 0)
+        set(PCL_VERSION_PRETTY "${PCL_VERSION_MAJOR}.${PCL_VERSION_MINOR}.${PCL_VERSION_PATCH}")
+    endif()
+endmacro()
+
+###############################################################################
+# Get the operating system information. Generally, CMake does a good job of
+# this. Sometimes, though, it doesn't give enough information. This macro will
+# distinguish between the UNIX variants. Otherwise, use the CMake variables
+# such as WIN32 and APPLE and CYGWIN.
+# Sets OS_IS_64BIT if the operating system is 64-bit.
+# Sets LINUX if the operating system is Linux.
+macro(GET_OS_INFO)
+    string(REGEX MATCH "Linux" OS_IS_LINUX ${CMAKE_SYSTEM_NAME})
+    if(CMAKE_SIZEOF_VOID_P EQUAL 8)
+        set(OS_IS_64BIT TRUE)
+    else()
+        set(OS_IS_64BIT FALSE)
+    endif()
+endmacro()
+
+
+###############################################################################
+# Set the destination directories for installing stuff.
+# Sets LIB_INSTALL_DIR. Install libraries here.
+# Sets BIN_INSTALL_DIR. Install binaries here.
+# Sets INCLUDE_INSTALL_DIR. Install include files here, preferably in a
+# subdirectory named after the library in question (e.g.
+# "registration/blorgle.h")
+macro(SET_INSTALL_DIRS)
+  if(NOT DEFINED LIB_INSTALL_DIR)
+    set(LIB_INSTALL_DIR "lib")
+  endif()
+    if(NOT ANDROID)
+      set(INCLUDE_INSTALL_ROOT
+          "include/${PROJECT_NAME_LOWER}-${PCL-ONEAPI_VERSION_MAJOR}.${PCL-ONEAPI_VERSION_MINOR}")
+    else()
+      set(INCLUDE_INSTALL_ROOT "include") # Android, don't put into subdir
+    endif()
+    
+    set(INCLUDE_INSTALL_DIR "${INCLUDE_INSTALL_ROOT}/pcl")
+    set(DOC_INSTALL_DIR "share/doc/${PROJECT_NAME_LOWER}-${PCL-ONEAPI_VERSION_MAJOR}.${PCL-ONEAPI_VERSION_MINOR}")
+    set(BIN_INSTALL_DIR "bin")
+    set(PKGCFG_INSTALL_DIR "${LIB_INSTALL_DIR}/pkgconfig")
+    if(WIN32 AND NOT MINGW)
+        set(PCLCONFIG_INSTALL_DIR "cmake")
+      else()
+        set(PCLCONFIG_INSTALL_DIR "share/${PROJECT_NAME_LOWER}-${PCL-ONEAPI_VERSION_MAJOR}.${PCL-ONEAPI_VERSION_MINOR}")
+      endif()
+endmacro()
+
+
+###############################################################################
+# This macro processes a list of arguments into separate lists based on
+# keywords found in the argument stream. For example:
+# BUILDBLAG (misc_arg INCLUDEDIRS /usr/include LIBDIRS /usr/local/lib
+#            LINKFLAGS -lthatawesomelib CFLAGS -DUSEAWESOMELIB SOURCES blag.c)
+# Any other args found at the start of the stream will go into the variable
+# specified in _other_args. Typically, you would take arguments to your macro
+# as normal, then pass ${ARGN} to this macro to parse the dynamic-length
+# arguments (so if ${_otherArgs} comes back non-empty, you've ignored something
+# or the user has passed in some arguments without a keyword).
+macro(PROCESS_ARGUMENTS _sources_args _include_dirs_args _lib_dirs_args
+        _link_libs_args _link_flags_args _cflags_args _idl_args _other_args)
+    set(${_sources_args})
+    set(${_include_dirs_args})
+    set(${_lib_dirs_args})
+    set(${_link_libs_args})
+    set(${_link_flags_args})
+    set(${_cflags_args})
+    set(${_idl_args})
+    set(${_other_args})
+    set(_current_dest ${_other_args})
+    foreach(_arg ${ARGN})
+        if(_arg STREQUAL "SOURCES")
+            set(_current_dest ${_sources_args})
+        elseif(_arg STREQUAL "INCLUDEDIRS")
+            set(_current_dest ${_include_dirs_args})
+        elseif(_arg STREQUAL "LIBDIRS")
+            set(_current_dest ${_lib_dirs_args})
+        elseif(_arg STREQUAL "LINKLIBS")
+            set(_current_dest ${_link_libs_args})
+        elseif(_arg STREQUAL "LINKFLAGS")
+            set(_current_dest ${_link_flags_args})
+        elseif(_arg STREQUAL "CFLAGS")
+            set(_current_dest ${_cflags_args})
+        elseif(_arg STREQUAL "IDL")
+            set(_current_dest ${_idl_args})
+        else()
+            list(APPEND ${_current_dest} ${_arg})
+        endif()
+    endforeach()
+endmacro()
+
+
+###############################################################################
+# Set a value in a map.
+# _map The map name.
+# _key The key name.
+# _value The value.
+macro(SET_IN_MAP _map _key _value)
+    set("${_map}_${_key}" "${_value}")
+endmacro()
+
+
+###############################################################################
+# Set a value in a global, cached map.
+# _map The map name.
+# _key The key name.
+# _value The value.
+macro(SET_IN_GLOBAL_MAP _map _key _value)
+    set("${_map}_${_key}" "${_value}" CACHE INTERNAL "Map value" FORCE)
+endmacro()
+
+
+###############################################################################
+# Get a value from a map.
+# _dest The name of the variable to store the value in.
+# _map The map name.
+# _key The key name.
+macro(GET_IN_MAP _dest _map _key)
+    set(${_dest} ${${_map}_${_key}})
+endmacro()
+
+##########################################################################
+# This function were copied from boost-cmake project.                    #
+# The license terms is as follow                                         #
+##########################################################################
+# Copyright (C) 2007 Douglas Gregor <doug.gregor@gmail.com>              #
+# Copyright (C) 2007 Troy Straszheim                                     #
+#                                                                        #
+# Distributed under the Boost Software License, Version 1.0.             #
+# See accompanying file LICENSE_1_0.txt or copy at                       #
+#   http://www.boost.org/LICENSE_1_0.txt                                 #
+##########################################################################
+# Perform a reverse topological sort on the given LIST.
+#
+#   topological_sort(my_list "MY_" "_EDGES")
+#
+# LIST is the name of a variable containing a list of elements to be
+# sorted in reverse topological order. Each element in the list has a
+# set of outgoing edges (for example, those other list elements that
+# it depends on). In the resulting reverse topological ordering
+# (written back into the variable named LIST), an element will come
+# later in the list than any of the elements that can be reached by
+# following its outgoing edges and the outgoing edges of any vertices
+# they target, recursively. Thus, if the edges represent dependencies
+# on build targets, for example, the reverse topological ordering is
+# the order in which one would build those targets.
+#
+# For each element E in this list, the edges for E are contained in
+# the variable named ${PREFIX}${E}${SUFFIX}, where E is the
+# upper-cased version of the element in the list. If no such variable
+# exists, then it is assumed that there are no edges. For example, if
+# my_list contains a, b, and c, one could provide a dependency graph
+# using the following variables:
+#
+#     MY_A_EDGES     b
+#     MY_B_EDGES
+#     MY_C_EDGES     a b
+#
+#  With the involcation of topological_sort shown above and these
+#  variables, the resulting reverse topological ordering will be b, a,
+#  c.
+
+macro(topological_sort LIST PREFIX SUFFIX)
+    # Clear the stack and output variable
+    set(VERTICES "${${LIST}}")
+    set(STACK)
+    set(${LIST})
+
+    # Loop over all of the vertices, starting the topological sort from
+    # each one.
+    foreach(VERTEX ${VERTICES})
+        string(TOUPPER ${VERTEX} UPPER_VERTEX)
+
+        # If we haven't already processed this vertex, start a depth-first
+        # search from where.
+        if(NOT FOUND_${UPPER_VERTEX})
+            # Push this vertex onto the stack with all of its outgoing edges
+            string(REPLACE ";" " " NEW_ELEMENT
+                "${VERTEX};${${PREFIX}${UPPER_VERTEX}${SUFFIX}}")
+            list(APPEND STACK ${NEW_ELEMENT})
+
+            # We've now seen this vertex
+            set(FOUND_${UPPER_VERTEX} TRUE)
+
+            # While the depth-first search stack is not empty
+            list(LENGTH STACK STACK_LENGTH)
+            while(STACK_LENGTH GREATER 0)
+                # Remove the vertex and its remaining out-edges from the top
+                # of the stack
+                list(GET STACK -1 OUT_EDGES)
+                list(REMOVE_AT STACK -1)
+
+                # Get the source vertex and the list of out-edges
+                separate_arguments(OUT_EDGES)
+                list(GET OUT_EDGES 0 SOURCE)
+                list(REMOVE_AT OUT_EDGES 0)
+
+                # While there are still out-edges remaining
+                list(LENGTH OUT_EDGES OUT_DEGREE)
+                while (OUT_DEGREE GREATER 0)
+                    # Pull off the first outgoing edge
+                    list(GET OUT_EDGES 0 TARGET)
+                    list(REMOVE_AT OUT_EDGES 0)
+
+                    string(TOUPPER ${TARGET} UPPER_TARGET)
+                    #Find the ONEAPI substring location.
+                    string(FIND ${UPPER_TARGET} "ONEAPI" loc)
+                    #We only need to deal with the ONEAPI module dependency.
+                    #Ignore all non-ONEAPI modules.
+                    if(NOT FOUND_${UPPER_TARGET} AND ${loc} EQUAL 0)
+                        # We have not seen the target before, so we will traverse
+                        # its outgoing edges before coming back to our
+                        # source. This is the key to the depth-first traversal.
+
+                        # We've now seen this vertex
+                        set(FOUND_${UPPER_TARGET} TRUE)
+
+                        # Push the remaining edges for the current vertex onto the
+                        # stack
+                        string(REPLACE ";" " " NEW_ELEMENT
+                            "${SOURCE};${OUT_EDGES}")
+                        list(APPEND STACK ${NEW_ELEMENT})
+
+                        # Setup the new source and outgoing edges
+                        set(SOURCE ${TARGET})
+                        string(TOUPPER ${SOURCE} UPPER_SOURCE)
+                        set(OUT_EDGES
+                            ${${PREFIX}${UPPER_SOURCE}${SUFFIX}})
+                    endif()
+
+                    list(LENGTH OUT_EDGES OUT_DEGREE)
+                endwhile (OUT_DEGREE GREATER 0)
+
+                # We have finished all of the outgoing edges for
+                # SOURCE; add it to the resulting list.
+                list(APPEND ${LIST} ${SOURCE})
+
+                # Check the length of the stack
+                list(LENGTH STACK STACK_LENGTH)
+            endwhile(STACK_LENGTH GREATER 0)
+        endif()
+    endforeach()
+    # Somewhere a # slaps into the list so remove it
+    list(REMOVE_ITEM ${LIST} "#")
+endmacro()
+
+##
+# Swaps 2 elements at _pos1 and _pos2 of a list
+# _list [IN/OUT] a list
+# _pos1 [IN] position of the first element
+# _pos2 [IN] position of the second element
+# TODO ensure _pos1 and _pos2 are in range
+##
+macro(swap_elements _list _pos1 _pos2)
+  unset(pos1)
+  unset(pos2)
+  unset(element1)
+  unset(element2)
+  # sort pos1 and pos2 such us pos1 < pos2
+  if(NOT (${_pos1} EQUAL ${_pos2}))
+    if(${_pos1} GREATER ${_pos2})
+      set(pos1 ${${_pos2}})
+      set(pos2 ${${_pos1}})
+    else()
+      set(pos1 ${${_pos1}})
+      set(pos2 ${${_pos2}})
+    endif()
+
+    list(GET ${_list} ${pos1} element1)
+    math(EXPR distance "${pos2} - ${pos1}")
+    if(distance GREATER 1)
+      list(GET ${_list} ${pos2} element2)
+      list(INSERT ${_list} ${pos1} ${element2})
+      math(EXPR pos1 "${pos1} + 1")
+      list(REMOVE_AT ${_list} ${pos1})
+      list(INSERT ${_list} ${pos2} ${element1})
+      math(EXPR pos2 "${pos2} + 1")
+      list(REMOVE_AT ${_list} ${pos2})
+    else()
+      list(REMOVE_AT ${_list} ${pos1})
+      list(INSERT ${_list} ${pos2} ${element1})
+    endif()
+  endif()
+endmacro()
+
+##
+# Fills a list with _length x _value
+# _list the list to fill
+# _length the desired list size
+# _value the filler
+##
+macro(fill_list _list _length _value)
+  if(${_length} LESS 1)
+    message(FATAL_ERROR "${_length} must be at least equal to 1")
+  endif()
+  math(EXPR size "${${_length}} - 1")
+  foreach(counter RANGE ${size})
+    list(APPEND ${_list} ${_value})
+  endforeach()
+endmacro()
+
+##
+# Set the value at element a known position of a list
+# _list the list to manipulate
+# _position position of the element to set
+# _value new element value
+##
+macro(set_in_list _list _position _value)
+  list(INSERT ${_list} ${${_position}} ${${_value}})
+  math(EXPR next "${${_position}} + 1")
+  list(REMOVE_AT ${_list} ${next})
+endmacro()
+
+###
+# Sorts list B the same way list A was sorted by fetching the indices
+# _list [IN] original list A
+# _sorted_list [IN] list A after sorting
+# _to_sort_relative [IN/OUT] list B
+##
+macro(sort_relative _list _sorted_list _to_sort_relative)
+  unset(sorted_list_length)
+  unset(list_length)
+  unset(to_sort_list_length)
+  # ensure sizes are equal for the three lists else fail gracefully
+  list(LENGTH ${_sorted_list} sorted_list_length)
+  list(LENGTH ${_list} list_length)
+  list(LENGTH ${_to_sort_relative} to_sort_list_length)
+
+  if(NOT (list_length EQUAL sorted_list_length))
+    message(STATUS "Original list: ${${_list}}")
+    message(STATUS "Sorted list: ${${_sorted_list}}")
+    message(FATAL_ERROR "size mismatch between ${_sorted_list} (length ${sorted_list_length}) and ${_list} (length ${list_length})")
+  endif()
+
+  if(NOT (list_length EQUAL to_sort_list_length))
+    message(FATAL_ERROR "size mismatch between ${_to_sort_relative} ${to_sort_list_length} and ${_list} ${list_length}")
+  endif()
+  # unset the temporary list to avoid surprises (I had some them and were hard to find)
+  unset(tmp_list)
+  # fill it with a dummy value
+  fill_list(tmp_list list_length "#")
+  #iterate over the original list
+  set(counter 0)
+  foreach(loop_var ${${_list}})
+    # get the element position in the sorted list
+    list(FIND ${_sorted_list} ${loop_var} sorted_position)
+    # get the corresponding element from the list to sort
+    list(GET ${_to_sort_relative} ${counter} to_insert)
+    # in the temporary list replace the dummy value by the corresponding
+    set_in_list(tmp_list sorted_position to_insert)
+    # increment the counter
+    math(EXPR counter "${counter} + 1")
+  endforeach()
+  # swap the temporary list and list to sort
+  set(${_to_sort_relative} ${tmp_list})
+endmacro()
+
+
+###############################################################################
+# Find a Python module
+# From http://www.cmake.org/pipermail/cmake/2011-January/041666.html
+function(find_python_module module)
+  string(TOUPPER ${module} module_upper)
+  if(NOT PY_${module_upper})
+    if(ARGC GREATER 1 AND ARGV1 STREQUAL "REQUIRED")
+      set(${module}_FIND_REQUIRED TRUE)
+    endif()
+    # A module's location is usually a directory, but for binary modules
+    # it's a .so file.
+    execute_process(COMMAND "${PYTHON_EXEC}" "-c"
+      "import re, ${module}; print re.compile('/__init__.py.*').sub('',${module}.__file__)"
+      RESULT_VARIABLE _${module}_status
+      OUTPUT_VARIABLE _${module}_location
+      ERROR_QUIET OUTPUT_STRIP_TRAILING_WHITESPACE)
+    if(NOT _${module}_status)
+      set(PY_${module_upper} ${_${module}_location} CACHE STRING
+        "Location of Python module ${module}")
+    endif()
+  endif()
+  find_package_handle_standard_args(PY_${module} DEFAULT_MSG PY_${module_upper})
+endfunction(find_python_module)
+
+
+###############################################################################
+# Checks if the current generator is an IDE
+# _out The boolean result
+macro(check_if_ide _out)
+  # Current known pool of generators
+  set(_ides
+    "Xcode"
+    "Visual Studio"
+  )
+
+  set(${_out} FALSE)
+  foreach(_ide ${_ides})
+    # Visual Studio has multiple year releases and Win64 variants
+    if(CMAKE_GENERATOR MATCHES "${_ide}*")
+      set(${_out} TRUE)
+      break()
+    endif()
+  endforeach()
+endmacro()
diff --git a/oneapi/cmake/pcl_verbosity.cmake b/oneapi/cmake/pcl_verbosity.cmake
new file mode 100644
index 000000000..a045638c6
--- /dev/null
+++ b/oneapi/cmake/pcl_verbosity.cmake
@@ -0,0 +1,21 @@
+# Set PCL default verbosity level from cmake
+
+# User input default info
+set(PCL_VERBOSITY_LEVEL Info CACHE STRING "Set PCL verbosity level. Available options are: Always Error Warn Info Debug Verbose")
+
+if(${PCL_VERBOSITY_LEVEL} STREQUAL Info)
+  set(VERBOSITY_LEVEL_INFO 1)
+elseif(${PCL_VERBOSITY_LEVEL} STREQUAL Always)
+  set(VERBOSITY_LEVEL_ALWAYS 1)
+elseif(${PCL_VERBOSITY_LEVEL} STREQUAL Error)
+  set(VERBOSITY_LEVEL_ERROR 1)
+elseif(${PCL_VERBOSITY_LEVEL} STREQUAL Warn)
+  set(VERBOSITY_LEVEL_WARN 1)
+elseif(${PCL_VERBOSITY_LEVEL} STREQUAL Debug)
+  set(VERBOSITY_LEVEL_DEBUG 1)
+elseif(${PCL_VERBOSITY_LEVEL} STREQUAL Verbose)
+  set(VERBOSITY_LEVEL_VERBOSE 1)
+else()
+#  message(WARNING "Unknown verbosity level ${PCL_VERBOSITY_LEVEL}. Set to Info!")
+  set(VERBOSITY_LEVEL_INFO)
+endif()
diff --git a/oneapi/cmake/pkgconfig-headeronly.cmake.in b/oneapi/cmake/pkgconfig-headeronly.cmake.in
new file mode 100644
index 000000000..9cf9b9d81
--- /dev/null
+++ b/oneapi/cmake/pkgconfig-headeronly.cmake.in
@@ -0,0 +1,12 @@
+# This file was generated by CMake for @PROJECT_NAME@ library @PKG_NAME@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=${prefix}
+libdir=${prefix}/@LIB_INSTALL_DIR@
+#includedir=${prefix}/@INCLUDE_INSTALL_DIR@
+includedir=${prefix}/include/@PROJECT_NAME_LOWER@-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@
+Name: @PKG_NAME@
+Description: @PKG_DESC@
+Version: @PCL_VERSION@
+Requires: @PKG_EXTERNAL_DEPS@
+Libs:
+Cflags: -I${includedir} @PKG_CFLAGS@
diff --git a/oneapi/cmake/pkgconfig.cmake.in b/oneapi/cmake/pkgconfig.cmake.in
new file mode 100644
index 000000000..c351e441a
--- /dev/null
+++ b/oneapi/cmake/pkgconfig.cmake.in
@@ -0,0 +1,13 @@
+# This file was generated by CMake for @PROJECT_NAME@ library @PKG_NAME@
+prefix=@CMAKE_INSTALL_PREFIX@
+exec_prefix=${prefix}
+libdir=${prefix}/@LIB_INSTALL_DIR@
+#includedir=${prefix}/@INCLUDE_INSTALL_DIR@
+includedir=${prefix}/include/@PROJECT_NAME_LOWER@-@PCL_VERSION_MAJOR@.@PCL_VERSION_MINOR@
+Name: @PKG_NAME@
+Description: @PKG_DESC@
+Version: @PCL_VERSION@
+Requires: @PKG_EXTERNAL_DEPS@
+Libs: -L${libdir} -l@PKG_NAME@ @PKG_LIBFLAGS@ @PKG_INTERNAL_DEPS@
+Cflags: -I${includedir} @PKG_CFLAGS@
+
diff --git a/oneapi/cmake/uninstall_target.cmake.in b/oneapi/cmake/uninstall_target.cmake.in
new file mode 100644
index 000000000..3d77e6c59
--- /dev/null
+++ b/oneapi/cmake/uninstall_target.cmake.in
@@ -0,0 +1,66 @@
+if(NOT EXISTS "@PROJECT_BINARY_DIR@/install_manifest.txt")
+  message(FATAL_ERROR "Cannot find install manifest: \"@PROJECT_BINARY_DIR@/install_manifest.txt\"")
+endif()
+
+file(READ "@PROJECT_BINARY_DIR@/install_manifest.txt" files)
+string(REGEX REPLACE "\n" ";" files "${files}")
+foreach(file ${files})
+  message(STATUS "Uninstalling \"$ENV{DESTDIR}${file}\"")
+  if(EXISTS "$ENV{DESTDIR}${file}" OR IS_SYMLINK "$ENV{DESTDIR}${file}")
+    exec_program("@CMAKE_COMMAND@" ARGS "-E remove \"$ENV{DESTDIR}${file}\""
+                 OUTPUT_VARIABLE rm_out RETURN_VALUE rm_retval)
+    if(NOT "${rm_retval}" STREQUAL 0)
+      message(FATAL_ERROR "Problem when removing \"$ENV{DESTDIR}${file}\"")
+    endif()
+  else()
+    message(STATUS "File \"$ENV{DESTDIR}${file}\" does not exist.")
+  endif()
+endforeach()
+
+# remove pcl directory in include (removes all files in it!)
+message(STATUS "Uninstalling \"@CMAKE_INSTALL_PREFIX@/@INCLUDE_INSTALL_ROOT@\"")
+if(EXISTS "@CMAKE_INSTALL_PREFIX@/@INCLUDE_INSTALL_ROOT@")
+  exec_program("@CMAKE_COMMAND@"
+               ARGS "-E remove_directory \"@CMAKE_INSTALL_PREFIX@/@INCLUDE_INSTALL_ROOT@\""
+               OUTPUT_VARIABLE rm_out RETURN_VALUE rm_retval)
+  if(NOT "${rm_retval}" STREQUAL 0)
+    message(FATAL_ERROR "Problem when removing \"@CMAKE_INSTALL_PREFIX@/@INCLUDE_INSTALL_ROOT@\"")
+  endif()
+else()
+  message(STATUS "Directory \"@CMAKE_INSTALL_PREFIX@/@INCLUDE_INSTALL_ROOT@\" does not exist.")
+endif()
+
+# remove pcl directory in share (removes all files in it!)
+# created by CMakeLists.txt for PCLConfig.cmake
+if(EXISTS "@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@")
+  file(GLOB_RECURSE CMAKE_CONFIG_FOLDER_FILES FOLLOW_SYMLINKS
+       LIST_DIRECTORIES false
+       "@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@/*")
+  list(LENGTH CMAKE_CONFIG_FOLDER_FILES CMAKE_CONFIG_FOLDER_FILES_NUMBER)
+  if(CMAKE_CONFIG_FOLDER_FILES_NUMBER EQUAL 0)
+    message(STATUS "Uninstalling \"@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@\"")
+    exec_program("@CMAKE_COMMAND@"
+                 ARGS "-E remove_directory \"@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@\""
+                 OUTPUT_VARIABLE rm_out RETURN_VALUE rm_retval)
+    if(NOT "${rm_retval}" STREQUAL 0)
+      message(FATAL_ERROR "Problem when removing \"@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@\"")
+    endif()
+  endif()
+else()
+  message(STATUS "Directory \"@CMAKE_INSTALL_PREFIX@/@PCLCONFIG_INSTALL_DIR@\" does not exist.")
+endif()
+
+# remove pcl directory in share/doc (removes all files in it!)
+if(@WITH_DOCS@)
+  message(STATUS "Uninstalling \"@CMAKE_INSTALL_PREFIX@/@DOC_INSTALL_DIR@\"")
+  if(EXISTS "@CMAKE_INSTALL_PREFIX@/@DOC_INSTALL_DIR@")
+    exec_program("@CMAKE_COMMAND@"
+                 ARGS "-E remove_directory \"@CMAKE_INSTALL_PREFIX@/@DOC_INSTALL_DIR@\""
+                 OUTPUT_VARIABLE rm_out RETURN_VALUE rm_retval)
+    if(NOT "${rm_retval}" STREQUAL 0)
+      message(FATAL_ERROR "Problem when removing \"@CMAKE_INSTALL_PREFIX@/@DOC_INSTALL_DIR@\"")
+    endif()
+  else()
+    message(STATUS "Directory \"@CMAKE_INSTALL_PREFIX@/@DOC_INSTALL_DIR@\" does not exist.")
+  endif()
+endif()
diff --git a/oneapi/cmake/version.rc.in b/oneapi/cmake/version.rc.in
new file mode 100644
index 000000000..6d1c848a4
--- /dev/null
+++ b/oneapi/cmake/version.rc.in
@@ -0,0 +1,44 @@
+#include <winres.h>
+
+#ifndef _DEBUG
+#define VER_DEBUG 0
+#else
+#define VER_DEBUG VS_FF_DEBUG
+#endif
+
+IDI_ICON1 ICON "@VERSION_INFO_ICON_PATH@"
+
+VS_VERSION_INFO VERSIONINFO
+  FILEVERSION    @VERSION_INFO_VERSION_WITH_COMMA@
+  PRODUCTVERSION @VERSION_INFO_VERSION_WITH_COMMA@
+  FILEFLAGSMASK  VS_FFI_FILEFLAGSMASK
+  FILEFLAGS      VER_DEBUG
+  FILEOS         VOS_NT_WINDOWS32
+  FILETYPE       VFT_APP
+  FILESUBTYPE    VFT2_UNKNOWN
+BEGIN
+  BLOCK "StringFileInfo"
+  BEGIN
+    BLOCK "040904E4"
+    BEGIN
+      VALUE "CompanyName",      "Open Perception Foundation"
+      VALUE "FileDescription",  "@VERSION_INFO_DISPLAY_NAME@"
+      VALUE "FileVersion",      "@PCL_VERSION_PRETTY@"
+      VALUE "LegalCopyright",   "Open Perception Foundation. All rights reserved."
+      VALUE "ProductName",      "Point Cloud Library"
+      VALUE "ProductVersion",   "@PCL_VERSION_PRETTY@"
+    END
+  END
+
+  BLOCK "VarFileInfo"
+  BEGIN
+    /* The following line should only be modified for localized versions.     */
+    /* It consists of any number of WORD,WORD pairs, with each pair           */
+    /* describing a language,codepage combination supported by the file.      */
+    /*                                                                        */
+    /* For example, a file might have values "0x409,1252" indicating that it  */
+    /* supports English language (0x409) in the Windows ANSI codepage (1252). */
+
+    VALUE "Translation", 0x409, 1252
+  END
+END
\ No newline at end of file
diff --git a/oneapi/common/CMakeLists.txt b/oneapi/common/CMakeLists.txt
new file mode 100644
index 000000000..ae6341843
--- /dev/null
+++ b/oneapi/common/CMakeLists.txt
@@ -0,0 +1,88 @@
+set(SUBSYS_NAME oneapi_common)
+set(SUBSYS_PATH oneapi/common)
+set(SUBSYS_DESC "Point cloud oneAPI common library")
+set(SUBSYS_DEPS common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+mark_as_advanced("BUILD_${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(srcs
+  src/point_types.cpp
+  src/io.cpp
+  src/pcl_base.cpp
+  src/device_memory.cpp.dp.cpp
+  src/error.cpp
+  src/gpu_memory_manager.dp.cpp
+  src/common.cpp
+  src/PCLPointCloud2.cpp
+)
+set(incs
+  include/pcl/oneapi/types.h
+  include/pcl/oneapi/pcl_base.h
+  include/pcl/oneapi/point_cloud.h
+  include/pcl/oneapi/point_types.h
+  include/pcl/oneapi/point_type_rgb.h
+  include/pcl/oneapi/PointIndices.h
+  include/pcl/oneapi/PCLPointCloud2.h
+)
+
+set(impl_incs
+  include/pcl/oneapi/impl/pcl_base.hpp
+)
+
+set(common_incs
+  include/pcl/oneapi/common/copy_point.h
+  include/pcl/oneapi/common/io.h
+  include/pcl/oneapi/common/centroid.h
+  include/pcl/oneapi/common/common.h
+)
+
+set(common_impl_incs
+  include/pcl/oneapi/common/impl/copy_point.hpp
+  include/pcl/oneapi/common/impl/io.hpp
+  include/pcl/oneapi/common/impl/common.hpp
+)
+
+set(device_incs
+  include/pcl/oneapi/common/device/vector_types.h
+  include/pcl/oneapi/common/device/matrix_types.h
+  include/pcl/oneapi/common/device/eigen.h
+  include/pcl/oneapi/common/device/centroid.h
+)
+
+set(container_incs
+  include/pcl/oneapi/containers/device_array.h
+  include/pcl/oneapi/containers/device_memory.h
+  include/pcl/oneapi/containers/gpu_memory_manager.h
+  include/pcl/oneapi/containers/initialization.h
+  include/pcl/oneapi/containers/kernel_containers.h
+)
+
+set(container_impl_incs
+  include/pcl/oneapi/containers/impl/device_array.hpp
+  include/pcl/oneapi/containers/impl/device_memory.hpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs}
+${common_incs} ${common_impl_incs} ${device_incs} ${container_incs} ${container_impl_incs})
+IF(WIN32)
+target_link_libraries("${LIB_NAME}" pcl_common)
+endif()
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC "${SUBSYS_DESC}")
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "oneapi" ${incs})
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${common_incs})
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "oneapi/containers/" ${container_incs})
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "oneapi/containers/impl" ${container_impl_incs})
diff --git a/oneapi/common/include/pcl/oneapi/PCLPointCloud2.h b/oneapi/common/include/pcl/oneapi/PCLPointCloud2.h
new file mode 100644
index 000000000..732c186df
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/PCLPointCloud2.h
@@ -0,0 +1,128 @@
+#pragma once
+
+#include <ostream>
+#include <vector>
+
+#include <boost/predef/other/endian.h>
+
+#include <pcl/pcl_macros.h>  // for PCL_EXPORTS
+#include <pcl/PCLHeader.h>
+#include <pcl/PCLPointField.h>
+#include <pcl/oneapi/types.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  struct PCL_EXPORTS PCLPointCloud2
+  {
+    ::pcl::PCLHeader header;
+
+    uindex_t height = 0;
+    uindex_t width = 0;
+
+    std::vector<::pcl::PCLPointField>  fields;
+
+    static_assert(BOOST_ENDIAN_BIG_BYTE || BOOST_ENDIAN_LITTLE_BYTE, "unable to determine system endianness");
+    std::uint8_t is_bigendian = BOOST_ENDIAN_BIG_BYTE;
+    uindex_t point_step = 0;
+    uindex_t row_step = 0;
+
+    DeviceArray<std::uint8_t> data;
+
+    std::uint8_t is_dense = 0;
+
+  public:
+    using Ptr = shared_ptr< ::pcl::oneapi::PCLPointCloud2>;
+    using ConstPtr = shared_ptr<const ::pcl::oneapi::PCLPointCloud2>;
+
+    //////////////////////////////////////////////////////////////////////////
+    /** \brief Inplace concatenate two pcl::PCLPointCloud2
+      *
+      * IFF the layout of all the fields in both the clouds is the same, this command
+      * doesn't remove any fields named "_" (aka marked as skip). For comparison of field
+      * names, "rgb" and "rgba" are considered equivalent
+      * However, if the order and/or number of non-skip fields is different, the skip fields
+      * are dropped and non-skip fields copied selectively.
+      * This function returns an error if
+      *   * the total number of non-skip fields is different
+      *   * the non-skip field names are named differently (excluding "rbg{a}") in serial order
+      *   * the endian-ness of both clouds is different
+      * \param[in,out] cloud1 the first input and output point cloud dataset
+      * \param[in] cloud2 the second input point cloud dataset
+      * \return true if successful, false if failed (e.g., name/number of fields differs)
+      */
+    static bool
+    concatenate (PCLPointCloud2 &cloud1, const PCLPointCloud2 &cloud2);
+
+    /** \brief Concatenate two pcl::PCLPointCloud2
+      * \param[in] cloud1 the first input point cloud dataset
+      * \param[in] cloud2 the second input point cloud dataset
+      * \param[out] cloud_out the resultant output point cloud dataset
+      * \return true if successful, false if failed (e.g., name/number of fields differs)
+      */
+    static bool
+    concatenate (const PCLPointCloud2 &cloud1,
+                 const PCLPointCloud2 &cloud2,
+                 PCLPointCloud2 &cloud_out)
+    {
+      cloud_out = cloud1;
+      return concatenate(cloud_out, cloud2);
+    }
+
+    /** \brief Add a point cloud to the current cloud.
+      * \param[in] rhs the cloud to add to the current cloud
+      * \return the new cloud as a concatenation of the current cloud and the new given cloud
+      */
+    PCLPointCloud2&
+    operator += (const PCLPointCloud2& rhs);
+
+    /** \brief Add a point cloud to another cloud.
+      * \param[in] rhs the cloud to add to the current cloud
+      * \return the new cloud as a concatenation of the current cloud and the new given cloud
+      */
+    inline PCLPointCloud2
+    operator + (const PCLPointCloud2& rhs)
+    {
+      return (PCLPointCloud2 (*this) += rhs);
+    }
+  }; // struct PCLPointCloud2
+
+  using PCLPointCloud2Ptr = PCLPointCloud2::Ptr;
+  using PCLPointCloud2ConstPtr = PCLPointCloud2::ConstPtr;
+
+  inline std::ostream& operator<<(std::ostream& s, const  PCLPointCloud2 &v)
+  {
+    s << "header: " << std::endl;
+    s << v.header;
+    s << "height: ";
+    s << "  " << v.height << std::endl;
+    s << "width: ";
+    s << "  " << v.width << std::endl;
+    s << "fields[]" << std::endl;
+    for (std::size_t i = 0; i < v.fields.size (); ++i)
+    {
+      s << "  fields[" << i << "]: ";
+      s << std::endl;
+      s << "    " << v.fields[i] << std::endl;
+    }
+    s << "is_bigendian: ";
+    s << "  " << v.is_bigendian << std::endl;
+    s << "point_step: ";
+    s << "  " << v.point_step << std::endl;
+    s << "row_step: ";
+    s << "  " << v.row_step << std::endl;
+    s << "data[]" << std::endl;
+    for (std::size_t i = 0; i < v.data.size (); ++i)
+    {
+      s << "  data[" << i << "]: ";
+      s << "  " << v.data[i] << std::endl;
+    }
+    s << "is_dense: ";
+    s << "  " << v.is_dense << std::endl;
+
+    return (s);
+  }
+
+} // namespace oneapi 
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/PointIndices.h b/oneapi/common/include/pcl/oneapi/PointIndices.h
new file mode 100644
index 000000000..4b348dd99
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/PointIndices.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include <ostream>
+
+// Include the correct Header path here
+#include <pcl/PCLHeader.h>
+#include <pcl/oneapi/types.h>
+#include <pcl/PointIndices.h>
+#include <pcl/oneapi/containers/device_array.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  struct PointIndicesDev
+  {
+    using Ptr = shared_ptr< ::pcl::oneapi::PointIndicesDev>;
+    using ConstPtr = shared_ptr<const ::pcl::oneapi::PointIndicesDev>;
+
+    PointIndicesDev ()
+    {}
+
+    ::pcl::PCLHeader header;
+
+    ::pcl::PointIndices::Ptr getPointIndices()
+    {
+      ::pcl::PointIndices pti;
+
+      pti.header = header;
+      pti.indices.resize(indices.size());
+      indices.download(pti.indices);
+
+      return std::make_shared<::pcl::PointIndices>(pti);
+    }
+
+    using IndicesDev = pcl::oneapi::DeviceArray<index_t>;
+    IndicesDev indices;
+  }; // struct PointIndices
+
+  using PointIndicesDevPtr = PointIndicesDev::Ptr;
+  using PointIndicesDevConstPtr = PointIndicesDev::ConstPtr;
+
+
+  inline std::ostream& operator << (std::ostream& s, const PointIndicesDev &v)
+  {
+    s << "header: " << std::endl;
+    s << "  " << v.header;
+    s << "indices[]" << std::endl;
+    for (std::size_t i = 0; i < v.indices.size (); ++i)
+    {
+      s << "  indices[" << i << "]: ";
+      s << "  " << v.indices[i] << std::endl;
+    }
+    return (s);
+  }
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/common/centroid.h b/oneapi/common/include/pcl/oneapi/common/centroid.h
new file mode 100644
index 000000000..42c8946b2
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/centroid.h
@@ -0,0 +1,125 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <pcl/point_cloud.h>
+#include <pcl/point_types.h>
+#include <pcl/common/point_tests.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  //inline unsigned int
+  template<typename PointT> unsigned int
+  computeMeanAndCovarianceMatrix (
+    const PointCloudDev<PointT> &cloud,
+    const IndicesDev &indices,
+    Eigen::Matrix<float, 3, 3> &covariance_matrix,
+    Eigen::Matrix<float, 4, 1> &centroid)
+  {
+    // Shifted data/with estimate of mean. This gives very good accuracy and good performance.
+    // create the buffer on the stack which is much faster than using cloud[indices[i]] and centroid as a buffer
+    Eigen::Matrix<float, 1, 9, Eigen::RowMajor> accu = Eigen::Matrix<float, 1, 9, Eigen::RowMajor>::Zero ();
+    Eigen::Matrix<float, 3, 1> K(0.0, 0.0, 0.0);
+
+    for(const auto& index : indices)
+      if(isFinite(cloud[index])) {
+        K.x() = cloud[index].x; K.y() = cloud[index].y; K.z() = cloud[index].z; break;
+      }
+    std::size_t point_count;
+    if (cloud.is_dense)
+    {
+      point_count = indices.size ();
+      for (const auto &index : indices)
+      {
+        float x = cloud[index].x - K.x(), y = cloud[index].y - K.y(), z = cloud[index].z - K.z();
+        accu [0] += x * x;
+        accu [1] += x * y;
+        accu [2] += x * z;
+        accu [3] += y * y;
+        accu [4] += y * z;
+        accu [5] += z * z;
+        accu [6] += x;
+        accu [7] += y;
+        accu [8] += z;
+      }
+    }
+    else
+    {
+      point_count = 0;
+      for (const auto &index : indices)
+      {
+        if (!isFinite (cloud[index]))
+          continue;
+
+        ++point_count;
+        float x = cloud[index].x - K.x(), y = cloud[index].y - K.y(), z = cloud[index].z - K.z();
+        accu [0] += x * x;
+        accu [1] += x * y;
+        accu [2] += x * z;
+        accu [3] += y * y;
+        accu [4] += y * z;
+        accu [5] += z * z;
+        accu [6] += x;
+        accu [7] += y;
+        accu [8] += z;
+      }
+    }
+
+    if (point_count != 0)
+    {
+      accu /= static_cast<float> (point_count);
+      centroid[0] = accu[6] + K.x(); centroid[1] = accu[7] + K.y(); centroid[2] = accu[8] + K.z();
+      centroid[3] = 1;
+      covariance_matrix.coeffRef (0) = accu [0] - accu [6] * accu [6];
+      covariance_matrix.coeffRef (1) = accu [1] - accu [6] * accu [7];
+      covariance_matrix.coeffRef (2) = accu [2] - accu [6] * accu [8];
+      covariance_matrix.coeffRef (4) = accu [3] - accu [7] * accu [7];
+      covariance_matrix.coeffRef (5) = accu [4] - accu [7] * accu [8];
+      covariance_matrix.coeffRef (8) = accu [5] - accu [8] * accu [8];
+      covariance_matrix.coeffRef (3) = covariance_matrix.coeff (1);
+      covariance_matrix.coeffRef (6) = covariance_matrix.coeff (2);
+      covariance_matrix.coeffRef (7) = covariance_matrix.coeff (5);
+    }
+    return (static_cast<unsigned int> (point_count));
+  }
+
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/common/common.h b/oneapi/common/include/pcl/oneapi/common/common.h
new file mode 100644
index 000000000..bfdf5d381
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/common.h
@@ -0,0 +1,314 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#ifdef __SSE__
+#include <xmmintrin.h> // for __m128
+#endif // ifdef __SSE__
+#ifdef __AVX__
+#include <immintrin.h> // for __m256
+#endif // ifdef __AVX__
+
+#include <pcl/oneapi/types.h>
+#include <pcl/oneapi/point_cloud.h> // for PointCloud
+#include <pcl/oneapi/PointIndices.h> // for PointIndices
+namespace pcl { namespace oneapi { struct PCLPointCloud2; }}
+
+/**
+  * \file pcl/common/common.h
+  * Define standard C methods and C++ classes that are common to all methods
+  * \ingroup common
+  */
+
+/*@{*/
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Compute the smallest angle between two 3D vectors in radians (default) or degree.
+    * \param v1 the first 3D vector (represented as a \a Eigen::Vector4f)
+    * \param v2 the second 3D vector (represented as a \a Eigen::Vector4f)
+    * \param in_degree determine if angle should be in radians or degrees
+    * \return the angle between v1 and v2 in radians or degrees
+    * \note Handles rounding error for parallel and anti-parallel vectors
+    * \ingroup common
+    */
+  inline double
+  getAngle3D (const Eigen::Vector4f &v1, const Eigen::Vector4f &v2, const bool in_degree = false);
+
+  /** \brief Compute the smallest angle between two 3D vectors in radians (default) or degree.
+    * \param v1 the first 3D vector (represented as a \a Eigen::Vector3f)
+    * \param v2 the second 3D vector (represented as a \a Eigen::Vector3f)
+    * \param in_degree determine if angle should be in radians or degrees
+    * \return the angle between v1 and v2 in radians or degrees
+    * \ingroup common
+    */
+  inline double
+  getAngle3D (const Eigen::Vector3f &v1, const Eigen::Vector3f &v2, const bool in_degree = false);
+
+#ifdef __SSE__
+  /** \brief Compute the approximate arccosine of four values at once using SSE instructions.
+    *
+    * The approximation used is \f$ (1.59121552+x*(-0.15461442+x*0.05354897))*\sqrt{0.89286965-0.89282669*x}+0.06681017+x*(-0.09402311+x*0.02708663) \f$.
+    * The average error is 0.00012 rad. This approximation is more accurate than other approximations of acos, but also uses a few more operations.
+    * \param x four floats, each should be in [0; 1]. They must not be greater than 1 since acos is undefined there.
+    *          They should not be less than 0 because there the approximation is less precise
+    * \return the four arccosines, each in [0; pi/2]
+    * \ingroup common
+    */
+  inline __m128
+  acos_SSE (const __m128 &x);
+
+  /** \brief Similar to getAngle3D, but four times in parallel using SSE instructions.
+    *
+    * This behaves like \f$ min(getAngle3D(dot_product), \pi-getAngle3D(dot_product)) \f$.
+    * All vectors must be normalized (length is 1.0).
+    * Since an approximate acos is used, the results may be slightly imprecise.
+    * \param[in] the x components of the first four vectors
+    * \param[in] the y components of the first four vectors
+    * \param[in] the z components of the first four vectors
+    * \param[in] the x components of the second four vectors
+    * \param[in] the y components of the second four vectors
+    * \param[in] the z components of the second four vectors
+    * \return the four angles in radians in [0; pi/2]
+    * \ingroup common
+    */
+  inline __m128
+  getAcuteAngle3DSSE (const __m128 &x1, const __m128 &y1, const __m128 &z1, const __m128 &x2, const __m128 &y2, const __m128 &z2);
+#endif // ifdef __SSE__
+
+#ifdef __AVX__
+  /** \brief Compute the approximate arccosine of eight values at once using AVX instructions.
+    *
+    * The approximation used is \f$ (1.59121552+x*(-0.15461442+x*0.05354897))*\sqrt{0.89286965-0.89282669*x}+0.06681017+x*(-0.09402311+x*0.02708663) \f$.
+    * The average error is 0.00012 rad. This approximation is more accurate than other approximations of acos, but also uses a few more operations.
+    * \param x eight floats, each should be in [0; 1]. They must not be greater than 1 since acos is undefined there.
+    *          They should not be less than 0 because there the approximation is less precise
+    * \return the eight arccosines, each in [0; pi/2]
+    * \ingroup common
+    */
+  inline __m256
+  acos_AVX (const __m256 &x);
+
+  /** \brief Similar to getAngle3D, but eight times in parallel using AVX instructions.
+    *
+    * This behaves like \f$ min(getAngle3D(dot_product), \pi-getAngle3D(dot_product)) \f$.
+    * All vectors must be normalized (length is 1.0).
+    * Since an approximate acos is used, the results may be slightly imprecise.
+    * \param[in] the x components of the first eight vectors
+    * \param[in] the y components of the first eight vectors
+    * \param[in] the z components of the first eight vectors
+    * \param[in] the x components of the second eight vectors
+    * \param[in] the y components of the second eight vectors
+    * \param[in] the z components of the second eight vectors
+    * \return the eight angles in radians in [0; pi/2]
+    * \ingroup common
+    */
+  inline __m256
+  getAcuteAngle3DAVX (const __m256 &x1, const __m256 &y1, const __m256 &z1, const __m256 &x2, const __m256 &y2, const __m256 &z2);
+#endif // ifdef __AVX__
+
+  /** \brief Compute both the mean and the standard deviation of an array of values
+    * \param values the array of values
+    * \param mean the resultant mean of the distribution
+    * \param stddev the resultant standard deviation of the distribution
+    * \ingroup common
+    */
+  inline void
+  getMeanStd (const std::vector<float> &values, double &mean, double &stddev);
+
+  /** \brief Get a set of points residing in a box given its bounds
+    * \param cloud the point cloud data message
+    * \param min_pt the minimum bounds
+    * \param max_pt the maximum bounds
+    * \param indices the resultant set of point indices residing in the box
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getPointsInBox (const pcl::PointCloud<PointT> &cloud, Eigen::Vector4f &min_pt,
+                  Eigen::Vector4f &max_pt, Indices &indices);
+
+  /** \brief Get the point at maximum distance from a given point and a given pointcloud
+    * \param cloud the point cloud data message
+    * \param pivot_pt the point from where to compute the distance
+    * \param max_pt the point in cloud that is the farthest point away from pivot_pt
+    * \ingroup common
+    */
+  template<typename PointT> inline void
+  getMaxDistance (const pcl::PointCloud<PointT> &cloud, const Eigen::Vector4f &pivot_pt, Eigen::Vector4f &max_pt);
+
+  /** \brief Get the point at maximum distance from a given point and a given pointcloud
+    * \param cloud the point cloud data message
+    * \param indices the vector of point indices to use from \a cloud
+    * \param pivot_pt the point from where to compute the distance
+    * \param max_pt the point in cloud that is the farthest point away from pivot_pt
+    * \ingroup common
+    */
+  template<typename PointT> inline void
+  getMaxDistance (const pcl::PointCloud<PointT> &cloud, const Indices &indices,
+                  const Eigen::Vector4f &pivot_pt, Eigen::Vector4f &max_pt);
+
+  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud
+    * \param[in] cloud the point cloud data message
+    * \param[out] min_pt the resultant minimum bounds
+    * \param[out] max_pt the resultant maximum bounds
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getMinMax3D (const PointCloudDev<PointT> &cloud, PointT &min_pt, PointT &max_pt);
+
+  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud
+    * \param[in] cloud the point cloud data message
+    * \param[out] min_pt the resultant minimum bounds
+    * \param[out] max_pt the resultant maximum bounds
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getMinMax3D (const PointCloudDev<PointT> &cloud,
+               Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt);
+
+  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud
+    * \param[in] cloud the point cloud data message
+    * \param[in] indices the vector of point indices to use from \a cloud
+    * \param[out] min_pt the resultant minimum bounds
+    * \param[out] max_pt the resultant maximum bounds
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getMinMax3D (const PointCloudDev<PointT> &cloud, const IndicesDev &indices,
+               Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt);
+
+  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions in a given pointcloud
+    * \param[in] cloud the point cloud data message
+    * \param[in] indices the vector of point indices to use from \a cloud
+    * \param[out] min_pt the resultant minimum bounds
+    * \param[out] max_pt the resultant maximum bounds
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getMinMax3D (const PointCloudDev<PointT> &cloud, const pcl::PointIndices &indices,
+               Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt);
+
+  /** \brief Compute the radius of a circumscribed circle for a triangle formed of three points pa, pb, and pc
+    * \param pa the first point
+    * \param pb the second point
+    * \param pc the third point
+    * \return the radius of the circumscribed circle
+    * \ingroup common
+    */
+  template <typename PointT> inline double
+  getCircumcircleRadius (const PointT &pa, const PointT &pb, const PointT &pc);
+
+  /** \brief Get the minimum and maximum values on a point histogram
+    * \param histogram the point representing a multi-dimensional histogram
+    * \param len the length of the histogram
+    * \param min_p the resultant minimum 
+    * \param max_p the resultant maximum 
+    * \ingroup common
+    */
+  template <typename PointT> inline void
+  getMinMax (const PointT &histogram, int len, float &min_p, float &max_p);
+
+  /** \brief Calculate the area of a polygon given a point cloud that defines the polygon 
+	  * \param polygon point cloud that contains those vertices that comprises the polygon. Vertices are stored in counterclockwise.
+	  * \return the polygon area 
+	  * \ingroup common
+	  */
+  template<typename PointT> inline float
+  calculatePolygonArea (const pcl::PointCloud<PointT> &polygon);
+
+  /** \brief Get the minimum and maximum values on a point histogram
+    * \param cloud the cloud containing multi-dimensional histograms
+    * \param idx point index representing the histogram that we need to compute min/max for
+    * \param field_name the field name containing the multi-dimensional histogram
+    * \param min_p the resultant minimum 
+    * \param max_p the resultant maximum 
+    * \ingroup common
+    */
+  PCL_EXPORTS void
+  getMinMax (const pcl::oneapi::PCLPointCloud2 &cloud, int idx, const std::string &field_name,
+             float &min_p, float &max_p);
+
+  /** \brief Compute both the mean and the standard deviation of an array of values
+    * \param values the array of values
+    * \param mean the resultant mean of the distribution
+    * \param stddev the resultant standard deviation of the distribution
+    * \ingroup common
+    */
+  PCL_EXPORTS void
+  getMeanStdDev (const std::vector<float> &values, double &mean, double &stddev);
+
+  /** \brief Compute the median of a list of values (fast). If the number of values is even, take the mean of the two middle values.
+    * This function can be used like this:
+    * \code{.cpp}
+    * std::vector<double> vector{1.0, 25.0, 9.0, 4.0, 16.0};
+    * const double median = pcl::computeMedian (vector.begin (), vector.end (), static_cast<double(*)(double)>(std::sqrt)); // = 3
+    * \endcode
+    * \param[in,out] begin,end Iterators that mark the beginning and end of the value range. These values will be reordered!
+    * \param[in] f A lamda, function pointer, or similar that is implicitly applied to all values before median computation. In reality, it will be applied lazily (i.e. at most twice) and thus may not change the sorting order (e.g. monotonic functions like sqrt are allowed)
+    * \return the median
+    * \ingroup common
+    */
+  template<typename IteratorT, typename Functor> inline auto
+  computeMedian (IteratorT begin, IteratorT end, Functor f) noexcept -> typename std::result_of<Functor(decltype(*begin))>::type
+  {
+    const std::size_t size = std::distance(begin, end);
+    const std::size_t mid = size/2;
+    if (size%2==0)
+    { // Even number of values
+      std::nth_element (begin, begin + (mid-1), end);
+      return (f(begin[mid-1]) + f(*(std::min_element (begin + mid, end)))) / 2.0;
+    }
+    else
+    { // Odd number of values
+      std::nth_element (begin, begin + mid, end);
+      return f(begin[mid]);
+    }
+  }
+
+  /** \brief Compute the median of a list of values (fast). See the other overloaded function for more information.
+    */
+  template<typename IteratorT> inline auto
+  computeMedian (IteratorT begin, IteratorT end) noexcept -> typename std::iterator_traits<IteratorT>::value_type
+  {
+    return computeMedian (begin, end, [](const auto& x){return x;});
+  }
+}
+}
+/*@}*/
+#include <pcl/oneapi/common/impl/common.hpp>
diff --git a/oneapi/common/include/pcl/oneapi/common/copy_point.h b/oneapi/common/include/pcl/oneapi/common/copy_point.h
new file mode 100644
index 000000000..233b44c51
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/copy_point.h
@@ -0,0 +1,61 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2014-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Copy the fields of a source point into a target point.
+    *
+    * If the source and the target point types are the same, then a complete
+    * copy is made. Otherwise only those fields that the two point types share
+    * in common are copied.
+    *
+    * \param[in]  point_in the source point
+    * \param[out] point_out the target point
+    *
+    * \ingroup common */
+  template <typename PointInT, typename PointOutT> void
+  copyPoint (const PointInT& point_in, PointOutT& point_out);
+
+  template <typename PointT> void
+  copyPoint(const PointT& point_in, PointT& point_out);
+  }
+}
+#include <pcl/oneapi/common/impl/copy_point.hpp>
diff --git a/oneapi/common/include/pcl/oneapi/common/device/centroid.h b/oneapi/common/include/pcl/oneapi/common/device/centroid.h
new file mode 100644
index 000000000..acfe87bee
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/device/centroid.h
@@ -0,0 +1,104 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/common/device/matrix_types.h>
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace device
+{
+  template <typename PointT> __device_inline__ void
+  compute3DCentroid(const PointT* cloud, const int* indices,
+      const int start, const int end, sycl::float3 &centroid_out)
+  {
+    const int neighbour =  end - start;
+
+    if (neighbour == 0)
+      centroid_out = sycl::float3(cloud[indices[start]].x,
+                                  cloud[indices[start]].y,
+                                  cloud[indices[start]].z);
+
+
+    sycl::float3 centroid = sycl::float3(0.0f);
+    for (int i = start; i < end; i++)
+    {
+      centroid += sycl::float3(cloud[indices[i]].x,
+                               cloud[indices[i]].y,
+                               cloud[indices[i]].z);
+    }
+
+    centroid /= neighbour;
+
+    centroid_out = centroid;
+  }
+
+  template <typename PointT> __device_inline__ void
+  computeCovarianceMatrix(const PointT* cloud, const int* indices,
+      const int start, const int end, const sycl::float3 &centroid, matrix3x3f &covariance)
+  {
+    covariance.setZero();
+
+    for (int i = start; i < end; i++)
+    {
+      float3 pt;
+      float3 cloud_pt = sycl::float3(cloud[indices[i]].x, cloud[indices[i]].y, cloud[indices[i]].z);
+      pt = cloud_pt - centroid;
+
+
+      covariance[1].y() += pt.y() * pt.y();
+      covariance[1].z() += pt.y() * pt.z();
+      covariance[2].z() += pt.z() * pt.z();
+
+      pt *= pt.x();
+      covariance[0] += pt;
+    }
+
+    covariance[1].x() = covariance[0].y();
+    covariance[2].x() = covariance[0].z();
+    covariance[2].y() = covariance[1].z();
+  }
+
+} // namespace device
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/common/device/eigen.h b/oneapi/common/include/pcl/oneapi/common/device/eigen.h
new file mode 100644
index 000000000..5e98115f3
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/device/eigen.h
@@ -0,0 +1,231 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*/
+// This file is part of Eigen, a lightweight C++ template library
+// for linear algebra.
+//
+// Copyright (C) 2010 Gael Guennebaud <gael.guennebaud@inria.fr>
+//
+// Eigen is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Lesser General Public
+// License as published by the Free Software Foundation; either
+// version 3 of the License, or (at your option) any later version.
+//
+// Alternatively, you can redistribute it and/or
+// modify it under the terms of the GNU General Public License as
+// published by the Free Software Foundation; either version 2 of
+// the License, or (at your option) any later version.
+//
+// Eigen is distributed in the hope that it will be useful, but WITHOUT ANY
+// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+// FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License or the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License and a copy of the GNU General Public License along with
+// Eigen. If not, see <http://www.gnu.org/licenses/>.
+
+// The computeRoots function included in this is based on materials
+// covered by the following copyright and license:
+//
+// Geometric Tools, LLC
+// Copyright (c) 1998-2010
+// Distributed under the Boost Software License, Version 1.0.
+//
+// Permission is hereby granted, free of charge, to any person or organization
+// obtaining a copy of the software and accompanying documentation covered by
+// this license (the "Software") to use, reproduce, display, distribute,
+// execute, and transmit the Software, and to prepare derivative works of the
+// Software, and to permit third-parties to whom the Software is furnished to
+// do so, all subject to the following:
+//
+// The copyright notices in the Software and this entire statement, including
+// the above license grant, this restriction and the following disclaimer,
+// must be included in all copies of the Software, in whole or in part, and
+// all derivative works of the Software, unless such copies or derivative
+// works are solely in the form of machine-executable object code generated by
+// a source language processor.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
+// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
+// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
+// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+// DEALINGS IN THE SOFTWARE.
+
+#ifndef PCL_ONEAPI_DEVICE_EIGEN_H_
+#define PCL_ONEAPI_DEVICE_EIGEN_H_
+
+#include <pcl/oneapi/common/device/matrix_types.h>
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+using namespace sycl;
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace device
+{
+  __device_inline__ sycl::float3 getLargest3x3Vector(const matrix3x3f& m)
+  {
+    matrix3x3f crossProduct;
+
+    crossProduct[0] = sycl::cross(m[0], m[1]);
+    crossProduct[1] = sycl::cross(m[0], m[2]);
+    crossProduct[2] = sycl::cross(m[1], m[2]);
+
+    sycl::float3 len;
+    len.x() = sycl::length(crossProduct[0]);
+    len.y() = sycl::length(crossProduct[1]);
+    len.z() = sycl::length(crossProduct[2]);
+
+    int index = 0;
+    float length = sycl::fmax (sycl::fmax (len.x(), len.y()),len.z());
+    for (int i = 0; i < 3; i++)
+    {
+      if (length == len[i])
+        index = i;
+    }
+
+    return crossProduct[index] / length;
+  }
+
+  __device_inline__ void computeRoots2(const float& b, const float& c, sycl::float3& roots)
+  {
+    roots.x() = 0.0f;
+    float d = b * b - 4.0f * c;
+    if (d < 0.0f) // no real roots!!!! THIS SHOULD NOT HAPPEN!
+      d = 0.0f;
+
+    const float sd = sycl::sqrt (d);
+
+    roots.z() = 0.5f * (b + sd);
+    roots.y() = 0.5f * (b - sd);
+  }
+
+  __device_inline__ void computeRoots(const matrix3x3f& m, sycl::float3& roots)
+  {
+    // The characteristic equation is x^3 - c2*x^2 + c1*x - c0 = 0.  The
+    // eigenvalues are the roots to this equation, all guaranteed to be
+    // real-valued, because the matrix is symmetric.
+
+    float  c0 =          m[0].x()*m[1].y()*m[2].z()
+                + 2.0f * m[0].y()*m[0].z()*m[1].z()
+                         - m[0].x()*m[1].z()*m[1].z()
+                         - m[1].y()*m[0].z()*m[0].z()
+                         - m[2].z()*m[0].y()*m[0].y();
+    float  c1 = m[0].x()*m[1].y() -
+                m[0].y()*m[0].y() +
+                m[0].x()*m[2].z() -
+                m[0].z()*m[0].z() +
+                m[1].y()*m[2].z() -
+                m[1].z()*m[1].z();
+    float  c2 = m[0].x() + m[1].y() + m[2].z();
+
+    if (sycl::fabs(c0) < std::numeric_limits<float>::epsilon())
+      computeRoots2 (c2, c1, roots);
+    else
+    {
+      const float  s_inv3 = 1.0f/3.0f;
+      const float  s_sqrt3 = sqrtf (3.0f);
+      // Construct the parameters used in classifying the roots of the equation
+      // and in solving the equation for the roots in closed form.
+      float c2_over_3 = c2 * s_inv3;
+      float a_over_3 = (c1 - c2 * c2_over_3) * s_inv3;
+      if (a_over_3 > 0.0f)
+        a_over_3 = 0.0f;
+
+      float half_b = 0.5f * (c0 + c2_over_3 * (2.0f * c2_over_3 * c2_over_3 - c1));
+
+      float q = half_b * half_b + a_over_3 * a_over_3 * a_over_3;
+      if (q > 0.0f)
+        q = 0.0f;
+
+      // Compute the eigenvalues by solving for the roots of the polynomial.
+      float rho = sycl::sqrt (-a_over_3);
+      float theta = sycl::atan2 (sycl::sqrt (-q), half_b) * s_inv3;
+      float cos_theta = sycl::cos (theta);
+      float sin_theta = sycl::sin (theta);
+      roots.x() = c2_over_3 + 2.f * rho * cos_theta;
+      roots.y() = c2_over_3 - rho * (cos_theta + s_sqrt3 * sin_theta);
+      roots.z() = c2_over_3 - rho * (cos_theta - s_sqrt3 * sin_theta);
+
+      // Sort in increasing order.
+      if (roots.x() >= roots.y())
+        std::swap (roots.x(), roots.y());
+      if (roots.y() >= roots.z())
+      {
+        std::swap (roots.y(), roots.z());
+        if (roots.x() >= roots.y())
+          std::swap (roots.x(), roots.y());
+      }
+
+      if (roots.x() <= 0.0f) // eigenval for symmetric positive semi-definite matrix can not be negative! Set it to 0
+        computeRoots2 (c2, c1, roots);
+    }
+  }
+
+  __device_inline__ void eigen33(const matrix3x3f& mat, float& eigen_value, sycl::float3& eigen_vector)
+  {
+    //Scalar scale = mat.cwiseAbs ().maxCoeff ();
+    sycl::float3 scale_tmp = sycl::fmax (sycl::fmax (sycl::fabs (mat[0]), sycl::fabs (mat[1])), sycl::fabs (mat[2]));
+    float scale = sycl::fmax (sycl::fmax (scale_tmp.x(), scale_tmp.y()), scale_tmp.z());
+
+    if (scale <= std::numeric_limits<float>::min())
+      scale = 1.0f;
+
+    matrix3x3f scaledMat;
+    scaledMat[0] = mat[0] / scale;
+    scaledMat[1] = mat[1] / scale;
+    scaledMat[2] = mat[2] / scale;
+
+    sycl::float3 eigenValues;
+    computeRoots (scaledMat, eigenValues);
+
+    eigen_value = eigenValues.x() * scale;
+
+    scaledMat[0].x() -= eigenValues.x();
+    scaledMat[1].y() -= eigenValues.x();
+    scaledMat[2].z() -= eigenValues.x();
+    eigen_vector = getLargest3x3Vector(scaledMat);
+  }
+
+};
+};
+};
+
+#endif // PCL_ONEAPI_DEVICE_EIGEN_H_
+
diff --git a/oneapi/common/include/pcl/oneapi/common/device/matrix_types.h b/oneapi/common/include/pcl/oneapi/common/device/matrix_types.h
new file mode 100644
index 000000000..50f9e15a8
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/device/matrix_types.h
@@ -0,0 +1,166 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef PCL_ONEAPI_DEVICE_MATRIX_TYPES_H_
+#define PCL_ONEAPI_DEVICE_MATRIX_TYPES_H_
+
+#include <pcl/oneapi/common/device/vector_types.h>
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace device
+{
+  template<typename T, int rows, typename RT = float>
+  struct GenericMatrix
+  {
+    T data[rows];
+
+    __device_inline__
+    void setZero()
+    {
+      for (int i = 0; i < rows; i++)
+      {
+        data[i] = (T)(0.0);
+      }
+    }
+
+    __device_inline__
+    T getFactor2x2(T& rowA, T& rowB)
+    {
+      T factor;
+      factor.x() = rowA.y() * rowB.z() - rowA.z() * rowB.y();
+      factor.y() = rowA.x() * rowB.z() - rowA.z() * rowB.x();
+      factor.z() = rowA.x() * rowB.y() - rowA.y() * rowB.x();
+
+      return factor;
+    }
+
+    __device_inline__
+    GenericMatrix<T, rows, RT> inverse2x2()
+    {
+      GenericMatrix<T, rows, RT> m;
+
+      RT det = data[0].x() * data[1].y() - data[0].y() * data[1].x();
+      if (det != 0.0f)
+      {
+        m.data[0] = {data[1].y(), data[1].x() * -1};
+        m.data[1] = {data[0].y() * -1, data[0].x()};
+        m.data[0] /= det;
+        m.data[1] /= det;
+      }
+      return m;
+    }
+
+    __device_inline__
+    GenericMatrix<T, rows, RT> inverse3x3()
+    {
+      GenericMatrix<T, rows, RT> m;
+      // Find cofactor
+      T factor0 = getFactor2x2(data[1], data[2]);
+      T factor1 = getFactor2x2(data[0], data[2]);
+      T factor2 = getFactor2x2(data[0], data[1]);
+
+      factor0 *= {1, -1, 1};
+      factor1 *= {-1, 1, -1};
+      factor2 *= {1, -1, 1};
+
+      // Get Determinate
+      T detA = data[0] * factor0;
+      RT det = detA.x() + detA.y() + detA.z();
+
+      // Transpose
+      if (det != 0.0f)
+      {
+        T factorT0 = {factor0.x(), factor1.x(), factor2.x()};
+        T factorT1 = {factor0.y(), factor1.y(), factor2.y()};
+        T factorT2 = {factor0.z(), factor1.z(), factor2.z()};
+
+        m.data[0] = factorT0 / det;
+        m.data[1] = factorT1 / det;
+        m.data[2] = factorT2 / det;
+      }
+
+      return m;
+    }
+
+    // TO be implement
+      __device_inline__
+    void inverse4x4(GenericMatrix<T, rows, RT> &rhs)
+    {
+      (void)rhs;
+    }
+
+    __device_inline__
+    RT trace3x3() { return data[0].x() + data[1].y() + data[2].z(); }
+
+    __device_inline__
+    GenericVector<T, RT> operator * (const GenericVector<sycl::float3, RT> &rhs)
+    {
+      T s0 = data[0] * rhs.data.x();
+      T s1 = data[1] * rhs.data.y();
+      T s2 = data[2] * rhs.data.z();
+
+      GenericVector<T, RT> nvec (s0.x() + s0.y() + s0.z(),
+                                s1.x() + s1.y() + s1.z(),
+                                s2.x() + s2.y() + s2.z());
+
+      return nvec;
+    }
+
+    __device_inline__
+    GenericVector<T, RT> operator * (const GenericVector<sycl::float2, RT> &rhs)
+    {
+      GenericVector<T, RT> nvec (data[0].x() * rhs.data.x() + data[0].y() * rhs.data.y(),
+                                 data[1].x() * rhs.data.x() + data[1].y() * rhs.data.y());
+
+      return nvec;
+    }
+
+    __device_inline__ T& operator[](int i) { return data[i]; }
+    __device_inline__ const T& operator[](int i) const { return data[i]; }
+  };
+};
+};
+};
+
+using matrix2x2f = pcl::oneapi::device::GenericMatrix<sycl::float2, 2>;
+using matrix3x3f = pcl::oneapi::device::GenericMatrix<sycl::float3, 3>;
+using matrix4x4f = pcl::oneapi::device::GenericMatrix<sycl::float4, 4>;
+
+#endif
+
diff --git a/oneapi/common/include/pcl/oneapi/common/device/vector_types.h b/oneapi/common/include/pcl/oneapi/common/device/vector_types.h
new file mode 100644
index 000000000..9145b0df1
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/device/vector_types.h
@@ -0,0 +1,155 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef PCL_ONEAPI_DEVICE_VECTOR_TYPES_H_
+#define PCL_ONEAPI_DEVICE_VECTOR_TYPES_H_
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace device
+{
+  template<typename T, typename RT = float>
+  struct GenericVector
+  {
+    T data;
+
+    __device_inline__
+    GenericVector() { }
+
+    __device_inline__
+    GenericVector(RT x, RT y) { data = {x,y}; }
+
+    __device_inline__
+    GenericVector(RT x, RT y, RT z) { data = {x,y,z}; }
+
+    __device_inline__
+    GenericVector(sycl::float3 xyz, RT w) { data = {xyz.x(),xyz.y(),xyz.z(),w}; }
+
+    __device_inline__
+    GenericVector(T rhs) { data = rhs; }
+
+    __device_inline__
+    RT x() { return data.x(); }
+
+    __device_inline__
+    RT y() { return data.y(); }
+
+    __device_inline__
+    RT z() { return data.z(); }
+
+    __device_inline__
+    RT w() { return data.w(); }
+
+    __device_inline__
+    void normalize() { data = sycl::normalize(data); }
+
+    __device_inline__
+    RT dot(const T &rhs) { return sycl::dot(data, rhs); }
+
+    __device_inline__
+    T cross(const T &rhs) { return sycl::cross(data, rhs); }
+
+    __device_inline__ bool isMuchSmallerThan(float x, float y)
+    {
+      float prec_sqr = std::numeric_limits<float>::epsilon() *
+                      std::numeric_limits<float>::epsilon();
+      return x * x <= prec_sqr * y * y;
+    }
+
+    __device_inline__
+    T unitOrthogonal (void)
+    {
+      T perp;
+
+      if ((!isMuchSmallerThan(data.x(), data.z()))
+        ||  (!isMuchSmallerThan(data.y(), data.z())))
+      {
+        sycl::float2 src2 = {data.x(), data.y()};
+        float invnm = 1.0f / sycl::length(src2);
+        perp.x() = -data.y() * invnm;
+        perp.y() = data.x() * invnm;
+        perp.z() = 0.0;
+      }
+      /* if both x and y are close to zero, then the vector is close
+       * to the z-axis, so it's far from colinear to the x-axis for instance
+       * So we take the crossed product with (1,0,0) and normalize it.
+       */
+      else
+      {
+        sycl::float2 src2 = {data.y(), data.z()};
+        float invnm = 1.0f / sycl::length(src2);
+        perp.x() = 0.0f;
+        perp.y() = -data.z() * invnm;
+        perp.z() = data.y() * invnm;
+      }
+      return perp;
+    }
+
+    __device_inline__
+    void operator+=(const RT rhs) { data += rhs; }
+
+    __device_inline__
+    void operator+=(const T& rhs) { data += rhs; }
+
+    __device_inline__
+    void operator-=(const RT rhs) { data -= rhs; }
+
+    __device_inline__
+    void operator-=(const T rhs) { data -= rhs; }
+
+    __device_inline__
+    void operator *(const RT rhs) { data * rhs; }
+
+    __device_inline__
+    void operator=(const T &rhs) { data = rhs; }
+
+    __device_inline__
+    operator T() const { return data; }
+  };
+};
+};
+};
+
+using vec2f = pcl::oneapi::device::GenericVector<sycl::float2>;
+using vec3f = pcl::oneapi::device::GenericVector<sycl::float3>;
+using vec4f = pcl::oneapi::device::GenericVector<sycl::float4>;
+using vec2d = pcl::oneapi::device::GenericVector<sycl::double2, double>;
+using vec3d = pcl::oneapi::device::GenericVector<sycl::double3, double>;
+using vec4d = pcl::oneapi::device::GenericVector<sycl::double4, double>;
+
+#endif //PCL_ONEAPI_DEVICE_VECTOR_TYPES_H_
diff --git a/oneapi/common/include/pcl/oneapi/common/impl/common.hpp b/oneapi/common/include/pcl/oneapi/common/impl/common.hpp
new file mode 100644
index 000000000..f61fe4943
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/impl/common.hpp
@@ -0,0 +1,441 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_COMMON_IMPL_H_
+#define PCL_ONEAPI_COMMON_IMPL_H_
+
+#include <pcl/point_types.h>
+#include <pcl/oneapi/types.h>
+#include <pcl/oneapi/common/common.h>
+#include <cfloat> // for FLT_MAX
+
+namespace pcl
+{
+namespace oneapi
+{
+//////////////////////////////////////////////////////////////////////////////////////////////
+inline double
+getAngle3D (const Eigen::Vector4f &v1, const Eigen::Vector4f &v2, const bool in_degree)
+{
+  // Compute the actual angle
+  double rad = v1.normalized ().dot (v2.normalized ());
+  if (rad < -1.0)
+    rad = -1.0;
+  else if (rad >  1.0)
+    rad = 1.0;
+  return (in_degree ? std::acos (rad) * 180.0 / M_PI : std::acos (rad));
+}
+
+inline double
+getAngle3D (const Eigen::Vector3f &v1, const Eigen::Vector3f &v2, const bool in_degree)
+{
+  // Compute the actual angle
+  double rad = v1.normalized ().dot (v2.normalized ());
+  if (rad < -1.0)
+    rad = -1.0;
+  else if (rad >  1.0)
+    rad = 1.0;
+  return (in_degree ? std::acos (rad) * 180.0 / M_PI : std::acos (rad));
+}
+
+#ifdef __SSE__
+inline __m128
+acos_SSE (const __m128 &x)
+{
+  /*
+  This python code generates the coefficients:
+  import math, numpy, scipy.optimize
+  def get_error(S):
+      err_sum=0.0
+      for x in numpy.arange(0.0, 1.0, 0.0025):
+          if (S[3]+S[4]*x)<0.0:
+              err_sum+=10.0
+          else:
+              err_sum+=((S[0]+x*(S[1]+x*S[2]))*numpy.sqrt(S[3]+S[4]*x)+S[5]+x*(S[6]+x*S[7])-math.acos(x))**2.0
+      return err_sum/400.0
+
+  print(scipy.optimize.minimize(fun=get_error, x0=[1.57, 0.0, 0.0, 1.0, -1.0, 0.0, 0.0, 0.0], method='Nelder-Mead', options={'maxiter':42000, 'maxfev':42000, 'disp':True, 'xatol':1e-6, 'fatol':1e-6}))
+  */
+  const __m128 mul_term = _mm_add_ps (_mm_set1_ps (1.59121552f), _mm_mul_ps (x, _mm_add_ps (_mm_set1_ps (-0.15461442f), _mm_mul_ps (x, _mm_set1_ps (0.05354897f)))));
+  const __m128 add_term = _mm_add_ps (_mm_set1_ps (0.06681017f), _mm_mul_ps (x, _mm_add_ps (_mm_set1_ps (-0.09402311f), _mm_mul_ps (x, _mm_set1_ps (0.02708663f)))));
+  return _mm_add_ps (_mm_mul_ps (mul_term, _mm_sqrt_ps (_mm_add_ps (_mm_set1_ps (0.89286965f), _mm_mul_ps (_mm_set1_ps (-0.89282669f), x)))), add_term);
+}
+
+inline __m128
+getAcuteAngle3DSSE (const __m128 &x1, const __m128 &y1, const __m128 &z1, const __m128 &x2, const __m128 &y2, const __m128 &z2)
+{
+  const __m128 dot_product = _mm_add_ps (_mm_add_ps (_mm_mul_ps (x1, x2), _mm_mul_ps (y1, y2)), _mm_mul_ps (z1, z2));
+  // The andnot-function realizes an abs-operation: the sign bit is removed
+  // -0.0f (negative zero) means that all bits are 0, only the sign bit is 1
+  return acos_SSE (_mm_min_ps (_mm_set1_ps (1.0f), _mm_andnot_ps (_mm_set1_ps (-0.0f), dot_product)));
+}
+#endif // ifdef __SSE__
+
+#ifdef __AVX__
+inline __m256
+acos_AVX (const __m256 &x)
+{
+  const __m256 mul_term = _mm256_add_ps (_mm256_set1_ps (1.59121552f), _mm256_mul_ps (x, _mm256_add_ps (_mm256_set1_ps (-0.15461442f), _mm256_mul_ps (x, _mm256_set1_ps (0.05354897f)))));
+  const __m256 add_term = _mm256_add_ps (_mm256_set1_ps (0.06681017f), _mm256_mul_ps (x, _mm256_add_ps (_mm256_set1_ps (-0.09402311f), _mm256_mul_ps (x, _mm256_set1_ps (0.02708663f)))));
+  return _mm256_add_ps (_mm256_mul_ps (mul_term, _mm256_sqrt_ps (_mm256_add_ps (_mm256_set1_ps (0.89286965f), _mm256_mul_ps (_mm256_set1_ps (-0.89282669f), x)))), add_term);
+}
+
+inline __m256
+getAcuteAngle3DAVX (const __m256 &x1, const __m256 &y1, const __m256 &z1, const __m256 &x2, const __m256 &y2, const __m256 &z2)
+{
+  const __m256 dot_product = _mm256_add_ps (_mm256_add_ps (_mm256_mul_ps (x1, x2), _mm256_mul_ps (y1, y2)), _mm256_mul_ps (z1, z2));
+  // The andnot-function realizes an abs-operation: the sign bit is removed
+  // -0.0f (negative zero) means that all bits are 0, only the sign bit is 1
+  return acos_AVX (_mm256_min_ps (_mm256_set1_ps (1.0f), _mm256_andnot_ps (_mm256_set1_ps (-0.0f), dot_product)));
+}
+#endif // ifdef __AVX__
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+inline void
+getMeanStd (const std::vector<float> &values, double &mean, double &stddev)
+{
+  // throw an exception when the input array is empty
+  if (values.empty ())
+  {
+    PCL_THROW_EXCEPTION (BadArgumentException, "Input array must have at least 1 element."); 
+  }
+
+  // when the array has only one element, mean is the number itself and standard dev is 0
+  if (values.size () == 1)
+  {
+    mean = values.at (0);
+    stddev = 0;
+    return;
+  }
+
+  double sum = 0, sq_sum = 0;
+
+  for (const float &value : values)
+  {
+    sum += value;
+    sq_sum += value * value;
+  }
+  mean = sum / static_cast<double>(values.size ());
+  double variance = (sq_sum - sum * sum / static_cast<double>(values.size ())) / (static_cast<double>(values.size ()) - 1);
+  stddev = sqrt (variance);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getPointsInBox (const pcl::PointCloud<PointT> &cloud, 
+                     Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt,
+                     Indices &indices)
+{
+  indices.resize (cloud.size ());
+  int l = 0;
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud.is_dense)
+  {
+    for (std::size_t i = 0; i < cloud.size (); ++i)
+    {
+      // Check if the point is inside bounds
+      if (cloud[i].x < min_pt[0] || cloud[i].y < min_pt[1] || cloud[i].z < min_pt[2])
+        continue;
+      if (cloud[i].x > max_pt[0] || cloud[i].y > max_pt[1] || cloud[i].z > max_pt[2])
+        continue;
+      indices[l++] = int (i);
+    }
+  }
+  // NaN or Inf values could exist => check for them
+  else
+  {
+    for (std::size_t i = 0; i < cloud.size (); ++i)
+    {
+      // Check if the point is invalid
+      if (!std::isfinite (cloud[i].x) ||
+          !std::isfinite (cloud[i].y) ||
+          !std::isfinite (cloud[i].z))
+        continue;
+      // Check if the point is inside bounds
+      if (cloud[i].x < min_pt[0] || cloud[i].y < min_pt[1] || cloud[i].z < min_pt[2])
+        continue;
+      if (cloud[i].x > max_pt[0] || cloud[i].y > max_pt[1] || cloud[i].z > max_pt[2])
+        continue;
+      indices[l++] = int (i);
+    }
+  }
+  indices.resize (l);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template<typename PointT> inline void
+getMaxDistance (const pcl::PointCloud<PointT> &cloud, const Eigen::Vector4f &pivot_pt, Eigen::Vector4f &max_pt)
+{
+  float max_dist = -FLT_MAX;
+  int max_idx = -1;
+  float dist;
+  const Eigen::Vector3f pivot_pt3 = pivot_pt.head<3> ();
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud.is_dense)
+  {
+    for (std::size_t i = 0; i < cloud.size (); ++i)
+    {
+      pcl::Vector3fMapConst pt = cloud[i].getVector3fMap ();
+      dist = (pivot_pt3 - pt).norm ();
+      if (dist > max_dist)
+      {
+        max_idx = int (i);
+        max_dist = dist;
+      }
+    }
+  }
+  // NaN or Inf values could exist => check for them
+  else
+  {
+    for (std::size_t i = 0; i < cloud.size (); ++i)
+    {
+      // Check if the point is invalid
+      if (!std::isfinite (cloud[i].x) || !std::isfinite (cloud[i].y) || !std::isfinite (cloud[i].z))
+        continue;
+      pcl::Vector3fMapConst pt = cloud[i].getVector3fMap ();
+      dist = (pivot_pt3 - pt).norm ();
+      if (dist > max_dist)
+      {
+        max_idx = int (i);
+        max_dist = dist;
+      }
+    }
+  }
+
+  if(max_idx != -1)
+    max_pt = cloud[max_idx].getVector4fMap ();
+  else
+    max_pt = Eigen::Vector4f(std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN());
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template<typename PointT> inline void
+getMaxDistance (const pcl::PointCloud<PointT> &cloud, const Indices &indices,
+                     const Eigen::Vector4f &pivot_pt, Eigen::Vector4f &max_pt)
+{
+  float max_dist = -FLT_MAX;
+  int max_idx = -1;
+  float dist;
+  const Eigen::Vector3f pivot_pt3 = pivot_pt.head<3> ();
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud.is_dense)
+  {
+    for (std::size_t i = 0; i < indices.size (); ++i)
+    {
+      pcl::Vector3fMapConst pt = cloud[indices[i]].getVector3fMap ();
+      dist = (pivot_pt3 - pt).norm ();
+      if (dist > max_dist)
+      {
+        max_idx = static_cast<int> (i);
+        max_dist = dist;
+      }
+    }
+  }
+  // NaN or Inf values could exist => check for them
+  else
+  {
+    for (std::size_t i = 0; i < indices.size (); ++i)
+    {
+      // Check if the point is invalid
+      if (!std::isfinite (cloud[indices[i]].x) || !std::isfinite (cloud[indices[i]].y)
+          ||
+          !std::isfinite (cloud[indices[i]].z))
+        continue;
+
+      pcl::Vector3fMapConst pt = cloud[indices[i]].getVector3fMap ();
+      dist = (pivot_pt3 - pt).norm ();
+      if (dist > max_dist)
+      {
+        max_idx = static_cast<int> (i);
+        max_dist = dist;
+      }
+    }
+  }
+
+  if(max_idx != -1)
+    max_pt = cloud[indices[max_idx]].getVector4fMap ();
+  else
+    max_pt = Eigen::Vector4f(std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN(),std::numeric_limits<float>::quiet_NaN());
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getMinMax3D (const PointCloudDev<PointT> &cloud, PointT &min_pt, PointT &max_pt)
+{
+  Eigen::Vector4f min_p, max_p;
+  getMinMax3D (cloud, min_p, max_p);
+  min_pt.x = min_p[0]; min_pt.y = min_p[1]; min_pt.z = min_p[2];
+  max_pt.x = max_p[0]; max_pt.y = max_p[1]; max_pt.z = max_p[2];
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getMinMax3D (const PointCloudDev<PointT> &cloud, Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt)
+{
+  min_pt.setConstant (FLT_MAX);
+  max_pt.setConstant (-FLT_MAX);
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud.is_dense)
+  {
+    for (const auto& point: cloud.points)
+    {
+      const pcl::Vector4fMapConst pt = point.getVector4fMap ();
+      min_pt = min_pt.cwiseMin (pt);
+      max_pt = max_pt.cwiseMax (pt);
+    }
+  }
+  // NaN or Inf values could exist => check for them
+  else
+  {
+    for (const auto& point: cloud.points)
+    {
+      // Check if the point is invalid
+      if (!std::isfinite (point.x) ||
+          !std::isfinite (point.y) ||
+          !std::isfinite (point.z))
+        continue;
+      const pcl::Vector4fMapConst pt = point.getVector4fMap ();
+      min_pt = min_pt.cwiseMin (pt);
+      max_pt = max_pt.cwiseMax (pt);
+    }
+  }
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getMinMax3D (const PointCloudDev<PointT> &cloud, const pcl::PointIndices &indices,
+                  Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt)
+{
+  getMinMax3D (cloud, indices.indices, min_pt, max_pt);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getMinMax3D (const PointCloudDev<PointT> &cloud, const IndicesDev &indices,
+                  Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt)
+{
+  min_pt.setConstant (FLT_MAX);
+  max_pt.setConstant (-FLT_MAX);
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud.is_dense)
+  {
+    for (const auto &index : indices)
+    {
+      const pcl::Vector4fMapConst pt = cloud[index].getVector4fMap ();
+      min_pt = min_pt.cwiseMin (pt);
+      max_pt = max_pt.cwiseMax (pt);
+    }
+  }
+  // NaN or Inf values could exist => check for them
+  else
+  {
+    for (const auto &index : indices)
+    {
+      // Check if the point is invalid
+      if (!std::isfinite (cloud[index].x) ||
+          !std::isfinite (cloud[index].y) ||
+          !std::isfinite (cloud[index].z))
+        continue;
+      const pcl::Vector4fMapConst pt = cloud[index].getVector4fMap ();
+      min_pt = min_pt.cwiseMin (pt);
+      max_pt = max_pt.cwiseMax (pt);
+    }
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline double
+getCircumcircleRadius (const PointT &pa, const PointT &pb, const PointT &pc)
+{
+  Eigen::Vector4f p1 (pa.x, pa.y, pa.z, 0);
+  Eigen::Vector4f p2 (pb.x, pb.y, pb.z, 0);
+  Eigen::Vector4f p3 (pc.x, pc.y, pc.z, 0);
+
+  double p2p1 = (p2 - p1).norm (), p3p2 = (p3 - p2).norm (), p1p3 = (p1 - p3).norm ();
+  // Calculate the area of the triangle using Heron's formula 
+  // (http://en.wikipedia.org/wiki/Heron's_formula)
+  double semiperimeter = (p2p1 + p3p2 + p1p3) / 2.0;
+  double area = sqrt (semiperimeter * (semiperimeter - p2p1) * (semiperimeter - p3p2) * (semiperimeter - p1p3));
+  // Compute the radius of the circumscribed circle
+  return ((p2p1 * p3p2 * p1p3) / (4.0 * area));
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+getMinMax (const PointT &histogram, int len, float &min_p, float &max_p)
+{
+  min_p = FLT_MAX;
+  max_p = -FLT_MAX;
+
+  for (int i = 0; i < len; ++i)
+  {
+    min_p = (histogram[i] > min_p) ? min_p : histogram[i];
+    max_p = (histogram[i] < max_p) ? max_p : histogram[i];
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline float
+calculatePolygonArea (const pcl::PointCloud<PointT> &polygon)
+{
+  float area = 0.0f;
+  int num_points = polygon.size ();
+  Eigen::Vector3f va,vb,res;
+
+  res(0) = res(1) = res(2) = 0.0f;
+  for (int i = 0; i < num_points; ++i)
+  {
+    int j = (i + 1) % num_points;
+    va = polygon[i].getVector3fMap ();
+    vb = polygon[j].getVector3fMap ();
+    res += va.cross (vb);
+  }
+  area = res.norm ();
+  return (area*0.5);
+}
+
+}
+}
+
+#endif  //#ifndef PCL_ONEAPI_COMMON_IMPL_H_
+
diff --git a/oneapi/common/include/pcl/oneapi/common/impl/copy_point.hpp b/oneapi/common/include/pcl/oneapi/common/impl/copy_point.hpp
new file mode 100644
index 000000000..a716f26af
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/impl/copy_point.hpp
@@ -0,0 +1,152 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2014-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <pcl/point_types.h>
+#include <pcl/type_traits.h>
+#include <pcl/for_each_type.h>
+#include <pcl/common/concatenate.h>
+#include <pcl/common/copy_point.h>
+
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace detail
+{
+
+/* CopyPointHelper and its specializations copy the contents of a source
+ * point to a target point. There are three cases:
+ *
+ *  - Points have the same type.
+ *    In this case a single `memcpy` is used.
+ *
+ *  - Points have different types and one of the following is true:
+ *      * both have RGB fields;
+ *      * both have RGBA fields;
+ *      * one or both have no RGB/RGBA fields.
+ *    In this case we find the list of common fields and copy their
+ *    contents one by one with `NdConcatenateFunctor`.
+ *
+ *  - Points have different types and one of these types has RGB field, and
+ *    the other has RGBA field.
+ *    In this case we also find the list of common fields and copy their
+ *    contents. In order to account for the fact that RGB and RGBA do not
+ *    match we have an additional `memcpy` to copy the contents of one into
+ *    another.
+ *
+ * An appropriate version of CopyPointHelper is instantiated during
+ * compilation time automatically, so there is absolutely no run-time
+ * overhead. */
+
+template <typename PointInT, typename PointOutT, typename Enable = void>
+struct CopyPointHelper { };
+
+template <typename PointInT, typename PointOutT>
+struct CopyPointHelper<PointInT, PointOutT, std::enable_if_t<std::is_same<PointInT, PointOutT>::value>>
+{
+  void operator () (const PointInT& point_in, PointOutT& point_out) const
+  {
+    memcpy (&point_out, &point_in, sizeof (PointInT));
+  }
+};
+
+template <typename PointInT, typename PointOutT>
+struct CopyPointHelper<PointInT, PointOutT,
+                       std::enable_if_t<boost::mpl::and_<boost::mpl::not_<std::is_same<PointInT, PointOutT>>,
+                                                         boost::mpl::or_<boost::mpl::not_<pcl::traits::has_color<PointInT>>,
+                                                                         boost::mpl::not_<pcl::traits::has_color<PointOutT>>,
+                                                                         boost::mpl::and_<pcl::traits::has_field<PointInT, pcl::fields::rgb>,
+                                                                                          pcl::traits::has_field<PointOutT, pcl::fields::rgb>>,
+                                                                         boost::mpl::and_<pcl::traits::has_field<PointInT, pcl::fields::rgba>,
+                                                                                          pcl::traits::has_field<PointOutT, pcl::fields::rgba>>>>::value>>
+{
+  void operator () (const PointInT& point_in, PointOutT& point_out) const
+  {
+    using FieldListInT = typename pcl::traits::fieldList<PointInT>::type;
+    using FieldListOutT = typename pcl::traits::fieldList<PointOutT>::type;
+    using FieldList = typename pcl::intersect<FieldListInT, FieldListOutT>::type;
+    pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointInT, PointOutT> (point_in, point_out));
+  }
+};
+
+template <typename PointInT, typename PointOutT>
+struct CopyPointHelper<PointInT, PointOutT,
+                       std::enable_if_t<boost::mpl::and_<boost::mpl::not_<std::is_same<PointInT, PointOutT>>,
+                                        boost::mpl::or_<boost::mpl::and_<pcl::traits::has_field<PointInT, pcl::fields::rgb>,
+                                                                         pcl::traits::has_field<PointOutT, pcl::fields::rgba>>,
+                                                        boost::mpl::and_<pcl::traits::has_field<PointInT, pcl::fields::rgba>,
+                                                                         pcl::traits::has_field<PointOutT, pcl::fields::rgb>>>>::value>>
+{
+  void operator () (const PointInT& point_in, PointOutT& point_out) const
+  {
+    using FieldListInT = typename pcl::traits::fieldList<PointInT>::type;
+    using FieldListOutT = typename pcl::traits::fieldList<PointOutT>::type;
+    using FieldList = typename pcl::intersect<FieldListInT, FieldListOutT>::type;
+    const std::uint32_t offset_in  = boost::mpl::if_<pcl::traits::has_field<PointInT, pcl::fields::rgb>,
+                                                pcl::traits::offset<PointInT, pcl::fields::rgb>,
+                                                pcl::traits::offset<PointInT, pcl::fields::rgba> >::type::value;
+    const std::uint32_t offset_out = boost::mpl::if_<pcl::traits::has_field<PointOutT, pcl::fields::rgb>,
+                                                pcl::traits::offset<PointOutT, pcl::fields::rgb>,
+                                                pcl::traits::offset<PointOutT, pcl::fields::rgba> >::type::value;
+    pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointInT, PointOutT> (point_in, point_out));
+    memcpy (reinterpret_cast<char*> (&point_out) + offset_out,
+            reinterpret_cast<const char*> (&point_in) + offset_in,
+            4);
+  }
+};
+
+} // namespace detail
+
+template <typename PointInT, typename PointOutT> void
+copyPoint (const PointInT& point_in, PointOutT& point_out)
+{
+  detail::CopyPointHelper<PointInT, PointOutT> copy;
+  copy (point_in, point_out);
+}
+
+template <typename PointT>
+void
+copyPoint(const PointT& point_in, PointT& point_out)
+{
+  point_out = point_in;
+}
+} // namespace oneapi
+} // namespace pcl
+
diff --git a/oneapi/common/include/pcl/oneapi/common/impl/io.hpp b/oneapi/common/include/pcl/oneapi/common/impl/io.hpp
new file mode 100644
index 000000000..8507be736
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/impl/io.hpp
@@ -0,0 +1,499 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#include <pcl/oneapi/common/io.h>
+#include <pcl/oneapi/common/copy_point.h>
+#include <pcl/conversions.h> // for FieldAdder
+#include <pcl/common/concatenate.h>
+#include <pcl/point_types.h>
+
+
+namespace pcl
+{
+namespace oneapi {
+template <typename PointT> int
+getFieldIndex (const pcl::PointCloud<PointT> &,
+               const std::string &field_name,
+               std::vector<pcl::PCLPointField> &fields)
+{
+  return getFieldIndex<PointT>(field_name, fields);
+}
+
+
+template <typename PointT> int
+getFieldIndex (const std::string &field_name,
+               std::vector<pcl::PCLPointField> &fields)
+{
+  fields = getFields<PointT> ();
+  const auto& ref = fields;
+  return pcl::oneapi::getFieldIndex<PointT> (field_name, ref);
+}
+
+
+template <typename PointT> int
+getFieldIndex (const std::string &field_name,
+               const std::vector<pcl::PCLPointField> &fields)
+{
+  const auto result = std::find_if(fields.begin (), fields.end (),
+      [&field_name](const auto& field) { return field.name == field_name; });
+  if (result == fields.end ())
+    return -1;
+  return std::distance(fields.begin (), result);
+}
+
+
+template <typename PointT> void
+getFields (const pcl::PointCloud<PointT> &, std::vector<pcl::PCLPointField> &fields)
+{
+  fields = getFields<PointT> ();
+}
+
+
+template <typename PointT> void
+getFields (std::vector<pcl::PCLPointField> &fields)
+{
+  fields = getFields<PointT> ();
+}
+
+
+template <typename PointT> std::vector<pcl::PCLPointField>
+getFields ()
+{
+  std::vector<pcl::PCLPointField> fields;
+  // Get the fields list
+  pcl::for_each_type<typename pcl::traits::fieldList<PointT>::type>(pcl::detail::FieldAdder<PointT>(fields));
+  return fields;
+}
+
+
+template <typename PointT> std::string
+getFieldsList (const pcl::PointCloud<PointT> &)
+{
+  // Get the fields list
+  const auto fields = getFields<PointT>();
+  std::string result;
+  for (std::size_t i = 0; i < fields.size () - 1; ++i)
+    result += fields[i].name + " ";
+  result += fields[fields.size () - 1].name;
+  return (result);
+}
+
+namespace detail
+{
+
+  template <typename PointInT, typename PointOutT> void
+  copyPointCloudMemcpy (const pcl::PointCloud<PointInT> &cloud_in,
+                        pcl::PointCloud<PointOutT> &cloud_out)
+  {
+    // Iterate over each point, if the point types of two clouds are different
+    for (std::size_t i = 0; i < cloud_in.size (); ++i)
+      copyPoint (cloud_in[i], cloud_out[i]);
+  }
+
+
+  template <typename PointT> void
+  copyPointCloudMemcpy (const pcl::PointCloud<PointT> &cloud_in,
+                        pcl::PointCloud<PointT> &cloud_out)
+  {
+    // Use std::copy directly, if the point types of two clouds are same
+    std::copy (&cloud_in[0], (&cloud_in[0]) + cloud_in.size (), &cloud_out[0]);
+  }
+
+} // namespace detail
+
+template <typename PointInT, typename PointOutT> void
+copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                pcl::PointCloud<PointOutT> &cloud_out)
+{
+  // Allocate enough space and copy the basics
+  cloud_out.header   = cloud_in.header;
+  cloud_out.width    = cloud_in.width;
+  cloud_out.height   = cloud_in.height;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+  cloud_out.resize (cloud_in.size ());
+
+  if (!cloud_in.empty ())
+    detail::copyPointCloudMemcpy (cloud_in, cloud_out);
+}
+
+
+template <typename PointT, typename IndicesVectorAllocator> void
+copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                const IndicesAllocator< IndicesVectorAllocator> &indices,
+                pcl::PointCloud<PointT> &cloud_out)
+{
+  // Do we want to copy everything?
+  if (indices.size () == cloud_in.size ())
+  {
+    cloud_out = cloud_in;
+    return;
+  }
+
+  // Allocate enough space and copy the basics
+  cloud_out.clear ();
+  cloud_out.reserve (indices.size ());
+  cloud_out.header   = cloud_in.header;
+  cloud_out.width    = indices.size ();
+  cloud_out.height   = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each point
+  for (const auto& index : indices)
+    cloud_out.transient_push_back (cloud_in[index]);
+}
+
+
+template <typename PointInT, typename PointOutT, typename IndicesVectorAllocator> void
+copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                const IndicesAllocator< IndicesVectorAllocator> &indices,
+                pcl::PointCloud<PointOutT> &cloud_out)
+{
+  // Allocate enough space and copy the basics
+  cloud_out.resize (indices.size ());
+  cloud_out.header   = cloud_in.header;
+  cloud_out.width    = indices.size ();
+  cloud_out.height   = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < indices.size (); ++i)
+    copyPoint (cloud_in[indices[i]], cloud_out[i]);
+}
+
+
+template <typename PointT> void
+copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                const pcl::PointIndices &indices,
+                     pcl::PointCloud<PointT> &cloud_out)
+{
+  copyPointCloud (cloud_in, indices.indices, cloud_out);
+}
+
+
+template <typename PointInT, typename PointOutT> void
+copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                const pcl::PointIndices &indices,
+                pcl::PointCloud<PointOutT> &cloud_out)
+{
+  copyPointCloud (cloud_in, indices.indices, cloud_out);
+}
+
+template <typename PointT, typename IndicesVectorAllocator> void
+copyPointCloud(const pcl::oneapi::PointCloudDev<PointT>& cloud_in,
+               const IndicesAllocator<IndicesVectorAllocator> &indices,
+               pcl::PointCloud<PointT>& cloud_out)
+{
+  cloud_out.resize(indices.size());
+  cloud_out.header = cloud_in.header;
+  cloud_out.width = indices.size();
+  cloud_out.height = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < indices.size(); ++i)
+    copyPoint(cloud_in[indices[i]], cloud_out[i]);
+}
+
+template <typename PointT>
+void
+copyPointCloud(const pcl::oneapi::PointCloudDev<PointT>& cloud_in,
+               const pcl::oneapi::DeviceArray<int>& indices,
+               pcl::oneapi::PointCloudDev<PointT>& cloud_out)
+{
+  cloud_out.resize(indices.size());
+  cloud_out.header = cloud_in.header;
+  cloud_out.width = indices.size();
+  cloud_out.height = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < indices.size(); ++i)
+    copyPoint(cloud_in.points[indices[i]], cloud_out.points[i]);
+}
+
+template <typename PointT> void
+copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                const std::vector<pcl::PointIndices> &indices,
+                pcl::PointCloud<PointT> &cloud_out)
+{
+  std::size_t nr_p = 0;
+  for (const auto &index : indices)
+    nr_p += index.indices.size ();
+
+  // Do we want to copy everything? Remember we assume UNIQUE indices
+  if (nr_p == cloud_in.size ())
+  {
+    cloud_out = cloud_in;
+    return;
+  }
+
+  // Allocate enough space and copy the basics
+  cloud_out.clear ();
+  cloud_out.reserve (nr_p);
+  cloud_out.header   = cloud_in.header;
+  cloud_out.width    = nr_p;
+  cloud_out.height   = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each cluster
+  for (const auto &cluster_index : indices)
+  {
+    // Iterate over each idx
+    for (const auto &index : cluster_index.indices)
+    {
+      // Iterate over each dimension
+      cloud_out.transient_push_back (cloud_in[index]);
+    }
+  }
+}
+
+
+template <typename PointInT, typename PointOutT> void
+copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                const std::vector<pcl::PointIndices> &indices,
+                pcl::PointCloud<PointOutT> &cloud_out)
+{
+  const auto nr_p = std::accumulate(indices.begin (), indices.end (), 0,
+      [](const auto& acc, const auto& index) { return index.indices.size() + acc; });
+
+  // Do we want to copy everything? Remember we assume UNIQUE indices
+  if (nr_p == cloud_in.size ())
+  {
+    copyPointCloud (cloud_in, cloud_out);
+    return;
+  }
+
+  // Allocate enough space and copy the basics
+  cloud_out.resize (nr_p);
+  cloud_out.header   = cloud_in.header;
+  cloud_out.width    = nr_p;
+  cloud_out.height   = 1;
+  cloud_out.is_dense = cloud_in.is_dense;
+  cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+  // Iterate over each cluster
+  std::size_t cp = 0;
+  for (const auto &cluster_index : indices)
+  {
+    // Iterate over each idx
+    for (const auto &index : cluster_index.indices)
+    {
+      copyPoint (cloud_in[index], cloud_out[cp]);
+      ++cp;
+    }
+  }
+}
+
+
+template <typename PointIn1T, typename PointIn2T, typename PointOutT> void
+concatenateFields (const pcl::PointCloud<PointIn1T> &cloud1_in,
+                   const pcl::PointCloud<PointIn2T> &cloud2_in,
+                   pcl::PointCloud<PointOutT> &cloud_out)
+{
+  using FieldList1 = typename pcl::traits::fieldList<PointIn1T>::type;
+  using FieldList2 = typename pcl::traits::fieldList<PointIn2T>::type;
+
+  if (cloud1_in.size () != cloud2_in.size ())
+  {
+    PCL_ERROR ("[pcl::concatenateFields] The number of points in the two input datasets differs!\n");
+    return;
+  }
+
+  // Resize the output dataset
+  cloud_out.resize (cloud1_in.size ());
+  cloud_out.header   = cloud1_in.header;
+  cloud_out.width    = cloud1_in.width;
+  cloud_out.height   = cloud1_in.height;
+  if (!cloud1_in.is_dense || !cloud2_in.is_dense)
+    cloud_out.is_dense = false;
+  else
+    cloud_out.is_dense = true;
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < cloud_out.size (); ++i)
+  {
+    // Iterate over each dimension
+    pcl::for_each_type <FieldList1> (pcl::NdConcatenateFunctor <PointIn1T, PointOutT> (cloud1_in[i], cloud_out[i]));
+    pcl::for_each_type <FieldList2> (pcl::NdConcatenateFunctor <PointIn2T, PointOutT> (cloud2_in[i], cloud_out[i]));
+  }
+}
+
+
+template <typename PointT> void
+copyPointCloud (const pcl::PointCloud<PointT> &cloud_in, pcl::PointCloud<PointT> &cloud_out,
+                int top, int bottom, int left, int right, pcl::oneapi::InterpolationType border_type, const PointT& value)
+{
+  if (top < 0 || left < 0 || bottom < 0 || right < 0)
+  {
+    std::string faulty = (top < 0) ? "top" : (left < 0) ? "left" : (bottom < 0) ? "bottom" : "right";
+    PCL_THROW_EXCEPTION (pcl::BadArgumentException, "[pcl::copyPointCloud] error: " << faulty << " must be positive!");
+    return;
+  }
+
+  if (top == 0 && left == 0 && bottom == 0 && right == 0)
+   cloud_out = cloud_in;
+  else
+  {
+    // Allocate enough space and copy the basics
+    cloud_out.header   = cloud_in.header;
+    cloud_out.width    = cloud_in.width + left + right;
+    cloud_out.height   = cloud_in.height + top + bottom;
+    if (cloud_out.size () != cloud_out.width * cloud_out.height)
+      cloud_out.resize (cloud_out.width * cloud_out.height);
+    cloud_out.is_dense = cloud_in.is_dense;
+    cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+    cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+
+    if (border_type == pcl::oneapi::BORDER_TRANSPARENT)
+    {
+      const PointT* in = &(cloud_in[0]);
+      PointT* out = &(cloud_out[0]);
+      PointT* out_inner = out + cloud_out.width*top + left;
+      for (std::uint32_t i = 0; i < cloud_in.height; i++, out_inner += cloud_out.width, in += cloud_in.width)
+      {
+        if (out_inner != in)
+          memcpy (out_inner, in, cloud_in.width * sizeof (PointT));
+      }
+    }
+    else
+    {
+      // Copy the data
+      if (border_type != pcl::oneapi::BORDER_CONSTANT)
+      {
+        try
+        {
+          std::vector<int> padding (cloud_out.width - cloud_in.width);
+          int right = cloud_out.width - cloud_in.width - left;
+          int bottom = cloud_out.height - cloud_in.height - top;
+
+          for (int i = 0; i < left; i++)
+            padding[i] = pcl::oneapi::interpolatePointIndex (i-left, cloud_in.width, border_type);
+
+          for (int i = 0; i < right; i++)
+            padding[i+left] = pcl::oneapi::interpolatePointIndex (cloud_in.width+i, cloud_in.width, border_type);
+
+          const PointT* in = &(cloud_in[0]);
+          PointT* out = &(cloud_out[0]);
+          PointT* out_inner = out + cloud_out.width*top + left;
+
+          for (std::uint32_t i = 0; i < cloud_in.height; i++, out_inner += cloud_out.width, in += cloud_in.width)
+          {
+            if (out_inner != in)
+              memcpy (out_inner, in, cloud_in.width * sizeof (PointT));
+
+            for (int j = 0; j < left; j++)
+              out_inner[j - left] = in[padding[j]];
+
+            for (int j = 0; j < right; j++)
+              out_inner[j + cloud_in.width] = in[padding[j + left]];
+          }
+
+          for (int i = 0; i < top; i++)
+          {
+            int j = pcl::oneapi::interpolatePointIndex (i - top, cloud_in.height, border_type);
+            memcpy (out + i*cloud_out.width,
+                    out + (j+top) * cloud_out.width,
+                    sizeof (PointT) * cloud_out.width);
+          }
+
+          for (int i = 0; i < bottom; i++)
+          {
+            int j = pcl::oneapi::interpolatePointIndex (i + cloud_in.height, cloud_in.height, border_type);
+            memcpy (out + (i + cloud_in.height + top)*cloud_out.width,
+                    out + (j+top)*cloud_out.width,
+                    cloud_out.width * sizeof (PointT));
+          }
+        }
+        catch (pcl::BadArgumentException&)
+        {
+          PCL_ERROR ("[pcl::copyPointCloud] Unhandled interpolation type %d!\n", border_type);
+        }
+      }
+      else
+      {
+        int right = cloud_out.width - cloud_in.width - left;
+        int bottom = cloud_out.height - cloud_in.height - top;
+        std::vector<PointT> buff (cloud_out.width, value);
+        PointT* buff_ptr = &(buff[0]);
+        const PointT* in = &(cloud_in[0]);
+        PointT* out = &(cloud_out[0]);
+        PointT* out_inner = out + cloud_out.width*top + left;
+
+        for (std::uint32_t i = 0; i < cloud_in.height; i++, out_inner += cloud_out.width, in += cloud_in.width)
+        {
+          if (out_inner != in)
+            memcpy (out_inner, in, cloud_in.width * sizeof (PointT));
+
+          memcpy (out_inner - left, buff_ptr, left  * sizeof (PointT));
+          memcpy (out_inner + cloud_in.width, buff_ptr, right * sizeof (PointT));
+        }
+
+        for (int i = 0; i < top; i++)
+        {
+          memcpy (out + i*cloud_out.width, buff_ptr, cloud_out.width * sizeof (PointT));
+        }
+
+        for (int i = 0; i < bottom; i++)
+        {
+          memcpy (out + (i + cloud_in.height + top)*cloud_out.width,
+                  buff_ptr,
+                  cloud_out.width * sizeof (PointT));
+        }
+      }
+    }
+  }
+}
+} // namespace oneapi
+} // namespace pcl
+
diff --git a/oneapi/common/include/pcl/oneapi/common/io.h b/oneapi/common/include/pcl/oneapi/common/io.h
new file mode 100644
index 000000000..9045bb9f1
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/common/io.h
@@ -0,0 +1,566 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+#include <oneapi/dpl/execution>
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/oneapi/PCLPointCloud2.h>
+#include <numeric>
+#include <string>
+
+#include <pcl/point_cloud.h>
+#include <pcl/PointIndices.h>
+#include <pcl/pcl_macros.h>
+#include <pcl/PolygonMesh.h>
+#include <locale>
+
+namespace pcl {
+namespace oneapi {
+  /** \brief Get the index of a specified field (i.e., dimension/channel)
+    * \param[in] cloud the point cloud message
+    * \param[in] field_name the string defining the field name
+    * \ingroup common
+    */
+  inline int
+  getFieldIndex (const pcl::oneapi::PCLPointCloud2 &cloud, const std::string &field_name)
+  {
+    // Get the index we need
+    const auto result = std::find_if(cloud.fields.begin (), cloud.fields.end (),
+        [&field_name](const auto field) { return field.name == field_name; });
+    if (result == cloud.fields.end ())
+      return -1;
+    return std::distance(cloud.fields.begin (), result);
+  }
+
+  /** \brief Get the index of a specified field (i.e., dimension/channel)
+    * \tparam PointT datatype for which fields is being queries
+    * \param[in] field_name the string defining the field name
+    * \param[out] fields a vector to the original \a PCLPointField vector that the raw PointCloud message contains
+    * \ingroup common
+    */
+  template <typename PointT> inline int
+  getFieldIndex (const std::string &field_name,
+                 std::vector<pcl::PCLPointField> &fields);
+  /** \brief Get the index of a specified field (i.e., dimension/channel)
+    * \tparam PointT datatype for which fields is being queries
+    * \param[in] field_name the string defining the field name
+    * \param[in] fields a vector to the original \a PCLPointField vector that the raw PointCloud message contains
+    * \ingroup common
+    */
+  template <typename PointT> inline int
+  getFieldIndex (const std::string &field_name,
+                 const std::vector<pcl::PCLPointField> &fields);
+
+  /** \brief Get the list of available fields (i.e., dimension/channel)
+    * \tparam PointT datatype whose details are requested
+    * \ingroup common
+    */
+  template <typename PointT> inline std::vector<pcl::PCLPointField>
+  getFields ();
+
+  /** \brief Get the list of all fields available in a given cloud
+    * \param[in] cloud the point cloud message
+    * \ingroup common
+    */
+  template <typename PointT> inline std::string
+  getFieldsList (const pcl::PointCloud<PointT> &cloud);
+
+  /** \brief Get the available point cloud fields as a space separated string
+    * \param[in] cloud a pointer to the PointCloud message
+    * \ingroup common
+    */
+  inline std::string
+  getFieldsList (const pcl::oneapi::PCLPointCloud2 &cloud)
+  {
+    return std::accumulate(std::next (cloud.fields.begin ()), cloud.fields.end (), cloud.fields[0].name,
+        [](const auto& acc, const auto& field) { return acc + " " + field.name; });
+  }
+
+  /** \brief Obtains the size of a specific field data type in bytes
+    * \param[in] datatype the field data type (see PCLPointField.h)
+    * \ingroup common
+    */
+  inline int
+  getFieldSize (const int datatype)
+  {
+    switch (datatype)
+    {
+      case pcl::PCLPointField::INT8:
+      case pcl::PCLPointField::UINT8:
+        return (1);
+
+      case pcl::PCLPointField::INT16:
+      case pcl::PCLPointField::UINT16:
+        return (2);
+
+      case pcl::PCLPointField::INT32:
+      case pcl::PCLPointField::UINT32:
+      case pcl::PCLPointField::FLOAT32:
+        return (4);
+
+      case pcl::PCLPointField::FLOAT64:
+        return (8);
+
+      default:
+        return (0);
+    }
+  }
+
+  /** \brief Obtain a vector with the sizes of all valid fields (e.g., not "_")
+    * \param[in] fields the input vector containing the fields
+    * \param[out] field_sizes the resultant field sizes in bytes
+    */
+  PCL_EXPORTS void
+  getFieldsSizes (const std::vector<pcl::PCLPointField> &fields,
+                  std::vector<int> &field_sizes);
+
+  /** \brief Obtains the type of the PCLPointField from a specific size and type
+    * \param[in] size the size in bytes of the data field
+    * \param[in] type a char describing the type of the field  ('F' = float, 'I' = signed, 'U' = unsigned)
+    * \ingroup common
+    */
+  inline int
+  getFieldType (const int size, char type)
+  {
+    type = std::toupper (type, std::locale::classic ());
+    switch (size)
+    {
+      case 1:
+        if (type == 'I')
+          return (pcl::PCLPointField::INT8);
+        if (type == 'U')
+          return (pcl::PCLPointField::UINT8);
+        break;
+
+      case 2:
+        if (type == 'I')
+          return (pcl::PCLPointField::INT16);
+        if (type == 'U')
+          return (pcl::PCLPointField::UINT16);
+        break;
+
+      case 4:
+        if (type == 'I')
+          return (pcl::PCLPointField::INT32);
+        if (type == 'U')
+          return (pcl::PCLPointField::UINT32);
+        if (type == 'F')
+          return (pcl::PCLPointField::FLOAT32);
+        break;
+
+      case 8:
+        if (type == 'F')
+          return (pcl::PCLPointField::FLOAT64);
+        break;
+    }
+    return (-1);
+  }
+
+  /** \brief Obtains the type of the PCLPointField from a specific PCLPointField as a char
+    * \param[in] type the PCLPointField field type
+    * \ingroup common
+    */
+  inline char
+  getFieldType (const int type)
+  {
+    switch (type)
+    {
+      case pcl::PCLPointField::INT8:
+      case pcl::PCLPointField::INT16:
+      case pcl::PCLPointField::INT32:
+        return ('I');
+
+      case pcl::PCLPointField::UINT8:
+      case pcl::PCLPointField::UINT16:
+      case pcl::PCLPointField::UINT32:
+        return ('U');
+
+      case pcl::PCLPointField::FLOAT32:
+      case pcl::PCLPointField::FLOAT64:
+        return ('F');
+      default:
+        return ('?');
+    }
+  }
+
+  enum InterpolationType
+  {
+    BORDER_CONSTANT = 0, BORDER_REPLICATE = 1,
+    BORDER_REFLECT = 2, BORDER_WRAP = 3,
+    BORDER_REFLECT_101 = 4, BORDER_TRANSPARENT = 5,
+    BORDER_DEFAULT = BORDER_REFLECT_101
+  };
+
+  /** \brief \return the right index according to the interpolation type.
+    * \note this is adapted from OpenCV
+    * \param p the index of point to interpolate
+    * \param length the top/bottom row or left/right column index
+    * \param type the requested interpolation
+    * \throws pcl::BadArgumentException if type is unknown
+    */
+  PCL_EXPORTS int
+  interpolatePointIndex (int p, int length, InterpolationType type);
+
+  /** \brief Concatenate two pcl::PointCloud<PointT>
+    * \param[in] cloud1 the first input point cloud dataset
+    * \param[in] cloud2 the second input point cloud dataset
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \return true if successful, false otherwise
+    * \ingroup common
+    */
+  template <typename PointT>
+  PCL_EXPORTS bool
+  concatenate (const pcl::PointCloud<PointT> &cloud1,
+               const pcl::PointCloud<PointT> &cloud2,
+               pcl::PointCloud<PointT> &cloud_out)
+  {
+    return pcl::PointCloud<PointT>::concatenate(cloud1, cloud2, cloud_out);
+  }
+
+  /** \brief Concatenate two pcl::PCLPointCloud2
+    *
+    * \warning This function will concatenate IFF the non-skip fields are in the correct
+    * order and same in number.
+    * \param[in] cloud1 the first input point cloud dataset
+    * \param[in] cloud2 the second input point cloud dataset
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \return true if successful, false otherwise
+    * \ingroup common
+    */
+  PCL_EXPORTS inline bool
+  concatenate (const pcl::oneapi::PCLPointCloud2 &cloud1,
+               const pcl::oneapi::PCLPointCloud2 &cloud2,
+               pcl::oneapi::PCLPointCloud2 &cloud_out)
+  {
+    return pcl::oneapi::PCLPointCloud2::concatenate(cloud1, cloud2, cloud_out);
+  }
+
+  /** \brief Concatenate two pcl::PolygonMesh
+    * \param[in] mesh1 the first input mesh
+    * \param[in] mesh2 the second input mesh
+    * \param[out] mesh_out the resultant output mesh
+    * \return true if successful, false otherwise
+    * \ingroup common
+    */
+  PCL_EXPORTS inline bool
+  concatenate (const pcl::PolygonMesh &mesh1,
+               const pcl::PolygonMesh &mesh2,
+               pcl::PolygonMesh &mesh_out)
+  {
+    return pcl::PolygonMesh::concatenate(mesh1, mesh2, mesh_out);
+  }
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from \a cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  PCL_EXPORTS void
+  copyPointCloud (const pcl::oneapi::PCLPointCloud2 &cloud_in,
+                  const Indices &indices,
+                  pcl::oneapi::PCLPointCloud2 &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from \a cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  PCL_EXPORTS void
+  copyPointCloud (const pcl::oneapi::PCLPointCloud2 &cloud_in,
+                  const IndicesAllocator< Eigen::aligned_allocator<index_t> > &indices,
+                  pcl::oneapi::PCLPointCloud2 &cloud_out);
+
+  /** \brief Copy fields and point cloud data from \a cloud_in to \a cloud_out
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \ingroup common
+    */
+  PCL_EXPORTS void
+  copyPointCloud (const pcl::oneapi::PCLPointCloud2 &cloud_in,
+                  pcl::oneapi::PCLPointCloud2 &cloud_out);
+
+  /** \brief Check if two given point types are the same or not. */
+  template <typename Point1T, typename Point2T> inline bool
+  isSamePointType ()
+  {
+    return (typeid (Point1T) == typeid (Point2T));
+  }
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from \a cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointT, typename IndicesVectorAllocator = std::allocator<index_t>> void
+  copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                  const IndicesAllocator< IndicesVectorAllocator> &indices,
+                  pcl::PointCloud<PointT> &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the PointIndices structure representing the points to be copied from cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointT> void
+  copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                  const PointIndices &indices,
+                  pcl::PointCloud<PointT> &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from \a cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointT> void
+  copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                  const std::vector<pcl::PointIndices> &indices,
+                  pcl::PointCloud<PointT> &cloud_out);
+
+  /** \brief Copy all the fields from a given point cloud into a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \ingroup common
+    */
+  template <typename PointInT, typename PointOutT> void
+  copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                  pcl::PointCloud<PointOutT> &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from \a cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointInT, typename PointOutT, typename IndicesVectorAllocator = std::allocator<index_t>> void
+  copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                  const IndicesAllocator<IndicesVectorAllocator> &indices,
+                  pcl::PointCloud<PointOutT> &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the PointIndices structure representing the points to be copied from cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointInT, typename PointOutT> void
+  copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                  const PointIndices &indices,
+                  pcl::PointCloud<PointOutT> &cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+   * \param[in] cloud_in the input point cloud dataset
+   * \param[in] indices the PointIndices structure representing the points to be copied
+   * from cloud_in \param[out] cloud_out the resultant output point cloud dataset \note
+   * Assumes unique indices. \ingroup common
+   */
+  template <typename PointT, typename IndicesVectorAllocator = std::allocator<index_t>> void
+  copyPointCloud(const pcl::oneapi::PointCloudDev<PointT>& cloud_in,
+                 const IndicesAllocator<IndicesVectorAllocator> &indices,
+                 pcl::PointCloud<PointT>& cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+   * \param[in] cloud_in the input point cloud dataset
+   * \param[in] indices the PointIndices structure representing the points to be copied
+   * from cloud_in \param[out] cloud_out the resultant output point cloud dataset \note
+   * Assumes unique indices. \ingroup common
+   */
+  template <typename PointT> void
+  copyPointCloud(const pcl::oneapi::PointCloudDev<PointT>& cloud_in,
+                 const pcl::oneapi::DeviceArray<int>& indices,
+                 pcl::oneapi::PointCloudDev<PointT>& cloud_out);
+
+  /** \brief Extract the indices of a given point cloud as a new point cloud
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[in] indices the vector of indices representing the points to be copied from cloud_in
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \note Assumes unique indices.
+    * \ingroup common
+    */
+  template <typename PointInT, typename PointOutT> void
+  copyPointCloud (const pcl::PointCloud<PointInT> &cloud_in,
+                  const std::vector<pcl::PointIndices> &indices,
+                  pcl::PointCloud<PointOutT> &cloud_out);
+
+  /** \brief Copy a point cloud inside a larger one interpolating borders.
+    * \param[in] cloud_in the input point cloud dataset
+    * \param[out] cloud_out the resultant output point cloud dataset
+    * \param top
+    * \param bottom
+    * \param left
+    * \param right
+    * Position of cloud_in inside cloud_out is given by \a top, \a left, \a bottom \a right.
+    * \param[in] border_type the interpolating method (pcl::BORDER_XXX)
+    *  BORDER_REPLICATE:     aaaaaa|abcdefgh|hhhhhhh
+    *  BORDER_REFLECT:       fedcba|abcdefgh|hgfedcb
+    *  BORDER_REFLECT_101:   gfedcb|abcdefgh|gfedcba
+    *  BORDER_WRAP:          cdefgh|abcdefgh|abcdefg
+    *  BORDER_CONSTANT:      iiiiii|abcdefgh|iiiiiii  with some specified 'i'
+    *  BORDER_TRANSPARENT:   mnopqr|abcdefgh|tuvwxyz  where m-r and t-z are original values of cloud_out
+    * \param value
+    * \throw pcl::BadArgumentException if any of top, bottom, left or right is negative.
+    * \ingroup common
+    */
+  template <typename PointT> void
+  copyPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                  pcl::PointCloud<PointT> &cloud_out,
+                  int top, int bottom, int left, int right,
+                  pcl::oneapi::InterpolationType border_type, const PointT& value);
+
+  /** \brief Concatenate two datasets representing different fields.
+    *
+    * \note If the input datasets have overlapping fields (i.e., both contain
+    * the same fields), then the data in the second cloud (cloud2_in) will
+    * overwrite the data in the first (cloud1_in).
+    *
+    * \param[in] cloud1_in the first input dataset
+    * \param[in] cloud2_in the second input dataset (overwrites the fields of the first dataset for those that are shared)
+    * \param[out] cloud_out the resultant output dataset created by the concatenation of all the fields in the input datasets
+    * \ingroup common
+    */
+  template <typename PointIn1T, typename PointIn2T, typename PointOutT> void
+  concatenateFields (const pcl::PointCloud<PointIn1T> &cloud1_in,
+                     const pcl::PointCloud<PointIn2T> &cloud2_in,
+                     pcl::PointCloud<PointOutT> &cloud_out);
+
+  /** \brief Concatenate two datasets representing different fields.
+    *
+    * \note If the input datasets have overlapping fields (i.e., both contain
+    * the same fields), then the data in the second cloud (cloud2_in) will
+    * overwrite the data in the first (cloud1_in).
+    *
+    * \param[in] cloud1_in the first input dataset
+    * \param[in] cloud2_in the second input dataset (overwrites the fields of the first dataset for those that are shared)
+    * \param[out] cloud_out the output dataset created by concatenating all the fields in the input datasets
+    * \ingroup common
+    */
+  PCL_EXPORTS bool
+  concatenateFields (const pcl::oneapi::PCLPointCloud2 &cloud1_in,
+                     const pcl::oneapi::PCLPointCloud2 &cloud2_in,
+                     pcl::oneapi::PCLPointCloud2 &cloud_out);
+
+  /** \brief Copy the XYZ dimensions of a pcl::PCLPointCloud2 into Eigen format
+    * \param[in] in the point cloud message
+    * \param[out] out the resultant Eigen MatrixXf format containing XYZ0 / point
+    * \ingroup common
+    */
+  PCL_EXPORTS bool
+  getPointCloudAsEigen (const pcl::oneapi::PCLPointCloud2 &in, Eigen::MatrixXf &out);
+
+  /** \brief Copy the XYZ dimensions from an Eigen MatrixXf into a pcl::PCLPointCloud2 message
+    * \param[in] in the Eigen MatrixXf format containing XYZ0 / point
+    * \param[out] out the resultant point cloud message
+    * \note the method assumes that the PCLPointCloud2 message already has the fields set up properly !
+    * \ingroup common
+    */
+  PCL_EXPORTS bool
+  getEigenAsPointCloud (Eigen::MatrixXf &in, pcl::oneapi::PCLPointCloud2 &out);
+
+  namespace io
+  {
+    /** \brief swap bytes order of a char array of length N
+      * \param bytes char array to swap
+      * \ingroup common
+      */
+    template <std::size_t N> void
+    swapByte (char* bytes);
+
+   /** \brief specialization of swapByte for dimension 1
+     * \param bytes char array to swap
+     */
+    template <> inline void
+    swapByte<1> (char* bytes) { //bytes[0] = bytes[0]; 
+    }
+
+
+   /** \brief specialization of swapByte for dimension 2
+     * \param bytes char array to swap
+     */
+    template <> inline void
+    swapByte<2> (char* bytes) { std::swap (bytes[0], bytes[1]); }
+
+   /** \brief specialization of swapByte for dimension 4
+     * \param bytes char array to swap
+     */
+    template <> inline void
+    swapByte<4> (char* bytes)
+    {
+      std::swap (bytes[0], bytes[3]);
+      std::swap (bytes[1], bytes[2]);
+    }
+
+   /** \brief specialization of swapByte for dimension 8
+     * \param bytes char array to swap
+     */
+    template <> inline void
+    swapByte<8> (char* bytes)
+    {
+      std::swap (bytes[0], bytes[7]);
+      std::swap (bytes[1], bytes[6]);
+      std::swap (bytes[2], bytes[5]);
+      std::swap (bytes[3], bytes[4]);
+    }
+
+    /** \brief swaps byte of an arbitrary type T casting it to char*
+      * \param value the data you want its bytes swapped
+      */
+    template <typename T> void
+    swapByte (T& value)
+    {
+      pcl::oneapi::io::swapByte<sizeof(T)> (reinterpret_cast<char*> (&value));
+    }
+  }
+} // namespace oneapi
+} // namespace pcl
+#include <pcl/oneapi/common/impl/io.hpp>
diff --git a/oneapi/common/include/pcl/oneapi/containers/device_array.h b/oneapi/common/include/pcl/oneapi/containers/device_array.h
new file mode 100644
index 000000000..59e30ffaa
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/device_array.h
@@ -0,0 +1,587 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#pragma once
+
+#include <pcl/oneapi/containers/device_memory.h>
+#include <pcl/pcl_exports.h>
+
+#include <vector>
+#include <iterator>
+#include <cstddef>
+
+namespace pcl {
+namespace oneapi {
+
+template <typename T> class device_iterator;
+
+template <typename T>
+class device_pointer  {
+protected:
+  T *ptr;
+
+public:
+  using value_type = T;
+  using difference_type = std::make_signed<std::size_t>::type;
+  using pointer = T *;
+  using reference = T &;
+  using const_reference = const T &;
+  using iterator_category = std::random_access_iterator_tag;
+//  using is_hetero = std::false_type;         // required
+  using is_passed_directly = std::true_type; // required
+
+  device_pointer(T *p) : ptr(p) {}
+  // needed for malloc_device, count is number of bytes to allocate
+  device_pointer() {}
+  device_pointer &operator=(const device_iterator<T> &in) {
+    this->ptr = static_cast<device_pointer<T>>(in).ptr;
+    return *this;
+  }
+
+  // include operators from base class
+  device_pointer operator+(difference_type forward) {
+    return device_pointer(this->ptr + forward);
+  }
+  device_pointer operator-(difference_type forward) {
+    return device_pointer(this->ptr - forward);
+  }
+  device_pointer &operator++() {
+    ++(this->ptr);
+    return *this;
+  }
+  device_pointer &operator--() {
+    --(this->ptr);
+    return *this;
+  }
+  device_pointer &operator+=(difference_type forward) {
+    this->ptr = this->ptr + forward;
+    return *this;
+  }
+  device_pointer &operator-=(difference_type backward) {
+    this->ptr = this->ptr - backward;
+    return *this;
+  }
+
+  pointer data() {
+    return ptr;
+  }
+
+  // Dereference operator
+  reference operator*() {
+    return *ptr;
+  }
+
+  const_reference operator*() const {
+    return *ptr;
+  }
+};
+
+template <typename T>
+class device_iterator : public device_pointer<T> {
+  using Base = device_pointer<T>;
+
+protected:
+  std::size_t idx;
+
+public:
+  using value_type = T;
+  using difference_type = std::make_signed<std::size_t>::type;
+  using pointer = typename Base::pointer;
+  using reference = typename Base::reference;
+  using iterator_category = std::random_access_iterator_tag;
+//  using is_hetero = std::false_type;         // required
+  using is_passed_directly = std::true_type; // required
+  static constexpr sycl::access_mode mode =
+      sycl::access_mode::read_write; // required
+
+  device_iterator() : Base(nullptr), idx(0) {}
+  device_iterator(T *vec, std::size_t index) : Base(vec), idx(index) {}
+  template <sycl::access_mode inMode>
+  device_iterator(const device_iterator<T> &in)
+      : Base(in.ptr), idx(in.idx) {} // required for iter_mode
+/*
+  device_iterator &operator=(const device_iterator &in) {
+    Base::buffer = in.buffer;
+    Base::idx = in.idx;
+    return *this;
+  }
+*/
+
+  reference operator*() const { return *(Base::ptr + idx); }
+
+  reference operator[](difference_type i) { return Base::ptr[idx + i]; }
+  reference operator[](difference_type i) const { return Base::ptr[idx + i]; }
+  device_iterator &operator++() {
+    ++idx;
+    return *this;
+  }
+  device_iterator &operator--() {
+    --idx;
+    return *this;
+  }
+  device_iterator operator++(int) {
+    device_iterator it(*this);
+    ++(*this);
+    return it;
+  }
+  device_iterator operator--(int) {
+    device_iterator it(*this);
+    --(*this);
+    return it;
+  }
+  device_iterator operator+(difference_type forward) const {
+    const auto new_idx = idx + forward;
+    return {Base::ptr, new_idx};
+  }
+  device_iterator &operator+=(difference_type forward) {
+    idx += forward;
+    return *this;
+  }
+  device_iterator operator-(difference_type backward) const {
+    return {Base::ptr, idx - backward};
+  }
+  device_iterator &operator-=(difference_type backward) {
+    idx -= backward;
+    return *this;
+  }
+  friend device_iterator operator+(difference_type forward,
+                                   const device_iterator &it) {
+    return it + forward;
+  }
+  difference_type operator-(const device_iterator &it) const {
+    return idx - it.idx;
+  }
+
+  /*
+  template <typename OtherIterator>
+  typename std::enable_if<internal::is_hetero_iterator<OtherIterator>::value,
+                          difference_type>::type
+  operator-(const OtherIterator &it) const {
+    return idx - it.get_idx();
+  }
+  */
+
+  bool operator==(const device_iterator &it) const { return *this - it == 0; }
+  bool operator!=(const device_iterator &it) const { return !(*this == it); }
+  bool operator<(const device_iterator &it) const { return *this - it < 0; }
+  bool operator>(const device_iterator &it) const { return it < *this; }
+  bool operator<=(const device_iterator &it) const { return !(*this > it); }
+  bool operator>=(const device_iterator &it) const { return !(*this < it); }
+
+  std::size_t get_idx() const { return idx; } // required
+
+  device_iterator &get_buffer() { return *this; } // required
+
+  std::size_t size() const { return idx; }
+};
+
+
+
+//////////////////////////////////////////////////////////////////////////////
+/** \brief @b DeviceArray class
+ *
+ * \note Typed container for GPU memory with reference counting.
+ *
+ * \author Anatoly Baksheev
+ */
+template <class T>
+class PCL_EXPORTS DeviceArray : public DeviceMemory {
+public:
+  /** \brief Element type. */
+  using iterator = device_iterator<T>;
+  using const_iterator = const iterator;
+  using type = T;
+  using reference = T&;
+  using difference_type =
+      typename ::std::iterator_traits<iterator>::difference_type;
+
+  /** \brief Element size. */
+  enum { elem_size = sizeof(T) };
+
+  /** \brief Empty constructor. */
+  DeviceArray();
+
+  /** \brief Allocates internal buffer in GPU memory
+   * \param size number of elements to allocate
+   * */
+  DeviceArray(std::size_t size);
+
+  DeviceArray(std::size_t size, sycl::queue *q);
+
+  template <class A>
+  DeviceArray(std::size_t size, A pattern, bool wait=true);
+
+  template <class A>
+  DeviceArray(std::size_t size, sycl::queue *q, A pattern, bool wait=true);
+  /** \brief Initializes with user allocated buffer. Reference counting is disabled in
+   * this case.
+   * \param ptr pointer to buffer
+   * \param size elements number
+   * */
+  DeviceArray(T* ptr, std::size_t size);
+
+  DeviceArray(const T* ptr, std::size_t size);
+
+  /** \brief Allocates internal buffer based on memory type
+   * \param size number of elements to allocate
+   * \param type Memory type such as shared, device, or host
+   * */
+  DeviceArray(std::size_t size, MemoryType type);
+
+  /** \brief Copy constructor. Just increments reference counter. */
+  DeviceArray(const DeviceArray& other);
+
+  /** \brief Assignment operator. Just increments reference counter. */
+  DeviceArray&
+  operator=(const DeviceArray& other);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param size elements number
+   * */
+  void
+  create(std::size_t size);
+
+  void
+  create(std::size_t size, sycl::queue *q);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param size elements number
+   * \param type Memory type such as shared, device, or host
+   * */
+  void
+  create(std::size_t size, MemoryType type);
+
+  void
+  create(std::size_t size, MemoryType type, sycl::queue *q);
+
+  /** \brief Change the size without reallocate the buffer if the new size is smaller.
+   * \param size elements number
+   * */
+  void
+  resize(std::size_t size);
+
+  /** \brief Decrements reference counter and releases internal buffer if needed. */
+  void
+  release();
+
+  /** \brief Performs data copying. If destination size differs it will be reallocated.
+   * \param other destination container
+   * */
+  void
+  copyTo(DeviceArray& other) const;
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param host_ptr pointer to buffer to upload
+   * \param size elements number
+   * */
+  void
+  upload(const T* host_ptr, std::size_t size);
+
+  /** \brief Uploads data from CPU memory to internal buffer.
+   * \return true if upload successful
+   * \note In contrast to the other upload function, this function
+   * never allocates memory.
+   * \param host_ptr pointer to buffer to upload
+   * \param device_begin_offset begin upload
+   * \param num_elements number of elements from device_bein_offset
+   * */
+  bool
+  upload(const T* host_ptr, std::size_t device_begin_offset, std::size_t num_elements);
+
+  /** \brief Downloads data from internal buffer to CPU memory
+   * \param host_ptr pointer to buffer to download
+   * */
+  void
+  download(T* host_ptr) const;
+
+  /** \brief Downloads data from internal buffer to CPU memory.
+   * \return true if download successful
+   * \param host_ptr pointer to buffer to download
+   * \param device_begin_offset begin download location
+   * \param num_elements number of elements from device_begin_offset
+   * */
+  bool
+  download(T* host_ptr,
+           std::size_t device_begin_offset,
+           std::size_t num_elements) const;
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param data host vector to upload from
+   * */
+  template <class A>
+  void
+  upload(const std::vector<T, A>& data);
+
+  /** \brief Downloads data from internal buffer to CPU memory
+   * \param data  host vector to download to
+   * */
+  template <typename A>
+  void
+  download(std::vector<T, A>& data) const;
+
+  void
+  clear();
+
+  void
+  insert(device_iterator<T> position, device_iterator<const T> first, device_iterator<const T> last);
+
+  reference
+  front() const { return *begin(); }
+
+  reference
+  front() { return *begin(); }
+
+  reference
+  back(void) const { return (ptr()[size() - 1]); }
+
+  reference
+  back(void) { return (ptr()[size() - 1]); }
+
+
+  /** \brief Performs swap of data pointed with another device array.
+   * \param other_arg device array to swap with
+   * */
+  void
+  swap(DeviceArray& other_arg);
+
+  /** \brief Returns pointer for internal buffer in GPU memory. */
+  T*
+  ptr();
+
+  /** \brief Returns const pointer for internal buffer in GPU memory. */
+  const T*
+  ptr() const;
+
+  // using DeviceMemory::ptr;
+
+  /** \brief Returns pointer for internal buffer in GPU memory. */
+  operator T*();
+
+  /** \brief Returns const pointer for internal buffer in GPU memory. */
+  operator const T*() const;
+
+  void operator +=(const T rhs) {  for (int i = 0; i < size(); i++) ptr()[i] += rhs; }
+
+  void operator -=(const T rhs) {  for (int i = 0; i < size(); i++) ptr()[i] -= rhs; }
+
+  void operator *=(const T rhs) {  for (int i = 0; i < size(); i++) ptr()[i] *= rhs; }
+
+  void operator /=(const T rhs) {  for (int i = 0; i < size(); i++) ptr()[i] /= rhs; }
+
+  /** \brief Returns size in elements. */
+  std::size_t
+  size() const;
+
+  iterator begin() noexcept { return device_iterator<T>(&ptr()[0], 0); }
+  iterator end() { return device_iterator<T>(&ptr()[0], size()); }
+
+  device_iterator<const T> begin() const noexcept { return device_iterator<const T>(&ptr()[0], 0); }
+  device_iterator<const T> end() const { return device_iterator<const T>(&ptr()[0], size()); }
+
+
+};
+
+///////////////////////////////////////////////////////////////////////////////
+/** \brief @b DeviceArray2D class
+ *
+ * \note Typed container for pitched GPU memory with reference counting.
+ *
+ * \author Anatoly Baksheev
+ */
+template <class T>
+class PCL_EXPORTS DeviceArray2D : public DeviceMemory2D {
+public:
+  /** \brief Element type. */
+  using type = T;
+
+  /** \brief Element size. */
+  enum { elem_size = sizeof(T) };
+
+  /** \brief Empty constructor. */
+  DeviceArray2D();
+
+  /** \brief Allocates internal buffer in GPU memory
+   * \param rows number of rows to allocate
+   * \param cols number of elements in each row
+   * */
+  DeviceArray2D(int rows, int cols);
+
+  /** \brief Initializes with user allocated buffer. Reference counting is disabled in
+   * this case.
+   * \param rows number of rows
+   * \param cols number of elements in each row
+   * \param data pointer to buffer
+   * \param stepBytes stride between two consecutive rows in bytes
+   * */
+  DeviceArray2D(int rows, int cols, void* data, std::size_t stepBytes);
+
+  /** \brief Copy constructor. Just increments reference counter. */
+  DeviceArray2D(const DeviceArray2D& other);
+
+  /** \brief Assignment operator. Just increments reference counter. */
+  DeviceArray2D&
+  operator=(const DeviceArray2D& other);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param rows number of rows to allocate
+   * \param cols number of elements in each row
+   * */
+  void
+  create(int rows, int cols);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param rows number of rows to allocate
+   * \param cols number of elements in each row
+   * \param type Memory type such as shared, device, or host
+   * */
+  void
+  create(int rows, int cols, MemoryType type);
+
+  void
+  create(int rows, int cols, std::size_t stepBytes);
+
+
+  /** \brief Decrements reference counter and releases internal buffer if needed. */
+  void
+  release();
+
+  /** \brief Performs data copying. If destination size differs it will be reallocated.
+   * \param other destination container
+   * */
+  void
+  copyTo(DeviceArray2D& other);
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param host_ptr pointer to host buffer to upload
+   * \param host_step stride between two consecutive rows in bytes for host buffer
+   * \param rows number of rows to upload
+   * \param cols number of elements in each row
+   * */
+  void
+  upload(const void* host_ptr, std::size_t host_step, int rows, int cols);
+
+  /** \brief Downloads data from internal buffer to CPU memory. User is responsible for
+   * correct host buffer size.
+   * \param host_ptr pointer to host buffer to download
+   * \param host_step stride between two consecutive rows in bytes for host buffer
+   * */
+  void
+  download(void* host_ptr, std::size_t host_step);
+
+  /** \brief Performs swap of data pointed with another device array.
+   * \param other_arg device array to swap with
+   * */
+  void
+  swap(DeviceArray2D& other_arg);
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param data host vector to upload from
+   * \param cols stride in elements between two consecutive rows for host buffer
+   * */
+  template <class A>
+  void
+  upload(const std::vector<T, A>& data, int cols);
+
+  /** \brief Downloads data from internal buffer to CPU memory
+   * \param data host vector to download to
+   * \param cols Output stride in elements between two consecutive rows for host vector.
+   * */
+  template <class A>
+  void
+  download(std::vector<T, A>& data, int& cols);
+
+  /** \brief Returns pointer to given row in internal buffer.
+   * \param y row index
+   * */
+  T*
+  ptr() const;
+
+  /** \brief Returns pointer to given row in internal buffer.
+   * \param y row index
+   * */
+  T*
+  ptr(int y = 0);
+
+  /** \brief Returns const pointer to given row in internal buffer.
+   * \param y row index
+   * */
+  const T*
+  ptr(int y = 0) const;
+
+  /**
+   * Operator that returns a (pointer to a) row of the data.
+   */
+  const T *operator[](size_t index) const;
+
+  // using DeviceMemory2D::ptr;
+
+  /** \brief Returns pointer for internal buffer in GPU memory. */
+  operator T*();
+
+  /** \brief Returns const pointer for internal buffer in GPU memory. */
+  operator const T*() const;
+
+  /** \brief Returns number of elements in each row. */
+  int
+  cols() const;
+
+  /** \brief Returns number of rows. */
+  int
+  rows() const;
+
+  /** \brief Returns step in elements. */
+  std::size_t
+  elem_step() const;
+};
+
+
+
+} // namespace oneapi
+} // namespace pcl
+
+#include <pcl/oneapi/containers/impl/device_array.hpp>
diff --git a/oneapi/common/include/pcl/oneapi/containers/device_memory.h b/oneapi/common/include/pcl/oneapi/containers/device_memory.h
new file mode 100644
index 000000000..0e1328dc1
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/device_memory.h
@@ -0,0 +1,404 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#pragma once
+
+#include <pcl/oneapi/containers/kernel_containers.h>
+#include <pcl/pcl_exports.h>
+
+#include <atomic>
+
+namespace pcl {
+namespace oneapi {
+///////////////////////////////////////////////////////////////////////////////
+enum MemoryType {
+  SHARED_MEMORY,
+  DEVICE_MEMORY,
+  HOST_MEMORY
+};
+/** \brief @b DeviceMemory class
+ *
+ * \note This is a BLOB container class with reference counting for GPU memory.
+ *
+ * \author Anatoly Baksheev
+ */
+
+class PCL_EXPORTS DeviceMemory {
+public:
+  /** \brief Empty constructor. */
+  DeviceMemory();
+
+  /** \brief Destructor. */
+  ~DeviceMemory();
+
+  /** \brief Allocates internal buffer in GPU memory
+   * \param sizeBytes_arg amount of memory to allocate
+   * */
+  DeviceMemory(std::size_t sizeBytes_arg);
+
+  DeviceMemory(std::size_t sizeBytes_arg, sycl::queue *q);
+
+  template <typename A>
+  DeviceMemory(std::size_t sizeBytes_arg, A pattern, bool wait);
+
+  template <typename A>
+  DeviceMemory(std::size_t sizeBytes_arg, sycl::queue *q, A pattern, bool wait);
+
+  /** \brief Initializes with user allocated buffer. Reference counting is disabled in
+   * this case.
+   * \param ptr_arg pointer to buffer
+   * \param sizeBytes_arg buffer size
+   * */
+  DeviceMemory(void* ptr_arg, std::size_t sizeBytes_arg);
+
+  DeviceMemory(const void* ptr_arg, std::size_t sizeBytes_arg);
+  /** \brief Initializes with user allocated buffer. Reference counting is disabled in
+   * this case.
+   * \param sizeBytes_arg buffer size
+   * \param type Memory type such as shared, device, or host
+   * */
+  DeviceMemory(std::size_t sizeBytes_arg, MemoryType type);
+
+  /** \brief Copy constructor. Just increments reference counter. */
+  DeviceMemory(const DeviceMemory& other_arg);
+
+  /** \brief Assignment operator. Just increments reference counter. */
+  DeviceMemory&
+  operator=(const DeviceMemory& other_arg);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param sizeBytes_arg buffer size
+   * */
+  void
+  create(std::size_t sizeBytes_arg);
+
+  void
+  create(std::size_t sizeBytes_arg, sycl::queue* q);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param sizeBytes_arg buffer size
+   * \param type device memory type (MemoryType)
+   * */
+  void
+  create(std::size_t sizeBytes_arg, MemoryType type);
+
+  void
+  create(std::size_t sizeBytes_arg, MemoryType type, sycl::queue* q);
+
+  /** \brief Change the size without reallocate the buffer if the new size is smaller.
+   * \param sizeBytes_arg buffer size
+   * */
+  void
+  resize(std::size_t sizeBytes_arg);
+
+  /** \brief Decrements reference counter and releases internal buffer if needed. */
+  void
+  release();
+
+  /** \brief Performs data copying. If destination size differs it will be reallocated.
+   * \param other destination container
+   * */
+  void
+  copyTo(DeviceMemory& other) const;
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param host_ptr_arg pointer to buffer to upload
+   * \param sizeBytes_arg buffer size
+   * */
+  void
+  upload(const void* host_ptr_arg, std::size_t sizeBytes_arg);
+
+  /** \brief Uploads data from CPU memory to device array.
+   * \note This overload never allocates memory in contrast to the
+   * other upload function.
+   * \return true if upload successful
+   * \param host_ptr_arg pointer to buffer to upload
+   * \param device_begin_byte_offset first byte position to upload to
+   * \param num_bytes number of bytes to upload
+   * */
+  bool
+  upload(const void* host_ptr_arg,
+         std::size_t device_begin_byte_offset,
+         std::size_t num_bytes);
+
+  /** \brief Downloads data from internal buffer to CPU memory
+   * \param host_ptr_arg pointer to buffer to download
+   * */
+  void
+  download(void* host_ptr_arg) const;
+
+  /** \brief Downloads data from internal buffer to CPU memory.
+   * \return true if download successful
+   * \param host_ptr_arg pointer to buffer to download
+   * \param device_begin_byte_offset first byte position to download
+   * \param num_bytes number of bytes to download
+   * */
+  bool
+  download(void* host_ptr_arg,
+           std::size_t device_begin_byte_offset,
+           std::size_t num_bytes) const;
+
+
+  void
+  clear();
+
+  /** \brief Performs swap of data pointed with another device memory.
+   * \param other_arg device memory to swap with
+   * */
+  void
+  swap(DeviceMemory& other_arg);
+
+  /** \brief Returns pointer for internal buffer in GPU memory. */
+  template <class T>
+  T*
+  ptr();
+
+  /** \brief Returns constant pointer for internal buffer in GPU memory. */
+  template <class T>
+  const T*
+  ptr() const;
+
+  /** \brief Conversion to PtrSz for passing to kernel functions. */
+  template <class U>
+  operator PtrSz<U>() const;
+
+  /** \brief Returns true if unallocated otherwise false. */
+  bool
+  empty() const;
+
+  std::size_t
+  sizeBytes() const;
+
+
+private:
+  void
+  create_(std::size_t sizeBytes_arg, MemoryType type);
+
+  /** \brief Device pointer. */
+  void* data_;
+
+  /** \brief Allocated size in bytes. */
+  std::size_t sizeBytes_;
+
+  /** \brief Memory Type. */
+  MemoryType type_;
+
+  /** \brief Pointer to reference counter in CPU memory. */
+  std::atomic<int>* refcount_;
+
+  /** \brief HW queue from SYCL */
+  sycl::queue *q_;
+};
+
+///////////////////////////////////////////////////////////////////////////////
+/** \brief @b DeviceMemory2D class
+ *
+ * \note This is a BLOB container class with reference counting for pitched GPU memory.
+ *
+ * \author Anatoly Baksheev
+ */
+
+class PCL_EXPORTS DeviceMemory2D {
+public:
+  /** \brief Empty constructor. */
+  DeviceMemory2D();
+
+  /** \brief Destructor. */
+  ~DeviceMemory2D();
+
+  /** \brief Allocates internal buffer in GPU memory
+   * \param rows_arg number of rows to allocate
+   * \param colsBytes_arg width of the buffer in bytes
+   * */
+  DeviceMemory2D(int rows_arg, int colsBytes_arg);
+
+  /** \brief Initializes with user allocated buffer. Reference counting is disabled in
+   * this case.
+   * \param rows_arg number of rows
+   * \param colsBytes_arg width of the buffer in bytes
+   * \param data_arg pointer to buffer
+   * \param step_arg stride between two consecutive rows in bytes
+   * */
+  DeviceMemory2D(int rows_arg, int colsBytes_arg, void* data_arg, std::size_t step_arg);
+
+  /** \brief Copy constructor. Just increments reference counter. */
+  DeviceMemory2D(const DeviceMemory2D& other_arg);
+
+  /** \brief Assignment operator. Just increments reference counter. */
+  DeviceMemory2D&
+  operator=(const DeviceMemory2D& other_arg);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param rows_arg number of rows to allocate
+   * \param colsBytes_arg width of the buffer in bytes
+   * */
+  void
+  create(int rows_arg, int colsBytes_arg);
+
+  /** \brief Allocates internal buffer in GPU memory. If internal buffer was created
+   * before the function recreates it with new size. If new and old sizes are equal it
+   * does nothing.
+   * \param rows_arg number of rows to allocate
+   * \param colsBytes_arg width of the buffer in bytes
+   * \param type Memory type such as shared, device, or host
+   * */
+  void
+  create(int rows_arg, int colsBytes_arg, MemoryType type);
+
+
+  void
+  create(int rows_arg, int colsBytes_arg, std::size_t step_arg);
+
+
+  /** \brief Decrements reference counter and releases internal buffer if needed. */
+  void
+  release();
+
+  /** \brief Performs data copying. If destination size differs it will be reallocated.
+   * \param other destination container
+   * */
+  void
+  copyTo(DeviceMemory2D& other);
+
+  /** \brief Uploads data to internal buffer in GPU memory. It calls create() inside to
+   * ensure that intenal buffer size is enough.
+   * \param host_ptr_arg pointer to host buffer to upload
+   * \param host_step_arg stride between two consecutive rows in bytes for host buffer
+   * \param rows_arg number of rows to upload
+   * \param colsBytes_arg width of host buffer in bytes
+   * */
+  void
+  upload(const void* host_ptr_arg,
+         std::size_t host_step_arg,
+         int rows_arg,
+         int colsBytes_arg);
+
+  /** \brief Downloads data from internal buffer to CPU memory. User is responsible for
+   * correct host buffer size.
+   * \param host_ptr_arg pointer to host buffer to download
+   * \param host_step_arg stride between two consecutive rows in bytes for host buffer
+   * */
+  void
+  download(void* host_ptr_arg, std::size_t host_step_arg);
+
+  /** \brief Performs swap of data pointed with another device memory.
+   * \param other_arg device memory to swap with
+   * */
+  void
+  swap(DeviceMemory2D& other_arg);
+
+  /** \brief Returns pointer to given row in internal buffer.
+   * \param y_arg row index
+   * */
+  template <class T>
+  T*
+  ptr();
+
+  /** \brief Returns pointer to given row in internal buffer.
+   * \param y_arg row index
+   * */
+  template <class T>
+  T*
+  ptr(int y_arg = 0);
+
+  /** \brief Returns constant pointer to given row in internal buffer.
+   * \param y_arg row index
+   * */
+  template <class T>
+  const T*
+  ptr(int y_arg = 0) const;
+
+  /** \brief Conversion to PtrStep for passing to kernel functions. */
+  template <class U>
+  operator PtrStep<U>() const;
+
+  /** \brief Conversion to PtrStepSz for passing to kernel functions. */
+  template <class U>
+  operator PtrStepSz<U>() const;
+
+  /** \brief Returns true if unallocated otherwise false. */
+  bool
+  empty() const;
+
+  /** \brief Returns number of bytes in each row. */
+  int
+  colsBytes() const;
+
+  /** \brief Returns number of rows. */
+  int
+  rows() const;
+
+  /** \brief Returns stride between two consecutive rows in bytes for internal buffer.
+   * Step is stored always and everywhere in bytes!!! */
+  std::size_t
+  step() const;
+
+private:
+  void
+  create_(std::size_t& step, int cols, int rows, MemoryType type);
+  /** \brief Device pointer. */
+  void* data_;
+
+  /** \brief Stride between two consecutive rows in bytes for internal buffer. Step is
+   * stored always and everywhere in bytes!!! */
+  std::size_t step_;
+
+  /** \brief Width of the buffer in bytes. */
+  int colsBytes_;
+
+  /** \brief Number of rows. */
+  int rows_;
+
+  /** \brief Memory Type. */
+  MemoryType type_;
+
+  /** \brief Pointer to reference counter in CPU memory. */
+  std::atomic<int>* refcount_;
+
+  /** \brief HW queue from SYCL */
+  sycl::queue *q_;
+};
+} // namespace oneapi
+} // namespace pcl
+
+#include <pcl/oneapi/containers/impl/device_memory.hpp>
diff --git a/oneapi/common/include/pcl/oneapi/containers/gpu_memory_manager.h b/oneapi/common/include/pcl/oneapi/containers/gpu_memory_manager.h
new file mode 100644
index 000000000..23f3c1d8a
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/gpu_memory_manager.h
@@ -0,0 +1,84 @@
+/*
+Author: Gao Mingcen
+Date: 28/02/2013
+
+File Name: GpuMemoryManager.h
+
+Class definition of GpuMemoryManager, a simple manager of managing memory for GPU
+
+===============================================================================
+
+Copyright (c) 2012, 2013, School of Computing, National University of Singapore.
+All rights reserved.
+
+Project homepage: http://www.comp.nus.edu.sg/~tants/flipflop.html
+
+If you use ffHull and you like it or have comments on its usefulness etc., we
+would love to hear from you at <tants@comp.nus.edu.sg>. You may share with us
+your experience and any possibilities that we may improve the work/code.
+
+===============================================================================
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list of
+conditions and the following disclaimer. Redistributions in binary form must reproduce
+the above copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the distribution.
+
+Neither the name of the National University of Singapore nor the names of its contributors
+may be used to endorse or promote products derived from this software without specific
+prior written permission from the National University of Singapore.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+*/
+
+#pragma once
+
+#include <dpct/dpl_utils.hpp>
+
+struct GpuMemoryUnit
+{
+  int * pointer;
+  int byteLength;
+};
+
+class GpuMemoryManager
+{
+private:
+  int _initialized;
+  size_t _maxByteLength;
+  size_t _usedByteLength;
+  int _createTimes;
+  int _reuseTimes;
+  int _releaseTimes;
+  int _deleteTimes;
+  size_t _accumulatedLength;
+  bool _shared;
+  std::vector <GpuMemoryUnit> freeMemoryPool;
+  std::vector <GpuMemoryUnit> usingMemoryPool;
+  int _findFirstFittingFreeUnit(size_t byteLength);
+  int _findUsingUnit(void * pointer);
+  bool _createMemory(void ** pointer, size_t byteLength);
+  bool _freeMemory(size_t byteLength);
+
+  dpct::device_ext *dev_ct1;
+
+public:
+  GpuMemoryManager(bool shared);
+  ~GpuMemoryManager(void);
+  void InitializeQueue(size_t maxByteLength);
+  bool GetMemory(void ** pointer, size_t byteLength);
+  bool ReleaseMemory(void * pointer);
+  bool ExpandArray(void ** pointer, size_t oldByteLength, size_t newByteLength);
+};
diff --git a/oneapi/common/include/pcl/oneapi/containers/impl/device_array.hpp b/oneapi/common/include/pcl/oneapi/containers/impl/device_array.hpp
new file mode 100644
index 000000000..1f4239690
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/impl/device_array.hpp
@@ -0,0 +1,450 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_CONTAINER_DEVICE_ARRAY_IMPL_HPP_
+#define PCL_ONEAPI_CONTAINER_DEVICE_ARRAY_IMPL_HPP_
+
+namespace pcl {
+
+namespace oneapi {
+
+////////////////////  Inline implementations of DeviceArray //////////////////
+
+template <class T>
+inline DeviceArray<T>::DeviceArray()
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(std::size_t size) : DeviceMemory(size * elem_size)
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(std::size_t size, sycl::queue *q) : DeviceMemory(size * elem_size, q)
+{}
+
+template <class T>
+template <class A>
+inline DeviceArray<T>::DeviceArray(std::size_t size, A pattern, bool wait) : DeviceMemory(size * elem_size, pattern, wait)
+{}
+
+template <class T>
+template <class A>
+inline DeviceArray<T>::DeviceArray(std::size_t size, sycl::queue *q, A pattern, bool wait) : DeviceMemory(size * elem_size, q, pattern, wait)
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(T* ptr, std::size_t size)
+: DeviceMemory(ptr, size * elem_size)
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(const T* ptr, std::size_t size)
+: DeviceMemory(ptr, size * elem_size)
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(std::size_t size, MemoryType type)
+: DeviceMemory(size * elem_size, type)
+{}
+
+template <class T>
+inline DeviceArray<T>::DeviceArray(const DeviceArray& other) : DeviceMemory(other)
+{}
+
+template <class T>
+inline DeviceArray<T>&
+DeviceArray<T>::operator=(const DeviceArray& other)
+{
+  DeviceMemory::operator=(other);
+  return *this;
+}
+
+template <class T>
+inline void
+DeviceArray<T>::create(std::size_t size)
+{
+  DeviceMemory::create(size * elem_size);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::create(std::size_t size, sycl::queue *q)
+{
+  DeviceMemory::create(size * elem_size, q);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::create(std::size_t size, MemoryType type)
+{
+  DeviceMemory::create(size * elem_size, type);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::create(std::size_t size, MemoryType type, sycl::queue *q)
+{
+  DeviceMemory::create(size * elem_size, type, q);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::resize(std::size_t size)
+{
+  DeviceMemory::resize(size * elem_size);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::release()
+{
+  DeviceMemory::release();
+}
+
+template <class T>
+inline void
+DeviceArray<T>::copyTo(DeviceArray& other) const
+{
+  DeviceMemory::copyTo(other);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::upload(const T* host_ptr, std::size_t size)
+{
+  DeviceMemory::upload(host_ptr, size * elem_size);
+}
+
+template <class T>
+inline bool
+DeviceArray<T>::upload(const T* host_ptr,
+                       std::size_t device_begin_offset,
+                       std::size_t num_elements)
+{
+  std::size_t begin_byte_offset = device_begin_offset * sizeof(T);
+  std::size_t num_bytes = num_elements * sizeof(T);
+  return DeviceMemory::upload(host_ptr, begin_byte_offset, num_bytes);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::download(T* host_ptr) const
+{
+  DeviceMemory::download(host_ptr);
+}
+
+template <class T>
+inline bool
+DeviceArray<T>::download(T* host_ptr,
+                         std::size_t device_begin_offset,
+                         std::size_t num_elements) const
+{
+  std::size_t begin_byte_offset = device_begin_offset * sizeof(T);
+  std::size_t num_bytes = num_elements * sizeof(T);
+  return DeviceMemory::download(host_ptr, begin_byte_offset, num_bytes);
+}
+
+template <class T>
+inline void
+DeviceArray<T>::clear()
+{
+  DeviceMemory::clear();
+}
+
+template <class T>
+void
+DeviceArray<T>::swap(DeviceArray& other_arg)
+{
+  DeviceMemory::swap(other_arg);
+}
+
+template <typename T>
+void
+DeviceArray<T>::insert(device_iterator<T> position, device_iterator<const T> first, device_iterator<const T> last)
+{
+  auto n = std::distance(first, last);
+  if (n < 0)
+    throw std::invalid_argument("Incorrect negative index of iterator distance");
+
+  if (position == end())
+  {
+    resize(size() + n);
+    upload(first.get_buffer().data(), n * elem_size, n * elem_size);
+  }
+  else
+  {
+    auto old_idx = std::distance(begin(), position);
+    auto remaining_elems = std::distance(position, end());
+
+    if (remaining_elems < 0)
+      throw std::invalid_argument("Incorrect negative index of iterator distance");
+
+    DeviceArray<T> tmp (remaining_elems);
+    tmp.upload((T *)(position.get_buffer().data() + position.get_idx()), 0, remaining_elems);
+    resize(size() + n);
+
+    upload(first.get_buffer().data(), old_idx * elem_size, n * elem_size);
+    upload(tmp.ptr(), (old_idx + n) * elem_size, remaining_elems * elem_size);
+  }
+}
+
+template <class T>
+inline DeviceArray<T>::operator T*()
+{
+  return ptr();
+}
+
+template <class T>
+inline DeviceArray<T>::operator const T*() const
+{
+  return ptr();
+}
+
+template <class T>
+inline std::size_t
+DeviceArray<T>::size() const
+{
+  return sizeBytes() / sizeof(T);
+}
+
+template <class T>
+inline T*
+DeviceArray<T>::ptr()
+{
+  return DeviceMemory::ptr<T>();
+}
+
+template <class T>
+inline const T*
+DeviceArray<T>::ptr() const
+{
+  return DeviceMemory::ptr<T>();
+}
+
+
+template <class T>
+template <class A>
+inline void
+DeviceArray<T>::upload(const std::vector<T, A>& data)
+{
+  upload(&data[0], data.size());
+}
+
+template <class T>
+template <class A>
+inline void
+DeviceArray<T>::download(std::vector<T, A>& data) const
+{
+  data.resize(size());
+  if (!data.empty())
+    download(&data[0]);
+}
+
+///////////////////  Inline implementations of DeviceArray2D //////////////////
+
+template <class T>
+inline DeviceArray2D<T>::DeviceArray2D()
+{}
+
+template <class T>
+inline DeviceArray2D<T>::DeviceArray2D(int rows, int cols)
+: DeviceMemory2D(rows, cols * elem_size)
+{}
+
+template <class T>
+inline DeviceArray2D<T>::DeviceArray2D(int rows,
+                                       int cols,
+                                       void* data,
+                                       std::size_t stepBytes)
+: DeviceMemory2D(rows, cols * elem_size, data, stepBytes)
+{}
+
+template <class T>
+inline DeviceArray2D<T>::DeviceArray2D(const DeviceArray2D& other)
+: DeviceMemory2D(other)
+{}
+
+template <class T>
+inline DeviceArray2D<T>&
+DeviceArray2D<T>::operator=(const DeviceArray2D& other)
+{
+  DeviceMemory2D::operator=(other);
+  return *this;
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::create(int rows, int cols)
+{
+  DeviceMemory2D::create(rows, cols * elem_size);
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::create(int rows, int cols, MemoryType type)
+{
+  DeviceMemory2D::create(rows, cols * elem_size, type);
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::create(int rows, int cols, std::size_t stepBytes)
+{
+  DeviceMemory2D::create(rows, cols * elem_size, stepBytes);
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::release()
+{
+  DeviceMemory2D::release();
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::copyTo(DeviceArray2D& other)
+{
+  DeviceMemory2D::copyTo(other);
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::upload(const void* host_ptr,
+                         std::size_t host_step,
+                         int rows,
+                         int cols)
+{
+  DeviceMemory2D::upload(host_ptr, host_step, rows, cols * elem_size);
+}
+
+template <class T>
+inline void
+DeviceArray2D<T>::download(void* host_ptr, std::size_t host_step)
+{
+  DeviceMemory2D::download(host_ptr, host_step);
+}
+
+template <class T>
+template <class A>
+inline void
+DeviceArray2D<T>::upload(const std::vector<T, A>& data, int cols)
+{
+  upload(&data[0], cols * elem_size, data.size() / cols, cols);
+}
+
+template <class T>
+template <class A>
+inline void
+DeviceArray2D<T>::download(std::vector<T, A>& data, int& elem_step)
+{
+  elem_step = cols();
+  data.resize(cols() * rows());
+  if (!data.empty())
+    download(&data[0], colsBytes());
+}
+
+template <class T>
+void
+DeviceArray2D<T>::swap(DeviceArray2D& other_arg)
+{
+  DeviceMemory2D::swap(other_arg);
+}
+
+template <class T>
+inline T*
+DeviceArray2D<T>::ptr() const
+{
+  return DeviceMemory2D::ptr<T>();
+}
+
+template <class T>
+inline T*
+DeviceArray2D<T>::ptr(int y)
+{
+  return DeviceMemory2D::ptr<T>(y);
+}
+
+template <class T>
+inline const T*
+DeviceArray2D<T>::ptr(int y) const
+{
+  return DeviceMemory2D::ptr<T>(y);
+}
+
+template <class T>
+inline const T *
+DeviceArray2D<T>::operator[](size_t index) const
+{
+  return DeviceMemory2D::ptr<T>(index);
+}
+
+template <class T>
+inline DeviceArray2D<T>::operator T*()
+{
+  return DeviceMemory2D::ptr<T>();
+}
+
+template <class T>
+inline DeviceArray2D<T>::operator const T*() const
+{
+  return DeviceMemory2D::ptr<T>();
+}
+
+template <class T>
+inline int
+DeviceArray2D<T>::cols() const
+{
+  return DeviceMemory2D::colsBytes() / sizeof(T);
+}
+
+template <class T>
+inline int
+DeviceArray2D<T>::rows() const
+{
+  return DeviceMemory2D::rows();
+}
+
+template <class T>
+inline std::size_t
+DeviceArray2D<T>::elem_step() const
+{
+  return DeviceMemory2D::step() / sizeof(T);
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#endif /* PCL_ONEAPI_CONTAINER_DEVICE_ARRAY_IMPL_HPP_ */
diff --git a/oneapi/common/include/pcl/oneapi/containers/impl/device_memory.hpp b/oneapi/common/include/pcl/oneapi/containers/impl/device_memory.hpp
new file mode 100644
index 000000000..169904695
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/impl/device_memory.hpp
@@ -0,0 +1,134 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_CONTAINER_DEVICE_MEMORY_IMPL_HPP_
+#define PCL_ONEAPI_CONTAINER_DEVICE_MEMORY_IMPL_HPP_
+
+#include <dpct/dpct.hpp>
+
+namespace pcl {
+
+namespace oneapi {
+
+////////////////////  Inline implementations of DeviceMemory //////////////////
+template <typename U>
+pcl::oneapi::DeviceMemory::DeviceMemory(std::size_t sizeBytes_arg, U pattern, bool wait)
+: data_(nullptr), sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(&dpct::get_default_queue())
+{
+  create(sizeBytes_arg);
+
+  if (wait)
+    q_->fill(data_, pattern, sizeBytes_arg/sizeof(U)).wait_and_throw();
+  else
+    q_->fill(data_, pattern, sizeBytes_arg/sizeof(U));
+}
+
+template <typename U>
+pcl::oneapi::DeviceMemory::DeviceMemory(std::size_t sizeBytes_arg, sycl::queue* q, U pattern, bool wait)
+: data_(nullptr), sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(q)
+{
+  create(sizeBytes_arg, q);
+
+  if (wait)
+    q->fill(data_, pattern, sizeBytes_arg/sizeof(U)).wait_and_throw();
+  else
+    q->fill(data_, pattern, sizeBytes_arg/sizeof(U));
+}
+
+template <class T>
+inline T*
+DeviceMemory::ptr()
+{
+  return (T*)data_;
+}
+
+template <class T>
+inline const T*
+DeviceMemory::ptr() const
+{
+  return (const T*)data_;
+}
+
+template <class U>
+inline DeviceMemory::operator PtrSz<U>() const
+{
+  PtrSz<U> result;
+  result.data = (U*)ptr<U>();
+  result.size = sizeBytes_ / sizeof(U);
+  return result;
+}
+
+////////////////////  Inline implementations of DeviceMemory2D ////////////////
+template <class T>
+T*
+DeviceMemory2D::ptr(int y_arg)
+{
+  return (T*)((char*)data_ + y_arg * colsBytes_);
+}
+
+template <class T>
+const T*
+DeviceMemory2D::ptr(int y_arg) const
+{
+  return (const T*)((const char*)data_ + y_arg * colsBytes_);
+}
+
+template <class U>
+DeviceMemory2D::operator PtrStep<U>() const
+{
+  PtrStep<U> result;
+  result.data = (U*)ptr<U>();
+  result.step = step_;
+  return result;
+}
+
+template <class U>
+DeviceMemory2D::operator PtrStepSz<U>() const
+{
+  PtrStepSz<U> result;
+  result.data = (U*)ptr<U>();
+  result.step = step_;
+  result.cols = colsBytes_ / sizeof(U);
+  result.rows = rows_;
+  return result;
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#endif /* PCL_ONEAPI_CONTAINER_DEVICE_MEMORY_IMPL_HPP_ */
diff --git a/oneapi/common/include/pcl/oneapi/containers/initialization.h b/oneapi/common/include/pcl/oneapi/containers/initialization.h
new file mode 100644
index 000000000..ea8f84e84
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/initialization.h
@@ -0,0 +1,85 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#pragma once
+
+#include <pcl/pcl_exports.h>
+
+#include <string>
+
+namespace pcl {
+namespace oneapi {
+/** \brief Returns number of Cuda device. */
+PCL_EXPORTS int
+getCudaEnabledDeviceCount();
+
+/** \brief Sets active device to work with. */
+PCL_EXPORTS void
+setDevice(int device);
+
+/** \brief Return device name for given device. */
+PCL_EXPORTS std::string
+getDeviceName(int device);
+
+/** \brief Prints information about given cuda device or about all devices
+ *  \param device: if < 0 prints info for all devices, otherwise the function interprets
+ * it as device id.
+ */
+void PCL_EXPORTS
+printCudaDeviceInfo(int device = -1);
+
+/** \brief Prints information about given cuda device or about all devices
+ *  \param device: if < 0 prints info for all devices, otherwise the function interprets
+ * it as device id.
+ */
+void PCL_EXPORTS
+printShortCudaDeviceInfo(int device = -1);
+
+/** \brief Returns true if pre-Fermi generator GPU.
+ * \param device: device id to check, if < 0 checks current device.
+ */
+bool PCL_EXPORTS
+checkIfPreFermiGPU(int device = -1);
+
+/** \brief Error handler. All GPU functions call this to report an error. For internal
+ * use only */
+void PCL_EXPORTS
+error(const char* error_string,
+      const char* file,
+      const int line,
+      const char* func = "");
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/containers/kernel_containers.h b/oneapi/common/include/pcl/oneapi/containers/kernel_containers.h
new file mode 100644
index 000000000..9427b71eb
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/containers/kernel_containers.h
@@ -0,0 +1,142 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#pragma once
+
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#if defined(SYCL_LANGUAGE_VERSION)
+#define __PCL_ONEAPI_HOST_DEVICE__ __inline__ __attribute__ ((always_inline))
+#else
+#define __PCL_ONEAPI_HOST_DEVICE__
+#endif
+
+#include <CL/sycl.hpp>
+#include <cstddef>
+
+namespace pcl {
+namespace oneapi {
+template <typename T>
+struct DevPtr {
+  using elem_type = T;
+  const static std::size_t elem_size = sizeof(elem_type);
+
+  T* data;
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  DevPtr() : data(nullptr) {}
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  DevPtr(T* data_arg) : data(data_arg) {}
+
+  __PCL_ONEAPI_HOST_DEVICE__ std::size_t
+  elemSize() const
+  {
+    return elem_size;
+  }
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  operator T*() { return data; }
+  __PCL_ONEAPI_HOST_DEVICE__ operator const T*() const { return data; }
+};
+
+template <typename T>
+struct PtrSz : public DevPtr<T> {
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrSz() : size(0) {}
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrSz(T* data_arg, std::size_t size_arg) : DevPtr<T>(data_arg), size(size_arg) {}
+
+  std::size_t size;
+};
+
+template <typename T>
+struct PtrStep : public DevPtr<T> {
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrStep() : step(0) {}
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrStep(T* data_arg, std::size_t step_arg) : DevPtr<T>(data_arg), step(step_arg) {}
+
+  /** \brief stride between two consecutive rows in bytes. Step is stored always and
+   * everywhere in bytes!!! */
+  std::size_t step;
+
+  __PCL_ONEAPI_HOST_DEVICE__ T*
+  ptr(int y = 0)
+  {
+    return (T*)((char*)DevPtr<T>::data + y * step);
+  }
+
+  __PCL_ONEAPI_HOST_DEVICE__ const T*
+  ptr(int y = 0) const
+  {
+    return (const T*)((const char*)DevPtr<T>::data + y * step);
+  }
+
+  __PCL_ONEAPI_HOST_DEVICE__ T&
+  operator()(int y, int x)
+  {
+    return ptr(y)[x];
+  }
+
+  __PCL_ONEAPI_HOST_DEVICE__ const T&
+  operator()(int y, int x) const
+  {
+    return ptr(y)[x];
+  }
+};
+
+template <typename T>
+struct PtrStepSz : public PtrStep<T> {
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrStepSz() : cols(0), rows(0) {}
+
+  __PCL_ONEAPI_HOST_DEVICE__
+  PtrStepSz(int rows_arg, int cols_arg, T* data_arg, std::size_t step_arg)
+  : PtrStep<T>(data_arg, step_arg), cols(cols_arg), rows(rows_arg)
+  {}
+
+  int cols;
+  int rows;
+};
+} // namespace oneapi
+} // namespace pcl
+
+#undef __PCL_ONEAPI_HOST_DEVICE__
diff --git a/oneapi/common/include/pcl/oneapi/impl/pcl_base.hpp b/oneapi/common/include/pcl/oneapi/impl/pcl_base.hpp
new file mode 100644
index 000000000..34710b6ca
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/impl/pcl_base.hpp
@@ -0,0 +1,228 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef PCL_ONEAPI_PCL_IMPL_BASE_HPP_
+#define PCL_ONEAPI_PCL_IMPL_BASE_HPP_
+
+#include <pcl/oneapi/pcl_base.h>
+#include <pcl/console/print.h>
+#include <cstddef>
+
+namespace pcl
+{
+namespace oneapi
+{
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT>
+PCLBase<PointT>::PCLBase ()
+  : input_ (std::make_shared<PointCloudDev>())
+  , indices_ (std::make_shared<IndicesDev>())
+  , use_indices_ (false)
+  , fake_indices_ (false)
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT>
+PCLBase<PointT>::PCLBase (const PCLBase& base)
+  : input_ (base.input_)
+  , indices_ (base.indices_)
+  , use_indices_ (base.use_indices_)
+  , fake_indices_ (base.fake_indices_)
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setInputCloud (const PointCloudConstPtr &cloud)
+{
+  PointCloudDev tmp(cloud);
+
+  input_ = tmp.makeShared();
+  //input_ext_ = cloud;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setInputCloud(const PointCloudDevConstPtr &cloud)
+{
+  input_ = cloud;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const IndicesPtr &indices)
+{
+  indices_->upload(indices->data(), indices->size());
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const IndicesDevPtr &indices)
+{
+  indices_ = indices;
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const IndicesConstPtr &indices)
+{
+  indices_->upload(indices->data(), indices->size());
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const IndicesDevConstPtr &indices)
+{
+  indices_ = std::const_pointer_cast<IndicesDev>(indices);
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const PointIndicesConstPtr &indices)
+{
+  indices_->upload(indices->indices.data(), indices->indices.size());
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (const PointIndicesDevConstPtr &indices)
+{
+  indices_ = std::make_shared<IndicesDev>(indices->indices);
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+PCLBase<PointT>::setIndices (std::size_t row_start, std::size_t col_start, std::size_t nb_rows, std::size_t nb_cols)
+{
+  if ((nb_rows > input_->height) || (row_start > input_->height))
+  {
+    PCL_ERROR ("[PCLBase::setIndices] cloud is only %d height\n", input_->height);
+    return;
+  }
+
+  if ((nb_cols > input_->width) || (col_start > input_->width))
+  {
+    PCL_ERROR ("[PCLBase::setIndices] cloud is only %d width\n", input_->width);
+    return;
+  }
+
+  std::size_t row_end = row_start + nb_rows;
+  if (row_end > input_->height)
+  {
+    PCL_ERROR ("[PCLBase::setIndices] %d is out of rows range %d\n", row_end, input_->height);
+    return;
+  }
+
+  std::size_t col_end = col_start + nb_cols;
+  if (col_end > input_->width)
+  {
+    PCL_ERROR ("[PCLBase::setIndices] %d is out of columns range %d\n", col_end, input_->width);
+    return;
+  }
+
+  indices_->resize(nb_cols * nb_rows);
+  for(std::size_t i = row_start; i < row_end; i++)
+    for(std::size_t j = col_start; j < col_end; j++)
+      indices_->ptr()[i* input_->width + j] = static_cast<int>((i * input_->width) + j);
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+PCLBase<PointT>::initCompute ()
+{
+  // Check if input was set
+  if (!input_)
+  {
+    PCL_ERROR ("[initCompute] No input set.\n");
+    return (false);
+  }
+
+  // If no point indices have been given, construct a set of indices for the entire input point cloud
+  if (indices_->size() == 0)
+  {
+    fake_indices_ = true;
+//    indices_->clear();
+  }
+
+  // If we have a set of fake indices, but they do not match the number of points in the cloud, update them
+  if (fake_indices_ && indices_->size () != input_->size ())
+  {
+    const auto indices_size = indices_->size ();
+    try
+    {
+      indices_->resize(input_->size());
+     // indices_ext_->resize(input_->size());
+    }
+    catch (const std::bad_alloc&)
+    {
+      PCL_ERROR ("[initCompute] Failed to allocate %lu indices.\n", input_->size ());
+    }
+    for (auto i = indices_size; i < indices_->size (); ++i) { (*indices_)[i] = static_cast<int>(i); }
+  }
+
+  return (true);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+PCLBase<PointT>::deinitCompute ()
+{
+  return (true);
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_OneAPI_PCLBase(T) template class PCL_EXPORTS pcl::oneapi::PCLBase<T>;
+
+#endif  //#ifndef PCL_ONEAPI_PCL_IMPL_BASE_HPP_
+
diff --git a/oneapi/common/include/pcl/oneapi/pcl_base.h b/oneapi/common/include/pcl/oneapi/pcl_base.h
new file mode 100644
index 000000000..f5a84e9e9
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/pcl_base.h
@@ -0,0 +1,310 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#if defined __GNUC__
+#  pragma GCC system_header
+#endif
+//#include <oneapi/dpl/execution>
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/oneapi/PointIndices.h>
+#include <pcl/oneapi/types.h>
+// Include PCL macros such as PCL_ERROR, PCL_MAKE_ALIGNED_OPERATOR_NEW, etc
+#include <pcl/memory.h>
+#include <pcl/pcl_macros.h>
+
+// Point Cloud message includes. Needed everywhere.
+#include <pcl/point_cloud.h>
+#include <pcl/oneapi/PointIndices.h>
+#include <pcl/oneapi/PCLPointCloud2.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  // definitions used everywhere
+  using IndicesPtr = shared_ptr<Indices>;
+  using IndicesConstPtr = shared_ptr<const Indices>;
+
+  using IndicesDev = typename pcl::oneapi::DeviceArray<index_t>;
+  using IndicesDevPtr = shared_ptr<IndicesDev>;
+  using IndicesDevConstPtr = shared_ptr<const IndicesDev>;
+
+  //Used to denote that a value has not been set for an index_t variable
+  static  constexpr index_t UNAVAILABLE = static_cast<index_t>(-1);
+
+  /////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief PCL base class. Implements methods that are used by most PCL algorithms.
+    * \ingroup common
+    */
+  template <typename PointT>
+  class PCLBase
+  {
+    public:
+      using PointCloud = pcl::PointCloud<PointT>;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+      using PointCloudDev = pcl::oneapi::PointCloudDev<PointT>;
+      using PointCloudDevPtr = typename PointCloudDev::Ptr;
+      using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+      using PointIndicesPtr = PointIndices::Ptr;
+      using PointIndicesConstPtr = PointIndices::ConstPtr;
+
+      using PointIndicesDevPtr = PointIndicesDev::Ptr;
+      using PointIndicesDevConstPtr = PointIndicesDev::ConstPtr;
+
+      /** \brief Empty constructor. */
+      PCLBase ();
+
+      /** \brief Copy constructor. */
+      PCLBase (const PCLBase& base);
+
+      /** \brief Destructor. */
+      virtual ~PCLBase () = default;
+
+      /** \brief Provide a pointer to the input dataset
+        * \param[in] cloud the const boost shared pointer to a PointCloud message
+        */
+      virtual void
+      setInputCloud (const PointCloudConstPtr &cloud);
+
+      /** \brief Provide a pointer to the input dataset
+       * \param[in] cloud the const boost shared pointer to a PointCloud device message
+       */
+      virtual void
+      setInputCloud (const PointCloudDevConstPtr &cloud);
+
+      /** \brief Get a pointer to the input point cloud dataset. */
+      inline PointCloudDevConstPtr const
+      getInputCloud () const { return (input_); }
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const IndicesPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const IndicesDevPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const IndicesConstPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const IndicesDevConstPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const PointIndicesConstPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      virtual void
+      setIndices (const PointIndicesDevConstPtr &indices);
+
+      /** \brief Set the indices for the points laying within an interest region of
+        * the point cloud.
+        * \note you shouldn't call this method on unorganized point clouds!
+        * \param[in] row_start the offset on rows
+        * \param[in] col_start the offset on columns
+        * \param[in] nb_rows the number of rows to be considered row_start included
+        * \param[in] nb_cols the number of columns to be considered col_start included
+        */
+      virtual void
+      setIndices (std::size_t row_start, std::size_t col_start, std::size_t nb_rows, std::size_t nb_cols);
+
+      /** \brief Get a pointer to the vector of indices used. */
+      inline IndicesDevPtr
+      getIndices () { return (indices_); }
+
+      /** \brief Get a pointer to the vector of indices used. */
+      inline IndicesDevConstPtr const
+      getIndices () const { return (indices_); }
+
+      /** \brief Override PointCloud operator[] to shorten code
+        * \note this method can be called instead of (*input_)[(*indices_)[pos]]
+        * or (*input_)[(*indices_)[pos]]
+        * \param[in] pos position in indices_ vector
+        */
+      inline const PointT operator[] (std::size_t pos) const
+      {
+        return ((*input_)[(*indices_)[pos]]);
+      }
+
+      /** \brief assignment operator. */
+      inline PCLBase& operator=(const PCLBase& base)
+      {
+        input_ = base.input_;
+        indices_ = base.indices_;
+        use_indices_ = base.use_indices_;
+        fake_indices_ = base.fake_indices_;
+        return *this;
+      }
+    protected:
+      /** \brief The input point cloud dataset. */
+      PointCloudDevConstPtr input_;
+
+      /** \brief A pointer to the vector of point indices to use. */
+      IndicesDevPtr indices_;
+
+      /** \brief Set to true if point indices are used. */
+      bool use_indices_;
+
+      /** \brief If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud. */
+      bool fake_indices_;
+
+      /** \brief This method should get called before starting the actual computation.
+        *
+        * Internally, initCompute() does the following:
+        *   - checks if an input dataset is given, and returns false otherwise
+        *   - checks whether a set of input indices has been given. Returns true if yes.
+        *   - if no input indices have been given, a fake set is created, which will be used until:
+        *     - either a new set is given via setIndices(), or
+        *     - a new cloud is given that has a different set of points. This will trigger an update on the set of fake indices
+        */
+      bool
+      initCompute ();
+
+      /** \brief This method should get called after finishing the actual computation.
+        */
+      bool
+      deinitCompute ();
+
+    public:
+      PCL_MAKE_ALIGNED_OPERATOR_NEW
+  };
+
+  /////////////////////////////////////////////////////////////////////////////////////////
+  template <>
+  class PCL_EXPORTS PCLBase<PCLPointCloud2>
+  {
+    public:
+      using PCLPointCloud2 = pcl::oneapi::PCLPointCloud2;
+      using PCLPointCloud2Ptr = PCLPointCloud2::Ptr;
+      using PCLPointCloud2ConstPtr = PCLPointCloud2::ConstPtr;
+
+      using PointIndicesPtr = PointIndices::Ptr;
+      using PointIndicesConstPtr = PointIndices::ConstPtr;
+
+      using PointIndicesDevPtr = PointIndicesDev::Ptr;
+      using PointIndicesDevConstPtr = PointIndicesDev::ConstPtr;
+
+      /** \brief Empty constructor. */
+      PCLBase ();
+
+      /** \brief destructor. */
+      virtual ~PCLBase () = default;
+
+      /** \brief Provide a pointer to the input dataset
+        * \param cloud the const boost shared pointer to a PointCloud message
+        */
+      void
+      setInputCloud (const PCLPointCloud2ConstPtr &cloud);
+
+      /** \brief Get a pointer to the input point cloud dataset. */
+      inline PCLPointCloud2ConstPtr const
+      getInputCloud () const { return (input_); }
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      void
+      setIndices (const IndicesPtr &indices);
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the indices that represent the input data.
+        */
+      void
+      setIndices (const PointIndicesConstPtr &indices);
+
+      /** \brief Get a pointer to the vector of indices used. */
+      inline IndicesPtr const
+      //getIndices () const { return (indices_); }
+      getIndices () const { return std::make_shared<Indices>(indices_->begin(), indices_->end()); }
+
+    protected:
+      /** \brief The input point cloud dataset. */
+      PCLPointCloud2ConstPtr input_;
+
+      /** \brief A pointer to the vector of point indices to use. */
+      IndicesDevPtr indices_;
+
+      /** \brief Set to true if point indices are used. */
+      bool use_indices_;
+
+      /** \brief If no set of indices are given, we construct a set of fake indices that mimic the input PointCloud. */
+      bool fake_indices_;
+
+      /** \brief The size of each individual field. */
+      std::vector<uindex_t> field_sizes_;
+
+      /** \brief The x-y-z fields indices. */
+      index_t x_idx_, y_idx_, z_idx_;
+
+      /** \brief The desired x-y-z field names. */
+      std::string x_field_name_, y_field_name_, z_field_name_;
+
+      bool initCompute ();
+      bool deinitCompute ();
+    public:
+      PCL_MAKE_ALIGNED_OPERATOR_NEW
+  };
+}
+}
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/impl/pcl_base.hpp>
+#endif
diff --git a/oneapi/common/include/pcl/oneapi/point_cloud.h b/oneapi/common/include/pcl/oneapi/point_cloud.h
new file mode 100644
index 000000000..7918a06ba
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/point_cloud.h
@@ -0,0 +1,226 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+//#include <oneapi/dpl/execution>
+//#include <oneapi/dpl/algorithm>
+//#include <CL/sycl.hpp>
+//#include <dpct/dpct.hpp>
+//#include <dpct/dpl_extras/vector.h>
+//#include <dpct/dpl_extras/algorithm.h>
+#include <pcl/memory.h>
+#include <pcl/point_cloud.h>
+#include <pcl/oneapi/point_types.h>
+#include <pcl/oneapi/containers/device_array.h>
+namespace pcl
+{
+  namespace oneapi
+  {
+    /** \brief Host helper class. Contains several typedefs and some static
+     *         functions to help writing portable code (that runs both on host
+     *         and device) */
+    template <typename T>
+    struct Host
+    {
+      // vector type
+      using type = std::vector<T>;
+    };
+
+    /** \brief Device helper class. Contains several typedefs and some static
+     *         functions to help writing portable code (that runs both on host
+     *         and device) */
+    template <typename T>
+    struct Device
+    {
+      // vector type
+        using type = DeviceArray<T>;
+    };
+
+    /** @b PointCloudDev represents an PointCloudDevice object
+      * implementation for oneapi processing.
+      *
+      * This is the most efficient way to perform operations on x86 architectures 
+      * (using SSE alignment).
+      */
+    template <typename PointT, template <typename> class Storage = Device>
+    class PointCloudDev
+    {
+      public:
+        using Ptr = shared_ptr<PointCloudDev<PointT, Storage>>;
+        using ConstPtr = shared_ptr<const PointCloudDev<PointT, Storage>>;
+
+        PointCloudDev () : width (0), height (0), is_dense (true)
+        {}
+
+        PointCloudDev (std::size_t w, std::size_t h) : is_dense(true)
+        {
+          width = w;
+          height = h;
+          points.create(width * height);
+        }
+
+        PointCloudDev (std::size_t size) : is_dense(true)
+        {
+          width = size;
+          height = 1;
+          points.create(width * height);
+        }
+
+
+        PointCloudDev(typename pcl::PointCloud<PointT>::ConstPtr cloud)
+        {
+          upload(cloud);
+        }
+
+        void create (std::size_t w, std::size_t h)
+        {
+          width = w;
+          height = h;
+          is_dense = true;
+          points.create(width * height);
+        }
+
+        void upload(typename pcl::PointCloud<PointT>::ConstPtr cloud)
+        {
+          points.create(cloud->size());
+          std::transform( cloud->begin(),
+                         cloud->end(),
+                         points.ptr(),
+                         [](PointT p) { return p; });
+          width = cloud->width;
+          height = cloud->height;
+          is_dense = cloud->is_dense;
+        }
+
+        inline void download(typename pcl::PointCloud<PointT>& cloud) const
+        {
+          cloud.points.resize(points.size());
+          std::transform(//dpl::execution::make_device_policy(dpct::get_default_queue()),
+                         points.ptr(),
+                         points.ptr() + points.size(),
+                         cloud.begin(),
+                         [](PointT p) { return p; });
+          cloud.width = width;
+          cloud.height = height;
+          cloud.is_dense = is_dense;
+        }
+
+        /** \brief Copy the cloud to the heap and return a smart pointer
+         * Note that deep copy is performed, so avoid using this function on non-empty clouds.
+         * The changes of the returned cloud are not mirrored back to this one.
+         * \return shared pointer to the copy of the cloud
+         */
+        inline Ptr
+        makeShared () const { return Ptr (new PointCloudDev<PointT> (*this)); }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        template <typename OtherStorage>
+        inline PointCloudDev& operator << (const OtherStorage& rhs)
+        {
+          points.resize (rhs.points.size ());
+          std::copy(
+              //dpl::execution::make_device_policy(dpct::get_default_queue()),
+              rhs.points.begin(),
+              rhs.points.end(),
+              points.begin());
+
+          width    = rhs.width;
+          height   = rhs.height;
+          is_dense = rhs.is_dense;
+          return (*this);
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        inline std::size_t size () const { return points.size (); }
+        inline void resize (std::size_t size) { points.resize (size); }
+        inline bool empty () const { return points.empty (); }
+        inline const PointT& operator[] (std::size_t n) const { return (points[n]); }
+        inline PointT& operator[] (std::size_t n) { return (points[n]); }
+        inline PointT
+        at (int u, int v) const
+        {
+          if (this->height > 1)
+            return (points[v * this->width + u]);
+          return (PointT(std::numeric_limits<float>::quiet_NaN(),
+                                std::numeric_limits<float>::quiet_NaN (),
+                                std::numeric_limits<float>::quiet_NaN (),
+                                0));
+        }
+
+        //////////////////////////////////////////////////////////////////////////////////////
+        inline PointT& operator () (int u, int v)
+        {
+          return (points[v* this->width +u]);
+        }
+        inline const PointT& operator () (int u, int v) const
+        {
+          return (points[v* this->width +u]);
+        }
+
+        /** \brief Removes all points in a cloud and sets the width and height to 0. */
+        inline void
+        clear ()
+        {
+          points.clear();
+          width = 0;
+          height = 0;
+        }
+
+        /** \brief The point data. */
+        typename Storage<PointT>::type points;
+
+        //using iterator = typename Storage<PointT>::type::iterator;
+
+        /** \brief The point cloud width (if organized as an image-structure). */
+        unsigned int width;
+        /** \brief The point cloud height (if organized as an image-structure). */
+        unsigned int height;
+
+        /** \brief True if no points are invalid (e.g., have NaN or Inf values). */
+        bool is_dense;
+        /** \brief The point cloud header. It contains information about the acquisition time. */
+        pcl::PCLHeader header;
+        /** \brief Sensor acquisition pose (origin/translation). */
+        Eigen::Vector4f sensor_origin_ = Eigen::Vector4f::Zero();
+        /** \brief Sensor acquisition pose (rotation). */
+        Eigen::Quaternionf sensor_orientation_ = Eigen::Quaternionf::Identity();
+    };
+  } // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/point_type_rgb.h b/oneapi/common/include/pcl/oneapi/point_type_rgb.h
new file mode 100644
index 000000000..2574aeab8
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/point_type_rgb.h
@@ -0,0 +1,115 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#ifdef RGB
+# undef RGB
+#endif
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Default RGB structure, defined as a union over 4 chars. */
+  union RGB
+  {
+    int rgb;
+    struct
+    {
+      char r;
+      char g;
+      char b;
+      char alpha;
+    };
+
+    inline RGB () {}
+    inline RGB (int _rgb) : rgb(_rgb) {}
+    inline RGB (char _r, char _g, char _b, char _alpha) :
+                                       r(_r), g(_g), b(_b), alpha(_alpha) {}
+
+    inline bool operator == (const RGB &rhs) const
+    {
+      return (r == rhs.r && g == rhs.g && b == rhs.b && alpha == rhs.alpha);
+    }
+
+    inline RGB& operator - (RGB &rhs)
+    {
+      r = -rhs.r;
+      g = -rhs.g;
+      b = -rhs.b;
+      alpha = -rhs.alpha;
+      return (*this);
+    }
+
+    inline RGB& operator += (const RGB &rhs)
+    {
+      r += rhs.r;
+      g += rhs.g;
+      b += rhs.b;
+      alpha += rhs.alpha;
+      return (*this);
+    }
+
+    inline RGB& operator -= (const RGB &rhs)
+    {
+      r -= rhs.r;
+      g -= rhs.g;
+      b -= rhs.b;
+      alpha -= rhs.alpha;
+      return (*this);
+    }
+
+    inline RGB& operator *= (const RGB &rhs)
+    {
+      r *= rhs.r;
+      g *= rhs.g;
+      b *= rhs.b;
+      alpha *= rhs.alpha;
+      return (*this);
+    }
+
+    inline RGB& operator /= (const RGB &rhs)
+    {
+      r /= rhs.r;
+      g /= rhs.g;
+      b /= rhs.b;
+      alpha /= rhs.alpha;
+      return (*this);
+    }
+  };
+
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/point_types.h b/oneapi/common/include/pcl/oneapi/point_types.h
new file mode 100644
index 000000000..3fe2e0ec8
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/point_types.h
@@ -0,0 +1,109 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <CL/sycl.hpp>
+//#include <dpct/dpct.hpp>
+#include <pcl/oneapi/point_type_rgb.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Default point xyz-rgb structure. */
+  struct /*__align__(16)*/ PointXYZRGB
+  {
+    inline PointXYZRGB () {}
+    inline PointXYZRGB (float _x, float _y, float _z, int _rgb) :
+                                     x(_x), y(_y), z(_z), rgb(_rgb) {}
+
+    // Declare a union for XYZ
+    union
+    {
+      sycl::float3 xyz{};
+      struct
+      {
+        float x;
+        float y;
+        float z;
+      };
+    };
+    RGB rgb;
+
+    inline bool operator == (const PointXYZRGB &rhs)
+    {
+      return (x == rhs.x && y == rhs.y && z == rhs.z && rgb == rhs.rgb);
+    }
+
+    // this allows direct assignment of a PointXYZRGB to float3...
+    inline operator sycl::float3() const
+    {
+      return xyz;
+    }
+
+    inline PointXYZRGB& operator += (const PointXYZRGB &rhs)
+    {
+      xyz += rhs.xyz;
+      rgb += rhs.rgb;
+      return (*this);
+    }
+
+    inline PointXYZRGB& operator -= (const PointXYZRGB &rhs)
+    {
+      xyz -= rhs.xyz;
+      rgb -= rhs.rgb;
+      return (*this);
+    }
+
+    inline PointXYZRGB& operator *= (const PointXYZRGB &rhs)
+    {
+      xyz *= rhs.xyz;
+      rgb *= rhs.rgb;
+      return (*this);
+    }
+
+    inline PointXYZRGB& operator /= (const PointXYZRGB &rhs)
+    {
+      xyz /= rhs.xyz;
+      rgb /= rhs.rgb;
+      return (*this);
+    }
+  };
+
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/common/include/pcl/oneapi/types.h b/oneapi/common/include/pcl/oneapi/types.h
new file mode 100644
index 000000000..2144317d0
--- /dev/null
+++ b/oneapi/common/include/pcl/oneapi/types.h
@@ -0,0 +1,141 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2020-, OpenPerception
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#pragma once
+
+/**
+ * \file pcl/types.h
+ *
+ * \brief Defines basic non-point types used by PCL
+ * \ingroup common
+ */
+#include <pcl/pcl_config.h>
+#include <pcl/pcl_macros.h>
+#include <pcl/oneapi/containers/device_array.h>
+
+
+#include <cstdint>
+
+namespace pcl
+{
+namespace oneapi
+{
+  namespace detail {
+    /**
+     * \brief int_type::type refers to an integral type that satisfies template parameters
+     * \tparam Bits number of bits in the integral type
+     * \tparam Signed signed or unsigned nature of the type
+     */
+    template <std::size_t Bits, bool Signed = true>
+    struct int_type { using type = void; };
+
+    /**
+     * \brief helper type to use for `int_type::type`
+     * \see int_type
+     */
+    template <std::size_t Bits, bool Signed = true>
+    using int_type_t = typename int_type<Bits, Signed>::type;
+
+    template <>
+    struct int_type<8, true> { using type = std::int8_t; };
+    template <>
+    struct int_type<8, false> { using type = std::uint8_t; };
+    template <>
+    struct int_type<16, true> { using type = std::int16_t; };
+    template <>
+    struct int_type<16, false> { using type = std::uint16_t; };
+    template <>
+    struct int_type<32, true> { using type = std::int32_t; };
+    template <>
+    struct int_type<32, false> { using type = std::uint32_t; };
+    template <>
+    struct int_type<64, true> { using type = std::int64_t; };
+    template <>
+    struct int_type<64, false> { using type = std::uint64_t; };
+
+    /**
+     * \brief number of bits in PCL's index type
+     *
+     * Please use PCL_INDEX_SIZE when building PCL to choose a size best suited for your needs.
+     * PCL 1.12 will come with default 32
+     *
+     * PCL 1.11 has a default size = sizeof(int)
+     */
+    constexpr std::uint8_t index_type_size = PCL_INDEX_SIZE;
+
+    /**
+     * \brief signed/unsigned nature of PCL's index type
+     * Please use PCL_INDEX_SIGNED when building PCL to choose a type best suited for your needs.
+     * Default: signed
+     */
+    constexpr bool index_type_signed = PCL_INDEX_SIGNED;
+}  // namespace detail
+
+  /**
+   * \brief Type used for an index in PCL
+   *
+   * Default index_t = int for PCL 1.11, std::int32_t for PCL >= 1.12
+   */
+  using index_t = detail::int_type_t<detail::index_type_size, detail::index_type_signed>;
+  static_assert(!std::is_void<index_t>::value, "`index_t` can't have type `void`");
+
+     /**
+   * \brief Type used for an unsigned index in PCL
+   *
+   * Unsigned index that mirrors the type of the index_t
+   */
+  using uindex_t = detail::int_type_t<detail::index_type_size, false>;
+  static_assert(!std::is_signed<uindex_t>::value, "`uindex_t` must be unsigned");
+
+  /**
+   * \brief Type used for indices in PCL
+   * \todo Remove with C++20
+   */
+ // using IndicesAllocator = DeviceArray<index_t>;
+
+  /**
+   * \brief Type used for indices in PCL
+   */
+  using IndicesDev = DeviceArray<index_t>;
+
+  /**
+   * \brief Type used for aligned vector of Eigen objects in PCL
+   */
+//  template <typename T>
+//  using AlignedVector = DeviceArray<T>;
+}  // namespace oneapi
+}  // namespace pcl
+
diff --git a/oneapi/common/src/PCLPointCloud2.cpp b/oneapi/common/src/PCLPointCloud2.cpp
new file mode 100644
index 000000000..01fcce0d5
--- /dev/null
+++ b/oneapi/common/src/PCLPointCloud2.cpp
@@ -0,0 +1,177 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <vector>
+
+#include <pcl/oneapi/common/io.h>
+#include <pcl/pcl_macros.h>
+#include <pcl/exceptions.h>
+#include <pcl/oneapi/PCLPointCloud2.h>
+
+bool
+pcl::oneapi::PCLPointCloud2::concatenate (pcl::oneapi::PCLPointCloud2 &cloud1, const pcl::oneapi::PCLPointCloud2 &cloud2)
+{
+  if (cloud1.is_bigendian != cloud2.is_bigendian)
+  {
+    // In future, it might be possible to convert based on pcl::oneapi::getFieldSize(fields.datatype)
+    PCL_ERROR ("[pcl::PCLPointCloud2::concatenate] Endianness of clouds does not match\n");
+    return (false);
+  }
+
+  const auto size1 = cloud1.width * cloud1.height;
+  const auto size2 = cloud2.width * cloud2.height;
+  //if one input cloud has no points, but the other input does, just select the cloud with points
+  switch ((bool (size1) << 1) + bool (size2))
+  {
+    case 1:
+      cloud1 = cloud2;
+      PCL_FALLTHROUGH
+    case 0:
+    case 2:
+      cloud1.header.stamp = std::max (cloud1.header.stamp, cloud2.header.stamp);
+      return (true);
+    default:
+      break;
+  }
+
+  // Ideally this should be in PCLPointField class since this is global behavior
+  auto field_eq = [](const auto& field1, const auto& field2)
+  {
+    // We're fine with the special RGB vs RGBA use case
+    return ((field1.name == field2.name) ||
+            (field1.name == "rgb" && field2.name == "rgba") ||
+            (field1.name == "rgba" && field2.name == "rgb"));
+  };
+
+  // A simple memcpy is possible if layout (name and order of fields) is same for both clouds
+  bool simple_layout = std::equal(cloud1.fields.begin (),
+                                    cloud1.fields.end (),
+                                    cloud2.fields.begin (),
+                                    cloud2.fields.end (),
+                                    field_eq);
+
+  struct FieldDetails
+  {
+    std::size_t idx1, idx2;
+    std::uint16_t size;
+    FieldDetails (std::size_t idx1_, std::size_t idx2_, std::uint16_t size_): idx1 (idx1_), idx2 (idx2_), size (size_)
+    {}
+  };
+  std::vector<FieldDetails> valid_fields;
+  const auto max_field_size = std::max (cloud1.fields.size (), cloud2.fields.size ());
+  valid_fields.reserve (max_field_size);
+
+  // @TODO: Refactor to return std::optional<std::vector<FieldDetails>>
+  // Store the details of fields with common data in both cloud, exit early if any errors are found
+  if (!simple_layout)
+  {
+    std::size_t i = 0, j = 0;
+    while (i < cloud1.fields.size () && j < cloud2.fields.size ())
+    {
+      if (cloud1.fields[i].name == "_")
+      {
+        ++i;
+        continue;
+      }
+      if (cloud2.fields[j].name == "_")
+      {
+        ++j;
+        continue;
+      }
+
+      if (field_eq(cloud1.fields[i], cloud2.fields[j]))
+      {
+        // Assumption: cloud1.fields[i].datatype == cloud2.fields[j].datatype
+        valid_fields.emplace_back(i, j, pcl::oneapi::getFieldSize (cloud2.fields[j].datatype));
+        ++i;
+        ++j;
+        continue;
+      }
+      PCL_ERROR ("[pcl::PCLPointCloud2::concatenate] Name of field %d in cloud1, %s, does not match name in cloud2, %s\n", i, cloud1.fields[i].name.c_str (), cloud2.fields[i].name.c_str ());
+      return (false);
+    }
+    // Both i and j should have exhausted their respective cloud.fields
+    if (i != cloud1.fields.size () || j != cloud2.fields.size ())
+    {
+      PCL_ERROR ("[pcl::PCLPointCloud2::concatenate] Number of fields to copy in cloud1 (%u) != Number of fields to copy in cloud2 (%u)\n", i, j);
+      return (false);
+    }
+  }
+
+  // Save the latest timestamp in the destination cloud
+  cloud1.header.stamp = std::max (cloud1.header.stamp, cloud2.header.stamp);
+
+  cloud1.is_dense = cloud1.is_dense && cloud2.is_dense;
+  cloud1.height = 1;
+  cloud1.width = size1 + size2;
+
+  if (simple_layout)
+  {
+    cloud1.data.insert (cloud1.data.end (), cloud2.data.begin (), cloud2.data.end ());
+    return (true);
+  }
+  const auto data1_size = cloud1.data.size ();
+  cloud1.data.resize(data1_size + cloud2.data.size ());
+  for (uindex_t cp = 0; cp < size2; ++cp)
+  {
+    for (const auto& field_data: valid_fields)
+    {
+      const auto& i = field_data.idx1;
+      const auto& j = field_data.idx2;
+      const auto& size = field_data.size;
+      // Leave the data for the skip fields untouched in cloud1
+      // Copy only the required data from cloud2 to the correct location for cloud1
+      memcpy (reinterpret_cast<char*> (&cloud1.data[data1_size + cp * cloud1.point_step + cloud1.fields[i].offset]),
+              reinterpret_cast<const char*> (&cloud2.data[cp * cloud2.point_step + cloud2.fields[j].offset]),
+              cloud2.fields[j].count * size);
+    }
+  }
+  return (true);
+}
+
+pcl::oneapi::PCLPointCloud2&
+pcl::oneapi::PCLPointCloud2::operator += (const PCLPointCloud2& rhs)
+{
+  if (concatenate((*this), rhs))
+  {
+    return (*this);
+  }
+  PCL_THROW_EXCEPTION(ComputeFailedException, "Field or Endian mismatch. Please check log for more details");
+}
diff --git a/oneapi/common/src/common.cpp b/oneapi/common/src/common.cpp
new file mode 100644
index 000000000..a889d132b
--- /dev/null
+++ b/oneapi/common/src/common.cpp
@@ -0,0 +1,88 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: distances.cpp 527 2011-04-17 23:57:26Z rusu $
+ *
+ */
+
+#include <limits>
+
+#include <pcl/oneapi/PCLPointCloud2.h> // for PCLPointCloud2
+#include <pcl/oneapi/common/common.h>
+#include <pcl/console/print.h>
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+void
+pcl::oneapi::getMinMax (const pcl::oneapi::PCLPointCloud2 &cloud, int,
+                const std::string &field_name, float &min_p, float &max_p)
+{
+  min_p = std::numeric_limits<float>::max();
+  max_p = -std::numeric_limits<float>::max();
+
+  const auto result = std::find_if(cloud.fields.begin (), cloud.fields.end (),
+      [&field_name](const auto& field) { return field.name == field_name; });
+  if (result == cloud.fields.end ())
+  {
+    PCL_ERROR ("[getMinMax] Invalid field (%s) given!\n", field_name.c_str ());
+    return;
+  }
+  const auto field_idx = std::distance(cloud.fields.begin (), result);
+
+  for (uindex_t i = 0; i < cloud.fields[field_idx].count; ++i)
+  {
+    float data;
+    // TODO: replace float with the real data type
+    memcpy (&data, &cloud.data[cloud.fields[field_idx].offset + i * sizeof (float)], sizeof (float));
+    min_p = (data > min_p) ? min_p : data; 
+    max_p = (data < max_p) ? max_p : data; 
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+void
+pcl::oneapi::getMeanStdDev (const std::vector<float> &values, double &mean, double &stddev)
+{
+  double sum = 0, sq_sum = 0;
+
+  for (const float &value : values)
+  {
+    sum += value;
+    sq_sum += value * value;
+  }
+  mean = sum / static_cast<double>(values.size ());
+  double variance = (sq_sum - sum * sum / static_cast<double>(values.size ())) / (static_cast<double>(values.size ()) - 1);
+  stddev = sqrt (variance);
+}
+
diff --git a/oneapi/common/src/device_memory.cpp.dp.cpp b/oneapi/common/src/device_memory.cpp.dp.cpp
new file mode 100644
index 000000000..2cdc65d59
--- /dev/null
+++ b/oneapi/common/src/device_memory.cpp.dp.cpp
@@ -0,0 +1,573 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <pcl/oneapi/containers/device_memory.h>
+#include <pcl/pcl_macros.h> // used for PCL_DEPRECATED
+#include <pcl/oneapi/containers/gpu_memory_manager.h>
+
+#include <cassert>
+
+//////////////////////////    XADD    ///////////////////////////////
+
+template <typename _Tp>
+PCL_DEPRECATED(1, 16, "Removed in favour of c++11 atomics")
+static inline _Tp CV_XADD(std::atomic<_Tp>* addr, std::atomic<_Tp> delta)
+{
+  _Tp tmp = addr->fetch_add(delta);
+  return tmp;
+}
+
+////////////////////////    DeviceArray    /////////////////////////////
+
+GpuMemoryManager *memoryManagerShared = new GpuMemoryManager(true);
+GpuMemoryManager *memoryManagerDevice = new GpuMemoryManager(false);
+
+pcl::oneapi::DeviceMemory::DeviceMemory()
+: data_(nullptr), sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(&dpct::get_default_queue())
+{}
+
+pcl::oneapi::DeviceMemory::DeviceMemory(void* ptr_arg, std::size_t sizeBytes_arg)
+: sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(&dpct::get_default_queue())
+{
+  create(sizeBytes_arg);
+
+  upload(ptr_arg, sizeBytes_arg);
+}
+
+pcl::oneapi::DeviceMemory::DeviceMemory(const void* ptr_arg, std::size_t sizeBytes_arg)
+: sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(&dpct::get_default_queue())
+{
+  create(sizeBytes_arg);
+
+  upload(ptr_arg, sizeBytes_arg);
+}
+
+pcl::oneapi::DeviceMemory::DeviceMemory(std::size_t sizeBytes_arg)
+: data_(nullptr), sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(&dpct::get_default_queue())
+{
+  create(sizeBytes_arg);
+}
+
+pcl::oneapi::DeviceMemory::DeviceMemory(std::size_t sizeBytes_arg, sycl::queue *q)
+: data_(nullptr), sizeBytes_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr), q_(q)
+{
+  create(sizeBytes_arg);
+}
+
+pcl::oneapi::DeviceMemory::DeviceMemory(std::size_t sizeBtes_arg, MemoryType type)
+: data_(nullptr), sizeBytes_(0), type_(type), refcount_(nullptr), q_(&dpct::get_default_queue())
+{
+  create(sizeBtes_arg, type);
+}
+
+pcl::oneapi::DeviceMemory::~DeviceMemory() { release(); }
+
+pcl::oneapi::DeviceMemory::DeviceMemory(const DeviceMemory& other_arg)
+: data_(other_arg.data_),
+  sizeBytes_(other_arg.sizeBytes_),
+  type_(other_arg.type_),
+  refcount_(other_arg.refcount_),
+  q_(&dpct::get_default_queue())
+{
+  if (refcount_)
+    refcount_->fetch_add(1);
+}
+
+pcl::oneapi::DeviceMemory&
+pcl::oneapi::DeviceMemory::operator=(const pcl::oneapi::DeviceMemory& other_arg)
+{
+  if (this != &other_arg) {
+    if (other_arg.refcount_)
+      other_arg.refcount_->fetch_add(1);
+    release();
+
+    data_ = other_arg.data_;
+    sizeBytes_ = other_arg.sizeBytes_;
+    refcount_ = other_arg.refcount_;
+  }
+  return *this;
+}
+
+void
+pcl::oneapi::DeviceMemory::create_(std::size_t sizeBytes, MemoryType type)
+{
+  switch(type)
+  {
+    case DEVICE_MEMORY:
+      memoryManagerDevice->InitializeQueue(-1);
+      memoryManagerDevice->GetMemory((void **) &data_, sizeBytes);
+      refcount_ = new std::atomic<int>(1);
+      break;
+    case SHARED_MEMORY:
+      memoryManagerShared->InitializeQueue(-1);
+      memoryManagerShared->GetMemory((void **) &data_, sizeBytes);
+      refcount_ = new std::atomic<int>(1);
+      break;
+    case HOST_MEMORY:
+      data_ = (void*)sycl::malloc_host(sizeBytes, *q_);
+      refcount_ = new std::atomic<int>(1);
+      break;
+    default:
+      break;
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory::create(std::size_t sizeBytes_arg)
+{
+  if (sizeBytes_arg == sizeBytes_)
+    return;
+
+  if (data_)
+    release();
+
+  sizeBytes_ = sizeBytes_arg;
+
+  create_(sizeBytes_, type_);
+}
+
+void
+pcl::oneapi::DeviceMemory::create(std::size_t sizeBytes_arg, sycl::queue* q)
+{
+  if (sizeBytes_arg == sizeBytes_)
+    return;
+
+  if (data_)
+    release();
+
+  sizeBytes_ = sizeBytes_arg;
+
+  q_ = q;
+
+  create_(sizeBytes_, type_);
+}
+
+void
+pcl::oneapi::DeviceMemory::create(std::size_t sizeBytes_arg, MemoryType type)
+{
+  if (sizeBytes_ == sizeBytes_arg)
+    return;
+
+  if (data_)
+    release();
+
+  sizeBytes_ = sizeBytes_arg;
+  type_ = type;
+
+  create_(sizeBytes_, type);
+}
+
+void
+pcl::oneapi::DeviceMemory::create(std::size_t sizeBytes_arg, MemoryType type, sycl::queue* q)
+{
+  if (sizeBytes_ == sizeBytes_arg)
+    return;
+
+  if (data_)
+    release();
+
+  sizeBytes_ = sizeBytes_arg;
+  type_ = type;
+  q_ = q;
+
+  create_(sizeBytes_, type);
+}
+
+void
+pcl::oneapi::DeviceMemory::resize(std::size_t sizeBytes_arg)
+{
+  if (sizeBytes_arg <= sizeBytes_) {
+    sizeBytes_ = sizeBytes_arg;
+  }
+  else {
+    create(sizeBytes_arg);
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory::copyTo(DeviceMemory& other) const
+{
+  if (empty())
+    other.release();
+  else {
+    other.create(sizeBytes_, type_);
+    q_->memcpy(other.data_, data_, sizeBytes_).wait_and_throw();
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory::release()
+{
+  if (refcount_ && refcount_->fetch_sub(1) == 1)
+  {
+    delete refcount_;
+
+    switch(type_)
+    {
+      case DEVICE_MEMORY:
+        memoryManagerDevice->ReleaseMemory(data_);
+        break;
+      case SHARED_MEMORY:
+        memoryManagerShared->ReleaseMemory(data_);
+        break;
+      case HOST_MEMORY:
+        sycl::free(data_, *q_);
+        break;
+      default:
+        break;
+    }
+  }
+  data_ = nullptr;
+  sizeBytes_ = 0;
+  refcount_ = nullptr;
+}
+
+void
+pcl::oneapi::DeviceMemory::clear()
+{
+  release();
+}
+
+void
+pcl::oneapi::DeviceMemory::upload(const void* host_ptr_arg, std::size_t sizeBytes_arg)
+{
+  create(sizeBytes_arg);
+
+   q_->memcpy(data_, host_ptr_arg, sizeBytes_).wait_and_throw();
+}
+
+bool
+pcl::oneapi::DeviceMemory::upload(const void* host_ptr_arg,
+                               std::size_t device_begin_byte_offset,
+                               std::size_t num_bytes)
+{
+  if (device_begin_byte_offset + num_bytes > sizeBytes_) {
+    return false;
+  }
+  void* begin = static_cast<char*>(data_) + device_begin_byte_offset;
+
+   q_->memcpy(begin, host_ptr_arg, num_bytes).wait_and_throw();
+
+  return true;
+}
+
+void
+pcl::oneapi::DeviceMemory::download(void* host_ptr_arg) const
+{
+   q_->memcpy(host_ptr_arg, data_, sizeBytes_).wait_and_throw();
+}
+
+bool
+pcl::oneapi::DeviceMemory::download(void* host_ptr_arg,
+                                 std::size_t device_begin_byte_offset,
+                                 std::size_t num_bytes) const
+{
+  if (device_begin_byte_offset + num_bytes > sizeBytes_) {
+    return false;
+  }
+  const void* begin = static_cast<char*>(data_) + device_begin_byte_offset;
+
+  q_->memcpy(host_ptr_arg, begin, num_bytes).wait_and_throw();
+
+  return true;
+}
+
+void
+pcl::oneapi::DeviceMemory::swap(DeviceMemory& other_arg)
+{
+  std::swap(data_, other_arg.data_);
+  std::swap(sizeBytes_, other_arg.sizeBytes_);
+  std::swap(refcount_, other_arg.refcount_);
+}
+
+bool
+pcl::oneapi::DeviceMemory::empty() const
+{
+  return !data_;
+}
+
+std::size_t
+pcl::oneapi::DeviceMemory::sizeBytes() const
+{
+  return sizeBytes_;
+}
+
+////////////////////////    DeviceArray2D    /////////////////////////////
+
+pcl::oneapi::DeviceMemory2D::DeviceMemory2D()
+: data_(nullptr), step_(0), colsBytes_(0), rows_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr),  q_(&dpct::get_default_queue())
+{}
+
+pcl::oneapi::DeviceMemory2D::DeviceMemory2D(int rows_arg, int colsBytes_arg)
+: data_(nullptr), step_(0), colsBytes_(0), rows_(0), type_(SHARED_MEMORY),
+  refcount_(nullptr),  q_(&dpct::get_default_queue())
+{
+  create(rows_arg, colsBytes_arg);
+}
+
+pcl::oneapi::DeviceMemory2D::DeviceMemory2D(int rows_arg,
+                                         int colsBytes_arg,
+                                         void* data_arg,
+                                         std::size_t step_arg)
+: data_(data_arg),
+  step_(step_arg),
+  colsBytes_(colsBytes_arg),
+  rows_(rows_arg),
+  type_(SHARED_MEMORY),
+  refcount_(nullptr),
+  q_(&dpct::get_default_queue())
+{}
+
+pcl::oneapi::DeviceMemory2D::~DeviceMemory2D() { release(); }
+
+pcl::oneapi::DeviceMemory2D::DeviceMemory2D(const DeviceMemory2D& other_arg)
+: data_(other_arg.data_),
+  step_(other_arg.step_),
+  colsBytes_(other_arg.colsBytes_),
+  rows_(other_arg.rows_),
+  type_(other_arg.type_),
+  refcount_(other_arg.refcount_),
+  q_(&dpct::get_default_queue())
+{
+  if (refcount_)
+    refcount_->fetch_add(1);
+}
+
+pcl::oneapi::DeviceMemory2D&
+pcl::oneapi::DeviceMemory2D::operator=(const pcl::oneapi::DeviceMemory2D& other_arg)
+{
+  if (this != &other_arg) {
+    if (other_arg.refcount_)
+      other_arg.refcount_->fetch_add(1);
+    //release();
+
+    colsBytes_ = other_arg.colsBytes_;
+    rows_ = other_arg.rows_;
+    data_ = other_arg.data_;
+    step_ = other_arg.step_;
+
+    refcount_ = other_arg.refcount_;
+  }
+  return *this;
+}
+
+#define STEP_DEFAULT_ALIGN(x) (((x) + 31) & ~(0x1f))
+void
+pcl::oneapi::DeviceMemory2D::create_(std::size_t& step, int cols, int rows,
+    MemoryType type)
+{
+  step = cols;
+  auto size = rows * step;
+
+  switch(type)
+  {
+  case DEVICE_MEMORY:
+    data_ = (void*)sycl::malloc_device(size, *q_);
+    refcount_ = new std::atomic<int>(1);
+    break;
+  case SHARED_MEMORY:
+    data_ = (void*)sycl::malloc_shared(size, *q_);
+    refcount_ = new std::atomic<int>(1);
+    break;
+  case HOST_MEMORY:
+    data_ = (void*)sycl::malloc_host(size, *q_);
+    refcount_ = new std::atomic<int>(1);
+    break;
+  default:
+    break;
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory2D::create(int rows_arg, int colsBytes_arg)
+{
+  if (colsBytes_ == colsBytes_arg && rows_ == rows_arg)
+    return;
+
+  if (rows_arg > 0 && colsBytes_arg > 0) {
+    if (data_)
+      release();
+
+    colsBytes_ = colsBytes_arg;
+    rows_ = rows_arg;
+
+    create_(step_, colsBytes_, rows_, type_);
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory2D::create(int rows_arg, int colsBytes_arg, std::size_t step_arg)
+{
+  if (colsBytes_ == colsBytes_arg && rows_ == rows_arg)
+    return;
+
+  if (rows_arg > 0 && colsBytes_arg > 0) {
+    if (data_)
+      release();
+
+    step_ = step_arg;
+    colsBytes_ = colsBytes_arg;
+    rows_ = rows_arg;
+
+    create_(step_, colsBytes_, rows_, type_);
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory2D::create(int rows_arg, int colsBytes_arg, MemoryType type)
+{
+  if (colsBytes_ == colsBytes_arg && rows_ == rows_arg)
+    return;
+
+  if (rows_arg > 0 && colsBytes_arg > 0) {
+    if (data_)
+      release();
+
+    colsBytes_ = colsBytes_arg;
+    rows_ = rows_arg;
+
+    create_(step_, colsBytes_, rows_, type);
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory2D::release()
+{
+  if (refcount_ && refcount_->fetch_sub(1) == 1) {
+    delete refcount_;
+
+    sycl::free(data_, *q_);
+  }
+
+  colsBytes_ = 0;
+  rows_ = 0;
+  step_ = 0;
+  data_ = nullptr;
+  refcount_ = nullptr;
+}
+
+void
+pcl::oneapi::DeviceMemory2D::copyTo(DeviceMemory2D& other)
+{
+  if (empty())
+    other.release();
+  else {
+    other.create(rows_, colsBytes_);
+
+    dpct::dpct_memcpy(other.data_,
+                      other.step_,
+                      data_,
+                      step_,
+                      colsBytes_,
+                      rows_,
+                      dpct::device_to_device);
+
+    dpct::get_current_device().queues_wait_and_throw();
+  }
+}
+
+void
+pcl::oneapi::DeviceMemory2D::upload(const void* host_ptr_arg,
+                                 std::size_t host_step_arg,
+                                 int rows_arg,
+                                 int colsBytes_arg)
+{
+  create(rows_arg, colsBytes_arg);
+
+  auto copy_size = host_step_arg * colsBytes_arg;
+
+  q_->memcpy(data_,
+            host_ptr_arg,
+            copy_size).wait_and_throw();
+
+}
+
+void
+pcl::oneapi::DeviceMemory2D::download(void* host_ptr_arg, std::size_t host_step_arg)
+{
+
+  auto copy_size = host_step_arg * rows_;
+
+  q_->memcpy(host_ptr_arg,
+            data_,
+            copy_size).wait_and_throw();
+}
+void
+pcl::oneapi::DeviceMemory2D::swap(DeviceMemory2D& other_arg)
+{
+  std::swap(data_, other_arg.data_);
+  std::swap(step_, other_arg.step_);
+
+  std::swap(colsBytes_, other_arg.colsBytes_);
+  std::swap(rows_, other_arg.rows_);
+  std::swap(refcount_, other_arg.refcount_);
+}
+
+bool
+pcl::oneapi::DeviceMemory2D::empty() const
+{
+  return !data_;
+}
+
+int
+pcl::oneapi::DeviceMemory2D::colsBytes() const
+{
+  return colsBytes_;
+}
+
+int
+pcl::oneapi::DeviceMemory2D::rows() const
+{
+  return rows_;
+}
+
+std::size_t
+pcl::oneapi::DeviceMemory2D::step() const
+{
+  return step_;
+}
+
diff --git a/oneapi/common/src/error.cpp b/oneapi/common/src/error.cpp
new file mode 100644
index 000000000..cb492c4f9
--- /dev/null
+++ b/oneapi/common/src/error.cpp
@@ -0,0 +1,50 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#include <pcl/oneapi/containers/initialization.h>
+
+#include <cstdlib>
+#include <iostream>
+
+void
+pcl::oneapi::error(const char* error_string,
+                const char* file,
+                const int line,
+                const char* func)
+{
+  std::cout << "Error: " << error_string << "\t" << file << ":" << line << std::endl;
+  exit(EXIT_FAILURE);
+}
diff --git a/oneapi/common/src/gpu_memory_manager.dp.cpp b/oneapi/common/src/gpu_memory_manager.dp.cpp
new file mode 100644
index 000000000..44db96a27
--- /dev/null
+++ b/oneapi/common/src/gpu_memory_manager.dp.cpp
@@ -0,0 +1,271 @@
+/*
+Author: Gao Mingcen
+Date: 28/02/2013
+
+File Name: GpuMemoryManager.cu
+
+Functions of GpuMemoryManager, a simple manager of managing memory for GPU
+
+===============================================================================
+
+Copyright (c) 2012, 2013, School of Computing, National University of Singapore.
+All rights reserved.
+
+Project homepage: http://www.comp.nus.edu.sg/~tants/flipflop.html
+
+If you use ffHull and you like it or have comments on its usefulness etc., we
+would love to hear from you at <tants@comp.nus.edu.sg>. You may share with us
+your experience and any possibilities that we may improve the work/code.
+
+===============================================================================
+
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+
+Redistributions of source code must retain the above copyright notice, this list of
+conditions and the following disclaimer. Redistributions in binary form must reproduce
+the above copyright notice, this list of conditions and the following disclaimer
+in the documentation and/or other materials provided with the distribution.
+
+Neither the name of the National University of Singapore nor the names of its contributors
+may be used to endorse or promote products derived from this software without specific
+prior written permission from the National University of Singapore.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGE.
+*/
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "pcl/oneapi/containers/gpu_memory_manager.h"
+
+GpuMemoryManager::GpuMemoryManager(bool shared)
+{
+
+  this->_initialized = false;
+  this->_usedByteLength = 0;
+  this->_createTimes = 1;
+  this->_deleteTimes = 1;
+  this->_releaseTimes = 1;
+  this->_reuseTimes = 1;
+  this->_accumulatedLength = 0;
+  this->_shared = shared;
+}
+
+GpuMemoryManager::~GpuMemoryManager()
+{
+  sycl::queue q = dev_ct1->default_queue();
+  if(this->_initialized)
+  {
+    this->_initialized = false;
+    for(unsigned int i = 0; i < this->freeMemoryPool.size(); i++)
+    {
+      int * pointer = this->freeMemoryPool[i].pointer;
+      sycl::free(pointer, q);
+    }
+    for(unsigned int i = 0; i < this->usingMemoryPool.size(); i++)
+    {
+      int * pointer = this->usingMemoryPool[i].pointer;
+      sycl::free(pointer, q);
+    }
+    this->freeMemoryPool.clear();
+    this->usingMemoryPool.clear();
+  }
+}
+
+void GpuMemoryManager::InitializeQueue(size_t maxByteLength)
+{
+  if (this->_initialized)
+    return;
+  dpct::device_ext &dev = dpct::get_current_device();
+  dev_ct1 = &dev;
+
+  size_t totalMemory = dev.get_info<sycl::info::device::global_mem_size>();
+
+  if(maxByteLength<=0 || maxByteLength > totalMemory)
+    maxByteLength = totalMemory;
+
+  this->_maxByteLength = maxByteLength;
+  this->_initialized = true;
+}
+
+bool GpuMemoryManager::ReleaseMemory(void * pointer)
+{
+  int index = this->_findUsingUnit(pointer);
+  if(index == -1)
+  {
+    printf("GpuMemoryManager Error: Space is lost when released\n");
+    return false;
+  }
+
+  GpuMemoryUnit gmu = this->usingMemoryPool[index];
+  int byteLength =gmu.byteLength;
+  //--reorganize
+  this->usingMemoryPool.erase(this->usingMemoryPool.begin() + index);
+  int pos = this->_findFirstFittingFreeUnit(byteLength);
+  if(pos>=0)
+    this->freeMemoryPool.insert(this->freeMemoryPool.begin() + pos, gmu);
+  else
+    this->freeMemoryPool.push_back(gmu);
+
+  return true;
+}
+
+bool GpuMemoryManager::GetMemory(void ** pointer, size_t byteLength)
+{
+  //--find the proper one
+  int index = this->_findFirstFittingFreeUnit(byteLength);
+  if(index >= 0)
+  {
+    GpuMemoryUnit gmu = this->freeMemoryPool[index];
+    if(gmu.byteLength > byteLength*10 && byteLength <= 50)
+    {
+      return this->_createMemory(pointer, byteLength);
+    }
+    else
+    {
+      * pointer = gmu.pointer;
+      //--reorganize
+      this->freeMemoryPool.erase(freeMemoryPool.begin() + index);
+      this->usingMemoryPool.push_back(gmu);
+    }
+  }
+  else
+  {
+    return this->_createMemory(pointer, byteLength);
+  }
+  return true;
+}
+bool GpuMemoryManager::ExpandArray(void ** pointer, size_t oldByteLength, size_t newByteLength)
+{
+  sycl::queue q = dev_ct1->default_queue();
+  if(oldByteLength >= newByteLength)
+    return false;
+  void * newArray;
+  if(!this->GetMemory((void **) &newArray, newByteLength))
+    exit(-1);
+  q.memcpy(newArray, *pointer, oldByteLength).wait();
+  if(!this->ReleaseMemory(*pointer))
+    exit(-1);
+  *pointer = newArray;
+  return true;
+}
+bool GpuMemoryManager::_createMemory(void **pointer, size_t byteLength)
+{
+  sycl::queue q = dev_ct1->default_queue();
+  if(byteLength> this->_maxByteLength - this->_usedByteLength)
+  {
+    if(!this->_freeMemory(byteLength))
+    {
+      printf("GpuMemoryManager Error: No extra space is valid(%ld > %ld - %ld)\n",
+        byteLength, this->_maxByteLength , this->_usedByteLength);
+      return false;
+    }
+  }
+  //malloc space
+  int * space;
+  if(_shared)
+    space = (int *)sycl::malloc_shared(byteLength, q);
+  else
+    space = (int *)sycl::malloc_device(byteLength, q);
+  this->_usedByteLength +=byteLength;
+  this->_accumulatedLength +=byteLength;
+  * pointer = space;
+  //create unit
+  GpuMemoryUnit gmu;
+  gmu.pointer = space;
+  gmu.byteLength = byteLength;
+  //--reorganize
+  this->usingMemoryPool.push_back(gmu);
+
+  return true;
+}
+bool GpuMemoryManager::_freeMemory(size_t byteLength)
+{
+  sycl::queue q = dev_ct1->default_queue();
+  int freeByteLength =0;
+  while(freeByteLength < byteLength && !this->freeMemoryPool.empty())
+  {
+    GpuMemoryUnit gmu = this->freeMemoryPool[this->freeMemoryPool.size()-1];
+    sycl::free(gmu.pointer, q);
+    freeByteLength += gmu.byteLength;
+    this->_usedByteLength -= gmu.byteLength;
+
+    this->freeMemoryPool.pop_back();
+  }
+  return freeByteLength >= byteLength;
+}
+int GpuMemoryManager::_findFirstFittingFreeUnit(size_t byteLength)
+{
+  if(this->freeMemoryPool.empty()) return -1;
+  int low = 0, high = this->freeMemoryPool.size()-1;
+  int pos = -1;
+  while(true)
+  {
+    pos=(low + high)/2;
+    if(this->freeMemoryPool[pos].byteLength == byteLength)
+    {
+      break;
+    }
+    else if(this->freeMemoryPool[pos].byteLength > byteLength)
+    {
+      if(pos == 0)
+        break;
+      else if(this->freeMemoryPool[pos-1].byteLength < byteLength)
+        break;
+      else
+      {
+        high = pos-1;
+      }
+    }
+    else if(this->freeMemoryPool[pos].byteLength < byteLength)
+    {
+      if(pos == this->freeMemoryPool.size()-1)
+      {
+        pos = -1;
+        break;
+      }
+      else if(this->freeMemoryPool[pos+1].byteLength > byteLength)
+      {
+        pos = pos + 1;
+        break;
+      }
+      else
+      {
+        low = pos+1;
+      }
+    }
+    if(low>high)
+    {
+      pos = -1;
+      break;
+    }
+  }
+  return pos;
+}
+
+int GpuMemoryManager::_findUsingUnit(void * pointer)
+{
+  int index;
+  for(index = 0; index < (int)this->usingMemoryPool.size(); index++)
+  {
+    if(pointer == this->usingMemoryPool[index].pointer)
+      break;
+  }
+  if(index >= (int)this->usingMemoryPool.size())
+  {
+    index = -1;
+  }
+  return index;
+}
diff --git a/oneapi/common/src/io.cpp b/oneapi/common/src/io.cpp
new file mode 100644
index 000000000..21bac053c
--- /dev/null
+++ b/oneapi/common/src/io.cpp
@@ -0,0 +1,407 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/common/io.h>
+
+//////////////////////////////////////////////////////////////////////////
+void
+getFieldsSizes (const std::vector<pcl::PCLPointField> &fields,
+                std::vector<int> &fields_sizes)
+{
+  int valid = 0;
+  fields_sizes.resize (fields.size ());
+  for (std::size_t i = 0; i < fields.size (); ++i)
+  {
+    if (fields[i].name == "_")
+      continue;
+
+    int fs = fields[i].count * pcl::oneapi::getFieldSize (fields[i].datatype);
+    fields_sizes[i] = fs;
+    valid++;
+  }
+  fields_sizes.resize (valid);
+}
+
+bool fieldComp (const pcl::PCLPointField* i, const pcl::PCLPointField* j)
+{
+  return i->offset < j->offset;
+}
+
+//////////////////////////////////////////////////////////////////////////
+bool
+pcl::oneapi::concatenateFields (const pcl::oneapi::PCLPointCloud2 &cloud1,
+                        const pcl::oneapi::PCLPointCloud2 &cloud2,
+                        pcl::oneapi::PCLPointCloud2 &cloud_out)
+{
+  // If the cloud's sizes differ (points wise), then exit with error
+  if (cloud1.width != cloud2.width || cloud1.height != cloud2.height)
+  {
+    PCL_ERROR ("[pcl::concatenateFields] Dimensions of input clouds do not match: cloud1 (w, %d, h, %d), cloud2 (w, %d, h, %d)\n", cloud1.width, cloud1.height, cloud2.width, cloud2.height );
+    return (false);
+  }
+  
+
+  if (cloud1.is_bigendian != cloud2.is_bigendian)
+  {
+    PCL_ERROR ("[pcl::concatenateFields] Endianness of clouds does not match\n");
+    return (false);
+  }
+  
+  // Else, copy the second cloud (width, height, header stay the same)
+  // we do this since fields from the second cloud are supposed to overwrite
+  // those of the first
+  cloud_out.header = cloud2.header;
+  cloud_out.fields = cloud2.fields;
+  cloud_out.width = cloud2.width;
+  cloud_out.height = cloud2.height;
+  cloud_out.is_bigendian = cloud2.is_bigendian;
+
+  //We need to find how many fields overlap between the two clouds
+  std::size_t total_fields = cloud2.fields.size ();
+
+  //for the non-matching fields in cloud1, we need to store the offset
+  //from the beginning of the point
+  std::vector<const pcl::PCLPointField*> cloud1_unique_fields;
+  std::vector<int> field_sizes;
+
+  //We need to make sure that the fields for cloud 1 are sorted
+  //by offset so that we can compute sizes correctly. There is no
+  //guarantee that the fields are in the correct order when they come in
+  std::vector<const pcl::PCLPointField*> cloud1_fields_sorted;
+  for (const auto &field : cloud1.fields)
+    cloud1_fields_sorted.push_back (&field);
+
+  std::sort (cloud1_fields_sorted.begin (), cloud1_fields_sorted.end (), fieldComp);
+
+  for (std::size_t i = 0; i < cloud1_fields_sorted.size (); ++i)
+  {
+    bool match = false;
+    for (const auto &field : cloud2.fields)
+    {
+      if (cloud1_fields_sorted[i]->name == field.name)
+        match = true;
+    }
+
+    //if the field is new, we'll increment out total fields
+    if (!match && cloud1_fields_sorted[i]->name != "_")
+    {
+      cloud1_unique_fields.push_back (cloud1_fields_sorted[i]);
+
+      int size = 0;
+      std::size_t next_valid_field = i + 1;
+
+      while (next_valid_field < cloud1_fields_sorted.size())
+      {
+        if (cloud1_fields_sorted[next_valid_field]->name != "_")
+          break;
+        next_valid_field++;
+      }
+
+      if (next_valid_field < cloud1_fields_sorted.size ())
+        //compute the true size of the field, including padding
+        size = cloud1_fields_sorted[next_valid_field]->offset - cloud1_fields_sorted[i]->offset;
+      else
+        //for the last point, we'll just use the point step to compute the size
+        size = cloud1.point_step - cloud1_fields_sorted[i]->offset;
+
+      field_sizes.push_back (size);
+
+      total_fields++;
+    }
+  }
+
+  //we need to compute the size of the additional data added from cloud 1
+  std::uint32_t cloud1_unique_point_step = 0;
+  for (std::size_t i = 0; i < cloud1_unique_fields.size (); ++i)
+    cloud1_unique_point_step += field_sizes[i];
+
+  //the total size of extra data should be the size of data per point
+  //multiplied by the total number of points in the cloud
+  std::uint32_t cloud1_unique_data_size = cloud1_unique_point_step * cloud1.width * cloud1.height; 
+
+  // Point step must increase with the length of each matching field
+  cloud_out.point_step = cloud2.point_step + cloud1_unique_point_step;
+  // Recalculate row_step
+  cloud_out.row_step = cloud_out.point_step * cloud_out.width;
+
+  // Resize data to hold all clouds
+  cloud_out.data.resize (cloud2.data.size () + cloud1_unique_data_size);
+
+  // Concatenate fields
+  cloud_out.fields.resize (cloud2.fields.size () + cloud1_unique_fields.size ());
+  int offset = cloud2.point_step;
+
+  for (std::size_t d = 0; d < cloud1_unique_fields.size (); ++d)
+  {
+    const pcl::PCLPointField& f = *cloud1_unique_fields[d];
+    cloud_out.fields[cloud2.fields.size () + d].name = f.name;
+    cloud_out.fields[cloud2.fields.size () + d].datatype = f.datatype;
+    cloud_out.fields[cloud2.fields.size () + d].count = f.count;
+    // Adjust the offset
+    cloud_out.fields[cloud2.fields.size () + d].offset = offset;
+    offset += field_sizes[d];
+  }
+ 
+  // Iterate over each point and perform the appropriate memcpys
+  int point_offset = 0;
+  for (uindex_t cp = 0; cp < cloud_out.width * cloud_out.height; ++cp)
+  {
+    memcpy (&cloud_out.data[point_offset], &cloud2.data[cp * cloud2.point_step], cloud2.point_step);
+    int field_offset = cloud2.point_step;
+
+    // Copy each individual point, we have to do this on a per-field basis
+    // since some fields are not unique
+    for (std::size_t i = 0; i < cloud1_unique_fields.size (); ++i)
+    {
+      const pcl::PCLPointField& f = *cloud1_unique_fields[i];
+      int local_data_size = f.count * pcl::oneapi::getFieldSize(f.datatype);
+      int padding_size = field_sizes[i] - local_data_size;
+      
+      memcpy (&cloud_out.data[point_offset + field_offset], &cloud1.data[cp * cloud1.point_step + f.offset], local_data_size);
+      field_offset +=  local_data_size;
+
+      //make sure that we add padding when its needed
+      if (padding_size > 0)
+        memset (&cloud_out.data[point_offset + field_offset], 0, padding_size);
+      field_offset += padding_size;
+    }
+    point_offset += field_offset;
+  }
+
+  if (!cloud1.is_dense || !cloud2.is_dense)
+    cloud_out.is_dense = false;
+  else
+    cloud_out.is_dense = true;
+
+  return (true);
+}
+
+//////////////////////////////////////////////////////////////////////////
+bool
+pcl::oneapi::getPointCloudAsEigen(const pcl::oneapi::PCLPointCloud2& in, Eigen::MatrixXf& out)
+{
+  // Get X-Y-Z indices
+  int x_idx = getFieldIndex (in, "x");
+  int y_idx = getFieldIndex (in, "y");
+  int z_idx = getFieldIndex (in, "z");
+
+  if (x_idx == -1 || y_idx == -1 || z_idx == -1)
+  {
+    PCL_ERROR ("Input dataset has no X-Y-Z coordinates! Cannot convert to Eigen format.\n");
+    return (false);
+  }
+
+  if (in.fields[x_idx].datatype != pcl::PCLPointField::FLOAT32 ||
+      in.fields[y_idx].datatype != pcl::PCLPointField::FLOAT32 ||
+      in.fields[z_idx].datatype != pcl::PCLPointField::FLOAT32)
+  {
+    PCL_ERROR ("X-Y-Z coordinates not floats. Currently only floats are supported.\n");
+    return (false);
+  }
+
+  std::size_t npts = in.width * in.height;
+  out = Eigen::MatrixXf::Ones (4, npts);
+
+  Eigen::Array4i xyz_offset (in.fields[x_idx].offset, in.fields[y_idx].offset, in.fields[z_idx].offset, 0);
+
+  // Copy the input dataset into Eigen format
+  for (std::size_t i = 0; i < npts; ++i)
+  {
+     // Unoptimized memcpys: assume fields x, y, z are in random order
+     memcpy (&out (0, i), &in.data[xyz_offset[0]], sizeof (float));
+     memcpy (&out (1, i), &in.data[xyz_offset[1]], sizeof (float));
+     memcpy (&out (2, i), &in.data[xyz_offset[2]], sizeof (float));
+
+     xyz_offset += in.point_step;
+  }
+
+  return (true);
+}
+
+//////////////////////////////////////////////////////////////////////////
+bool 
+pcl::oneapi::getEigenAsPointCloud(Eigen::MatrixXf& in, pcl::oneapi::PCLPointCloud2& out)
+{
+  // Get X-Y-Z indices
+  int x_idx = getFieldIndex (out, "x");
+  int y_idx = getFieldIndex (out, "y");
+  int z_idx = getFieldIndex (out, "z");
+
+  if (x_idx == -1 || y_idx == -1 || z_idx == -1)
+  {
+    PCL_ERROR ("Output dataset has no X-Y-Z coordinates set up as fields! Cannot convert from Eigen format.\n");
+    return (false);
+  }
+
+  if (out.fields[x_idx].datatype != pcl::PCLPointField::FLOAT32 ||
+      out.fields[y_idx].datatype != pcl::PCLPointField::FLOAT32 ||
+      out.fields[z_idx].datatype != pcl::PCLPointField::FLOAT32)
+  {
+    PCL_ERROR ("X-Y-Z coordinates not floats. Currently only floats are supported.\n");
+    return (false);
+  }
+
+  if (in.cols () != static_cast<int>(out.width * out.height))
+  {
+    PCL_ERROR ("Number of points in the point cloud differs from the Eigen matrix. Cannot continue.\n");
+    return (false);
+  }
+
+  std::size_t npts = in.cols ();
+
+  Eigen::Array4i xyz_offset (out.fields[x_idx].offset, out.fields[y_idx].offset, out.fields[z_idx].offset, 0);
+
+  // Copy the input dataset into Eigen format
+  for (std::size_t i = 0; i < npts; ++i)
+  {
+     // Unoptimized memcpys: assume fields x, y, z are in random order
+     memcpy (&out.data[xyz_offset[0]], &in (0, i), sizeof (float));
+     memcpy (&out.data[xyz_offset[1]], &in (1, i), sizeof (float));
+     memcpy (&out.data[xyz_offset[2]], &in (2, i), sizeof (float));
+
+     xyz_offset += out.point_step;
+  }
+
+  return (true);
+}
+
+//////////////////////////////////////////////////////////////////////////
+void 
+pcl::oneapi::copyPointCloud(
+    const pcl::oneapi::PCLPointCloud2 &cloud_in,
+    const Indices &indices,
+    pcl::oneapi::PCLPointCloud2 &cloud_out)
+{
+  cloud_out.header       = cloud_in.header;
+  cloud_out.height       = 1;
+  cloud_out.width        = indices.size (); 
+  cloud_out.fields       = cloud_in.fields;
+  cloud_out.is_bigendian = cloud_in.is_bigendian;
+  cloud_out.point_step   = cloud_in.point_step;
+  cloud_out.row_step     = cloud_in.point_step * static_cast<std::uint32_t> (indices.size ());
+  cloud_out.is_dense     = cloud_in.is_dense;
+
+  cloud_out.data.resize (cloud_out.width * cloud_out.height * cloud_out.point_step);
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < indices.size (); ++i)
+    memcpy (&cloud_out.data[i * cloud_out.point_step], &cloud_in.data[indices[i] * cloud_in.point_step], cloud_in.point_step);
+}
+
+//////////////////////////////////////////////////////////////////////////
+void 
+pcl::oneapi::copyPointCloud(
+    const pcl::oneapi::PCLPointCloud2 &cloud_in,
+    const IndicesAllocator< Eigen::aligned_allocator<index_t> > &indices,
+    pcl::oneapi::PCLPointCloud2 &cloud_out)
+{
+  cloud_out.header       = cloud_in.header;
+  cloud_out.height       = 1;
+  cloud_out.width        = indices.size (); 
+  cloud_out.fields       = cloud_in.fields;
+  cloud_out.is_bigendian = cloud_in.is_bigendian;
+  cloud_out.point_step   = cloud_in.point_step;
+  cloud_out.row_step     = cloud_in.point_step * static_cast<std::uint32_t> (indices.size ());
+  cloud_out.is_dense     = cloud_in.is_dense;
+
+  cloud_out.data.resize (cloud_out.width * cloud_out.height * cloud_out.point_step);
+
+  // Iterate over each point
+  for (std::size_t i = 0; i < indices.size (); ++i)
+    memcpy (&cloud_out.data[i * cloud_out.point_step], &cloud_in.data[indices[i] * cloud_in.point_step], cloud_in.point_step);
+}
+
+////////////////////////////////////////////////////////////////////////////////
+void 
+pcl::oneapi::copyPointCloud(const pcl::oneapi::PCLPointCloud2& cloud_in,
+                     pcl::oneapi::PCLPointCloud2 &cloud_out)
+{
+  cloud_out.header       = cloud_in.header;
+  cloud_out.height       = cloud_in.height;
+  cloud_out.width        = cloud_in.width;
+  cloud_out.fields       = cloud_in.fields;
+  cloud_out.is_bigendian = cloud_in.is_bigendian;
+  cloud_out.point_step   = cloud_in.point_step;
+  cloud_out.row_step     = cloud_in.row_step;
+  cloud_out.is_dense     = cloud_in.is_dense;
+  cloud_out.data         = cloud_in.data;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+int
+pcl::oneapi::interpolatePointIndex(int p, int len, InterpolationType type)
+{
+  if (static_cast<unsigned> (p) >= static_cast<unsigned> (len))
+  {
+    if (type == BORDER_REPLICATE)
+      p = p < 0 ? 0 : len - 1;
+    else if (type == BORDER_REFLECT || type == BORDER_REFLECT_101)
+    {
+      int delta = type == BORDER_REFLECT_101;
+      if (len == 1)
+        return 0;
+      do
+      {
+        if (p < 0)
+          p = -p - 1 + delta;
+        else
+          p = len - 1 - (p - len) - delta;
+      }
+      while (static_cast<unsigned> (p) >= static_cast<unsigned> (len));
+    }
+    else if (type == BORDER_WRAP)
+    {
+      if (p < 0)
+        p -= ((p-len+1)/len)*len;
+      if (p >= len)
+        p %= len;
+    }
+    else if (type == BORDER_CONSTANT)
+      p = -1;
+    else
+    {
+      PCL_THROW_EXCEPTION (BadArgumentException,
+                           "[pcl::interpolate_point_index] error: Unhandled interpolation type "
+                           << type << " !");
+    }
+  }
+
+  return (p);
+}
diff --git a/oneapi/common/src/pcl_base.cpp b/oneapi/common/src/pcl_base.cpp
new file mode 100644
index 000000000..e1a7907aa
--- /dev/null
+++ b/oneapi/common/src/pcl_base.cpp
@@ -0,0 +1,173 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/impl/pcl_base.hpp>
+#include <algorithm>
+#include <numeric>
+
+///////////////////////////////////////////////////////////////////////////////////////////
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::PCLBase ()
+  : use_indices_ (false)
+  , fake_indices_ (false)
+  , field_sizes_ (0)
+  , x_idx_ (UNAVAILABLE)
+  , y_idx_ (UNAVAILABLE)
+  , z_idx_ (UNAVAILABLE)
+  , x_field_name_ ("x")
+  , y_field_name_ ("y")
+  , z_field_name_ ("z")
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+void
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::setInputCloud (const pcl::oneapi::PCLPointCloud2ConstPtr &cloud)
+{
+  input_ = cloud;
+
+  for (std::size_t d = 0; d < cloud->fields.size (); ++d)
+  {
+    if (cloud->fields[d].name == x_field_name_)
+      x_idx_ = d;
+    if (cloud->fields[d].name == y_field_name_)
+      y_idx_ = d;
+    if (cloud->fields[d].name == z_field_name_)
+      z_idx_ = d;
+  }
+
+  // Obtain the size of datatype
+  const auto sizeofDatatype = [](const auto& datatype) -> int
+  {
+    switch (datatype)
+    {
+      case pcl::PCLPointField::INT8:
+      case pcl::PCLPointField::UINT8: return 1;
+
+      case pcl::PCLPointField::INT16:
+      case pcl::PCLPointField::UINT16: return 2;
+
+      case pcl::PCLPointField::INT32:
+      case pcl::PCLPointField::UINT32:
+      case pcl::PCLPointField::FLOAT32: return 4;
+
+      case pcl::PCLPointField::FLOAT64: return 8;
+
+      default:
+        PCL_ERROR("[PCLBase::setInputCloud] Invalid field type (%d)!\n", datatype);
+        return 0;
+    }
+  };
+
+  // Restrict size of a field to be at-max sizeof(FLOAT32) for now
+  field_sizes_.resize(input_->fields.size());
+  std::transform(input_->fields.begin(), input_->fields.end(), field_sizes_.begin(),
+                 [&sizeofDatatype](const auto& field)
+                 {
+                   return std::min(sizeofDatatype(field.datatype), static_cast<int>(sizeof(float)));
+                 });
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+bool
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::deinitCompute ()
+{
+  return (true);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+bool
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::initCompute ()
+{
+  // Check if input was set
+  if (!input_)
+    return (false);
+
+  // If no point indices have been given, construct a set of indices for the entire input point cloud
+  if (!indices_)
+  {
+    fake_indices_ = true;
+    indices_.reset (new IndicesDev);
+  }
+
+  // If we have a set of fake indices, but they do not match the number of points in the cloud, update them
+  if (fake_indices_ && indices_->size () != (input_->width * input_->height))
+  {
+    const auto indices_size = indices_->size ();
+    try
+    {
+      indices_->resize (input_->width * input_->height);
+    }
+    catch (const std::bad_alloc&)
+    {
+      PCL_ERROR ("[initCompute] Failed to allocate %lu indices.\n", (input_->width * input_->height));
+    }
+    if (indices_size < indices_->size ())
+      std::iota(indices_->begin () + indices_size, indices_->end (), indices_size);
+  }
+
+  return (true);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+void
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::setIndices (const IndicesPtr &indices)
+{
+  IndicesDev indices_dev;
+  indices_dev.resize(indices->size());
+  indices_dev.upload(indices->data(), indices->size());
+
+  indices_ = std::make_shared<IndicesDev>(indices_dev);
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+void
+pcl::oneapi::PCLBase<pcl::oneapi::PCLPointCloud2>::setIndices (const PointIndicesConstPtr &indices)
+{
+  indices_->upload(indices->indices.data(), indices->indices.size());
+  fake_indices_ = false;
+  use_indices_  = true;
+}
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+PCL_INSTANTIATE(OneAPI_PCLBase, PCL_POINT_TYPES)
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/common/src/point_types.cpp b/oneapi/common/src/point_types.cpp
new file mode 100644
index 000000000..37b26e037
--- /dev/null
+++ b/oneapi/common/src/point_types.cpp
@@ -0,0 +1,38 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <pcl/oneapi/point_types.h>
+
diff --git a/oneapi/features/CMakeLists.txt b/oneapi/features/CMakeLists.txt
new file mode 100755
index 000000000..ba34bca7a
--- /dev/null
+++ b/oneapi/features/CMakeLists.txt
@@ -0,0 +1,43 @@
+set(SUBSYS_NAME oneapi_features)
+set(SUBSYS_PATH oneapi/features)
+set(SUBSYS_DESC "Point cloud oneAPI features library")
+set(SUBSYS_DEPS common oneapi_common oneapi_search kdtree search)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(srcs
+  src/normal_3d.cpp
+)
+
+set(incs
+  include/pcl/oneapi/features/feature.h
+  include/pcl/oneapi/features/normal_3d.h
+)
+
+set(impl_incs_release
+  include/pcl/oneapi/features/impl/feature.hpp
+)
+
+
+set(impl_incs
+  include/pcl/oneapi/features/impl/normal_3d.hpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs})
+target_link_libraries("${LIB_NAME}" pcl_common pcl_oneapi_common pcl_oneapi_kdtree pcl_oneapi_search pcl_search)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include" "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}/impl" ${impl_incs_release})
diff --git a/oneapi/features/include/pcl/oneapi/features/feature.h b/oneapi/features/include/pcl/oneapi/features/feature.h
new file mode 100644
index 000000000..5c331b875
--- /dev/null
+++ b/oneapi/features/include/pcl/oneapi/features/feature.h
@@ -0,0 +1,267 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef _PCL_ONEAPI_FEATURES_H_
+#define _PCL_ONEAPI_FEATURES_H_
+
+#include <pcl/oneapi/pcl_base.h>
+#include <pcl/oneapi/search/kdtree.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/pcl_macros.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+
+  ////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief @b Feature represents the base feature class.  */
+  template <typename PointInT, typename PointOutT>
+  class Feature : public PCLBase<PointInT>
+  {
+    public:
+      using PCLBase<PointInT>::indices_;
+      using PCLBase<PointInT>::input_;
+
+      using Ptr = shared_ptr<Feature<PointInT, PointOutT>>;
+      using ConstPtr = shared_ptr<const Feature<PointInT, PointOutT>>;
+
+      using PointCloudIn = pcl::PointCloud<PointInT>;
+      using PointCloudInPtr = typename PointCloudIn::Ptr;
+      using PointCloudInConstPtr = typename PointCloudIn::ConstPtr;
+
+      using PointCloudDevIn = typename PCLBase<PointInT>::PointCloudDev;
+      using PointCloudDevInPtr = typename PointCloudDevIn::Ptr;
+      using PointCloudDevInConstPtr = typename PointCloudDevIn::ConstPtr;
+
+      using PointCloudOut = pcl::PointCloud<PointOutT>;
+      using PointCloudDevOut = typename PCLBase<PointOutT>::PointCloudDev;
+
+      using SearchMethodSurface = std::function<int (const PointCloudDevInConstPtr &cloud, double,
+          pcl::oneapi::DeviceArray<int> &, pcl::oneapi::DeviceArray<float> &,
+          pcl::oneapi::DeviceArray<int> &)>;
+
+      using KdTreePtr = shared_ptr<pcl::oneapi::KdTreeFLANN<PointInT>>;
+
+      /** \brief Empty constructor. */
+      Feature () :
+        feature_name_(), surface_(), tree_(),
+        search_parameter_(0), search_radius_(0), k_(0),
+        fake_surface_(false)
+      {}
+
+      /** \brief Empty destructor */
+      virtual ~Feature () {}
+
+      /** \brief Provide a pointer to a dataset to add additional information
+        * to estimate the features for every point in the input dataset.  This
+        * is optional, if this is not set, it will only use the data in the
+        * input cloud to estimate the features.  This is useful when you only
+        * need to compute the features for a downsampled cloud.
+        * \param[in] cloud a pointer to a PointCloud message
+        */
+      inline void
+      setSearchSurface (const PointCloudInConstPtr &cloud)
+      {
+        PointCloudDevIn tmp(cloud);
+        surface_ = tmp.makeShared();
+        fake_surface_ = false;
+      }
+
+      inline void
+      setSearchSurface (const PointCloudDevInConstPtr &cloud)
+      {
+        surface_ = cloud;
+        fake_surface_ = false;
+      }
+
+      /** \brief Get a pointer to the surface point cloud dataset. */
+      inline PointCloudInConstPtr
+      getSearchSurface () const
+      {
+        PointCloudIn surface;
+        surface_->download(surface);
+        return surface.makeShared();
+      }
+
+      /** \brief Provide a pointer to the search object.
+        * \param[in] tree a pointer to the spatial search object.
+        */
+      inline void
+      setSearchMethod (const KdTreePtr &tree) { tree_ = tree; }
+
+      /** \brief Get a pointer to the search method used. */
+      inline KdTreePtr
+      getSearchMethod () const
+      {
+        return (tree_);
+      }
+
+      /** \brief Get the internal search parameter. */
+      inline double
+      getSearchParameter () const
+      {
+        return (search_parameter_);
+      }
+
+      /** \brief Set the number of k nearest neighbors to use for the feature estimation.
+        * \param[in] k the number of k-nearest neighbors
+        */
+      inline void
+      setKSearch (int k)
+      {
+        k_ = k;
+      }
+
+      /** \brief get the number of k nearest neighbors used for the feature estimation. */
+      inline int
+      getKSearch () const
+      {
+        return (k_);
+      }
+
+      /** \brief Set the sphere radius that is to be used for determining the nearest neighbors used for the feature
+        * estimation.
+        * \param[in] radius the sphere radius used as the maximum distance to consider a point a neighbor
+        */
+      inline void
+      setRadiusSearch (double radius)
+      {
+        search_radius_ = radius;
+      }
+
+      /** \brief Get the sphere radius used for determining the neighbors. */
+      inline double
+      getRadiusSearch () const
+      {
+        return (search_radius_);
+      }
+
+      /** \brief Base method for feature estimation for all points given in
+        * <setInputCloud (), setIndices ()> using the surface in setSearchSurface ()
+        * and the spatial locator in setSearchMethod ()
+        * \param[out] output the resultant point cloud model dataset containing the estimated features
+        */
+      template  <typename PointCloudT>
+      void
+      compute (PointCloudT &output);
+
+    protected:
+
+      /** \brief The feature name. */
+      std::string feature_name_;
+
+      /** \brief The search method template for points. */
+      SearchMethodSurface search_method_surface_;
+
+      /** \brief An input point cloud describing the surface that is to be used
+        * for nearest neighbors estimation.
+        */
+      PointCloudDevInConstPtr surface_;
+
+      /** \brief A pointer to the spatial search object. */
+      KdTreePtr tree_;
+
+      /** \brief The actual search parameter (from either \a search_radius_ or \a k_). */
+      double search_parameter_;
+
+      /** \brief The nearest neighbors search radius for each point. */
+      double search_radius_;
+
+      /** \brief The number of K nearest neighbors to use for each point. */
+      int k_;
+
+      /** \brief Get a string representation of the name of this class. */
+      inline const std::string&
+      getClassName () const { return (feature_name_); }
+
+      /** \brief This method should get called before starting the actual computation. */
+      virtual bool
+      initCompute ();
+
+      /** \brief This method should get called after ending the actual computation. */
+      virtual bool
+      deinitCompute ();
+
+      /** \brief If no surface is given, we use the input PointCloud as the surface. */
+      bool fake_surface_;
+
+      /** \brief Search for k-nearest neighbors using the spatial locator from
+        * \a setSearchmethod, and the given surface from \a setSearchSurface.
+        * \param[in] cloud the query point cloud
+        * \param[in] index the index of the query point in \a cloud
+        * \param[in] parameter the search parameter (either k or radius)
+        * \param[out] indices the resultant vector of indices representing the k-nearest neighbors
+        * \param[out] distances the resultant vector of distances representing the distances from the query point to the
+        * k-nearest neighbors
+        *
+        * \return the number of neighbors found. If no neighbors are found or an error occurred, return 0.
+        */
+      inline int
+      searchForNeighbors (const PointCloudDevInConstPtr &cloud, double parameter,
+                          pcl::oneapi::DeviceArray<int> &indices,
+                          pcl::oneapi::DeviceArray<float>  &distances,
+                          pcl::oneapi::DeviceArray<int> &splits) const
+      {
+        return (search_method_surface_ (cloud, parameter, indices, distances, splits));
+      }
+
+    private:
+      /** \brief Abstract feature estimation method.
+        * \param[out] output the resultant features
+        */
+      virtual void
+      computeFeature (PointCloudOut &output) = 0;
+
+      /** \brief Abstract feature estimation method.
+        * \param[out] output the resultant features
+        */
+      virtual void
+      computeFeature (PointCloudDevOut &output) = 0;
+    };
+}
+}
+
+#include <pcl/oneapi/features/impl/feature.hpp>
+
+#endif /* _PCL_ONEAPI_FEATURES_H_ */
+
+
diff --git a/oneapi/features/include/pcl/oneapi/features/impl/feature.hpp b/oneapi/features/include/pcl/oneapi/features/impl/feature.hpp
new file mode 100644
index 000000000..7710866e0
--- /dev/null
+++ b/oneapi/features/include/pcl/oneapi/features/impl/feature.hpp
@@ -0,0 +1,197 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+#ifndef PCL_ONEAPI_FEATURES_IMPL_FEATURES_HPP_
+#define PCL_ONEAPI_FEATURES_IMPL_FEATURES_HPP_
+
+#include <pcl/oneapi/containers/initialization.h>
+#include <pcl/oneapi/features/feature.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+
+using namespace pcl::oneapi;
+
+template <typename PointInT, typename PointOutT> bool
+Feature<PointInT, PointOutT>::initCompute ()
+{
+  if (!PCLBase<PointInT>::initCompute ())
+  {
+    PCL_ERROR ("[pcl::%s::initCompute] Init failed.\n", getClassName ().c_str ());
+    return (false);
+  }
+
+  // If the dataset is empty, just return
+  if (input_->points.empty ())
+  {
+    PCL_ERROR ("[pcl::%s::compute] input_ is empty!\n", getClassName ().c_str ());
+    // Cleanup
+    deinitCompute ();
+    return (false);
+  }
+
+  // If no search surface has been defined, use the input dataset as the search surface itself
+  if (!surface_)
+  {
+    fake_surface_ = true;
+    surface_ = input_;
+  }
+
+  // Check if a space search locator was given
+  if (!tree_)
+  {
+    tree_ = std::make_shared<pcl::oneapi::KdTreeFLANN<PointInT>> (false);
+  }
+
+
+  if (tree_->getInputCloudDev () != surface_) // Make sure the tree searches the surface
+  {
+    if (k_ != 0)
+    {
+      tree_->setInputCloud (surface_);
+    }
+    else
+    {
+      tree_->setInputCloud (surface_, search_radius_);
+      tree_->setSortedResults(false);
+    }
+  }
+
+  // Do a fast check to see if the search parameters are well defined
+  if (search_radius_ != 0.0)
+  {
+    if (k_ != 0)
+    {
+      PCL_ERROR ("[pcl::%s::compute] ", getClassName ().c_str ());
+      PCL_ERROR ("Both radius (%f) and K (%d) defined! ", search_radius_, k_);
+      PCL_ERROR ("Set one of them to zero first and then re-run compute ().\n");
+      // Cleanup
+      deinitCompute ();
+      return (false);
+    }
+    else // Use the radiusSearch () function
+    {
+      search_parameter_ = search_radius_;
+      // Declare the search locator definition
+      search_method_surface_ = [this] (const PointCloudDevInConstPtr &cloud,
+                                       double search_radius,
+                                       pcl::oneapi::DeviceArray<int> &k_indices,
+                                       pcl::oneapi::DeviceArray<float> &k_distances,
+                                       pcl::oneapi::DeviceArray<int> &k_splits)
+      {
+        return tree_->fixedRadiusSearch (cloud, k_indices, k_distances, k_splits);
+      };
+    }
+  }
+  else
+  {
+    if (k_ != 0) // Use the nearestKSearch () function
+    {
+      search_parameter_ = k_;
+      // Declare the search locator definition
+      search_method_surface_ = [this] (const PointCloudDevInConstPtr &cloud, int k,
+                                       pcl::oneapi::DeviceArray<int> &k_indices,
+                                       pcl::oneapi::DeviceArray<float> &k_distances,
+                                       pcl::oneapi::DeviceArray<int> &k_splits)
+      {
+        return tree_->nearestKSearch (cloud, k, k_indices, k_distances, k_splits);
+      };
+    }
+    else
+    {
+      PCL_ERROR ("[pcl::%s::compute] Neither radius nor K defined! ", getClassName ().c_str ());
+      PCL_ERROR ("Set one of them to a positive number first and then re-run compute ().\n");
+      // Cleanup
+      deinitCompute ();
+      return (false);
+    }
+  }
+  return (true);
+}
+
+template <typename PointInT, typename PointOutT> bool
+Feature<PointInT, PointOutT>::deinitCompute ()
+{
+  // Reset the surface
+  if (fake_surface_)
+  {
+    surface_.reset ();
+    fake_surface_ = false;
+  }
+  return (true);
+}
+
+
+template <typename PointInT, typename PointOutT>
+template <typename PointCloudT> void
+Feature<PointInT, PointOutT>::compute (PointCloudT &output)
+{
+  if (!initCompute ())
+  {
+    output.width = output.height = 0;
+    output.clear ();
+    return;
+  }
+
+  // Copy the header
+  output.header = input_->header;
+
+  // Resize the output dataset
+  if (output.size () != indices_->size ())
+    output.resize (indices_->size ());
+
+  // Check if the output will be computed for all points or only a subset
+  // If the input width or height are not set, set output width as size
+  if (indices_->size () != input_->points.size () || input_->width * input_->height == 0)
+  {
+    output.width = indices_->size ();
+    output.height = 1;
+  }
+  else
+  {
+    output.width = input_->width;
+    output.height = input_->height;
+  }
+  output.is_dense = input_->is_dense;
+
+  // Perform the actual feature computation
+  computeFeature (output);
+
+  deinitCompute ();
+}
+
+#endif  // PCL_ONEAPI_FEATURES_IMPL_FEATURES_HPP_
diff --git a/oneapi/features/include/pcl/oneapi/features/impl/normal_3d.hpp b/oneapi/features/include/pcl/oneapi/features/impl/normal_3d.hpp
new file mode 100644
index 000000000..740a9c927
--- /dev/null
+++ b/oneapi/features/include/pcl/oneapi/features/impl/normal_3d.hpp
@@ -0,0 +1,433 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_FEATURES_IMPL_NORMAL_3D_H_
+#define PCL_ONEAPI_FEATURES_IMPL_NORMAL_3D_H_
+
+#include <pcl/oneapi/features/normal_3d.h>
+#include <pcl/oneapi/utils/common.h>
+#include <pcl/oneapi/common/device/eigen.h>
+#include <pcl/oneapi/common/device/centroid.h>
+
+namespace pcl {
+namespace oneapi {
+namespace device {
+
+  //////////////////////////////////////////////////////////////////////////////////////////////
+  template<typename PointInT, typename PointOutT>
+  struct NormalEstimator
+  {
+    enum
+    {
+      LOG_WARP_SIZE = 4,
+      WARP_SIZE     = 1 << LOG_WARP_SIZE,
+      STRIDE        = WARP_SIZE,
+      CTA_SIZE      = 128,
+      WARPS         = CTA_SIZE / WARP_SIZE,
+      MIN_NEIGHBOORS = 3
+    };
+
+    const int *splits_ptr;
+    const int *indices_ptr;
+    const PointInT *input_ptr;
+    PointOutT *plane_ptr;
+    std::size_t total_items;
+    int * check_nan_ptr;
+
+    __dpct_inline__ void
+    computePointNormalGPUKernel(sycl::nd_item<2>& it) const
+    {
+      sycl::sub_group sg = it.get_sub_group();
+      int sg_idx = sg.get_local_id()[0];
+      int gidx = it.get_local_linear_id() >> LOG_WARP_SIZE;
+
+      int idx = it.get_group_linear_id() * WARPS + gidx;
+
+      if (idx >= total_items)
+        return;
+
+      int size = splits_ptr[idx+1] -  splits_ptr[idx];
+
+      if ((size < MIN_NEIGHBOORS) && (sg_idx == 0))
+      {
+        constexpr float NaN = std::numeric_limits<float>::quiet_NaN();
+        plane_ptr[idx].normal[0] = NaN;
+        plane_ptr[idx].normal[1] = NaN;
+        plane_ptr[idx].normal[2] = NaN;
+        plane_ptr[idx].curvature = NaN;
+        sycl::atomic_ref<int, sycl::memory_order::relaxed, sycl::memory_scope::system,
+          sycl::access::address_space::global_space>(*check_nan_ptr) += 1;
+        return;
+      }
+
+      const int *ibeg = &indices_ptr[splits_ptr[idx]];
+      const int *iend = ibeg + size;
+
+      //compute covariance matrix
+      float dxx = 0.0f;
+      float dxy = 0.0f;
+      float dxz = 0.0f;
+      float dyy = 0.0f;
+      float dyz = 0.0f;
+      float dzz = 0.0f;
+      float dx = 0.0f;
+      float dy = 0.0f;
+      float dz = 0.0f;
+
+      PointInT first_pt = input_ptr[*ibeg];
+
+      /*
+      if ((sg_idx == 0) && (idx == 0))
+      {
+        int startidx = splits_ptr[idx];
+        sycl::ext::oneapi::experimental::printf("indices is %d %d %d %d\n",
+            indices_ptr[startidx], indices_ptr[startidx+1],
+            indices_ptr[startidx+2], indices_ptr[startidx+3]);
+
+        sycl::ext::oneapi::experimental::printf("first point = (%f %f %f), size=%d\n",
+            first_pt.x, first_pt.y, first_pt.z, size);
+      }
+      */
+
+      for(const int *t = ibeg + sg_idx; t < iend; t += STRIDE)
+      {
+        PointInT p = input_ptr[*t];
+        PointInT d = p;
+
+        d.x = p.x - first_pt.x;
+        d.y = p.y - first_pt.y;
+        d.z = p.z - first_pt.z;
+
+        dxx += d.x * d.x;
+        dxy += d.x * d.y;
+        dxz += d.x * d.z;
+        dyy += d.y * d.y;
+        dyz += d.y * d.z;
+        dzz += d.z * d.z;
+        dx += d.x;
+        dy += d.y;
+        dz += d.z;
+      }
+
+      dxx = sycl::reduce_over_group(sg, dxx, std::plus<>());
+      dxy = sycl::reduce_over_group(sg, dxy, std::plus<>());
+      dxz = sycl::reduce_over_group(sg, dxz, std::plus<>());
+      dyy = sycl::reduce_over_group(sg, dyy, std::plus<>());
+      dyz = sycl::reduce_over_group(sg, dyz, std::plus<>());
+      dzz = sycl::reduce_over_group(sg, dzz, std::plus<>());
+      dx = sycl::reduce_over_group(sg, dx, std::plus<>());
+      dy = sycl::reduce_over_group(sg, dy, std::plus<>());
+      dz = sycl::reduce_over_group(sg, dz, std::plus<>());
+
+      //solvePlaneParameters
+      if (sg_idx == 0)
+      {
+        dxx *= 1.f / size;
+        dxy *= 1.f / size;
+        dxz *= 1.f / size;
+        dyy *= 1.f / size;
+        dyz *= 1.f / size;
+        dzz *= 1.f / size;
+        dx *= 1.f / size;
+        dy *= 1.f / size;
+        dz *= 1.f / size;
+
+        matrix3x3f covariance;
+        covariance[0].x() = dxx - dx * dx;
+        covariance[0].y() = dxy - dx * dy;
+        covariance[0].z() = dxz - dx * dz;
+        covariance[1].y() = dyy - dy * dy;
+        covariance[1].z() = dyz - dy * dz;
+        covariance[2].z() = dzz - dz * dz;
+        covariance[1].x() = covariance[0].y();
+        covariance[2].x() = covariance[0].z();
+        covariance[2].y() = covariance[1].z();
+
+        float3 eigen_vector;
+        float eigen_value;
+
+        oneapi::device::eigen33(covariance, eigen_value, eigen_vector);
+
+        // Compute the curvature surface change
+        float eig_sum = covariance[0].x() + covariance[1].y() + covariance[2].z();
+        float curvature = (eig_sum == 0) ? 0 : sycl::fabs(eigen_value / eig_sum);
+
+        plane_ptr[idx].normal[0] = eigen_vector.x();
+        plane_ptr[idx].normal[1] = eigen_vector.y();
+        plane_ptr[idx].normal[2] = eigen_vector.z();
+        plane_ptr[idx].curvature = curvature;
+      }
+    }
+
+    __dpct_inline__ void
+    computePointNormalCPUKernel(int idx) const
+    {
+      const int start = splits_ptr[idx];
+      const int end = splits_ptr[idx+1];
+
+      sycl::float3 centroid;
+      oneapi::device::compute3DCentroid(input_ptr, indices_ptr,  start, end, centroid);
+
+      matrix3x3f covariance;
+      oneapi::device::computeCovarianceMatrix(input_ptr, indices_ptr, start, end, centroid,
+          covariance);
+
+      float3 eigen_vector;
+      float eigen_value;
+
+      oneapi::device::eigen33(covariance, eigen_value, eigen_vector);
+
+      // Compute the curvature surface change
+      float eig_sum = covariance[0].x() + covariance[1].y() + covariance[2].z();
+      float curvature = (eig_sum == 0) ? 0 : sycl::fabs(eigen_value / eig_sum);
+
+      plane_ptr[idx].normal[0] = eigen_vector.x();
+      plane_ptr[idx].normal[1] = eigen_vector.y();
+      plane_ptr[idx].normal[2] = eigen_vector.z();
+      plane_ptr[idx].curvature = curvature;
+    }
+
+  };
+
+  //////////////////////////////////////////////////////////////////////////////////////////////
+  template<typename PointInT, typename PointOutT>
+  struct FlipNormal
+  {
+    const PointInT *input_ptr;
+    sycl::float3 vp;
+    std::size_t total_items;
+    PointOutT *normal_ptr;
+
+    __dpct_inline__ void
+    flipNormalTowardsViewpointKernel(sycl::nd_item<2>& it) const
+    {
+      int idx = it.get_global_linear_id();
+
+      if (idx < total_items)
+      {
+        sycl::float3 n = sycl::float3(normal_ptr[idx].normal[0],
+                                      normal_ptr[idx].normal[1],
+                                      normal_ptr[idx].normal[2]);
+
+        float vp_x = vp.x() - input_ptr[idx].x;
+        float vp_y = vp.y() - input_ptr[idx].y;
+        float vp_z = vp.z() - input_ptr[idx].z;
+
+        // Dot product between the (viewpoint - point) and the plane normal
+        float cos_theta = vp_x * n.x() + vp_y * n.y() + vp_z * n.z();
+
+        if ((cos_theta < 0) && (!sycl::isnan(n.x()) && !sycl::isnan(n.y()) && !sycl::isnan(n.z())))
+        {
+          n.x() *= -1;
+          n.y() *= -1;
+          n.z() *= -1;
+
+          normal_ptr[idx].normal[0] = n.x();
+          normal_ptr[idx].normal[1] = n.y();
+          normal_ptr[idx].normal[2] = n.z();
+        }
+        else if (!sycl::isfinite(n.x()) || !sycl::isfinite(n.y()) || !sycl::isfinite(n.z()))
+        {
+          constexpr float NaN = std::numeric_limits<float>::quiet_NaN();
+          normal_ptr[idx].normal[0] = NaN;
+          normal_ptr[idx].normal[1] = NaN;
+          normal_ptr[idx].normal[2] = NaN;
+        }
+      }
+    }
+  };
+
+} // device
+
+
+template <typename PointInT, typename PointOutT> void
+flipNormalTowardsViewpoint (const typename pcl::oneapi::PointCloudDev<PointInT>::ConstPtr &cloud,
+    const float vpx, const float vpy, const float vpz,
+    pcl::oneapi::PointCloudDev<PointOutT> &normals)
+{
+  int block = 64;
+  int grid = divUp(normals.size(), block);
+
+  pcl::oneapi::device::FlipNormal<PointInT, PointOutT> flip;
+  flip.input_ptr = cloud->points.ptr();
+  flip.vp = sycl::float3(vpx, vpy, vpz);
+  flip.total_items = normals.size();
+  flip.normal_ptr = normals.points.ptr();
+
+  sycl::queue q = dpct::get_default_queue();
+
+  q.submit([&](sycl::handler &cgh) {
+
+    cgh.parallel_for(sycl::nd_range<2>(sycl::range<2>(1, grid) * sycl::range<2>(1, block),
+                                       sycl::range<2>(1, block)),
+        [=](sycl::nd_item<2> it) {
+
+          flip.flipNormalTowardsViewpointKernel(it);
+    });
+  }).wait();
+}
+
+template<typename PointInT, typename PointOutT> void
+flipNormalTowardsNormalsMean (const typename pcl::oneapi::PointCloudDev<PointInT>::ConstPtr &cloud,
+    pcl::oneapi::PointCloudDev<PointOutT> &normals)
+{
+  (void) cloud;
+  (void) normals;
+
+
+    /* TODO:
+    Eigen::Vector3f normal_mean = Eigen::Vector3f::Zero ();
+
+    for (const auto &normal_index : normal_indices)
+    {
+      const PointNT& cur_pt = normal_cloud[normal_index];
+
+      if (pcl::isFinite (cur_pt))
+      {
+        normal_mean += cur_pt.getNormalVector3fMap ();
+      }
+    }
+
+    if (normal_mean.isZero ())
+      return false;
+
+    normal_mean.normalize ();
+
+    if (normal.dot (normal_mean) < 0)
+    {
+      normal = -normal;
+    }
+    */
+}
+
+
+} // oneapi
+} // pcl
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::NormalEstimation<PointInT, PointOutT>::computeFeature (PointCloudOut &output)
+{
+  PointCloudDevOut normals;
+
+  computeFeature(normals);
+
+  normals.download(output);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::NormalEstimation<PointInT, PointOutT>::computeFeature (PointCloudDevOut &output)
+{
+  pcl::oneapi::DeviceArray<int> nn_indices;
+  pcl::oneapi::DeviceArray<float> nn_dists;
+  pcl::oneapi::DeviceArray<int> nn_splits;
+
+  // FIXME remove normals below, just use output
+  PointCloudDevOut normals (input_->size());
+
+  output.is_dense = true;
+
+  // Save a few cycles by not checking every point for NaN/Inf values if the cloud is set to dense
+  if (this->searchForNeighbors (input_, search_parameter_, nn_indices, nn_dists, nn_splits) != 0)
+  {
+    if (computePointNormal(surface_, nn_indices, nn_splits, normals) != true)
+    {
+      output.is_dense = false;
+    }
+
+    pcl::oneapi::flipNormalTowardsViewpoint<PointInT>(input_, vpx_, vpy_, vpz_, normals);
+  }
+
+  output = normals;
+}
+
+template <typename PointInT, typename PointOutT> bool
+pcl::oneapi::NormalEstimation<PointInT, PointOutT>::computePointNormal (const PointCloudDevConstPtr &cloud,
+    const pcl::oneapi::DeviceArray<int> &indices, const pcl::oneapi::DeviceArray<int> &splits,
+    PointCloudDevOut &normals)
+{
+  pcl::oneapi::DeviceArray<int> check_nan(1);
+  check_nan[0] = 0;
+  bool status = true;
+
+  using NE = pcl::oneapi::device::NormalEstimator<PointInT, PointOutT>;
+  pcl::oneapi::device::NormalEstimator<PointInT, PointOutT> est;
+  est.total_items = normals.size();
+  est.splits_ptr = splits.ptr();
+  est.indices_ptr = indices.ptr();
+  est.input_ptr = cloud->points.ptr();
+  est.plane_ptr = normals.points.ptr();
+  est.check_nan_ptr = check_nan.ptr();
+
+  int block = NE::CTA_SIZE;
+  int grid = divUp(est.total_items, NE::WARPS);
+
+  if (q_.get_device().is_gpu())
+  {
+    q_.submit([&](sycl::handler &cgh) {
+
+      cgh.parallel_for(sycl::nd_range<2>(sycl::range<2>(1, grid) * sycl::range<2>(1, block),
+                                         sycl::range<2>(1, block)),
+          [=](sycl::nd_item<2> it)[[intel::reqd_sub_group_size(NE::WARP_SIZE)]] {
+            est.computePointNormalGPUKernel(it);
+      });
+    }).wait();
+  }
+  else
+  {
+    q_.submit([&](sycl::handler &cgh) {
+      cgh.parallel_for(est.total_items, [=](auto &idx) {
+            est.computePointNormalCPUKernel(idx);
+      });
+    }).wait();
+  }
+
+  if (*est.check_nan_ptr > 0)
+    status = false;
+
+  return status;
+}
+
+
+
+#define PCL_INSTANTIATE_NormalEstimation(T,NT) template class PCL_EXPORTS pcl::oneapi::NormalEstimation<T,NT>;
+
+#endif    // PCL_ONEAPI_FEATURES_IMPL_NORMAL_3D_H_
diff --git a/oneapi/features/include/pcl/oneapi/features/normal_3d.h b/oneapi/features/include/pcl/oneapi/features/normal_3d.h
new file mode 100644
index 000000000..e9c91b127
--- /dev/null
+++ b/oneapi/features/include/pcl/oneapi/features/normal_3d.h
@@ -0,0 +1,262 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/features/feature.h>
+#include <pcl/pcl_macros.h>
+#include <pcl/memory.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+
+  /** \brief Flip (in place) the estimated normal of a point towards a given viewpoint
+    * \param point a given point
+    * \param vp_x the X coordinate of the viewpoint
+    * \param vp_y the X coordinate of the viewpoint
+    * \param vp_z the X coordinate of the viewpoint
+    * \param normal the plane normal to be flipped
+    * \ingroup features
+    */
+  template <typename PointInT, typename PointOutT> inline void
+  flipNormalTowardsViewpoint (const typename pcl::oneapi::PointCloudDev<PointInT>::ConstPtr &point,
+      const float vp_x, const float vp_y, const float vp_z,
+      pcl::oneapi::PointCloudDev<PointOutT>& normal);
+
+
+  /** \brief Flip (in place) normal to get the same sign of the mean of the normals specified by normal_indices.
+    *
+    * The method is described in:
+    * A. Petrelli, L. Di Stefano, "A repeatable and efficient canonical reference for surface matching", 3DimPVT, 2012
+    * A. Petrelli, L. Di Stefano, "On the repeatability of the local reference frame for partial shape matching", 13th International Conference on Computer Vision (ICCV), 2011
+    *
+    * Normals should be unit vectors. Otherwise the resulting mean would be weighted by the normal norms.
+    * \param[in] normal_cloud Cloud of normals used to compute the mean
+    * \param[in] normal_indices Indices of normals used to compute the mean
+    * \param[in] normal input Normal to flip. Normal is modified by the function.
+    * \return false if normal_indices does not contain any valid normal.
+    * \ingroup features
+    */
+
+    template<typename PointInT, typename PointOutT> inline void
+    flipNormalTowardsNormalsMean (const typename pcl::oneapi::PointCloudDev<PointInT>::ConstPtr &cloud,
+        pcl::oneapi::PointCloudDev<PointOutT> &normals);
+
+  /** \brief NormalEstimation estimates local surface properties (surface normals and curvatures)at each
+    * 3D point. If PointOutT is specified as pcl::Normal, the normal is stored in the first 3 components (0-2),
+    * and the curvature is stored in component 3.
+    *
+    * \note The code is stateful as we do not expect this class to be multicore parallelized. Please look at
+    * \ref NormalEstimationOMP for a parallel implementation.
+    * \author Radu B. Rusu
+    * \ingroup features
+    */
+  template <typename PointInT, typename PointOutT>
+  class NormalEstimation: public pcl::oneapi::Feature<PointInT, PointOutT>
+  {
+    public:
+      using Ptr = shared_ptr<NormalEstimation<PointInT, PointOutT> >;
+      using ConstPtr = shared_ptr<const NormalEstimation<PointInT, PointOutT> >;
+      using Feature<PointInT, PointOutT>::feature_name_;
+      using Feature<PointInT, PointOutT>::getClassName;
+      using Feature<PointInT, PointOutT>::indices_;
+      using Feature<PointInT, PointOutT>::input_;
+      using Feature<PointInT, PointOutT>::surface_;
+      using Feature<PointInT, PointOutT>::k_;
+      using Feature<PointInT, PointOutT>::search_radius_;
+      using Feature<PointInT, PointOutT>::search_parameter_;
+
+      using PointCloudOut = typename Feature<PointInT, PointOutT>::PointCloudOut;
+      using PointCloudDevOut = typename Feature<PointInT, PointOutT>::PointCloudDevOut;
+      using PointCloudConstPtr = typename Feature<PointInT, PointOutT>::PointCloudConstPtr;
+      using PointCloudDevConstPtr = typename Feature<PointInT, PointOutT>::PointCloudDevConstPtr;
+
+      /** \brief Empty constructor. */
+      NormalEstimation ()
+      : vpx_ (0)
+      , vpy_ (0)
+      , vpz_ (0)
+      , use_sensor_origin_ (true)
+      , q_ (dpct::get_default_queue())
+      {
+        feature_name_ = "NormalEstimation";
+      };
+
+      /** \brief Empty destructor */
+      ~NormalEstimation () {}
+
+      /** \brief Compute the Least-Squares plane fit for a given set of points, using their indices,
+        * and return the estimated plane parameters together with the surface curvature.
+        * \param cloud the input point cloud
+        * \param indices the point cloud indices that need to be used
+        * \param plane_parameters the plane parameters as: a, b, c, d (ax + by + cz + d = 0)
+        * \param curvature the estimated surface curvature as a measure of
+        * \f[
+        * \lambda_0 / (\lambda_0 + \lambda_1 + \lambda_2)
+        * \f]
+        */
+      bool
+      computePointNormal (const PointCloudDevConstPtr &cloud,
+                          const pcl::oneapi::DeviceArray<int> &indices,
+                          const pcl::oneapi::DeviceArray<int> &splits,
+                          PointCloudDevOut &normal);
+
+
+      /** \brief Provide a pointer to the input dataset
+        * \param cloud the const boost shared pointer to a PointCloud message
+        */
+      inline void
+      setInputCloud (const PointCloudDevConstPtr &cloud) override
+      {
+        input_ = cloud;
+        if (use_sensor_origin_)
+        {
+          vpx_ = input_->sensor_origin_.coeff (0);
+          vpy_ = input_->sensor_origin_.coeff (1);
+          vpz_ = input_->sensor_origin_.coeff (2);
+        }
+      }
+
+      /** \brief Provide a pointer to the input dataset
+        * \param cloud the const boost shared pointer to a PointCloud message
+        */
+      inline void
+      setInputCloud (const PointCloudConstPtr &cloud) override
+      {
+        Feature<PointInT, PointOutT>::setInputCloud(cloud);
+
+        if (use_sensor_origin_)
+        {
+          vpx_ = cloud->sensor_origin_.coeff (0);
+          vpy_ = cloud->sensor_origin_.coeff (1);
+          vpz_ = cloud->sensor_origin_.coeff (2);
+        }
+      }
+
+      /** \brief Set the viewpoint.
+        * \param vpx the X coordinate of the viewpoint
+        *
+        * \param vpy the Y coordinate of the viewpoint
+        * \param vpz the Z coordinate of the viewpoint
+        */
+      inline void
+      setViewPoint (float vpx, float vpy, float vpz)
+      {
+        vpx_ = vpx;
+        vpy_ = vpy;
+        vpz_ = vpz;
+        use_sensor_origin_ = false;
+      }
+
+      /** \brief Get the viewpoint.
+        * \param [out] vpx x-coordinate of the view point
+        * \param [out] vpy y-coordinate of the view point
+        * \param [out] vpz z-coordinate of the view point
+        * \note this method returns the currently used viewpoint for normal flipping.
+        * If the viewpoint is set manually using the setViewPoint method, this method will return the set view point coordinates.
+        * If an input cloud is set, it will return the sensor origin otherwise it will return the origin (0, 0, 0)
+        */
+      inline void
+      getViewPoint (float &vpx, float &vpy, float &vpz)
+      {
+        vpx = vpx_;
+        vpy = vpy_;
+        vpz = vpz_;
+      }
+
+      /** \brief sets whether the sensor origin or a user given viewpoint should be used. After this method, the
+        * normal estimation method uses the sensor origin of the input cloud.
+        * to use a user defined view point, use the method setViewPoint
+        */
+      inline void
+      useSensorOriginAsViewPoint ()
+      {
+        use_sensor_origin_ = true;
+        if (input_)
+        {
+          vpx_ = input_->sensor_origin_.coeff (0);
+          vpy_ = input_->sensor_origin_.coeff (1);
+          vpz_ = input_->sensor_origin_.coeff (2);
+        }
+        else
+        {
+          vpx_ = 0;
+          vpy_ = 0;
+          vpz_ = 0;
+        }
+      }
+
+    protected:
+      /** \brief Estimate normals for all points given in <setInputCloud (), setIndices ()> using the surface in
+        * setSearchSurface () and the spatial locator in setSearchMethod ()
+        * \note In situations where not enough neighbors are found, the normal and curvature values are set to NaN.
+        * \param output the resultant point cloud model dataset that contains surface normals and curvatures
+        */
+      void
+      computeFeature (PointCloudOut &output) override;
+
+      void
+      computeFeature (PointCloudDevOut &output) override;
+
+      /** \brief Values describing the viewpoint ("pinhole" camera model assumed). For per point viewpoints, inherit
+        * from NormalEstimation and provide your own computeFeature (). By default, the viewpoint is set to 0,0,0. */
+      float vpx_, vpy_, vpz_;
+
+      /** \brief Placeholder for the 3x3 covariance matrix at each surface patch. */
+      EIGEN_ALIGN16 Eigen::Matrix3f covariance_matrix_;
+
+      /** \brief 16-bytes aligned placeholder for the XYZ centroid of a surface patch. */
+      sycl::float4 xyz_centroid_;
+
+      /** whether the sensor origin of the input cloud or a user given viewpoint should be used.*/
+      bool use_sensor_origin_;
+
+
+      /** sycl queue **/
+      sycl::queue q_;
+  };
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/features/impl/normal_3d.hpp>
+#endif
diff --git a/oneapi/features/src/normal_3d.cpp b/oneapi/features/src/normal_3d.cpp
new file mode 100644
index 000000000..ce497909d
--- /dev/null
+++ b/oneapi/features/src/normal_3d.cpp
@@ -0,0 +1,51 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/features/impl/normal_3d.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+// Instantiations of specific point types
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+  PCL_INSTANTIATE_PRODUCT(NormalEstimation, ((pcl::PointSurfel)(pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGB)(pcl::PointXYZRGBA)(pcl::PointNormal))((pcl::Normal)(pcl::PointNormal)(pcl::PointXYZRGBNormal)))
+#else
+  PCL_INSTANTIATE_PRODUCT(NormalEstimation, (PCL_XYZ_POINT_TYPES)(PCL_NORMAL_POINT_TYPES))
+#endif
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/CMakeLists.txt b/oneapi/filters/CMakeLists.txt
new file mode 100644
index 000000000..87c85cd2b
--- /dev/null
+++ b/oneapi/filters/CMakeLists.txt
@@ -0,0 +1,54 @@
+set(SUBSYS_NAME oneapi_filters)
+set(SUBSYS_PATH oneapi/filters)
+set(SUBSYS_DESC "Point cloud oneAPI filter library")
+set(SUBSYS_DEPS oneapi_common oneapi_search oneapi_kdtree kdtree common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/${SUBSYS_PATH}/filter.h"
+  "include/pcl/${SUBSYS_PATH}/filter_indices.h"
+  "include/pcl/${SUBSYS_PATH}/extract_indices.h"
+  "include/pcl/${SUBSYS_PATH}/passthrough.h"
+  "include/pcl/${SUBSYS_PATH}/voxel_grid.h"
+  "include/pcl/${SUBSYS_PATH}/statistical_outlier_removal.h"
+)
+
+set(impl_incs
+  "include/pcl/${SUBSYS_PATH}/impl/filter.hpp"
+  "include/pcl/${SUBSYS_PATH}/impl/filter_indices.hpp"
+  "include/pcl/${SUBSYS_PATH}/impl/extract_indices.hpp"
+  "include/pcl/${SUBSYS_PATH}/impl/passthrough.hpp"
+  "include/pcl/${SUBSYS_PATH}/impl/voxel_grid.hpp"
+  "include/pcl/${SUBSYS_PATH}/impl/statistical_outlier_removal.hpp"
+)
+
+set(srcs
+  src/filter.cpp
+  src/filter_indices.cpp
+  src/extract_indices.cpp
+  src/passthrough.cpp
+  src/voxel_grid.cpp
+  src/statistical_outlier_removal.cpp
+)
+
+find_package(TBB REQUIRED)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs})
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+target_link_libraries("${LIB_NAME}"  pcl_oneapi_search pcl_oneapi_kdtree pcl_oneapi_common pcl_kdtree pcl_common TBB::tbb)
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/filters/include/pcl/oneapi/filters/extract_indices.h b/oneapi/filters/include/pcl/oneapi/filters/extract_indices.h
new file mode 100644
index 000000000..a5289b296
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/extract_indices.h
@@ -0,0 +1,208 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/filters/filter_indices.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b ExtractIndices extracts a set of indices from a point cloud.
+    * \details Usage example:
+    * \code
+    * pcl::ExtractIndices<PointType> eifilter (true); // Initializing with true will allow us to extract the removed indices
+    * eifilter.setInputCloud (cloud_in);
+    * eifilter.setIndices (indices_in);
+    * eifilter.filter (*cloud_out);
+    * // The resulting cloud_out contains all points of cloud_in that are indexed by indices_in
+    * indices_rem = eifilter.getRemovedIndices ();
+    * // The indices_rem array indexes all points of cloud_in that are not indexed by indices_in
+    * eifilter.setNegative (true);
+    * eifilter.filter (*indices_out);
+    * // Alternatively: the indices_out array is identical to indices_rem
+    * eifilter.setNegative (false);
+    * eifilter.setUserFilterValue (1337.0);
+    * eifilter.filterDirectly (cloud_in);
+    * // This will directly modify cloud_in instead of creating a copy of the cloud
+    * // It will overwrite all fields of the filtered points by the user value: 1337
+    * \endcode
+    * \author Radu Bogdan Rusu
+    * \ingroup filters
+    */
+  template<typename PointT>
+  class ExtractIndices : public FilterIndices<PointT>
+  {
+    protected:
+      using PointCloud = typename FilterIndices<PointT>::PointCloud;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+      using PointCloudDev = typename FilterIndices<PointT>::PointCloudDev;
+      using PointCloudDevPtr = typename PointCloudDev::Ptr;
+      using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+      using FieldList = typename pcl::traits::fieldList<PointT>::type;
+
+    public:
+
+      using Ptr = shared_ptr<ExtractIndices<PointT> >;
+      using ConstPtr = shared_ptr<const ExtractIndices<PointT> >;
+
+      /** \brief Constructor.
+        * \param[in] extract_removed_indices Set to true if you want to be able to extract the indices of points being removed (default = false).
+        */
+      ExtractIndices (bool extract_removed_indices = false) :
+        FilterIndices<PointT>::FilterIndices (extract_removed_indices)
+      {
+        use_indices_ = true;
+        filter_name_ = "ExtractIndices";
+      }
+
+      /** \brief Apply the filter and store the results directly in the input cloud.
+        * \details This method will save the time and memory copy of an output cloud but can not alter the original size of the input cloud:
+        * It operates as though setKeepOrganized() is true and will overwrite the filtered points instead of remove them.
+        * All fields of filtered points are replaced with the value set by setUserFilterValue() (default = NaN).
+        * This method also automatically alters the input cloud set via setInputCloud().
+        * It does not alter the value of the internal keep organized boolean as set by setKeepOrganized().
+        * \param cloud The point cloud used for input and output.
+        */
+      void
+      filterDirectly (PointCloudDevPtr &cloud);
+
+    protected:
+      using PCLBase<PointT>::input_;
+      using PCLBase<PointT>::indices_;
+      using PCLBase<PointT>::use_indices_;
+      using Filter<PointT>::filter_name_;
+      using Filter<PointT>::getClassName;
+      using FilterIndices<PointT>::negative_;
+      using FilterIndices<PointT>::keep_organized_;
+      using FilterIndices<PointT>::user_filter_value_;
+      using FilterIndices<PointT>::extract_removed_indices_;
+      using FilterIndices<PointT>::removed_indices_;
+
+      /** \brief Filtered results are stored in a separate point cloud.
+        * \param[out] output The resultant point cloud.
+        */
+      void
+      applyFilter (PointCloudDev &output) override;
+
+      /** \brief Filtered results are indexed by an indices array.
+        * \param[out] indices The resultant indices.
+        */
+      void
+      applyFilter (IndicesDev &indices) override
+      {
+        applyFilterIndices (indices);
+      }
+
+      /** \brief Filtered results are indexed by an indices array.
+        * \param[out] indices The resultant indices.
+        */
+      void
+      applyFilterIndices (IndicesDev &indices);
+  };
+
+  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief @b ExtractIndices extracts a set of indices from a point cloud.
+    * <br>
+    * Usage examples:
+    * \code
+    * pcl::ExtractIndices<PointType> filter;
+    * filter.setInputCloud (cloud_in);
+    * filter.setIndices (indices_in);
+    * // Extract the points in cloud_in referenced by indices_in as a separate point cloud:
+    * filter.filter (*cloud_out);
+    * // Retrieve indices to all points in cloud_in except those referenced by indices_in:
+    * filter.setNegative (true);
+    * filter.filter (*indices_out);
+    * // The resulting cloud_out is identical to cloud_in, but all points referenced by indices_in are made NaN:
+    * filter.setNegative (true);
+    * filter.setKeepOrganized (true);
+    * filter.filter (*cloud_out);
+    * \endcode
+    * \note Does not inherently remove NaNs from results, hence the \a extract_removed_indices_ system is not used.
+    * \author Radu Bogdan Rusu
+    * \ingroup filters
+    */
+  template<>
+  class PCL_EXPORTS ExtractIndices<pcl::oneapi::PCLPointCloud2> : public FilterIndices<pcl::oneapi::PCLPointCloud2>
+  {
+    public:
+      using PCLPointCloud2 = pcl::oneapi::PCLPointCloud2;
+      using PCLPointCloud2Ptr = PCLPointCloud2::Ptr;
+      using PCLPointCloud2ConstPtr = PCLPointCloud2::ConstPtr;
+
+      /** \brief Empty constructor. */
+      ExtractIndices ()
+      {
+        use_indices_ = true;
+        filter_name_ = "ExtractIndices";
+      }
+
+    protected:
+      using PCLBase<PCLPointCloud2>::input_;
+      using PCLBase<PCLPointCloud2>::indices_;
+      using PCLBase<PCLPointCloud2>::use_indices_;
+      using Filter<PCLPointCloud2>::filter_name_;
+      using Filter<PCLPointCloud2>::getClassName;
+      using FilterIndices<PCLPointCloud2>::negative_;
+      using FilterIndices<PCLPointCloud2>::keep_organized_;
+      using FilterIndices<PCLPointCloud2>::user_filter_value_;
+
+      /** \brief Extract point indices into a separate PointCloud
+        * \param[out] output the resultant point cloud
+        */
+      void
+      applyFilter (PCLPointCloud2 &output) override;
+
+      /** \brief Extract point indices
+        * \param indices the resultant indices
+        */
+      void
+      applyFilter (IndicesDev &indices) override;
+  };
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/extract_indices.hpp>
+#endif
diff --git a/oneapi/filters/include/pcl/oneapi/filters/filter.h b/oneapi/filters/include/pcl/oneapi/filters/filter.h
new file mode 100644
index 000000000..61cc93a0c
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/filter.h
@@ -0,0 +1,295 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+// #include <oneapi/dpl/execution>
+// #include <oneapi/dpl/algorithm>
+// #include <dpct/dpct.hpp>
+// #include <dpct/dpl_extras/vector.h>
+// #include <dpct/dpl_extras/algorithm.h>
+
+
+#include <pcl/oneapi/pcl_base.h>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/PointIndices.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Removes points with x, y, or z equal to NaN
+    * \param[in] cloud_in the input point cloud
+    * \param[out] cloud_out the output point cloud
+    * \param[out] index the mapping (ordered): cloud_out[i] = cloud_in[index[i]]
+    * \note The density of the point cloud is lost.
+    * \note Can be called with cloud_in == cloud_out
+    * \ingroup filters
+    */
+  template<typename PointT> void
+  removeNaNFromPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                           pcl::PointCloud<PointT> &cloud_out,
+                           Indices &index);
+
+  /** \brief Removes points that have their normals invalid (i.e., equal to NaN)
+    * \param[in] cloud_in the input point cloud
+    * \param[out] cloud_out the output point cloud
+    * \param[out] index the mapping (ordered): cloud_out[i] = cloud_in[index[i]]
+    * \note The density of the point cloud is lost.
+    * \note Can be called with cloud_in == cloud_out
+    * \ingroup filters
+    */
+  template<typename PointT> void
+  removeNaNNormalsFromPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                                  pcl::PointCloud<PointT> &cloud_out,
+                                  Indices &index);
+
+  ////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief Filter represents the base filter class. All filters must inherit from this interface.
+    * \author Radu B. Rusu
+    * \ingroup filters
+    */
+  template<typename PointT>
+  class Filter : public PCLBase<PointT>
+  {
+    public:
+      using Ptr = shared_ptr<Filter<PointT> >;
+      using ConstPtr = shared_ptr<const Filter<PointT> >;
+
+
+      using PointCloud = pcl::PointCloud<PointT>;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+      using PointCloudDev = typename PCLBase<PointT>::PointCloudDev;
+      /** \brief Empty constructor.
+        * \param[in] extract_removed_indices set to true if the filtered data indices should be saved in a
+        * separate list. Default: false.
+        */
+      Filter (bool extract_removed_indices = false) :
+        removed_indices_ (new IndicesDev),
+        extract_removed_indices_ (extract_removed_indices)
+      {
+      }
+
+      /** \brief Get the point indices being removed */
+      inline IndicesConstPtr const
+      getRemovedIndices () const
+      {
+        IndicesPtr removed_indices_ext = std::make_shared<Indices>(removed_indices_->size());
+        removed_indices_->download(removed_indices_ext->data());
+        return (removed_indices_ext);
+      }
+
+      /** \brief Get the point indices being removed
+        * \param[out] pi the resultant point indices that have been removed
+        */
+      inline void
+      getRemovedIndices (PointIndicesDev &pi)
+      {
+        pi.indices = *removed_indices_;
+      }
+
+      /** \brief Calls the filtering method and returns the filtered dataset in output.
+        * \param[out] output the resultant filtered point cloud dataset
+        */
+      inline void
+      filter (PointCloud &output)
+      {
+        if (!initCompute())
+          return;
+
+        PointCloudDev output_dev;
+        filter(output_dev);
+        output.resize(output_dev.size());
+        output.width = output_dev.width;
+        output.height = output_dev.height;
+        output.is_dense = output_dev.is_dense;
+        output.header = output_dev.header;
+        output.sensor_origin_ = output_dev.sensor_origin_;
+        output.sensor_orientation_ = output_dev.sensor_orientation_;
+        output_dev.points.download(output.data());
+
+        deinitCompute ();
+      }
+
+      /** \brief Calls the filtering method and returns the filtered dataset in DeviceArray output.
+       * \param[out] output the resultant filtered point cloud dataset
+       */
+      inline void
+      filter(PointCloudDev& output)
+      {
+        if (!initCompute())
+          return;
+
+        if (input_.get() == &output) // cloud_in = cloud_out
+        {
+          PointCloudDev output_temp;
+          applyFilter(output_temp);
+          output_temp.header = input_->header;
+          output_temp.sensor_origin_ = input_->sensor_origin_;
+          output_temp.sensor_orientation_ = input_->sensor_orientation_;
+          output = output_temp;
+        }
+        else {
+          output.header = input_->header;
+          output.sensor_origin_ = input_->sensor_origin_;
+          output.sensor_orientation_ = input_->sensor_orientation_;
+          applyFilter (output);
+        }
+
+        deinitCompute ();
+      }
+
+    protected:
+
+      using PCLBase<PointT>::indices_;
+      using PCLBase<PointT>::input_;
+
+      using PCLBase<PointT>::initCompute;
+      using PCLBase<PointT>::deinitCompute;
+
+      /** \brief Indices of the points that are removed */
+      IndicesDevPtr removed_indices_;
+
+      /** \brief The filter name. */
+      std::string filter_name_;
+
+      /** \brief Set to true if we want to return the indices of the removed points. */
+      bool extract_removed_indices_;
+
+      /** \brief Abstract filter method.
+        *
+        * The implementation needs to set output.{points, width, height, is_dense}.
+        *
+        * \param[out] output the resultant filtered point cloud
+        */
+      virtual void
+      applyFilter (PointCloudDev &output) = 0;
+
+      /** \brief Get a string representation of the name of this class. */
+      inline const std::string&
+      getClassName () const
+      {
+        return (filter_name_);
+      }
+  };
+
+  ////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief Filter represents the base filter class. All filters must inherit from this interface.
+    * \author Radu B. Rusu
+    * \ingroup filters
+    */
+  template<>
+  class PCL_EXPORTS Filter<pcl::oneapi::PCLPointCloud2> : public PCLBase<pcl::oneapi::PCLPointCloud2>
+  {
+    public:
+      using Ptr = shared_ptr<Filter<pcl::oneapi::PCLPointCloud2> >;
+      using ConstPtr = shared_ptr<const Filter<pcl::oneapi::PCLPointCloud2> >;
+
+      using PCLPointCloud2 = pcl::oneapi::PCLPointCloud2;
+      using PCLPointCloud2Ptr = PCLPointCloud2::Ptr;
+      using PCLPointCloud2ConstPtr = PCLPointCloud2::ConstPtr;
+
+      /** \brief Empty constructor.
+        * \param[in] extract_removed_indices set to true if the filtered data indices should be saved in a
+        * separate list. Default: false.
+        */
+      Filter (bool extract_removed_indices = false) :
+        removed_indices_ (std::make_shared<IndicesDev>()),
+        extract_removed_indices_ (extract_removed_indices)
+      {
+      }
+
+      /** \brief Get the point indices being removed */
+      inline IndicesConstPtr const
+      getRemovedIndices () const
+      {
+        IndicesPtr removed_indices_ext = std::make_shared<Indices>(removed_indices_->size());
+        removed_indices_->download(removed_indices_ext->data());
+        return (removed_indices_ext);
+      }
+
+      /** \brief Get the point indices being removed
+        * \param[out] pi the resultant point indices that have been removed
+        */
+      inline void
+      getRemovedIndices (PointIndicesDev &pi)
+      {
+        pi.indices = *removed_indices_;
+      }
+
+      /** \brief Calls the filtering method and returns the filtered dataset in output.
+        * \param[out] output the resultant filtered point cloud dataset
+        */
+      void
+      filter (PCLPointCloud2 &output);
+
+    protected:
+
+      /** \brief Indices of the points that are removed */
+      IndicesDevPtr removed_indices_;
+
+      /** \brief Set to true if we want to return the indices of the removed points. */
+      bool extract_removed_indices_;
+
+      /** \brief The filter name. */
+      std::string filter_name_;
+
+      /** \brief Abstract filter method.
+        *
+        * The implementation needs to set output.{data, row_step, point_step, width, height, is_dense}.
+        *
+        * \param[out] output the resultant filtered point cloud
+        */
+      virtual void
+      applyFilter (PCLPointCloud2 &output) = 0;
+
+      /** \brief Get a string representation of the name of this class. */
+      inline const std::string&
+      getClassName () const
+      {
+        return (filter_name_);
+      }
+  };
+}
+}
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/filter.hpp>
+#endif
diff --git a/oneapi/filters/include/pcl/oneapi/filters/filter_indices.h b/oneapi/filters/include/pcl/oneapi/filters/filter_indices.h
new file mode 100644
index 000000000..99badb04e
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/filter_indices.h
@@ -0,0 +1,311 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: filter_indices.h 4707 2012-02-23 10:34:17Z florentinus $
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/filters/filter.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief Removes points with x, y, or z equal to NaN (dry run).
+    *
+    * This function only computes the mapping between the points in the input
+    * cloud and the cloud that would result from filtering. It does not
+    * actually construct and output the filtered cloud.
+    *
+    * \note This function does not modify the input point cloud!
+    *
+    * \param cloud_in the input point cloud
+    * \param index the mapping (ordered): filtered_cloud[i] = cloud_in[index[i]]
+    *
+    * \see removeNaNFromPointCloud
+    * \ingroup filters
+    */
+  template<typename PointT> void
+  removeNaNFromPointCloud (const pcl::PointCloud<PointT> &cloud_in, Indices &index);
+
+  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief @b FilterIndices represents the base class for filters that are about binary point removal.
+    * <br>
+    * All derived classes have to implement the \a filter (PointCloud &output) and the \a filter (Indices &indices) methods.
+    * Ideally they also make use of the \a negative_, \a keep_organized_ and \a extract_removed_indices_ systems.
+    * The distinguishment between the \a negative_ and \a extract_removed_indices_ systems only makes sense if the class automatically
+    * filters non-finite entries in the filtering methods (recommended).
+    * \author Justin Rosen
+    * \ingroup filters
+    */
+  template<typename PointT>
+  class FilterIndices : public Filter<PointT>
+  {
+    public:
+      using Filter<PointT>::extract_removed_indices_;
+      using PointCloud = pcl::PointCloud<PointT>;
+
+      using Ptr = shared_ptr<FilterIndices<PointT> >;
+      using ConstPtr = shared_ptr<const FilterIndices<PointT> >;
+
+      using PointCloudDev = typename Filter<PointT>::PointCloudDev;
+
+      /** \brief Constructor.
+        * \param[in] extract_removed_indices Set to true if you want to be able to extract the indices of points being removed (default = false).
+        */
+      FilterIndices (bool extract_removed_indices = false) :
+          Filter<PointT> (extract_removed_indices),
+          negative_ (false),
+          keep_organized_ (false),
+          user_filter_value_ (std::numeric_limits<float>::quiet_NaN ())
+      {
+      }
+
+      using Filter<PointT>::filter;
+
+      /** \brief Calls the filtering method and returns the filtered point cloud indices.
+        * \param[out] indices the resultant filtered point cloud indices
+        */
+      void
+      filter (Indices &indices)
+      {
+        IndicesDev indices_dev;
+
+        if (!initCompute ())
+          return;
+
+        // Apply the actual filter
+        applyFilter(indices_dev);
+        indices.resize(indices_dev.size());
+        indices_dev.download(indices.data());
+        deinitCompute ();
+      }
+
+      /** \brief Calls the filtering method and returns the filtered point cloud indices.
+        * \param[out] indices the resultant filtered point cloud indices
+        */
+      void
+      filter (IndicesDev &indices)
+      {
+        if (!initCompute ())
+          return;
+
+        // Apply the actual filter
+        applyFilter(indices);
+        deinitCompute ();
+      }
+
+      /** \brief Set whether the regular conditions for points filtering should apply, or the inverted conditions.
+        * \param[in] negative false = normal filter behavior (default), true = inverted behavior.
+        */
+      inline void
+      setNegative (bool negative)
+      {
+        negative_ = negative;
+      }
+
+      /** \brief Get whether the regular conditions for points filtering should apply, or the inverted conditions.
+        * \return The value of the internal \a negative_ parameter; false = normal filter behavior (default), true = inverted behavior.
+        */
+      inline bool
+      getNegative () const
+      {
+        return (negative_);
+      }
+
+      /** \brief Set whether the filtered points should be kept and set to the value given through \a setUserFilterValue (default: NaN),
+        * or removed from the PointCloud, thus potentially breaking its organized structure.
+        * \param[in] keep_organized false = remove points (default), true = redefine points, keep structure.
+        */
+      inline void
+      setKeepOrganized (bool keep_organized)
+      {
+        keep_organized_ = keep_organized;
+      }
+
+      /** \brief Get whether the filtered points should be kept and set to the value given through \a setUserFilterValue (default = NaN),
+        * or removed from the PointCloud, thus potentially breaking its organized structure.
+        * \return The value of the internal \a keep_organized_ parameter; false = remove points (default), true = redefine points, keep structure.
+        */
+      inline bool
+      getKeepOrganized () const
+      {
+        return (keep_organized_);
+      }
+
+      /** \brief Provide a value that the filtered points should be set to instead of removing them.
+        * Used in conjunction with \a setKeepOrganized ().
+        * \param[in] value the user given value that the filtered point dimensions should be set to (default = NaN).
+        */
+      inline void
+      setUserFilterValue (float value)
+      {
+        user_filter_value_ = value;
+      }
+
+    protected:
+
+      using Filter<PointT>::initCompute;
+      using Filter<PointT>::deinitCompute;
+      using Filter<PointT>::input_;
+      using Filter<PointT>::removed_indices_;
+
+      /** \brief False = normal filter behavior (default), true = inverted behavior. */
+      bool negative_;
+
+      /** \brief False = remove points (default), true = redefine points, keep structure. */
+      bool keep_organized_;
+
+      /** \brief The user given value that the filtered point dimensions should be set to (default = NaN). */
+      float user_filter_value_;
+
+      /** \brief Abstract filter method for point cloud indices using DeviceArray. */
+      virtual void
+      applyFilter(IndicesDev& indices) = 0;
+
+      /** \brief Abstract filter method for point cloud using DeviceArray. */
+      void
+      applyFilter(PointCloudDev& output) override;
+  };
+
+  //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+  /** \brief @b FilterIndices represents the base class for filters that are about binary point removal.
+    * <br>
+    * All derived classes have to implement the \a filter (PointCloud &output) and the \a filter (Indices &indices) methods.
+    * Ideally they also make use of the \a negative_, \a keep_organized_ and \a extract_removed_indices_ systems.
+    * The distinguishment between the \a negative_ and \a extract_removed_indices_ systems only makes sense if the class automatically
+    * filters non-finite entries in the filtering methods (recommended).
+    * \author Justin Rosen
+    * \ingroup filters
+    */
+  template<>
+  class PCL_EXPORTS FilterIndices<pcl::oneapi::PCLPointCloud2> : public Filter<pcl::oneapi::PCLPointCloud2>
+  {
+    public:
+      using PCLPointCloud2 = pcl::oneapi::PCLPointCloud2;
+
+      /** \brief Constructor.
+        * \param[in] extract_removed_indices Set to true if you want to extract the indices of points being removed (default = false).
+        */
+      FilterIndices (bool extract_removed_indices = false) :
+          Filter<PCLPointCloud2> (extract_removed_indices),
+          negative_ (false), 
+          keep_organized_ (false), 
+          user_filter_value_ (std::numeric_limits<float>::quiet_NaN ())
+      {
+      }
+
+      using Filter<PCLPointCloud2>::filter;
+
+      /** \brief Calls the filtering method and returns the filtered point cloud indices.
+        * \param[out] indices the resultant filtered point cloud indices
+        */
+      void
+      filter (IndicesDev &indices);
+
+      /** \brief Set whether the regular conditions for points filtering should apply, or the inverted conditions.
+        * \param[in] negative false = normal filter behavior (default), true = inverted behavior.
+        */
+      inline void
+      setNegative (bool negative)
+      {
+        negative_ = negative;
+      }
+
+      /** \brief Get whether the regular conditions for points filtering should apply, or the inverted conditions.
+        * \return The value of the internal \a negative_ parameter; false = normal filter behavior (default), true = inverted behavior.
+        */
+      inline bool
+      getNegative () const
+      {
+        return (negative_);
+      }
+
+      /** \brief Set whether the filtered points should be kept and set to the value given through \a setUserFilterValue (default: NaN),
+        * or removed from the PointCloud, thus potentially breaking its organized structure.
+        * \param[in] keep_organized false = remove points (default), true = redefine points, keep structure.
+        */
+      inline void
+      setKeepOrganized (bool keep_organized)
+      {
+        keep_organized_ = keep_organized;
+      }
+
+      /** \brief Get whether the filtered points should be kept and set to the value given through \a setUserFilterValue (default = NaN),
+        * or removed from the PointCloud, thus potentially breaking its organized structure.
+        * \return The value of the internal \a keep_organized_ parameter; false = remove points (default), true = redefine points, keep structure.
+        */
+      inline bool
+      getKeepOrganized () const
+      {
+        return (keep_organized_);
+      }
+
+      /** \brief Provide a value that the filtered points should be set to instead of removing them.
+        * Used in conjunction with \a setKeepOrganized ().
+        * \param[in] value the user given value that the filtered point dimensions should be set to (default = NaN).
+        */
+      inline void
+      setUserFilterValue (float value)
+      {
+        user_filter_value_ = value;
+      }
+
+    protected:
+
+      /** \brief False = normal filter behavior (default), true = inverted behavior. */
+      bool negative_;
+
+      /** \brief False = remove points (default), true = redefine points, keep structure. */
+      bool keep_organized_;
+
+      /** \brief The user given value that the filtered point dimensions should be set to (default = NaN). */
+      float user_filter_value_;
+
+      /** \brief Abstract filter method for point cloud indices. */
+      virtual void
+      applyFilter (IndicesDev &indices) = 0;
+
+      /** \brief Abstract filter method for point cloud. */
+      void
+      applyFilter (PCLPointCloud2 &output) override = 0;
+  };
+}
+}
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/filter_indices.hpp>
+#endif
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/extract_indices.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/extract_indices.hpp
new file mode 100644
index 000000000..aba8da4ed
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/extract_indices.hpp
@@ -0,0 +1,187 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_FILTERS_IMPL_EXTRACT_INDICES_HPP_
+#define PCL_ONEAPI_FILTERS_IMPL_EXTRACT_INDICES_HPP_
+
+#include <pcl/oneapi/filters/extract_indices.h>
+#include <pcl/for_each_type.h>
+#include <pcl/conversions.h>
+#include <pcl/oneapi/common/io.h> // for copyPointCloud
+#include <numeric> // for std::iota
+
+namespace pcl
+{
+namespace oneapi
+{
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+ExtractIndices<PointT>::filterDirectly (PointCloudDevPtr &cloud)
+{
+  IndicesDev indices;
+  bool temp = extract_removed_indices_;
+  extract_removed_indices_ = true;
+  this->setInputCloud (cloud);
+  applyFilterIndices (indices);
+  extract_removed_indices_ = temp;
+
+  std::vector<pcl::PCLPointField> fields;
+  pcl::for_each_type<FieldList> (pcl::detail::FieldAdder<PointT> (fields));
+  for (const auto& rii : (*removed_indices_)) // rii = removed indices iterator
+  {
+    uindex_t pt_index = (uindex_t) rii;
+    if (pt_index >= input_->size ())
+    {
+      PCL_ERROR ("[pcl::%s::filterDirectly] The index exceeds the size of the input. Do nothing.\n",
+                 getClassName ().c_str ());
+      *cloud = *input_;
+      return;
+    }
+    std::uint8_t* pt_data = reinterpret_cast<std::uint8_t*> (&(*cloud)[pt_index]);
+    for (const auto &field : fields)
+      memcpy (pt_data + field.offset, &user_filter_value_, sizeof (float));
+  }
+  if (!std::isfinite (user_filter_value_))
+    cloud->is_dense = false;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+ExtractIndices<PointT>::applyFilter (PointCloudDev &output)
+{
+  IndicesDev indices;
+  if (keep_organized_)
+  {
+    bool temp = extract_removed_indices_;
+    extract_removed_indices_ = true;
+    applyFilterIndices (indices);
+    extract_removed_indices_ = temp;
+
+    output = *input_;
+    std::vector<pcl::PCLPointField> fields;
+    pcl::for_each_type<FieldList> (pcl::detail::FieldAdder<PointT> (fields));
+    for (const auto ri : *removed_indices_)  // ri = removed index
+    {
+      std::size_t pt_index = (std::size_t)ri;
+      if (pt_index >= input_->size ())
+      {
+        PCL_ERROR ("[pcl::%s::applyFilter] The index exceeds the size of the input. Do nothing.\n",
+                   getClassName ().c_str ());
+        output = *input_;
+        return;
+      }
+      std::uint8_t* pt_data = reinterpret_cast<std::uint8_t*> (&output[pt_index]);
+      for (const auto &field : fields)
+        memcpy (pt_data + field.offset, &user_filter_value_, sizeof (float));
+    }
+    if (!std::isfinite (user_filter_value_))
+      output.is_dense = false;
+  }
+  else
+  {
+    applyFilterIndices (indices);
+    copyPointCloud (*input_, indices, output);
+  }
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+ExtractIndices<PointT>::applyFilterIndices (IndicesDev &indices)
+{
+  if (indices_->size () > input_->size ())
+  {
+    PCL_ERROR ("[pcl::%s::applyFilter] The indices size exceeds the size of the input.\n", getClassName ().c_str ());
+    indices.clear ();
+    removed_indices_->clear ();
+    return;
+  }
+
+  if (!negative_)  // Normal functionality
+  {
+    indices = *indices_;
+
+    if (extract_removed_indices_)
+    {
+      // Set up the full indices set
+      IndicesDev full_indices (input_->size ());
+      std::iota (full_indices.begin (), full_indices.end (), static_cast<index_t> (0));
+
+      // Set up the sorted input indices
+      IndicesDev sorted_input_indices = *indices_;
+      std::sort (sorted_input_indices.begin (), sorted_input_indices.end ());
+
+      // Store the difference in removed_indices
+      removed_indices_->clear ();
+
+      Indices tmp_removed_indices;
+      std::set_difference (full_indices.begin (), full_indices.end (), sorted_input_indices.begin (), sorted_input_indices.end (), std::inserter(tmp_removed_indices, tmp_removed_indices.begin ()));
+      removed_indices_->upload(tmp_removed_indices);
+    }
+  }
+  else  // Inverted functionality
+  {
+    // Set up the full indices set
+    IndicesDev full_indices (input_->size ());
+    std::iota (full_indices.begin (), full_indices.end (), static_cast<index_t> (0));
+
+    // Set up the sorted input indices
+    IndicesDev sorted_input_indices = *indices_;
+    std::sort (sorted_input_indices.begin (), sorted_input_indices.end ());
+
+    // Store the difference in indices
+    indices.clear ();
+    Indices tmp_indices;
+    std::set_difference (full_indices.begin (), full_indices.end (), sorted_input_indices.begin (),
+            sorted_input_indices.end (), std::inserter (tmp_indices, tmp_indices.begin ()));
+
+    indices.upload(tmp_indices);
+
+    if (extract_removed_indices_)
+      removed_indices_ = indices_;
+  }
+}
+
+}
+}
+
+#define PCL_INSTANTIATE_ExtractIndices(T) template class PCL_EXPORTS pcl::oneapi::ExtractIndices<T>;
+
+#endif  // PCL_ONEAPI_FILTERS_IMPL_EXTRACT_INDICES_HPP_
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/filter.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/filter.hpp
new file mode 100644
index 000000000..cab06c597
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/filter.hpp
@@ -0,0 +1,144 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#include <pcl/oneapi/filters/filter.h>
+#include <pcl/pcl_exports.h> // for PCL_EXPORTS
+#include <pcl/common/point_tests.h> // for pcl::isFinite
+#include <pcl/oneapi/common/io.h> // for copyPointCloud
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+pcl::oneapi::removeNaNFromPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                              pcl::PointCloud<PointT> &cloud_out,
+                              Indices &index)
+{
+  // If the clouds are not the same, prepare the output
+  if (&cloud_in != &cloud_out)
+  {
+    cloud_out.header = cloud_in.header;
+    cloud_out.resize (cloud_in.size ());
+    cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+    cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  }
+  // Reserve enough space for the indices
+  index.resize (cloud_in.size ());
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud_in.is_dense)
+  {
+    // Simply copy the data
+    cloud_out = cloud_in;
+    for (std::size_t j = 0; j < cloud_out.size (); ++j)
+      index[j] = j;
+  }
+  else
+  {
+    std::size_t j = 0;
+    for (std::size_t i = 0; i < cloud_in.size (); ++i)
+    {
+      if (!std::isfinite (cloud_in[i].x) ||
+          !std::isfinite (cloud_in[i].y) ||
+          !std::isfinite (cloud_in[i].z))
+        continue;
+      cloud_out[j] = cloud_in[i];
+      index[j] = i;
+      j++;
+    }
+    if (j != cloud_in.size ())
+    {
+      // Resize to the correct size
+      cloud_out.resize (j);
+      index.resize (j);
+    }
+
+    cloud_out.height = 1;
+    cloud_out.width  = static_cast<std::uint32_t>(j);
+
+    // Removing bad points => dense (note: 'dense' doesn't mean 'organized')
+    cloud_out.is_dense = true;
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+pcl::oneapi::removeNaNNormalsFromPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                                     pcl::PointCloud<PointT> &cloud_out,
+                                     Indices &index)
+{
+  // If the clouds are not the same, prepare the output
+  if (&cloud_in != &cloud_out)
+  {
+    cloud_out.header = cloud_in.header;
+    cloud_out.resize (cloud_in.size ());
+    cloud_out.sensor_origin_ = cloud_in.sensor_origin_;
+    cloud_out.sensor_orientation_ = cloud_in.sensor_orientation_;
+  }
+  // Reserve enough space for the indices
+  index.resize (cloud_in.size ());
+  std::size_t j = 0;
+
+  // Assume cloud is dense
+  cloud_out.is_dense = true;
+
+  for (std::size_t i = 0; i < cloud_in.size (); ++i)
+  {
+    if (!std::isfinite (cloud_in[i].normal_x) ||
+        !std::isfinite (cloud_in[i].normal_y) ||
+        !std::isfinite (cloud_in[i].normal_z))
+      continue;
+    if (cloud_out.is_dense && !pcl::isFinite(cloud_in[i]))
+      cloud_out.is_dense = false;
+    cloud_out[j] = cloud_in[i];
+    index[j] = i;
+    j++;
+  }
+  if (j != cloud_in.size ())
+  {
+    // Resize to the correct size
+    cloud_out.resize (j);
+    index.resize (j);
+  }
+
+  cloud_out.height = 1;
+  cloud_out.width  = j;
+}
+
+
+#define PCL_INSTANTIATE_OneAPI_removeNaNFromPointCloud(T) template PCL_EXPORTS void pcl::oneapi::removeNaNFromPointCloud<T>(const pcl::PointCloud<T>&, pcl::PointCloud<T>&, Indices&);
+#define PCL_INSTANTIATE_OneAPI_removeNaNNormalsFromPointCloud(T) template PCL_EXPORTS void pcl::oneapi::removeNaNNormalsFromPointCloud<T>(const pcl::PointCloud<T>&, pcl::PointCloud<T>&, Indices&);
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/filter_indices.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/filter_indices.hpp
new file mode 100644
index 000000000..82746a129
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/filter_indices.hpp
@@ -0,0 +1,115 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: filter.hpp 1800 2011-07-15 11:45:31Z marton $
+ *
+ */
+
+#ifndef PCL_ONEAPI_FILTERS_IMPL_FILTER_INDICES_H_
+#define PCL_ONEAPI_FILTERS_IMPL_FILTER_INDICES_H_
+
+#include <pcl/oneapi/filters/filter_indices.h>
+#include <pcl/oneapi/common/io.h> // for copyPointCloud
+
+template <typename PointT> void
+pcl::oneapi::removeNaNFromPointCloud (const pcl::PointCloud<PointT> &cloud_in,
+                              Indices &index)
+{
+  // Reserve enough space for the indices
+  index.resize (cloud_in.size ());
+
+  // If the data is dense, we don't need to check for NaN
+  if (cloud_in.is_dense)
+  {
+    for (int j = 0; j < static_cast<int> (cloud_in.size ()); ++j)
+      index[j] = j;
+  }
+  else
+  {
+    int j = 0;
+    for (int i = 0; i < static_cast<int> (cloud_in.size ()); ++i)
+    {
+      if (!std::isfinite (cloud_in[i].x) || 
+          !std::isfinite (cloud_in[i].y) || 
+          !std::isfinite (cloud_in[i].z))
+        continue;
+      index[j] = i;
+      j++;
+    }
+    if (j != static_cast<int> (cloud_in.size ()))
+    {
+      // Resize to the correct size
+      index.resize (j);
+    }
+  }
+}
+
+template<typename PointT> void
+pcl::oneapi::FilterIndices<PointT>::applyFilter (PointCloudDev &output)
+{
+  IndicesDev indices;
+  if (keep_organized_)
+  {
+    if (!extract_removed_indices_)
+    {
+      PCL_WARN ("[pcl::FilterIndices<PointT>::applyFilter] extract_removed_indices_ was set to 'true' to keep the point cloud organized.\n");
+      extract_removed_indices_ = true;
+    }
+    applyFilter (indices);
+
+    output = *input_;
+
+    // To preserve legacy behavior, only coordinates xyz are filtered.
+    // Copying a PointXYZ initialized with the user_filter_value_ into a generic
+    // PointT, ensures only the xyz coordinates, if they exist at destination,
+    // are overwritten.
+    const PointXYZ ufv (user_filter_value_, user_filter_value_, user_filter_value_);
+    for (int i = 0; i < removed_indices_->size(); i++) // ri = removed index
+      pcl::copyPoint(ufv, output[(*removed_indices_)[i]]);
+    if (!std::isfinite (user_filter_value_))
+      output.is_dense = false;
+  }
+  else
+  {
+    output.is_dense = true;
+    applyFilter (indices);
+    pcl::oneapi::copyPointCloud (*input_, indices, output);
+  }
+}
+
+
+#define PCL_INSTANTIATE_OneAPI_removeNanFromPointCloud(T) template PCL_EXPORTS void pcl::oneapi::removeNaNFromPointCloud<T>(const pcl::PointCloud<T>&, Indices&);
+#define PCL_INSTANTIATE_OneAPI_FilterIndices(T) template class PCL_EXPORTS  pcl::oneapi::FilterIndices<T>;
+
+#endif    // PCL_ONEAPI_FILTERS_IMPL_FILTER_INDICES_H_
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/passthrough.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/passthrough.hpp
new file mode 100644
index 000000000..a6358310e
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/passthrough.hpp
@@ -0,0 +1,267 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_FILTERS_IMPL_PASSTHROUGH_HPP_
+#define PCL_ONEAPI_FILTERS_IMPL_PASSTHROUGH_HPP_
+#include <pcl/oneapi/filters/passthrough.h>
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+pcl::oneapi::PassThrough<PointT>::applyFilter(PointCloudDev &output)
+{
+  if (!filter_field_name_.empty() &&
+      !(filter_field_idx_ == FIELD_IDX_X || filter_field_idx_ == FIELD_IDX_Y ||
+       filter_field_idx_ == FIELD_IDX_Z)) {
+      PCL_WARN ("[pcl::%s::applyFilter] Unable to find field name in point type.\n", getClassName ().c_str ());
+      //indices.clear ();
+    removed_indices_->release();
+    return;
+  }
+  sycl::queue& q = dpct::get_default_queue();
+
+  const float const_filter_limit_min_ = filter_limit_min_;
+  const float const_filter_limit_max_ = filter_limit_max_;
+  bool is_empty = filter_field_name_.empty();
+  const uint8_t const_filter_field_idx_ = filter_field_idx_;
+  const bool const_negative = negative_;
+
+  pcl::oneapi::DeviceArray<int> sum(1, 0);
+  pcl::oneapi::DeviceArray<PointT> tmp_points(input_->size());
+
+  constexpr int CTA_SIZE_CPU = 512;
+  constexpr int CTA_SIZE_GPU = 64;
+
+  int point_size = input_->size();
+  int block = q.get_device().is_gpu() ? CTA_SIZE_GPU : CTA_SIZE_CPU;
+  int grid = (point_size + block - 1) / block;
+
+  q.submit([&](sycl::handler &h) {
+    auto in = input_->points.ptr();
+    auto out = tmp_points.ptr();
+    auto sum_ptr = sum.ptr();
+
+    // int [0] is to sum
+    // int [1] is the output index to write buffer
+    sycl::local_accessor<int> local_tmp(sycl::range<1>(2), h);
+
+    h.parallel_for(sycl::nd_range(sycl::range<1>(grid) * sycl::range<1>(block),
+                                               sycl::range<1>(block)),
+       [=](sycl::nd_item<1> item_ct1) {
+
+       local_tmp[0] = 0;
+       int idx = item_ct1.get_global_linear_id();
+
+       bool finite_check, field_check;
+       bool combine_check;
+
+       if (idx < point_size)
+       {
+          finite_check = (cl::sycl::isfinite(in[idx].x) && cl::sycl::isfinite(in[idx].y) &&
+                           cl::sycl::isfinite(in[idx].z));
+          if (is_empty) {
+            finite_check = 0;
+          }
+
+          field_check = (in[idx].data[const_filter_field_idx_] >= const_filter_limit_min_) &&
+                           (in[idx].data[const_filter_field_idx_] <= const_filter_limit_max_);
+
+          if (const_negative)
+            field_check = !field_check;
+
+          combine_check = finite_check && field_check;
+       }
+
+       auto v = sycl::atomic_ref<int, sycl::memory_order::relaxed,
+                                      sycl::memory_scope::device,
+                                      sycl::access::address_space::global_space>(
+                                      sum_ptr[0]);
+
+       auto local_v = sycl::atomic_ref<int, sycl::memory_order::relaxed,
+                                      sycl::memory_scope::work_group,
+                                      sycl::access::address_space::local_space>(
+                                      local_tmp[0]);
+       item_ct1.barrier(sycl::access::fence_space::local_space);
+
+       int local_idx = 0;
+       if (idx < point_size)
+       {
+         if (combine_check)
+         {
+            local_idx = local_v.fetch_add(1);
+         }
+       }
+
+       item_ct1.barrier(sycl::access::fence_space::local_space);
+
+       if (idx < point_size)
+       {
+         if (item_ct1.get_local_linear_id() == 0)
+         {
+            local_tmp[1] = v.fetch_add(local_tmp[0]);
+         }
+       }
+
+       item_ct1.barrier(sycl::access::fence_space::local_space);
+       if (idx < point_size)
+       {
+         if (combine_check)
+         {
+           int out_idx = local_tmp[1] + local_idx;
+           out[out_idx] = in[idx];
+         }
+       }
+    });
+  }).wait();
+
+  if (sum[0] == 0) {
+    //indices.clear();
+    if (extract_removed_indices_) {
+      indices_->copyTo(*removed_indices_);
+    }
+    return;
+  }
+
+  output.points.resize(sum[0]);
+  q.memcpy(output.points.ptr(), tmp_points.ptr(), sizeof(PointT)*sum[0]).wait();
+  output.height = 1;      // downsampling breaks the organized structure
+  output.is_dense = true; // we filter out invalid points
+  output.width = output.size();
+
+  if (extract_removed_indices_) {
+    int removed_idx_no = indices_->size() - sum[0];
+    if (removed_idx_no == 0) {
+      removed_indices_->release();
+      return;
+    }
+
+    int indices_size = indices_->size();
+    block = q.get_device().is_gpu() ? CTA_SIZE_GPU : CTA_SIZE_CPU;
+    grid = (indices_size + block - 1) / block;
+
+    pcl::oneapi::DeviceArray<int> tmp_indices(indices_->size());
+
+    sum[0] = 0;
+
+    q.submit([&](sycl::handler &h) {
+      auto in = input_->points.ptr();
+      auto input_indices = indices_->ptr();
+      auto out = tmp_indices.ptr();
+      auto sum_ptr = sum.ptr();
+
+      // int [0] is to sum
+      // int [1] is the output index to write buffer
+      sycl::local_accessor<int> local_tmp(sycl::range<1>(2), h);
+
+      h.parallel_for(sycl::nd_range(sycl::range<1>(grid) * sycl::range<1>(block),
+            sycl::range<1>(block)), [=](sycl::nd_item<1> item_ct1)
+      {
+        local_tmp[0] = 0;
+        int idx = item_ct1.get_global_linear_id();
+
+        bool finite_check, field_check;
+        bool combine_check;
+
+        if (idx < indices_size)
+        {
+          PointT xyz_point = in[input_indices[idx]];
+          finite_check = (cl::sycl::isfinite(xyz_point.x) && cl::sycl::isfinite(xyz_point.y) &&
+                           cl::sycl::isfinite(xyz_point.z));
+          if (is_empty) {
+            finite_check = !finite_check;
+          }
+
+          field_check = (xyz_point.data[const_filter_field_idx_] < const_filter_limit_min_) &&
+                           (xyz_point.data[const_filter_field_idx_] >= const_filter_limit_max_);
+
+          if (const_negative)
+            field_check = !field_check;
+
+          combine_check = !finite_check || field_check;
+        }
+
+        auto v = sycl::atomic_ref<int, sycl::memory_order::relaxed,
+                                      sycl::memory_scope::device,
+                                      sycl::access::address_space::global_space>(
+                                      sum_ptr[0]);
+
+        auto local_v = sycl::atomic_ref<int, sycl::memory_order::relaxed,
+                                      sycl::memory_scope::work_group,
+                                      sycl::access::address_space::local_space>(
+                                      local_tmp[0]);
+        item_ct1.barrier(sycl::access::fence_space::local_space);
+
+        int local_idx = 0;
+        if (idx < point_size)
+        {
+          if (combine_check)
+          {
+            local_idx = local_v.fetch_add(1);
+          }
+        }
+
+        item_ct1.barrier(sycl::access::fence_space::local_space);
+
+        if (idx < indices_size)
+        {
+          if (item_ct1.get_local_linear_id() == 0)
+          {
+            local_tmp[1] = v.fetch_add(local_tmp[0]);
+          }
+        }
+
+        item_ct1.barrier(sycl::access::fence_space::local_space);
+        if (idx < indices_size)
+        {
+          if (combine_check)
+          {
+            int out_idx = local_tmp[1] + local_idx;
+            out[out_idx] = input_indices[idx];
+          }
+        }
+      });
+    }).wait();
+
+    removed_indices_->create(removed_idx_no);
+    q.memcpy((*removed_indices_).ptr(), tmp_indices.ptr(), removed_idx_no).wait();
+  }
+}
+#define PCL_INSTANTIATE_OneAPI_PassThrough(T) template class PCL_EXPORTS pcl::oneapi::PassThrough<T>;
+
+#endif  // PCL_ONEAPI_FILTERS_IMPL_PASSTHROUGH_HPP_
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/statistical_outlier_removal.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/statistical_outlier_removal.hpp
new file mode 100644
index 000000000..fae6e83b2
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/statistical_outlier_removal.hpp
@@ -0,0 +1,160 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_FILTERS_IMPL_STATISTICAL_OUTLIER_REMOVAL_H_
+#define PCL_ONEAPI_FILTERS_IMPL_STATISTICAL_OUTLIER_REMOVAL_H_
+
+#include <pcl/oneapi/filters/statistical_outlier_removal.h>
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+pcl::oneapi::StatisticalOutlierRemoval<PointT>::setInputCloud(const PointCloudDevConstPtr &cloud)
+{
+  FilterIndices<PointT>::setInputCloud(cloud);
+
+  // Initialize the search class
+  if (!searcher_)
+  {
+    searcher_.reset(new pcl::oneapi::KdTreeFLANN<PointT>());
+  }
+
+  searcher_->setInputCloud(input_);
+}
+
+template <typename PointT> void
+pcl::oneapi::StatisticalOutlierRemoval<PointT>::setInputCloud(const PointCloudConstPtr &cloud)
+{
+  FilterIndices<PointT>::setInputCloud(cloud);
+
+  // Initialize the search class
+  if (!searcher_)
+  {
+    searcher_.reset(new pcl::oneapi::KdTreeFLANN<PointT>());
+  }
+
+  searcher_->setInputCloud(input_);
+}
+
+template <typename PointT> void
+pcl::oneapi::StatisticalOutlierRemoval<PointT>::applyFilterIndices(IndicesDev& indices)
+{
+  // The arrays to be used
+  Indices nn_indices (mean_k_);
+  std::vector<float> nn_dists (mean_k_);
+  std::vector<float> distances (indices_->size ());
+  indices.resize (indices_->size ());
+  removed_indices_->resize (indices_->size ());
+  int oii = 0, rii = 0;  // oii = output indices iterator, rii = removed indices iterator
+
+  //------------------------------
+  pcl::oneapi::DeviceArray2D<int> k_indices;
+  pcl::oneapi::DeviceArray2D<float> k_distances;
+
+  searcher_->nearestKSearch(input_, mean_k_ + 1, k_indices, k_distances);
+  int valid_distances = 0;
+  //------------------------------
+  // First pass: Compute the mean distances for all points with respect to their k
+  // nearest neighbors
+
+  for (int iii = 0; iii < static_cast<int>(indices_->size());
+       ++iii) // iii = input indices iterator
+  {
+    if (!std::isfinite((*input_)[(*indices_)[iii]].x) ||
+        !std::isfinite((*input_)[(*indices_)[iii]].y) ||
+        !std::isfinite((*input_)[(*indices_)[iii]].z)) {
+      distances[iii] = 0.0;
+      continue;
+    }
+
+    //// Perform the nearest k search
+    // if (searcher_->nearestKSearch ((*indices_)[iii], mean_k_ + 1, nn_indices,
+    // nn_dists) == 0)
+    //{
+    //   distances[iii] = 0.0;
+    //   PCL_WARN ("[pcl::%s::applyFilter] Searching for the closest %d neighbors
+    //   failed.\n", getClassName ().c_str (), mean_k_); continue;
+    // }
+
+    // Calculate the mean distance to its neighbors
+    double dist_sum = 0.0;
+    for (int k = 1; k < mean_k_ + 1; ++k) // k = 0 is the query point
+      dist_sum += sqrt(k_distances[iii][k]);
+    distances[iii] = static_cast<float>(dist_sum / mean_k_);
+    valid_distances++;
+  }
+
+  // Estimate the mean and the standard deviation of the distance vector
+  double sum = 0, sq_sum = 0;
+  for (const float &distance : distances)
+  {
+    sum += distance;
+    sq_sum += distance * distance;
+  }
+  double mean = sum / static_cast<double>(valid_distances);
+  double variance = (sq_sum - sum * sum / static_cast<double>(valid_distances)) / (static_cast<double>(valid_distances) - 1);
+  double stddev = sqrt (variance);
+  //getMeanStd (distances, mean, stddev);
+
+  double distance_threshold = mean + std_mul_ * stddev;
+
+  // Second pass: Classify the points on the computed distance threshold
+  for (int iii = 0; iii < static_cast<int> (indices_->size ()); ++iii)  // iii = input indices iterator
+  {
+    // Points having a too high average distance are outliers and are passed to removed indices
+    // Unless negative was set, then it's the opposite condition
+    if ((!negative_ && distances[iii] > distance_threshold) || (negative_ && distances[iii] <= distance_threshold))
+    {
+      if (extract_removed_indices_)
+        (*removed_indices_)[rii++] = (*indices_)[iii];
+      continue;
+    }
+
+    // Otherwise it was a normal point for output (inlier)
+    indices[oii++] = (*indices_)[iii];
+  }
+
+  // Resize the output arrays
+  indices.resize (oii);
+  removed_indices_->resize (rii);
+}
+
+#define PCL_INSTANTIATE_OneAPI_StatisticalOutlierRemoval(T) template class PCL_EXPORTS pcl::oneapi::StatisticalOutlierRemoval<T>;
+
+#endif  // PCL_ONEAPI_FILTERS_IMPL_STATISTICAL_OUTLIER_REMOVAL_H_
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/impl/voxel_grid.hpp b/oneapi/filters/include/pcl/oneapi/filters/impl/voxel_grid.hpp
new file mode 100644
index 000000000..899e45752
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/impl/voxel_grid.hpp
@@ -0,0 +1,417 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+#ifndef PCL_ONEAPI_FILTERS_IMPL_VOXEL_GRID_H_
+#define PCL_ONEAPI_FILTERS_IMPL_VOXEL_GRID_H_
+
+#include <pcl/oneapi/filters/voxel_grid.h>
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <pcl/common/common.h>
+#include <pcl/common/io.h>
+#include <tbb/tbb.h>
+
+#define DEBUG 0
+#define PERF 0
+
+#if PERF
+#include <chrono>
+using time_point = decltype(std::chrono::steady_clock::now());
+static inline time_point get_time_point() { return std::chrono::steady_clock::now(); }
+static inline double get_duration(const time_point& from, const time_point& to) {
+    return std::chrono::duration_cast<std::chrono::duration<double>>(to - from).count();
+}
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+pcl::oneapi::VoxelGrid<PointT>::applyFilter(PointCloudDev& output)
+{
+  bool has_field = !(filter_field_name_.empty());
+  const uint8_t const_filter_field_idx_ = filter_field_idx_;
+  const float const_filter_limit_min_ = filter_limit_min_;
+  const float const_filter_limit_max_ = filter_limit_max_;
+  const bool const_filter_limit_negative = filter_limit_negative_;
+
+#if PERF
+  auto t0 = get_time_point();
+#endif
+
+  // Step1, get the min/max boundary.
+  // find the min/max XYZ in the input cloud.
+
+#if 0 // cpu do it
+  sycl::float4 min_p(FLT_MAX);
+  sycl::float4 max_p(-FLT_MAX);
+  for (int i = 0; i < input_->size(); i++) {
+    min_p = sycl::min(min_p, input_->ptr()[i]);
+    max_p = sycl::max(max_p, input_->ptr()[i]);
+  }
+#else // gpu do it
+  DeviceArray<sycl::float4> min_vector;
+  DeviceArray<sycl::float4> max_vector;
+  int num_points = input_->size();
+  const int block_size = 16;
+  int num_thread = (num_points + block_size - 1) / block_size;
+  min_vector.create(num_thread);
+  max_vector.create(num_thread);
+
+  auto e = dpct::get_default_queue().submit([&](sycl::handler &h){
+    PointT* const in = const_cast<PointT *>(input_->points.ptr());
+    sycl::float4* const min = min_vector.ptr();
+    sycl::float4* const max = max_vector.ptr();
+    const int BZ = block_size;
+    const int TN = num_thread;
+
+    h.parallel_for(TN, [=](auto i){
+      sycl::float4 min_(FLT_MAX);
+      sycl::float4 max_(-FLT_MAX);
+      sycl::float4 point;
+      const PointT *point_xyz;
+      float point_field;
+      for (int index = 0; (index < BZ) && (i*BZ+index < num_points); index++) {
+        point_xyz = &(in[i * BZ + index]);
+        
+        if (has_field) {
+          point_field = point_xyz->data[const_filter_field_idx_];
+
+          if (const_filter_limit_negative) {
+            if ((point_field > const_filter_limit_min_) &&
+                (point_field < const_filter_limit_max_)) {
+                // if has field
+                // and the input is out of range, need to jump out
+                continue;
+            }
+          } else {
+            if((point_field < const_filter_limit_min_) ||
+               (point_field > const_filter_limit_max_)){
+                // if has field
+                // and the input is out of range, need to jump out
+                continue;
+            }
+          }
+        }
+        point = sycl::float4(point_xyz->x, point_xyz->y, point_xyz->z, 1);
+        min_ = sycl::min(min_, point);
+        max_ = sycl::max(max_, point);
+      }
+      min[i] = min_;
+      max[i] = max_;
+    });
+  });
+  e.wait();
+
+  sycl::float4 min_p(FLT_MAX);
+  sycl::float4 max_p(-FLT_MAX);
+  for (int i = 0; i < num_thread; i++) {
+    min_p = sycl::min(min_p, min_vector[i]);
+    max_p = sycl::max(max_p, max_vector[i]);
+  }
+#endif
+
+#if DEBUG // debug purpose
+  std::cout << "oneapi min p = " << min_p[0] << "," << min_p[1] << "," << min_p[2] << "," << min_p[3] << std::endl;
+  std::cout << "oneapi max p = " << max_p[0] << "," << max_p[1] << "," << max_p[2] << "," << max_p[3] << std::endl;
+#endif
+#if PERF
+  auto t1 = get_time_point();
+  auto time_usage = get_duration(t0, t1);
+  std::cout << "   1 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+
+
+  // step2
+  // calculate dx,dy,dz
+  // calculate min_b_,max_b_
+  // calculate div_b_
+  // calculate divb_mul_
+
+  // Check that the leaf size is not too small, given the size of the data
+  std::int64_t dx = static_cast<std::int64_t>((max_p[0] - min_p[0]) * inverse_leaf_size_[0])+1;
+  std::int64_t dy = static_cast<std::int64_t>((max_p[1] - min_p[1]) * inverse_leaf_size_[1])+1;
+  std::int64_t dz = static_cast<std::int64_t>((max_p[2] - min_p[2]) * inverse_leaf_size_[2])+1;
+
+  if ((dx*dy*dz) > static_cast<std::int64_t>(std::numeric_limits<std::int32_t>::max()))
+  {
+    PCL_WARN("[pcl::%s::applyFilter] Leaf size is too small for the input dataset. Integer indices would overflow.\n", getClassName().c_str());
+    output = *input_;
+    return;
+  }
+
+  // Compute the minimum and maximum bounding box values
+  min_b_[0] = static_cast<int> (std::floor (min_p[0] * inverse_leaf_size_[0]));
+  max_b_[0] = static_cast<int> (std::floor (max_p[0] * inverse_leaf_size_[0]));
+  min_b_[1] = static_cast<int> (std::floor (min_p[1] * inverse_leaf_size_[1]));
+  max_b_[1] = static_cast<int> (std::floor (max_p[1] * inverse_leaf_size_[1]));
+  min_b_[2] = static_cast<int> (std::floor (min_p[2] * inverse_leaf_size_[2]));
+  max_b_[2] = static_cast<int> (std::floor (max_p[2] * inverse_leaf_size_[2]));
+
+  // Compute the number of divisions needed along all axis
+  div_b_ = max_b_ - min_b_ + 1;
+  div_b_[3] = 0;
+
+  // Set up the division multiplier
+  divb_mul_ = sycl::int4({1, div_b_[0], div_b_[0] * div_b_[1], 0});
+
+#if DEBUG // debug purpose
+  std::cout << "oneapi dx,dy,dz = " << dx << "," << dy << "," << dz << std::endl;
+  std::cout << "oneapi min_b_ = " << min_b_[0] << "," << min_b_[1] << "," << min_b_[2] << std::endl;
+  std::cout << "oneapi max_b_ = " << max_b_[0] << "," << max_b_[1] << "," << max_b_[2] << std::endl;
+  std::cout << "oneapi div_b_ = " << div_b_[0] << "," << div_b_[1] << "," << div_b_[2] << std::endl;
+  std::cout << "oneapi divb_mul_ = " << divb_mul_[0] << "," << divb_mul_[1] << "," << divb_mul_[2] << std::endl;
+#endif
+#if PERF
+  auto t2 = get_time_point();
+  time_usage = get_duration(t1, t2);
+  std::cout << "   2 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+
+
+  // step3, push <voxel index, cloud index>
+  DeviceArray<sycl::int2> index_vector(num_points);
+  e = dpct::get_default_queue().submit([&](sycl::handler &h){
+
+    const int BZ = block_size;
+    const int TN = (num_points + block_size - 1) / block_size;
+    PointT* const in = const_cast<PointT *>(input_->points.ptr());
+    sycl::int2* out = index_vector.ptr();
+
+    const sycl::float4 const_inverse_leaf_size = inverse_leaf_size_;
+    const sycl::int4 const_min_b = min_b_;
+    const sycl::int4 const_divb_mul = divb_mul_;
+
+    h.parallel_for(TN, [=](auto i){
+      const PointT* point_xyz;
+      for (int index = 0; (index < BZ) && (i*BZ+index < num_points); index++) {
+        
+        int current_index = i*BZ+index;
+        point_xyz = &(in[current_index]);
+        if (!(sycl::isfinite(point_xyz->x) &&
+              sycl::isfinite(point_xyz->y) &&
+              sycl::isfinite(point_xyz->z)
+             )) {
+          out[current_index] = sycl::int2({INT_MAX, current_index}); // after sort, it will be at the begining
+          continue;
+        }
+
+        if (has_field) {
+          if (const_filter_limit_negative) {
+            if((point_xyz->data[const_filter_field_idx_] >= const_filter_limit_min_) &&
+               (point_xyz->data[const_filter_field_idx_] <= const_filter_limit_max_)){
+                // if has field
+                // and the input is out of range, need to jump out
+                out[current_index] = sycl::int2({INT_MAX, current_index}); // after sort, it will be at the begining
+                continue;
+            }
+          } else {
+            if((point_xyz->data[const_filter_field_idx_] < const_filter_limit_min_) ||
+               (point_xyz->data[const_filter_field_idx_] > const_filter_limit_max_)){
+                // if has field
+                // and the input is out of range, need to jump out
+                out[current_index] = sycl::int2({INT_MAX, current_index}); // after sort, it will be at the begining
+                continue;
+            }
+          }
+        }
+        int ijk0 = sycl::floor(point_xyz->x * const_inverse_leaf_size[0]) - const_min_b[0];
+        int ijk1 = sycl::floor(point_xyz->y * const_inverse_leaf_size[1]) - const_min_b[1];
+        int ijk2 = sycl::floor(point_xyz->z * const_inverse_leaf_size[2]) - const_min_b[2];
+
+        int voxel_index = ijk0 * const_divb_mul[0] + ijk1 * const_divb_mul[1] + ijk2 * const_divb_mul[2];
+
+        out[current_index] = sycl::int2({voxel_index, current_index});
+      }
+    });
+  });
+  e.wait();
+#if PERF
+  auto t3 = get_time_point();
+  time_usage = get_duration(t2, t3);
+  std::cout << "   3 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+
+  // step4, sort <voxel index, cloud index>
+  sycl::int2* index_vector_beg = index_vector.ptr();
+  sycl::int2* index_vector_end = index_vector_beg + index_vector.size();
+
+  // Second pass: sort the index_vector vector using value representing target cell as index
+  // in effect all points belonging to the same output cell will be next to each other
+  // #include <boost/sort/spreadsort/integer_sort.hpp>
+  // auto rightshift_func = [](const sycl::int2 &x, const unsigned offset) { return x[0] >> offset; };
+  // boost::sort::spreadsort::integer_sort(index_vector_beg, index_vector_end, rightshift_func, [](const sycl::int2& x1, const sycl::int2& x2){return x1[0] < x2[0];});
+
+#if 1
+  sycl::queue& q = dpct::get_default_queue();
+
+  if (q.get_device().is_gpu())
+  {
+    std::sort(dpl::execution::make_device_policy(q),
+    index_vector_beg, index_vector_end,
+    [](const sycl::int2& x1, const sycl::int2& x2){return x1[0] < x2[0];});
+  }
+  else
+  {
+    tbb::parallel_sort(//dpl::execution::make_device_policy(q),
+      index_vector_beg, index_vector_end,
+      [](const sycl::int2& x1, const sycl::int2& x2){return x1[0] < x2[0];});
+  }
+#else
+  // refer to https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneDPL/stable_sort_by_key
+  dpl::stable_sort(dpl::execution::dpcpp_default, index_vector_beg, index_vector_end, [](const sycl::int2& x1, const sycl::int2& x2){return x1[0] < x2[0];});
+#endif
+
+#if DEBUG
+  for (int i = 0; i < 10; i++) {
+    std::cout << "  i=" << i << ",index_vector = " << index_vector.ptr()[i][0] << "," << index_vector.ptr()[i][1] << std::endl;
+  }
+#endif
+#if PERF
+  auto t4 = get_time_point();
+  time_usage = get_duration(t3, t4);
+  std::cout << "   4 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+
+  // step5, first and last indice
+  // two ways to do it
+  // method 1. construct index_vector size, feed in
+  // method 2. calculate total first, and feed next.
+#if 1
+  // method 1. construct index_vector size, feed in
+  DeviceArray<sycl::int2> first_and_last_indices_vector(num_points);
+  int total = 0;
+  int index = 0;
+  while (index < num_points)
+  {
+    unsigned int i = index + 1;
+    while (i < num_points && index_vector[i][0] == index_vector[index][0])
+      ++i;
+    if (i - index >= min_points_per_voxel_)
+    {
+      first_and_last_indices_vector[total] = sycl::int2({index, i});
+      ++total;
+    }
+    index = i;
+  }
+#else
+  // method 2. calculate total first, and feed next.
+
+  std::vector<sycl::int2> temp_first_and_last_indices_vector;
+  temp_first_and_last_indices_vector.reserve (num_points);
+  int total = 0;
+  int index = 0;
+  while (index < num_points)
+  {
+    unsigned int i = index + 1;
+    while (i < num_points && index_vector[i][0] == index_vector[index][0])
+      ++i;
+    if (i - index >= min_points_per_voxel_)
+    {
+      temp_first_and_last_indices_vector.emplace_back(sycl::int2({index, i}));
+      ++total;
+    }
+    index = i;
+  }
+
+  DeviceArray<sycl::int2> first_and_last_indices_vector(total);
+  first_and_last_indices_vector.upload(temp_first_and_last_indices_vector.data(), total);
+#endif
+
+#if DEBUG
+  std::cout << "total = " << total << std::endl;
+  for (int i = 0; i < 5; i++) {
+    std::cout << "i = " << i << ", first/last = " << first_and_last_indices_vector[i][0] << "/" << first_and_last_indices_vector[i][1] << std::endl;
+  }
+#endif
+#if PERF
+  auto t5 = get_time_point();
+  time_usage = get_duration(t4, t5);
+  std::cout << "   5 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+
+  // step6, calculate the output[total]
+
+  // if there are nan data
+  if (index_vector[num_points - 1][0] == INT_MAX) {
+    // std::cout << "    there are nan points, removed it from the output" << std::endl;
+    total -= 1;
+  }
+
+  output.resize(total);
+
+  e = dpct::get_default_queue().submit([&](sycl::handler &h){
+    const sycl::int2* in_first_and_last = first_and_last_indices_vector.ptr();
+    const sycl::int2* in_index_vector = index_vector.ptr();
+    PointT* const in = const_cast<PointT *>(input_->points.ptr());
+    PointT* out = output.points.ptr();
+    const int TN = total;
+    h.parallel_for(TN, [=](auto i) {
+      sycl::int2 first_and_last = in_first_and_last[i];
+
+      sycl::float4 sum = sycl::float4({0.0f, 0.0f, 0.0f, 0.0f});
+      int num = 0;
+      const PointT* point_xyz;
+      for (int index = first_and_last[0]; index < first_and_last[1]; index++) {
+        // sum += in[in_index_vector[index][1]];
+        point_xyz = &(in[in_index_vector[index][1]]);
+        sum += sycl::float4(point_xyz->x, point_xyz->y, point_xyz->z, 1);
+        num += 1;
+      }
+      sum /= num;
+
+      // out[i] = sum;
+      out[i].x = sum.x();
+      out[i].y = sum.y();
+      out[i].z = sum.z();
+    });
+  });
+  e.wait();
+  output.height = 1;      // downsampling breaks the organized structure
+  output.is_dense = true; // we filter out invalid points
+  output.width = output.size();
+#if PERF
+  auto t6 = get_time_point();
+  time_usage = get_duration(t5, t6);
+  std::cout << "   6 time_usage = " << time_usage*1e3 << std::endl;
+#endif
+}
+
+#define PCL_INSTANTIATE_OneAPI_VoxelGrid(T) template class PCL_EXPORTS pcl::oneapi::VoxelGrid<T>;
+
+#endif    // PCL_ONEAPI_FILTERS_IMPL_VOXEL_GRID_H_
+
+
+
diff --git a/oneapi/filters/include/pcl/oneapi/filters/passthrough.h b/oneapi/filters/include/pcl/oneapi/filters/passthrough.h
new file mode 100644
index 000000000..4f791600d
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/passthrough.h
@@ -0,0 +1,245 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/filters/filter_indices.h>
+#include <cfloat> // for FLT_MIN, FLT_MAX
+#include <pcl/pcl_macros.h>
+
+#define FIELD_IDX_X 0U
+#define FIELD_IDX_Y 1U
+#define FIELD_IDX_Z 2U
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b PassThrough passes points in a cloud based on constraints for one particular field of the point type.
+    * \details Iterates through the entire input once, automatically filtering non-finite points and the points outside
+    * the interval specified by setFilterLimits(), which applies only to the field specified by setFilterFieldName().
+    * <br><br>
+    * Usage example:
+    * \code
+    * pcl::PassThrough<PointType> ptfilter (true); // Initializing with true will allow us to extract the removed indices
+    * ptfilter.setInputCloud (cloud_in);
+    * ptfilter.setFilterFieldName ("x");
+    * ptfilter.setFilterLimits (0.0, 1000.0);
+    * ptfilter.filter (*indices_x);
+    * // The indices_x array indexes all points of cloud_in that have x between 0.0 and 1000.0
+    * indices_rem = ptfilter.getRemovedIndices ();
+    * // The indices_rem array indexes all points of cloud_in that have x smaller than 0.0 or larger than 1000.0
+    * // and also indexes all non-finite points of cloud_in
+    * ptfilter.setIndices (indices_x);
+    * ptfilter.setFilterFieldName ("z");
+    * ptfilter.setFilterLimits (-10.0, 10.0);
+    * ptfilter.setNegative (true);
+    * ptfilter.filter (*indices_xz);
+    * // The indices_xz array indexes all points of cloud_in that have x between 0.0 and 1000.0 and z larger than 10.0 or smaller than -10.0
+    * ptfilter.setIndices (indices_xz);
+    * ptfilter.setFilterFieldName ("intensity");
+    * ptfilter.setFilterLimits (FLT_MIN, 0.5);
+    * ptfilter.setNegative (false);
+    * ptfilter.filter (*cloud_out);
+    * // The resulting cloud_out contains all points of cloud_in that are finite and have:
+    * // x between 0.0 and 1000.0, z larger than 10.0 or smaller than -10.0 and intensity smaller than 0.5.
+    * \endcode
+    * \author Radu Bogdan Rusu
+    * \ingroup filters
+    */
+  template <typename PointT>
+  class PassThrough : public FilterIndices<PointT>
+  {
+    protected:
+      using PointCloud = typename FilterIndices<PointT>::PointCloud;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+      using PointCloudDev = typename FilterIndices<PointT>::PointCloudDev;
+      using PointCloudDevPtr = typename PointCloudDev::Ptr;
+      using FieldList = typename pcl::traits::fieldList<PointT>::type;
+
+    public:
+
+      using Ptr = shared_ptr<PassThrough<PointT> >;
+      using ConstPtr = shared_ptr<const PassThrough<PointT> >;
+
+
+      /** \brief Constructor.
+        * \param[in] extract_removed_indices Set to true if you want to be able to extract the indices of points being removed (default = false).
+        */
+      PassThrough (bool extract_removed_indices = false) :
+        FilterIndices<PointT> (extract_removed_indices),
+        filter_field_name_ (""),
+        filter_field_idx_(0),
+        filter_limit_min_ (FLT_MIN),
+        filter_limit_max_ (FLT_MAX)
+      {
+        filter_name_ = "PassThrough";
+      }
+
+      /** \brief Provide the name of the field to be used for filtering data.
+        * \details In conjunction with setFilterLimits(), points having values outside this interval for this field will be discarded.
+        * \param[in] field_name The name of the field that will be used for filtering.
+        */
+      inline void
+      setFilterFieldName (const std::string &field_name)
+      {
+        filter_field_name_ = field_name;
+        if (filter_field_name_ == "x")
+        {
+          filter_field_idx_ = FIELD_IDX_X;
+        }
+        else if (filter_field_name_ == "y")
+        {
+          filter_field_idx_ = FIELD_IDX_Y;
+        }
+        else if (filter_field_name_ == "z")
+        {
+          filter_field_idx_ = FIELD_IDX_Z;
+        }
+      }
+
+      /** \brief Retrieve the name of the field to be used for filtering data.
+        * \return The name of the field that will be used for filtering.
+        */
+      inline std::string const
+      getFilterFieldName () const
+      {
+        return (filter_field_name_);
+      }
+
+      /** \brief Set the numerical limits for the field for filtering data.
+        * \details In conjunction with setFilterFieldName(), points having values outside this interval for this field will be discarded.
+        * \param[in] limit_min The minimum allowed field value (default = FLT_MIN).
+        * \param[in] limit_max The maximum allowed field value (default = FLT_MAX).
+        */
+      inline void
+      setFilterLimits (const float &limit_min, const float &limit_max)
+      {
+        filter_limit_min_ = limit_min;
+        filter_limit_max_ = limit_max;
+      }
+
+      /** \brief Get the numerical limits for the field for filtering data.
+        * \param[out] limit_min The minimum allowed field value (default = FLT_MIN).
+        * \param[out] limit_max The maximum allowed field value (default = FLT_MAX).
+        */
+      inline void
+      getFilterLimits (float &limit_min, float &limit_max) const
+      {
+        limit_min = filter_limit_min_;
+        limit_max = filter_limit_max_;
+      }
+
+      /** \brief Set to true if we want to return the data outside the interval specified by setFilterLimits (min, max)
+        * Default: false.
+        * \warning This method will be removed in the future. Use setNegative() instead.
+        * \param[in] limit_negative return data inside the interval (false) or outside (true)
+        */
+      inline void
+      setFilterLimitsNegative (const bool limit_negative)
+      {
+        negative_ = limit_negative;
+      }
+
+      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false).
+        * \warning This method will be removed in the future. Use getNegative() instead.
+        * \param[out] limit_negative true if data \b outside the interval [min; max] is to be returned, false otherwise
+        */
+      inline void
+      getFilterLimitsNegative (bool &limit_negative) const
+      {
+        limit_negative = negative_;
+      }
+
+      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false).
+        * \warning This method will be removed in the future. Use getNegative() instead.
+        * \return true if data \b outside the interval [min; max] is to be returned, false otherwise
+        */
+      inline bool
+      getFilterLimitsNegative () const
+      {
+        return (negative_);
+      }
+
+    protected:
+      using PCLBase<PointT>::input_;
+      using PCLBase<PointT>::indices_;
+      using Filter<PointT>::filter_name_;
+      using Filter<PointT>::getClassName;
+      using FilterIndices<PointT>::negative_;
+      using FilterIndices<PointT>::extract_removed_indices_;
+      using FilterIndices<PointT>::removed_indices_;
+
+      /** \brief Filtered results are indexed by an indices array.
+        * \param[out] indices The resultant indices.
+        */
+      void
+      applyFilter (IndicesDev &indices) override{}
+
+      // /** \brief Filtered results are indexed by an indices array.
+        // * \param[out] indices The resultant indices.
+        // */
+      // void
+      // applyFilterIndices (Indices &indices);
+
+      /** \brief Downsample a Point Cloud using a voxelized grid approach
+        * \param[out] output the resultant point cloud message
+        */
+      void
+      applyFilter (PointCloudDev &output) override;
+
+    private:
+      /** \brief The name of the field that will be used for filtering. */
+      std::string filter_field_name_;
+      std::uint8_t filter_field_idx_;
+
+      /** \brief The minimum allowed field value (default = FLT_MIN). */
+      float filter_limit_min_;
+
+      /** \brief The maximum allowed field value (default = FLT_MIN). */
+      float filter_limit_max_;
+  };
+
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/passthrough.hpp>
+#endif
diff --git a/oneapi/filters/include/pcl/oneapi/filters/statistical_outlier_removal.h b/oneapi/filters/include/pcl/oneapi/filters/statistical_outlier_removal.h
new file mode 100644
index 000000000..55c707332
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/statistical_outlier_removal.h
@@ -0,0 +1,206 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#include <pcl/oneapi/filters/filter_indices.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b StatisticalOutlierRemoval uses point neighborhood statistics to filter outlier data.
+    * \details The algorithm iterates through the entire input twice:
+    * During the first iteration it will compute the average distance that each point has to its nearest k neighbors.
+    * The value of k can be set using setMeanK().
+    * Next, the mean and standard deviation of all these distances are computed in order to determine a distance threshold.
+    * The distance threshold will be equal to: mean + stddev_mult * stddev.
+    * The multiplier for the standard deviation can be set using setStddevMulThresh().
+    * During the next iteration the points will be classified as inlier or outlier if their average neighbor distance is below or above this threshold respectively.
+    * <br>
+    * The neighbors found for each query point will be found amongst ALL points of setInputCloud(), not just those indexed by setIndices().
+    * The setIndices() method only indexes the points that will be iterated through as search query points.
+    * <br><br>
+    * For more information:
+    *   - R. B. Rusu, Z. C. Marton, N. Blodow, M. Dolha, and M. Beetz.
+    *     Towards 3D Point Cloud Based Object Maps for Household Environments
+    *     Robotics and Autonomous Systems Journal (Special Issue on Semantic Knowledge), 2008.
+    * <br><br>
+    * Usage example:
+    * \code
+    * pcl::StatisticalOutlierRemoval<PointType> sorfilter (true); // Initializing with true will allow us to extract the removed indices
+    * sorfilter.setInputCloud (cloud_in);
+    * sorfilter.setMeanK (8);
+    * sorfilter.setStddevMulThresh (1.0);
+    * sorfilter.filter (*cloud_out);
+    * // The resulting cloud_out contains all points of cloud_in that have an average distance to their 8 nearest neighbors that is below the computed threshold
+    * // Using a standard deviation multiplier of 1.0 and assuming the average distances are normally distributed there is a 84.1% chance that a point will be an inlier
+    * indices_rem = sorfilter.getRemovedIndices ();
+    * // The indices_rem array indexes all points of cloud_in that are outliers
+    * \endcode
+    * \author Radu Bogdan Rusu
+    * \ingroup filters
+    */
+  template<typename PointT>
+  class StatisticalOutlierRemoval : public FilterIndices<PointT>
+  {
+    protected:
+      using PointCloud = typename FilterIndices<PointT>::PointCloud;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+      using PointCloudDev = typename FilterIndices<PointT>::PointCloudDev;
+      using PointCloudDevPtr = typename PointCloudDev::Ptr;
+      using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+      using SearcherPtr = typename pcl::oneapi::KdTreeFLANN<PointT>::Ptr;
+
+    public:
+
+      using Ptr = shared_ptr<StatisticalOutlierRemoval<PointT> >;
+      using ConstPtr = shared_ptr<const StatisticalOutlierRemoval<PointT> >;
+
+
+      /** \brief Constructor.
+        * \param[in] extract_removed_indices Set to true if you want to be able to extract the indices of points being removed (default = false).
+        */
+      StatisticalOutlierRemoval (bool extract_removed_indices = false) :
+        FilterIndices<PointT> (extract_removed_indices),
+        searcher_ (),
+        mean_k_ (1),
+        std_mul_ (0.0)
+      {
+        filter_name_ = "StatisticalOutlierRemoval";
+      }
+
+      /** \brief Set the number of nearest neighbors to use for mean distance estimation.
+        * \param[in] nr_k The number of points to use for mean distance estimation.
+        */
+      inline void
+      setMeanK (int nr_k)
+      {
+        mean_k_ = nr_k;
+      }
+
+      /** \brief Get the number of nearest neighbors to use for mean distance estimation.
+        * \return The number of points to use for mean distance estimation.
+        */
+      inline int
+      getMeanK ()
+      {
+        return (mean_k_);
+      }
+
+      /** \brief Set the standard deviation multiplier for the distance threshold calculation.
+        * \details The distance threshold will be equal to: mean + stddev_mult * stddev.
+        * Points will be classified as inlier or outlier if their average neighbor distance is below or above this threshold respectively.
+        * \param[in] stddev_mult The standard deviation multiplier.
+        */
+      inline void
+      setStddevMulThresh (double stddev_mult)
+      {
+        std_mul_ = stddev_mult;
+      }
+
+      /** \brief Get the standard deviation multiplier for the distance threshold calculation.
+        * \details The distance threshold will be equal to: mean + stddev_mult * stddev.
+        * Points will be classified as inlier or outlier if their average neighbor distance is below or above this threshold respectively.
+        */
+      inline double
+      getStddevMulThresh ()
+      {
+        return (std_mul_);
+      }
+
+      /** \brief Provide a pointer to the input dataset
+        * \param[in] cloud the const boost shared pointer to a PointCloud message
+        */
+      void
+      setInputCloud (const PointCloudDevConstPtr &cloud) override;
+
+      /** \brief Provide a pointer to the input dataset
+        * \param[in] cloud the const boost shared pointer to a PointCloud message
+        */
+      void
+      setInputCloud (const PointCloudConstPtr &cloud) override;
+
+    protected:
+      using PCLBase<PointT>::input_;
+      using PCLBase<PointT>::indices_;
+      using pcl::oneapi::Filter<PointT>::filter_name_;
+      using pcl::oneapi::Filter<PointT>::getClassName;
+      using pcl::oneapi::FilterIndices<PointT>::negative_;
+      using pcl::oneapi::FilterIndices<PointT>::keep_organized_;
+      using pcl::oneapi::FilterIndices<PointT>::user_filter_value_;
+      using pcl::oneapi::FilterIndices<PointT>::extract_removed_indices_;
+      using pcl::oneapi::FilterIndices<PointT>::removed_indices_;
+
+      /** \brief Filtered results are indexed by an indices array.
+        * \param[out] indices The resultant indices.
+        */
+      void
+      applyFilter(IndicesDev& indices) override
+      {
+        applyFilterIndices (indices);
+      }
+
+      /** \brief Filtered results are indexed by an indices array.
+        * \param[out] indices The resultant indices.
+        */
+      void
+      applyFilterIndices(IndicesDev& indices);
+
+    private:
+      /** \brief A pointer to the spatial search object. */
+      SearcherPtr searcher_;
+
+      /** \brief The number of points to use for mean distance estimation. */
+      int mean_k_;
+
+      /** \brief Standard deviations threshold (i.e., points outside of 
+        * \f$ \mu \pm \sigma \cdot std\_mul \f$ will be marked as outliers). */
+      double std_mul_;
+
+  };
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/statistical_outlier_removal.hpp>
+#endif
diff --git a/oneapi/filters/include/pcl/oneapi/filters/voxel_grid.h b/oneapi/filters/include/pcl/oneapi/filters/voxel_grid.h
new file mode 100644
index 000000000..f55a10641
--- /dev/null
+++ b/oneapi/filters/include/pcl/oneapi/filters/voxel_grid.h
@@ -0,0 +1,423 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/filters/filter.h>
+#include <cfloat> // for FLT_MAX
+
+namespace pcl
+{
+  namespace oneapi{
+
+  /** \brief Get the minimum and maximum values on each of the 3 (x-y-z) dimensions
+    * in a given pointcloud, without considering points outside of a distance threshold from the laser origin
+    * \param[in] cloud the point cloud data message
+    * \param[in] indices the vector of indices to use
+    * \param[in] distance_field_name the field name that contains the distance values
+    * \param[in] min_distance the minimum distance a point will be considered from
+    * \param[in] max_distance the maximum distance a point will be considered to
+    * \param[out] min_pt the resultant minimum bounds
+    * \param[out] max_pt the resultant maximum bounds
+    * \param[in] limit_negative if set to true, then all points outside of the interval (min_distance;max_distace) are considered
+    * \ingroup filters
+    */
+  template <typename PointT> void
+  getMinMax3D (const typename pcl::PointCloud<PointT>::ConstPtr &cloud,
+               const Indices &indices,
+               const std::string &distance_field_name, float min_distance, float max_distance,
+               Eigen::Vector4f &min_pt, Eigen::Vector4f &max_pt, bool limit_negative = false);
+
+  /** \brief VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.
+    *
+    * The VoxelGrid class creates a *3D voxel grid* (think about a voxel
+    * grid as a set of tiny 3D boxes in space) over the input point cloud data.
+    * Then, in each *voxel* (i.e., 3D box), all the points present will be
+    * approximated (i.e., *downsampled*) with their centroid. This approach is
+    * a bit slower than approximating them with the center of the voxel, but it
+    * represents the underlying surface more accurately.
+    *
+    * \author Radu B. Rusu, Bastian Steder
+    * \ingroup filters
+    */
+  template <typename PointT>
+  class VoxelGrid: public Filter<PointT>
+  {
+    protected:
+      using Filter<PointT>::input_;
+      using Filter<PointT>::indices_;
+      using Filter<PointT>::filter_name_;
+      using Filter<PointT>::getClassName;
+
+    public:
+
+      using PointCloud = typename Filter<PointT>::PointCloud;
+      using PointCloudDev = typename Filter<PointT>::PointCloudDev;
+      using Ptr = shared_ptr<VoxelGrid<PointT>>;
+      using ConstPtr = shared_ptr<const VoxelGrid<PointT>>;
+
+      /** \brief Empty constructor. */
+      VoxelGrid () :
+        leaf_size_ ({0.0f,0.0f,0.0f,0.0f}),
+        inverse_leaf_size_ ({0.0f,0.0f,0.0f,0.0f}),
+        downsample_all_data_ (true),
+        save_leaf_layout_ (false),
+        leaf_layout_({}),
+        min_b_ ({0,0,0,0}),
+        max_b_ ({0,0,0,0}),
+        div_b_ ({0,0,0,0}),
+        divb_mul_ ({0,0,0,0}),
+        filter_field_name_ (""),
+        filter_field_idx_(0),
+        filter_limit_min_ (-FLT_MAX),
+        filter_limit_max_ (FLT_MAX),
+        filter_limit_negative_ (false),
+        min_points_per_voxel_ (0)
+      {
+        filter_name_ = "VoxelGrid";
+      }
+
+      /** \brief Destructor. */
+      ~VoxelGrid ()
+      {
+      }
+
+      /** \brief Set the voxel grid leaf size.
+        * \param[in] leaf_size the voxel grid leaf size
+        */
+      inline void
+      setLeafSize (const sycl::float4 &leaf_size)
+      {
+        leaf_size_ = leaf_size;
+        // Avoid division errors
+        if (leaf_size_[3] == 0)
+          leaf_size_[3] = 1;
+        // Use multiplications instead of divisions
+        inverse_leaf_size_ = sycl::float4(1.0f) / leaf_size_;
+      }
+
+      /** \brief Set the voxel grid leaf size.
+        * \param[in] lx the leaf size for X
+        * \param[in] ly the leaf size for Y
+        * \param[in] lz the leaf size for Z
+        */
+      inline void
+      setLeafSize (float lx, float ly, float lz)
+      {
+        leaf_size_[0] = lx; leaf_size_[1] = ly; leaf_size_[2] = lz;
+        // Avoid division errors
+        if (leaf_size_[3] == 0)
+          leaf_size_[3] = 1;
+        // Use multiplications instead of divisions
+        inverse_leaf_size_ = sycl::float4(1.0f) / leaf_size_;
+      }
+
+      /** \brief Get the voxel grid leaf size. */
+      inline sycl::float3
+      getLeafSize () const { return sycl::float3(leaf_size_[0],leaf_size_[1],leaf_size_[2]); }
+
+      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ.
+        * \param[in] downsample the new value (true/false)
+        */
+      inline void
+      setDownsampleAllData (bool downsample) { downsample_all_data_ = downsample; }
+
+      /** \brief Get the state of the internal downsampling parameter (true if
+        * all fields need to be downsampled, false if just XYZ).
+        */
+      inline bool
+      getDownsampleAllData () const { return (downsample_all_data_); }
+
+      /** \brief Set the minimum number of points required for a voxel to be used.
+        * \param[in] min_points_per_voxel the minimum number of points for required for a voxel to be used
+        */
+      inline void
+      setMinimumPointsNumberPerVoxel (unsigned int min_points_per_voxel) { min_points_per_voxel_ = min_points_per_voxel; }
+
+      /** \brief Return the minimum number of points required for a voxel to be used.
+       */
+      inline unsigned int
+      getMinimumPointsNumberPerVoxel () const { return min_points_per_voxel_; }
+
+      /** \brief Set to true if leaf layout information needs to be saved for later access.
+        * \param[in] save_leaf_layout the new value (true/false)
+        */
+      inline void
+      setSaveLeafLayout (bool save_leaf_layout) { save_leaf_layout_ = save_leaf_layout; }
+
+      /** \brief Returns true if leaf layout information will to be saved for later access. */
+      inline bool
+      getSaveLeafLayout () const { return (save_leaf_layout_); }
+
+      /** \brief Get the minimum coordinates of the bounding box (after
+        * filtering is performed).
+        */
+      inline sycl::int3
+      getMinBoxCoordinates () const { return sycl::int3(min_b_[0],min_b_[1],min_b_[2]); }
+
+#if 0
+      /** \brief Get the minimum coordinates of the bounding box (after
+        * filtering is performed).
+        */
+      inline Eigen::Vector3i
+      getMaxBoxCoordinates () const { return (max_b_.head<3> ()); }
+
+      /** \brief Get the number of divisions along all 3 axes (after filtering
+        * is performed).
+        */
+      inline Eigen::Vector3i
+      getNrDivisions () const { return (div_b_.head<3> ()); }
+
+      /** \brief Get the multipliers to be applied to the grid coordinates in
+        * order to find the centroid index (after filtering is performed).
+        */
+      inline Eigen::Vector3i
+      getDivisionMultiplier () const { return (divb_mul_.head<3> ()); }
+
+      /** \brief Returns the index in the resulting downsampled cloud of the specified point.
+        *
+        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering
+        * performed, and that the point is inside the grid, to avoid invalid access (or use
+        * getGridCoordinates+getCentroidIndexAt)
+        *
+        * \param[in] p the point to get the index at
+        */
+      inline int
+      getCentroidIndex (const PointT &p) const
+      {
+        return (leaf_layout_.at ((Eigen::Vector4i (static_cast<int> (std::floor (p.x * inverse_leaf_size_[0])),
+                                                   static_cast<int> (std::floor (p.y * inverse_leaf_size_[1])),
+                                                   static_cast<int> (std::floor (p.z * inverse_leaf_size_[2])), 0) - min_b_).dot (divb_mul_)));
+      }
+
+      /** \brief Returns the indices in the resulting downsampled cloud of the points at the specified grid coordinates,
+        * relative to the grid coordinates of the specified point (or -1 if the cell was empty/out of bounds).
+        * \param[in] reference_point the coordinates of the reference point (corresponding cell is allowed to be empty/out of bounds)
+        * \param[in] relative_coordinates matrix with the columns being the coordinates of the requested cells, relative to the reference point's cell
+        * \note for efficiency, user must make sure that the saving of the leaf layout is enabled and filtering performed
+        */
+      inline std::vector<int>
+      getNeighborCentroidIndices (const PointT &reference_point, const Eigen::MatrixXi &relative_coordinates) const
+      {
+        Eigen::Vector4i ijk (static_cast<int> (std::floor (reference_point.x * inverse_leaf_size_[0])),
+                             static_cast<int> (std::floor (reference_point.y * inverse_leaf_size_[1])),
+                             static_cast<int> (std::floor (reference_point.z * inverse_leaf_size_[2])), 0);
+        Eigen::Array4i diff2min = min_b_ - ijk;
+        Eigen::Array4i diff2max = max_b_ - ijk;
+        std::vector<int> neighbors (relative_coordinates.cols());
+        for (Eigen::Index ni = 0; ni < relative_coordinates.cols (); ni++)
+        {
+          Eigen::Vector4i displacement = (Eigen::Vector4i() << relative_coordinates.col(ni), 0).finished();
+          // checking if the specified cell is in the grid
+          if ((diff2min <= displacement.array()).all() && (diff2max >= displacement.array()).all())
+            neighbors[ni] = leaf_layout_[((ijk + displacement - min_b_).dot (divb_mul_))]; // .at() can be omitted
+          else
+            neighbors[ni] = -1; // cell is out of bounds, consider it empty
+        }
+        return (neighbors);
+      }
+
+      /** \brief Returns the layout of the leafs for fast access to cells relative to current position.
+        * \note position at (i-min_x) + (j-min_y)*div_x + (k-min_z)*div_x*div_y holds the index of the element at coordinates (i,j,k) in the grid (-1 if empty)
+        */
+      inline std::vector<int>
+      getLeafLayout () const { return (leaf_layout_); }
+
+      /** \brief Returns the corresponding (i,j,k) coordinates in the grid of point (x,y,z).
+        * \param[in] x the X point coordinate to get the (i, j, k) index at
+        * \param[in] y the Y point coordinate to get the (i, j, k) index at
+        * \param[in] z the Z point coordinate to get the (i, j, k) index at
+        */
+      inline Eigen::Vector3i
+      getGridCoordinates (float x, float y, float z) const
+      {
+        return (Eigen::Vector3i (static_cast<int> (std::floor (x * inverse_leaf_size_[0])),
+                                 static_cast<int> (std::floor (y * inverse_leaf_size_[1])),
+                                 static_cast<int> (std::floor (z * inverse_leaf_size_[2]))));
+      }
+
+      /** \brief Returns the index in the downsampled cloud corresponding to a given set of coordinates.
+        * \param[in] ijk the coordinates (i,j,k) in the grid (-1 if empty)
+        */
+      inline int
+      getCentroidIndexAt (const Eigen::Vector3i &ijk) const
+      {
+        int idx = ((Eigen::Vector4i() << ijk, 0).finished() - min_b_).dot (divb_mul_);
+        if (idx < 0 || idx >= static_cast<int> (leaf_layout_.size ())) // this checks also if leaf_layout_.size () == 0 i.e. everything was computed as needed
+        {
+          //if (verbose)
+          //  PCL_ERROR ("[pcl::%s::getCentroidIndexAt] Specified coordinate is outside grid bounds, or leaf layout is not saved, make sure to call setSaveLeafLayout(true) and filter(output) first!\n", getClassName ().c_str ());
+          return (-1);
+        }
+        return (leaf_layout_[idx]);
+      }
+#endif
+
+      /** \brief Provide the name of the field to be used for filtering data. In conjunction with  \a setFilterLimits,
+        * points having values outside this interval will be discarded.
+        * \param[in] field_name the name of the field that contains values used for filtering
+        */
+      inline void
+      setFilterFieldName (const std::string &field_name)
+      {
+        if (field_name == "x")
+          filter_field_idx_ = 0;
+        else if (field_name == "y")
+          filter_field_idx_ = 1;
+        else if (field_name == "z")
+          filter_field_idx_ = 2;
+        else {
+          std::cout << "oneapi notice: only support x/y/z field name" << std::endl;
+          return;
+        }
+        filter_field_name_ = field_name;
+      }
+
+      /** \brief Get the name of the field used for filtering. */
+      inline std::string const
+      getFilterFieldName () const
+      {
+        return (filter_field_name_);
+      }
+
+      /** \brief Set the field filter limits. All points having field values outside this interval will be discarded.
+        * \param[in] limit_min the minimum allowed field value
+        * \param[in] limit_max the maximum allowed field value
+        */
+      inline void
+      setFilterLimits (const double &limit_min, const double &limit_max)
+      {
+        filter_limit_min_ = limit_min;
+        filter_limit_max_ = limit_max;
+      }
+
+      /** \brief Get the field filter limits (min/max) set by the user. The default values are -FLT_MAX, FLT_MAX.
+        * \param[out] limit_min the minimum allowed field value
+        * \param[out] limit_max the maximum allowed field value
+        */
+      inline void
+      getFilterLimits (double &limit_min, double &limit_max) const
+      {
+        limit_min = filter_limit_min_;
+        limit_max = filter_limit_max_;
+      }
+
+      /** \brief Set to true if we want to return the data outside the interval specified by setFilterLimits (min, max).
+        * Default: false.
+        * \param[in] limit_negative return data inside the interval (false) or outside (true)
+        */
+      inline void
+      setFilterLimitsNegative (const bool limit_negative)
+      {
+        filter_limit_negative_ = limit_negative;
+      }
+
+      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false).
+        * \param[out] limit_negative true if data \b outside the interval [min; max] is to be returned, false otherwise
+        */
+      PCL_DEPRECATED(1, 16, "use bool getFilterLimitsNegative() instead")
+      inline void
+      getFilterLimitsNegative (bool &limit_negative) const
+      {
+        limit_negative = filter_limit_negative_;
+      }
+
+      /** \brief Get whether the data outside the interval (min/max) is to be returned (true) or inside (false).
+        * \return true if data \b outside the interval [min; max] is to be returned, false otherwise
+        */
+      inline bool
+      getFilterLimitsNegative () const
+      {
+        return (filter_limit_negative_);
+      }
+
+    protected:
+      /** \brief The size of a leaf. */
+      // Eigen::Vector4f leaf_size_;
+      sycl::float4 leaf_size_;
+
+      /** \brief Internal leaf sizes stored as 1/leaf_size_ for efficiency reasons. */
+      // Eigen::Array4f inverse_leaf_size_;
+      sycl::float4 inverse_leaf_size_;
+
+      /** \brief Set to true if all fields need to be downsampled, or false if just XYZ. */
+      bool downsample_all_data_;
+
+      /** \brief Set to true if leaf layout information needs to be saved in \a leaf_layout_. */
+      bool save_leaf_layout_;
+
+      /** \brief The leaf layout information for fast access to cells relative to current position **/
+      std::vector<int> leaf_layout_;
+
+      /** \brief The minimum and maximum bin coordinates, the number of divisions, and the division multiplier. */
+      // Eigen::Vector4i min_b_, max_b_, div_b_, divb_mul_;
+      sycl::int4 min_b_, max_b_, div_b_, divb_mul_;
+
+      /** \brief The desired user filter field name. */
+      std::string filter_field_name_;
+      std::uint8_t filter_field_idx_;
+
+      /** \brief The minimum allowed filter value a point will be considered from. */
+      double filter_limit_min_;
+
+      /** \brief The maximum allowed filter value a point will be considered from. */
+      double filter_limit_max_;
+
+      /** \brief Set to true if we want to return the data outside (\a filter_limit_min_;\a filter_limit_max_). Default: false. */
+      bool filter_limit_negative_;
+
+      /** \brief Minimum number of points per voxel for the centroid to be computed */
+      unsigned int min_points_per_voxel_;
+
+      // using FieldList = typename pcl::traits::fieldList<PointT>::type;
+
+      /** \brief Downsample a Point Cloud using a voxelized grid approach
+        * \param[out] output the resultant point cloud message
+        */
+      void
+      applyFilter (PointCloudDev &output) override;
+  };
+
+
+  } // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/filters/impl/voxel_grid.hpp>
+#endif
\ No newline at end of file
diff --git a/oneapi/filters/src/extract_indices.cpp b/oneapi/filters/src/extract_indices.cpp
new file mode 100644
index 000000000..5b19029a7
--- /dev/null
+++ b/oneapi/filters/src/extract_indices.cpp
@@ -0,0 +1,221 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/filters/impl/extract_indices.hpp>
+
+namespace pcl
+{
+namespace oneapi
+{
+
+///////////////////////////////////////////////////////////////////////////////////////////
+void
+ExtractIndices<pcl::oneapi::PCLPointCloud2>::applyFilter (PCLPointCloud2 &output)
+{
+  if (keep_organized_)
+  {
+    output = *input_;
+    if (negative_)
+    {
+      // Prepare the output and copy the data
+      for (std::size_t i = 0; i < indices_->size (); ++i)
+        for (std::size_t j = 0; j < output.fields.size(); ++j)
+          memcpy (&output.data[(*indices_)[i] * output.point_step + output.fields[j].offset],
+                  &user_filter_value_, sizeof(float));
+    }
+    else
+    {
+      // Prepare a vector holding all indices
+      IndicesDev all_indices (input_->width * input_->height);
+      for (index_t i = 0; i < static_cast<index_t>(all_indices.size ()); ++i)
+        all_indices[i] = i;
+
+      IndicesDev indices = *indices_;
+      std::sort (indices.begin (), indices.end ());
+
+      // Get the diference
+      IndicesDev remaining_indices;
+     // set_difference (all_indices.begin (), all_indices.end (), indices.begin (), indices.end (),
+     //                 inserter (remaining_indices, remaining_indices.begin ()));
+
+      // Prepare the output and copy the data
+      for (const auto &remaining_index : remaining_indices)
+        for (std::size_t j = 0; j < output.fields.size(); ++j)
+          memcpy (&output.data[remaining_index * output.point_step + output.fields[j].offset],
+                  &user_filter_value_, sizeof(float));
+    }
+    if (!std::isfinite (user_filter_value_))
+      output.is_dense = false;
+    return;
+  }
+  if (indices_->empty () || (input_->width * input_->height == 0))
+  {
+    output.width = output.height = 0;
+    output.data.clear ();
+    // If negative, copy all the data
+    if (negative_)
+      output = *input_;
+    return;
+  }
+  if (indices_->size () == (input_->width * input_->height))
+  {
+    // If negative, then return an empty cloud
+    if (negative_)
+    {
+      output.width = output.height = 0;
+      output.data.clear ();
+    }
+    // else, we need to return all points
+    else
+      output = *input_;
+    return;
+  }
+
+  // Copy the common fields (header and fields should have already been copied)
+  output.is_bigendian = input_->is_bigendian;
+  output.point_step   = input_->point_step;
+  output.height       = 1;
+  // TODO: check the output cloud and assign is_dense based on whether the points are valid or not
+  output.is_dense     = false;
+
+  if (negative_)
+  {
+    // Prepare a vector holding all indices
+    IndicesDev all_indices (input_->width * input_->height);
+    for (index_t i = 0; i < static_cast<index_t>(all_indices.size ()); ++i)
+      all_indices[i] = i;
+
+    IndicesDev indices = *indices_;
+    std::sort (indices.begin (), indices.end ());
+
+    // Get the diference
+    IndicesDev remaining_indices;
+//    set_difference (all_indices.begin (), all_indices.end (), indices.begin (), indices.end (),
+//                    inserter (remaining_indices, remaining_indices.begin ()));
+
+    // Prepare the output and copy the data
+    output.width = remaining_indices.size ();
+    output.data.resize (remaining_indices.size () * output.point_step);
+    for (std::size_t i = 0; i < remaining_indices.size (); ++i)
+      memcpy (&output.data[i * output.point_step], &input_->data[remaining_indices[i] * output.point_step], output.point_step);
+  }
+  else
+  {
+    // Prepare the output and copy the data
+    output.width = indices_->size ();
+    output.data.resize (indices_->size () * output.point_step);
+    for (std::size_t i = 0; i < indices_->size (); ++i)
+      memcpy (&output.data[i * output.point_step], &input_->data[(*indices_)[i] * output.point_step], output.point_step);
+  }
+  output.row_step = output.point_step * output.width;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+void
+ExtractIndices<pcl::oneapi::PCLPointCloud2>::applyFilter (IndicesDev &indices)
+{
+  if (indices_->size () > (input_->width * input_->height))
+  {
+    PCL_ERROR ("[pcl::%s::applyFilter] The indices size exceeds the size of the input.\n", getClassName ().c_str ());
+    indices.clear ();
+    removed_indices_->clear ();
+    return;
+  }
+
+  if (!negative_)  // Normal functionality
+  {
+    indices = *indices_;
+
+    if (extract_removed_indices_)
+    {
+      // Set up the full indices set
+      IndicesDev full_indices (input_->width * input_->height);
+      for (index_t fii = 0; fii < static_cast<index_t> (full_indices.size ()); ++fii)  // fii = full indices iterator
+        full_indices[fii] = fii;
+
+      // Set up the sorted input indices
+      IndicesDev sorted_input_indices = *indices_;
+      std::sort (sorted_input_indices.begin (), sorted_input_indices.end ());
+
+      // Store the difference in removed_indices
+      removed_indices_->clear ();
+      Indices tmp_removed_indices;
+      std::set_difference (full_indices.begin (), full_indices.end (), sorted_input_indices.begin (), sorted_input_indices.end (), std::inserter(tmp_removed_indices, tmp_removed_indices.begin ()));
+      removed_indices_->upload(tmp_removed_indices);
+    }
+  }
+  else  // Inverted functionality
+  {
+    // Set up the full indices set
+    IndicesDev full_indices (input_->width * input_->height);
+    for (index_t fii = 0; fii < static_cast<index_t> (full_indices.size ()); ++fii)  // fii = full indices iterator
+      full_indices[fii] = fii;
+
+    // Set up the sorted input indices
+    IndicesDev sorted_input_indices = *indices_;
+    std::sort (sorted_input_indices.begin (), sorted_input_indices.end ());
+
+    // Store the difference in indices
+    indices.clear ();
+    Indices tmp_indices;
+    std::set_difference (full_indices.begin (), full_indices.end (), sorted_input_indices.begin (),
+            sorted_input_indices.end (), std::inserter (tmp_indices, tmp_indices.begin ()));
+    indices.upload(tmp_indices);
+
+    if (extract_removed_indices_)
+      removed_indices_ = indices_;
+  }
+}
+
+}
+}
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+  PCL_INSTANTIATE(ExtractIndices, (pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGB)(pcl::PointXYZRGBA)(pcl::Normal)(pcl::PointNormal)(pcl::PointXYZRGBNormal))
+#else
+  PCL_INSTANTIATE(ExtractIndices, PCL_POINT_TYPES)
+#endif
+
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/src/filter.cpp b/oneapi/filters/src/filter.cpp
new file mode 100644
index 000000000..172996c37
--- /dev/null
+++ b/oneapi/filters/src/filter.cpp
@@ -0,0 +1,82 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/filters/impl/filter.hpp>
+#include <pcl/oneapi/PCLPointCloud2.h>
+
+///////////////////////////////////////////////////////////////////////////////////////////
+/** \brief Base method for feature estimation for all points given in <setInputCloud (), setIndices ()> using
+ * the surface in setSearchSurface () and the spatial locator in setSearchMethod ()
+ * \param output the resultant filtered point cloud dataset
+ */
+void
+pcl::oneapi::Filter<pcl::oneapi::PCLPointCloud2>::filter (PCLPointCloud2 &output)
+{
+  if (!initCompute ())
+    return;
+
+  if (input_.get () == &output)  // cloud_in = cloud_out
+  {
+    pcl::oneapi::PCLPointCloud2 output_temp;
+    applyFilter (output_temp);
+    output_temp.fields = input_->fields;
+    output_temp.header = input_->header;
+    pcl::oneapi::copyPointCloud (output_temp, output);
+  }
+  else
+  {
+    output.fields = input_->fields;
+    output.header = input_->header;
+    applyFilter (output);
+  }
+
+  deinitCompute ();
+}
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_removeNaNFromPointCloud, PCL_XYZ_POINT_TYPES)
+PCL_INSTANTIATE(OneAPI_removeNaNNormalsFromPointCloud, PCL_NORMAL_POINT_TYPES)
+
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/src/filter_indices.cpp b/oneapi/filters/src/filter_indices.cpp
new file mode 100644
index 000000000..483895341
--- /dev/null
+++ b/oneapi/filters/src/filter_indices.cpp
@@ -0,0 +1,68 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/filters/impl/filter_indices.hpp>
+namespace pcl { struct PCLPointCloud2; }
+
+/** \brief Base method for feature estimation for all points given in
+ * <setInputCloud (), setIndices ()> using the surface in setSearchSurface ()
+ * and the spatial locator in setSearchMethod ()
+ * \param output the resultant filtered point cloud dataset
+ */
+void
+pcl::oneapi::FilterIndices<pcl::oneapi::PCLPointCloud2>::filter (IndicesDev &indices)
+{
+  if (!initCompute ())
+    return;
+
+  // Apply the actual filter
+  applyFilter (indices);
+
+  deinitCompute ();
+}
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_removeNanFromPointCloud, PCL_XYZ_POINT_TYPES)
+PCL_INSTANTIATE(OneAPI_FilterIndices, PCL_POINT_TYPES)
+
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/src/passthrough.cpp b/oneapi/filters/src/passthrough.cpp
new file mode 100644
index 000000000..6d87dfe39
--- /dev/null
+++ b/oneapi/filters/src/passthrough.cpp
@@ -0,0 +1,50 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/filters/impl/passthrough.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_PassThrough, PCL_XYZ_POINT_TYPES)
+
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/src/statistical_outlier_removal.cpp b/oneapi/filters/src/statistical_outlier_removal.cpp
new file mode 100644
index 000000000..83426dc16
--- /dev/null
+++ b/oneapi/filters/src/statistical_outlier_removal.cpp
@@ -0,0 +1,52 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/filters/impl/statistical_outlier_removal.hpp>
+#include <pcl/conversions.h>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_StatisticalOutlierRemoval, PCL_XYZ_POINT_TYPES)
+
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/filters/src/voxel_grid.cpp b/oneapi/filters/src/voxel_grid.cpp
new file mode 100644
index 000000000..efaa8bdcd
--- /dev/null
+++ b/oneapi/filters/src/voxel_grid.cpp
@@ -0,0 +1,46 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+#include <pcl/oneapi/filters/impl/voxel_grid.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_VoxelGrid, PCL_XYZ_POINT_TYPES)
+
+#endif // PCL_NO_PRECOMPILE
\ No newline at end of file
diff --git a/oneapi/flann_dp_modification.png b/oneapi/flann_dp_modification.png
new file mode 100644
index 0000000000000000000000000000000000000000..05d1b8f7694e8a8eccfb367c82d2376e531c367d
GIT binary patch
literal 105360
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

literal 0
HcmV?d00001

diff --git a/oneapi/kdtree/CMakeLists.txt b/oneapi/kdtree/CMakeLists.txt
new file mode 100755
index 000000000..ac30e6067
--- /dev/null
+++ b/oneapi/kdtree/CMakeLists.txt
@@ -0,0 +1,52 @@
+set(SUBSYS_NAME oneapi_kdtree)
+set(SUBSYS_PATH oneapi/kdtree)
+set(SUBSYS_DESC "Point cloud oneAPI kdtree library")
+set(SUBSYS_DEPS oneapi_common common kdtree)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+# The define enables the dpcpp based kdtree index in flann library
+# Without it, the compilation will fail due to the dpcpp index enum
+# being disabled in defines.h file
+add_definitions("-DFLANN_USE_DPCPP")
+set(incs
+  "include/pcl/oneapi/kdtree/kdtree_flann.h"
+  "include/pcl/oneapi/kdtree/fixed_radius_index.h"
+  "include/pcl/oneapi/kdtree/memory_allocation.h"
+)
+
+set(impl_incs
+  "include/pcl/oneapi/kdtree/impl/kdtree_flann.hpp"
+)
+
+set(srcs
+  src/kdtree_flann.cpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+if(WIN32)
+set(FLANN_DP "${FLANN_ROOT}/lib/flann_dp.lib")
+else()
+find_library(FLANN_DP flann_dp)
+endif()
+
+find_package(TBB REQUIRED)
+
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs} )
+target_link_libraries("${LIB_NAME}" pcl_common pcl_oneapi_common pcl_kdtree FLANN::FLANN ${FLANN_DP} TBB::tbb)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include" "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include" )
+
+set(EXT_DEPS flann)
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS} EXT_DEPS ${EXT_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/fixed_radius_index.h b/oneapi/kdtree/include/pcl/oneapi/kdtree/fixed_radius_index.h
new file mode 100644
index 000000000..2aff57dfa
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/fixed_radius_index.h
@@ -0,0 +1,110 @@
+// ----------------------------------------------------------------------------
+// -                        Open3D: www.open3d.org                            -
+// ----------------------------------------------------------------------------
+// The MIT License (MIT)
+//
+// Copyright (c) 2018-2021 www.open3d.org
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+// ----------------------------------------------------------------------------
+
+#pragma once
+
+#include <pcl/point_types.h>
+#include <pcl/pcl_base.h>
+
+#include <CL/sycl.hpp>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/point_cloud.h>
+
+namespace pcl {
+namespace oneapi {
+
+/// \class FixedRadiusIndex
+///
+/// \brief FixedRadiusIndex for nearest neighbor range search.
+template <typename PointT>
+class FixedRadiusIndex {
+public:
+
+    /// \brief Parameterized Constructor.
+    ///
+    /// \param dataset_points Provides a set of data points as Tensor for KDTree
+    /// construction.
+    using PointCloud = pcl::PointCloud<PointT>;
+    using PointCloudConstPtr =  typename PointCloud::ConstPtr;
+    using PointCloudDev = pcl::oneapi::PointCloudDev<PointT>;
+    using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+    /// \brief Default Constructor.
+    FixedRadiusIndex() {};
+
+    FixedRadiusIndex(const PointCloudConstPtr& dataset_points, const double radius);
+    FixedRadiusIndex(const PointCloudDevConstPtr& dataset_points, const double radius);
+
+    ~FixedRadiusIndex() {};
+    FixedRadiusIndex(const FixedRadiusIndex&) = delete;
+    FixedRadiusIndex& operator=(const FixedRadiusIndex&) = delete;
+
+    void SetTensorData(const PointCloudConstPtr& dataset_points, const double radius);
+    void SetTensorData(const PointCloudDevConstPtr& dataset_points, const double radius);
+
+    int radiusSearch(const PointCloudConstPtr& query_points,
+                   std::vector<int32_t>& k_indices,
+                   std::vector<float>& k_sqr_dist,
+                   std::vector<int32_t>& k_splits,
+                   const int start,
+                   const int end,
+                   bool sort = true);
+
+    int radiusSearch(const PointCloudDevConstPtr& query_points,
+                   DeviceArray<int32_t>& k_indices,
+                   DeviceArray<float>& k_sqr_dist,
+                   DeviceArray<int32_t>& k_splits,
+                   const int start,
+                   const int end,
+                   bool sort = true);
+
+    int radiusSearch(const PointCloudDevConstPtr& query_points,
+                   const std::vector<int32_t>& query_row_splits,
+                   DeviceArray<int32_t>& k_indices,
+                   DeviceArray<float>& k_sqr_dist,
+                   DeviceArray<int32_t>& k_splits,
+                   bool sort = true);
+
+    const double hash_table_size_factor = 1.0 / 32;
+    const int32_t max_hash_table_size = 33554432;
+
+protected:
+    PointCloudDevConstPtr dataset_points_;
+    DeviceArray<uint32_t> hash_table_cell_splits_;
+    DeviceArray<uint32_t> hash_table_index_;
+    DeviceArray<int32_t> indices_unsorted_;
+    DeviceArray<float> distances_unsorted_;
+    double radius_;
+    sycl::queue q_ = dpct::get_default_queue();
+};
+
+}  // namespace oneapi
+}  // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/kdtree/impl/fixed_radius_index.hpp>
+#endif
+
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_index.hpp b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_index.hpp
new file mode 100644
index 000000000..798021989
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_index.hpp
@@ -0,0 +1,361 @@
+// ----------------------------------------------------------------------------
+// -                        Open3D: www.open3d.org                            -
+// ----------------------------------------------------------------------------
+// The MIT License (MIT)
+//
+// Copyright (c) 2018-2021 www.open3d.org
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+// ----------------------------------------------------------------------------
+//
+
+#ifndef PCL_ONEAPI_FIXED_RADIUS_INDEX_HPP_
+#define PCL_ONEAPI_FIXED_RADIUS_INDEX_HPP_
+
+#include <pcl/oneapi/kdtree/impl/fixed_radius_search.hpp>
+#include <pcl/oneapi/utils/segmented_sort.h>
+
+using namespace pcl::oneapi;
+
+
+/// Builds a spatial hash table for a fixed radius search of 3D points.
+///
+/// \param points    The tensor of 3D points. This tensor may be splitted into
+///        multiple batch items by defining points_row_splits_size accordingly.
+///
+/// \param radius    The radius that will be used for searching.
+///
+/// \param points_row_splits    Defines the start and end of the points in
+///        each batch item. The size of the tensor is batch_size+1. If there is
+///        only 1 batch item then this array is [0, num_points]
+///
+/// \param hash_table_splits    Tensor defining the start and end the hash table
+///        for each batch item. This is [0, number of cells] if there is only
+///        1 batch item or [0, hash_table_cell_splits_size-1] which is the same.
+///
+/// \param hash_table_index    This is an output tensor storing the values of
+/// the
+///        hash table, which are the indices to the points. The size of the
+///        tensor must be equal to the number of points.
+///
+/// \param hash_table_cell_splits    This is an output tensor storing the start
+///        of each hash table entry. The size of this array defines the size of
+///        the hash table.
+///        The hash table size is hash_table_cell_splits_size - 1.
+///
+template <typename PointT>
+void BuildSpatialHashTable(sycl::queue& q,
+                           const PointT& cloud_points,
+                           double radius,
+                           DeviceArray<uint32_t>& hash_table_index,
+                           DeviceArray<uint32_t>& hash_table_cell_splits)
+{
+  int texture_alignment = 512;
+
+  void* temp_ptr = nullptr;
+  size_t temp_size = 0;
+
+  pcl::oneapi::impl::BuildSpatialHashTable(
+      q, temp_ptr, temp_size, texture_alignment,
+      cloud_points->points.size(), cloud_points->points.ptr(), radius,
+      hash_table_cell_splits.ptr(),
+      hash_table_cell_splits.size(),
+      hash_table_index.ptr());
+
+  DeviceArray<uint32_t> temp_array (temp_size, 0);
+  temp_ptr = temp_array.ptr();
+
+  pcl::oneapi::impl::BuildSpatialHashTable(
+      q, temp_ptr, temp_size, texture_alignment,
+      cloud_points->points.size(), cloud_points->points.ptr(), radius,
+      hash_table_cell_splits.ptr(),
+      hash_table_cell_splits.size(),
+      hash_table_index.ptr());
+
+
+}
+
+// Fixed radius search. This function computes a list of neighbor indices
+/// for each query point. The lists are stored linearly and an exclusive prefix
+/// sum defines the start and end of list in the array.
+/// In addition the function optionally can return the distances for each
+/// neighbor in the same format as the indices to the neighbors.
+///
+/// \tparam T    Floating-point data type for the point positions.
+///
+/// \param points    Tensor with the 3D point positions. This must be the tensor
+///        that was used for building the spatial hash table.
+///
+/// \param queries    Tensor with the 3D query positions. This may be the same
+///                   tensor as \p points.
+///
+/// \param radius    The search radius.
+///
+/// \param points_row_splits    Defines the start and end of the points in each
+///        batch item. The size of the tensor is batch_size+1. If there is
+///        only 1 batch item then this tensor is [0, num_points]
+///
+/// \param queries_row_splits    Defines the start and end of the queries in
+/// each
+///        batch item. The size of the tensor is batch_size+1. If there is
+///        only 1 batch item then this tensor is [0, num_queries]
+///
+/// \param hash_table_splits    Tensor defining the start and end the hash table
+///        for each batch item. This is [0, number of cells] if there is only
+///        1 batch item or [0, hash_table_cell_splits_size-1] which is the same.
+///
+/// \param hash_table_index    This is an output of the function
+///        BuildSpatialHashTableCPU. This is tensor storing the values of the
+///        hash table, which are the indices to the points. The size of the
+///        tensor must be equal to the number of points.
+///
+/// \param hash_table_cell_splits    This is an output of the function
+///        BuildSpatialHashTableCPU. The row splits array describing the start
+///        and end of each cell.
+///
+/// \param metric    One of L1, L2, Linf. Defines the distance metric for the
+///        search.
+///
+/// \param ignore_query_point    If true then points with the same position as
+///        the query point will be ignored.
+///
+/// \param return_distances    If true then this function will return the
+///        distances for each neighbor to its query point in the same format
+///        as the indices.
+///        Note that for the L2 metric the squared distances will be returned!!
+///
+/// \param sort                If true then sort the results in ascending order
+/// of distance
+///
+/// \param neighbors_index     The output tensor that saves the resulting
+/// neighbor indices
+///
+/// \param neighbors_row_splits  Tensor defining the start and end the neighbor
+/// indices in each batch item. The size of the tensor is num_query_points + 1
+///
+/// \param neighbors_distance   The output tensor that saves the resulting
+/// neighbor distances.
+///
+template <class T, typename PointT>
+void FixedRadiusSearch(sycl::queue& q,
+                       const pcl::oneapi::PointCloudDev<PointT>& cloud_points,
+                       const pcl::oneapi::PointCloudDev<PointT>& queries,
+                       double radius,
+                       const std::vector<int32_t>& queries_row_splits,
+                       const DeviceArray<uint32_t>& hash_table_index,
+                       const DeviceArray<uint32_t>& hash_table_cell_splits,
+                       const impl::Metric metric,
+                       const bool ignore_query_point,
+                       const bool return_distances,
+                       const bool sort,
+                       DeviceArray<int32_t>& neighbors_indices_unsorted,
+                       DeviceArray<T> &neighbors_distances_unsorted,
+                       DeviceArray<int32_t>& neighbors_indices_sorted,
+                       DeviceArray<int32_t>& neighbors_row_splits,
+                       DeviceArray<T>& neighbors_distances_sorted)
+{
+  int texture_alignment = 512;
+  void* temp_ptr = nullptr;
+  size_t temp_size = 0;
+
+  pcl::oneapi::impl::FixedRadiusSearch(
+      q, temp_ptr, temp_size, texture_alignment,
+      neighbors_row_splits.ptr(),  cloud_points.points.size(),
+      cloud_points.points.ptr(), queries.points.size(), queries.points.ptr(),
+      T(radius), queries_row_splits.size(),
+      queries_row_splits.data(), hash_table_cell_splits.size(),
+      hash_table_cell_splits.ptr(), hash_table_index.ptr(),
+      metric, ignore_query_point, return_distances,
+      neighbors_indices_unsorted, neighbors_distances_unsorted);
+
+  DeviceArray<uint32_t> temp_array(temp_size, 0);
+  temp_ptr = temp_array.ptr();
+
+  pcl::oneapi::impl::FixedRadiusSearch(
+      q, temp_ptr, temp_size, texture_alignment,
+      neighbors_row_splits.ptr(), cloud_points.points.size(),
+      cloud_points.points.ptr(), queries.points.size(), queries.points.ptr(),
+      T(radius), queries_row_splits.size(),
+      queries_row_splits.data(), hash_table_cell_splits.size(),
+      hash_table_cell_splits.ptr(), hash_table_index.ptr(),
+      metric, ignore_query_point, return_distances,
+      neighbors_indices_unsorted, neighbors_distances_unsorted);
+
+
+  if (sort) {
+
+    neighbors_indices_sorted.create(neighbors_indices_unsorted.size());
+    neighbors_distances_sorted.create(neighbors_distances_unsorted.size());
+
+    int32_t num_segments = neighbors_row_splits.size() - 1;
+
+    pcl::oneapi::SegmentedSortPairs(
+        neighbors_distances_unsorted,
+        neighbors_indices_unsorted,
+        neighbors_distances_sorted,
+        neighbors_indices_sorted,
+        neighbors_row_splits.ptr(),
+        neighbors_distances_unsorted.size(),
+        num_segments);
+  }
+  else
+  {
+    neighbors_indices_sorted = neighbors_indices_unsorted;
+    neighbors_distances_sorted = neighbors_distances_unsorted;
+  }
+
+}
+
+template<typename PointT>
+pcl::oneapi::FixedRadiusIndex<PointT>::FixedRadiusIndex(const PointCloudConstPtr &dataset_points,
+                                   const double radius) {
+  //AssertTensorDtypes(dataset_points, {Float32, Float64});
+  SetTensorData(dataset_points, radius);
+}
+
+
+template<typename PointT>
+pcl::oneapi::FixedRadiusIndex<PointT>::FixedRadiusIndex(const PointCloudDevConstPtr &dataset_points,
+                                   const double radius) {
+  //AssertTensorDtypes(dataset_points, {Float32, Float64});
+  SetTensorData(dataset_points, radius);
+}
+
+template<typename PointT> void
+pcl::oneapi::FixedRadiusIndex<PointT>::SetTensorData(const PointCloudConstPtr &dataset_points,
+                                     const double radius) {
+
+  const int32_t num_dataset_points = (*dataset_points).size();
+  const int32_t hash_table_size = std::min<int32_t>(
+                  std::max<int32_t>(hash_table_size_factor * num_dataset_points, 1),
+                  max_hash_table_size);
+
+  radius_ = radius;
+
+  PointCloudDev tmp (dataset_points);
+  dataset_points_ = tmp.makeShared();
+
+  hash_table_index_ = pcl::oneapi::DeviceArray<uint32_t>(num_dataset_points, 0);
+  hash_table_cell_splits_ = pcl::oneapi::DeviceArray<uint32_t>(hash_table_size + 1, 0);
+
+  BuildSpatialHashTable(q_, dataset_points_, radius, hash_table_index_, hash_table_cell_splits_);
+}
+
+template<typename PointT> void
+pcl::oneapi::FixedRadiusIndex<PointT>::SetTensorData(const PointCloudDevConstPtr &dataset_points,
+                                     const double radius) {
+
+  const int32_t num_dataset_points = dataset_points->size();
+  const int32_t hash_table_size = std::min<int32_t>(
+                  std::max<int32_t>(hash_table_size_factor * num_dataset_points, 1),
+                  max_hash_table_size);
+
+  radius_ = radius;
+
+  dataset_points_ = dataset_points;
+
+  hash_table_index_ = pcl::oneapi::DeviceArray<uint32_t>(num_dataset_points, 0);
+  hash_table_cell_splits_ = pcl::oneapi::DeviceArray<uint32_t>(hash_table_size + 1, 0);
+
+  BuildSpatialHashTable(q_, dataset_points_, radius, hash_table_index_, hash_table_cell_splits_);
+}
+
+template<typename PointT> int
+pcl::oneapi::FixedRadiusIndex<PointT>::radiusSearch(const PointCloudConstPtr &query_points,
+                   std::vector<int32_t>& k_indices,
+                   std::vector<float>& k_sqr_dists,
+                   std::vector<int32_t>& k_splits,
+                   const int start,
+                   const int end,
+                   bool sort) {
+
+  const int32_t num_query_points = end - start;
+  std::vector<int32_t> query_row_splits {0, num_query_points};
+
+  DeviceArray<int32_t> d_indices;
+  DeviceArray<float> d_sqr_dists;
+  DeviceArray<int> d_splits;
+
+  PointCloudDev query_points_ (query_points);
+
+   d_splits.create(num_query_points + 1);
+
+  FixedRadiusSearch(q_, *dataset_points_, query_points_, radius_, query_row_splits,
+      hash_table_index_, hash_table_cell_splits_, impl::Metric::L2, false, true, sort,
+      indices_unsorted_, distances_unsorted_, d_indices, d_splits,  d_sqr_dists);
+
+  k_indices.resize(d_indices.size());
+  k_sqr_dists.resize(d_sqr_dists.size());
+  k_splits.resize(d_splits.size());
+
+  d_indices.download(k_indices);
+  d_sqr_dists.download(k_sqr_dists);
+  d_splits.download(k_splits);
+
+  return k_indices.size();
+}
+
+template<typename PointT> int
+pcl::oneapi::FixedRadiusIndex<PointT>::radiusSearch(const PointCloudDevConstPtr &query_points,
+                   DeviceArray<int32_t>& k_indices,
+                   DeviceArray<float>& k_sqr_dist,
+                   DeviceArray<int32_t>& k_splits,
+                   const int start,
+                   const int end,
+                   bool sort) {
+
+  const int32_t num_query_points = end - start;
+  std::vector<int32_t> query_row_splits {0, num_query_points};
+
+  PointCloudDev query_points_ (num_query_points);
+  query_points_.points.upload(query_points->points.ptr() + start, num_query_points);
+
+  k_splits.create(num_query_points + 1);
+
+  FixedRadiusSearch(q_, *dataset_points_, query_points_, radius_, query_row_splits,
+      hash_table_index_, hash_table_cell_splits_, impl::Metric::L2, false, true, sort,
+      indices_unsorted_, distances_unsorted_, k_indices, k_splits,  k_sqr_dist);
+
+  return k_indices.size();
+}
+
+template<typename PointT> int
+pcl::oneapi::FixedRadiusIndex<PointT>::radiusSearch(const PointCloudDevConstPtr &query_points,
+                   const std::vector<int32_t>& query_row_splits,
+                   DeviceArray<int32_t>& k_indices,
+                   DeviceArray<float>& k_sqr_dist,
+                   DeviceArray<int32_t>& k_splits,
+                   bool sort) {
+
+  const int64_t num_query_points = query_points->size();
+  if (num_query_points != query_row_splits.back()) {
+    std::cerr << "query_points and queries_row_splits has wrong size" << std::endl;
+    return -1;
+  }
+
+  k_splits.create(num_query_points + 1);
+
+  FixedRadiusSearch(q_, *dataset_points_, *query_points, radius_, query_row_splits,
+      hash_table_index_, hash_table_cell_splits_, impl::Metric::L2, false, true, sort,
+      indices_unsorted_, distances_unsorted_, k_indices, k_splits,  k_sqr_dist);
+
+  return k_indices.size();
+}
+
+#endif // PCL_ONEAPI_FIXED_RADIUS_INDEX_HPP_
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_search.hpp b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_search.hpp
new file mode 100644
index 000000000..352757c72
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/fixed_radius_search.hpp
@@ -0,0 +1,797 @@
+// ----------------------------------------------------------------------------
+// -                        Open3D: www.open3d.org                            -
+// ----------------------------------------------------------------------------
+// The MIT License (MIT)
+//
+// Copyright (c) 2018-2021 www.open3d.org
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+// ----------------------------------------------------------------------------
+#pragma once
+
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+
+#include <pcl/oneapi/kdtree/memory_allocation.h>
+#include <pcl/oneapi/utils/common.h>
+
+namespace pcl {
+namespace oneapi {
+namespace impl {
+
+/// Supported metrics
+enum Metric { L1, L2, Linf };
+
+/// Spatial hashing function for integer coordinates.
+__device_inline__ size_t SpatialHash(int x, int y, int z) {
+  return x * 73856096 ^ y * 193649663 ^ z * 83492791;
+}
+
+__device_inline__ size_t SpatialHash(const sycl::int3 &xyz) {
+  return SpatialHash(xyz[0], xyz[1], xyz[2]);
+}
+
+/// Computes the distance of two points and tests if the distance is below a
+/// threshold.
+///
+/// \tparam METRIC    The distance metric. One of L1, L2, Linf.
+/// \tparam T    Floating point type for the distances.
+///
+/// \param p1           A 3D point
+/// \param p2           Another 3D point
+/// \param dist         Output parameter for the distance.
+/// \param threshold    The scalar threshold.
+///
+/// \return Returns true if the distance is <= threshold.
+///
+template <int METRIC = L2, class T>
+__device_inline__ bool NeighborTest(const sycl::float3& p1,
+                         const sycl::float3& p2,
+                         T& dist,
+                         T threshold) {
+
+    bool result = false;
+    if (METRIC == Linf) {
+      sycl::float3 d = sycl::fabs(p1 - p2);
+      dist = d[0] > d[1] ? d[0] : d[1];
+      dist = dist > d[2] ? dist : d[2];
+    } else if (METRIC == L1) {
+      sycl::float3 d = sycl::fabs(p1 - p2);
+      dist = (d[0] + d[1] + d[2]);
+    } else {
+      sycl::float3 d = p1 - p2;
+      dist = sycl::dot(d, d);
+    }
+    result = dist <= threshold;
+    return result;
+}
+
+/// Computes an integer voxel index for a 3D position.
+///
+/// \param pos               A 3D position.
+/// \param inv_voxel_size    The reciprocal of the voxel size
+///
+__device_inline__ sycl::int3 ComputeVoxelIndex(
+      const sycl::float3 &pos,
+      const float &inv_voxel_size) {
+
+  sycl::float3 ref_coord = pos * inv_voxel_size;
+
+  sycl::int3 voxel_index;
+  voxel_index = sycl::floor(ref_coord).template convert<int>();
+  return voxel_index;
+}
+
+/// Kernel for CountHashTableEntries
+template <class T, typename PointT>
+void CountHashTableEntriesKernel(
+    uint32_t* count_table,
+    size_t hash_table_size,
+    T inv_voxel_size,
+    const PointT* points,
+    size_t num_points,
+    sycl::nd_item<2> item_ct1) {
+
+  const int idx = item_ct1.get_global_linear_id();
+  if (idx >= num_points) return;
+
+  sycl::float3 pos = sycl::float3(points[idx].x, points[idx].y, points[idx].z);
+
+  sycl::int3 voxel_index = ComputeVoxelIndex(pos, inv_voxel_size);
+  size_t hash = SpatialHash(voxel_index) % hash_table_size;
+
+  dpct::atomic_fetch_add<uint32_t, sycl::access::address_space::global_space>(
+        &count_table[hash + 1], (uint32_t)1);
+}
+
+/// Counts for each hash entry the number of points that map to this entry.
+///
+/// \param count_table    Pointer to the table for counting.
+///        The first element will not be used, i.e. the
+///        number of points for the first hash entry is in count_table[1].
+///        This array must be initialized before calling this function.
+///
+/// \param count_table_size    This is the size of the hash table + 1.
+///
+/// \param inv_voxel_size    Reciproval of the voxel size
+///
+/// \param points    Array with the 3D point positions.
+///
+/// \param num_points    The number of points.
+///
+template <class T, typename PointT>
+void CountHashTableEntries(
+    sycl::queue& q,
+    uint32_t* count_table,
+    size_t count_table_size,
+    T inv_voxel_size,
+    const PointT* points,
+    size_t num_points) {
+
+  const int BLOCKSIZE = 64;
+  sycl::range<2> block(BLOCKSIZE, 1);
+  sycl::range<2> grid(0, 1);
+  grid[0] = divUp(num_points, block[0]);
+
+  if (grid[0])
+    q.parallel_for(sycl::nd_range<2>(grid * block, block),
+          [=](sycl::nd_item<2> item_ct1) {
+            CountHashTableEntriesKernel<T>(
+                count_table, count_table_size - 1,
+                inv_voxel_size, points, num_points,
+                item_ct1);
+    }).wait();
+}
+
+/// Kernel for ComputePointIndexTable
+template <class T, typename PointT>
+void ComputePointIndexTableKernel(
+    uint32_t* point_index_table,
+    uint32_t* count_tmp,
+    const uint32_t* const hash_table_cell_splits,
+    size_t hash_table_size,
+    T inv_voxel_size,
+    const PointT* points,
+    const size_t total_points,
+    sycl::nd_item<2> item_ct1) {
+
+    const int idx = item_ct1.get_global_linear_id();
+
+    if (idx >= total_points) return;
+
+    sycl::float3 pos = sycl::float3(points[idx].x, points[idx].y, points[idx].z);
+
+    sycl::int3 voxel_index = ComputeVoxelIndex(pos, inv_voxel_size);
+    size_t hash = SpatialHash(voxel_index) % hash_table_size;
+
+    uint32_t pidx = dpct::atomic_fetch_add<uint32_t, sycl::access::address_space::global_space>(
+        &count_tmp[hash], (uint32_t)1);
+
+    point_index_table
+      [hash_table_cell_splits[hash] + pidx] = idx;
+
+}
+
+/// Writes the index of the points to the hash cells.
+///
+/// \param point_index_table    The output array storing the point indices for
+///        all cells. Start and end of each cell is defined by
+///        \p hash_table_prefix_sum
+///
+/// \param count_tmp    Temporary memory of size
+///                     \p hash_table_cell_splits_size.
+///
+/// \param hash_table_cell_splits    The row splits array describing the start
+///        and end of each cell.
+///
+/// \param hash_table_cell_splits_size    The size of the hash table.
+///
+/// \param inv_voxel_size    Reciproval of the voxel size
+///
+/// \param points    Array with the 3D point positions.
+///
+/// \param num_points    The number of points.
+///
+template <class T, typename PointT>
+void ComputePointIndexTable(sycl::queue& q,
+                            uint32_t* point_index_table,
+                            uint32_t* count_tmp,
+                            const uint32_t* const hash_table_cell_splits,
+                            size_t hash_table_cell_splits_size,
+                            T inv_voxel_size,
+                            const PointT* points,
+                            size_t num_points) {
+
+  q.memset(count_tmp, 0, sizeof(uint32_t) * hash_table_cell_splits_size).wait();
+
+  const int BLOCKSIZE = 64;
+  sycl::range<2> block(BLOCKSIZE, 1);
+  sycl::range<2> grid(0, 1);
+  grid[0] = divUp(num_points, block[0]);
+
+  if (grid[0])
+  {
+    q.submit([&](sycl::handler& h) {
+      h.parallel_for(sycl::nd_range<2>(grid * block, block),
+        [=](sycl::nd_item<2> item_ct1) {
+            ComputePointIndexTableKernel<T>(
+                point_index_table,
+                count_tmp,
+                hash_table_cell_splits,
+                hash_table_cell_splits_size - 1, inv_voxel_size,
+                points, num_points, item_ct1);
+       });
+    }).wait();
+  }
+}
+
+/// Kernel for CountNeighbors
+template <Metric METRIC, bool IGNORE_QUERY_POINT, class T, typename PointT>
+void CountNeighborsKernel(
+        uint32_t*  neighbors_count,
+        const uint32_t* point_index_table,
+        const uint32_t* hash_table_cell_splits,
+        size_t hash_table_size,
+        const PointT* query_points,
+        size_t num_queries,
+        const PointT* points,
+        const T inv_voxel_size,
+        const T radius,
+        const T threshold,
+        sycl::nd_item<2> item_ct1) {
+
+    const int query_idx = item_ct1.get_global_linear_id();
+    if (query_idx >= num_queries) return;
+
+    int count = 0;  // counts the number of neighbors for this query point
+
+    sycl::float3 query_pos = sycl::float3(query_points[query_idx].x,
+                                          query_points[query_idx].y,
+                                          query_points[query_idx].z);
+
+    sycl::int3 voxel_index = ComputeVoxelIndex(query_pos, inv_voxel_size);
+    int hash = SpatialHash(voxel_index) %  hash_table_size;
+
+    int bins_to_visit[8] = {hash, -1, -1, -1, -1, -1, -1, -1};
+
+    for (int dz = -1; dz <= 1; dz += 2)
+        for (int dy = -1; dy <= 1; dy += 2)
+            for (int dx = -1; dx <= 1; dx += 2) {
+
+                sycl::float3 p = query_pos + radius * sycl::float3(T(dx), T(dy), T(dz));
+                voxel_index = ComputeVoxelIndex(p, inv_voxel_size);
+                hash = SpatialHash(voxel_index) % hash_table_size;
+
+                // insert without duplicates
+                for (int i = 0; i < 8; ++i) {
+                    if (bins_to_visit[i] == hash) {
+                        break;
+                    } else if (bins_to_visit[i] == -1) {
+                        bins_to_visit[i] = hash;
+                        break;
+                    }
+                }
+            }
+
+    for (int bin_i = 0; bin_i < 8; ++bin_i) {
+        int bin = bins_to_visit[bin_i];
+        if (bin == -1) break;
+
+        size_t begin_idx = hash_table_cell_splits[bin];
+        size_t end_idx = hash_table_cell_splits[bin + 1];
+
+        for (size_t j = begin_idx; j < end_idx; ++j) {
+            uint32_t idx = point_index_table[j];
+            sycl::float3 p = sycl::float3(points[idx].x,
+                                          points[idx].y,
+                                          points[idx].z);
+
+            if (IGNORE_QUERY_POINT) {
+                if (sycl::all(sycl::isequal(query_pos, p))) continue;
+            }
+
+            T dist;
+            if (NeighborTest<METRIC>(p, query_pos, dist, threshold))
+               ++count;
+        }
+    }
+    neighbors_count[query_idx] = count;
+}
+
+/// Count the number of neighbors for each query point
+///
+/// \param neighbors_count    Output array for counting the number of neighbors.
+///        The size of the array is \p num_queries.
+///
+/// \param point_index_table    The array storing the point indices for all
+///        cells. Start and end of each cell is defined by \p
+///        hash_table_cell_splits
+///
+/// \param hash_table_cell_splits    The row splits array describing the start
+///        and end of each cell.
+///
+/// \param hash_table_cell_splits_size    This is the length of the
+///        hash_table_cell_splits array.
+///
+/// \param query_points    Array with the 3D query positions. This may be the
+///        same array as \p points.
+///
+/// \param num_queries    The number of query points.
+///
+/// \param points    Array with the 3D point positions.
+///
+/// \param num_points    The number of points.
+///
+/// \param inv_voxel_size    Reciproval of the voxel size
+///
+/// \param radius    The search radius.
+///
+/// \param metric    One of L1, L2, Linf. Defines the distance metric for the
+///        search.
+///
+/// \param ignore_query_point    If true then points with the same position as
+///        the query point will be ignored.
+///
+template <class T, typename PointT>
+void CountNeighbors(sycl::queue& q,
+        uint32_t* neighbors_count,
+        const uint32_t* point_index_table,
+        const uint32_t* hash_table_cell_splits,
+        size_t hash_table_cell_splits_size,
+        const PointT* query_points,
+        size_t num_queries,
+        const PointT* points,
+        const T inv_voxel_size,
+        const T radius,
+        const Metric metric,
+        const bool ignore_query_point) {
+    const T threshold = (metric == L2 ? radius * radius : radius);
+
+    const int BLOCKSIZE = 64;
+    sycl::range<2> block(BLOCKSIZE, 1);
+    sycl::range<2> grid(0, 1);
+    grid[0] = divUp(num_queries, block[0]);
+
+    if (grid[0]) {
+#define CALL_TEMPLATE(METRIC)                                   \
+    if (METRIC == metric) {                                     \
+        if (ignore_query_point)                                 \
+          q.parallel_for(sycl::nd_range<2>(grid * block, block),\
+              [=](sycl::nd_item<2> item_ct1) {                  \
+                CountNeighborsKernel<METRIC, true, T>(          \
+                    neighbors_count,                            \
+                    point_index_table,                          \
+                    hash_table_cell_splits,                     \
+                    hash_table_cell_splits_size - 1,            \
+                    query_points,                               \
+                    num_queries, points,                        \
+                    inv_voxel_size, radius,                     \
+                    threshold, item_ct1);                       \
+            }).wait();                                          \
+        else                                                    \
+          q.parallel_for(sycl::nd_range<2>(grid * block, block),\
+              [=](sycl::nd_item<2> item_ct1) {                  \
+                CountNeighborsKernel<METRIC, false, T>(         \
+                    neighbors_count,                            \
+                    point_index_table,                          \
+                    hash_table_cell_splits,                     \
+                    hash_table_cell_splits_size - 1,            \
+                    query_points,                               \
+                    num_queries, points,                        \
+                    inv_voxel_size, radius,                     \
+                    threshold, item_ct1);                       \
+          }).wait();                                            \
+    }
+
+        CALL_TEMPLATE(L1)
+        CALL_TEMPLATE(L2)
+        CALL_TEMPLATE(Linf)
+
+#undef CALL_TEMPLATE
+    }
+}
+
+/// Kernel for WriteNeighborsIndicesAndDistances
+template <class T, int METRIC, bool IGNORE_QUERY_POINT, bool RETURN_DISTANCES, typename PointT>
+void WriteNeighborsIndicesAndDistancesKernel(
+      int32_t* indices,
+      T* distances,
+      const int32_t* neighbors_row_splits,
+      const uint32_t* point_index_table,
+      const uint32_t* hash_table_cell_splits,
+      size_t hash_table_size,
+      const PointT* query_points,
+      size_t num_queries,
+      const PointT* points,
+      const T inv_voxel_size,
+      const T radius,
+      const T threshold,
+      sycl::nd_item<2> item_ct1) {
+    const int query_idx = item_ct1.get_global_linear_id();
+    if (query_idx >= num_queries) return;
+
+    int count = 0;  // counts the number of neighbors for this query point
+
+    size_t indices_offset = neighbors_row_splits[query_idx];
+
+    sycl::float3 query_pos = sycl::float3(query_points[query_idx].x,
+                                          query_points[query_idx].y,
+                                          query_points[query_idx].z);
+
+    sycl::int3 voxel_index = ComputeVoxelIndex(query_pos, inv_voxel_size);
+    int hash = SpatialHash(voxel_index) % hash_table_size;
+
+    int bins_to_visit[8] = {hash, -1, -1, -1, -1, -1, -1, -1};
+
+    for (int dz = -1; dz <= 1; dz += 2) {
+        for (int dy = -1; dy <= 1; dy += 2) {
+            for (int dx = -1; dx <= 1; dx += 2) {
+                /*
+                DPCT1084:36: The function call has multiple migration results in
+                different template instantiations that could not be unified. You
+                may need to adjust the code.
+                */
+                sycl::float3 p = query_pos + radius * sycl::float3(T(dx), T(dy), T(dz));
+                /*
+                DPCT1084:37: The function call has multiple migration results in
+                different template instantiations that could not be unified. You
+                may need to adjust the code.
+                */
+                voxel_index = ComputeVoxelIndex(p, inv_voxel_size);
+                hash = SpatialHash(voxel_index) % hash_table_size;
+
+                // insert without duplicates
+                for (int i = 0; i < 8; ++i) {
+                    if (bins_to_visit[i] == hash) {
+                        break;
+                    } else if (bins_to_visit[i] == -1) {
+                        bins_to_visit[i] = hash;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (int bin_i = 0; bin_i < 8; ++bin_i) {
+        int bin = bins_to_visit[bin_i];
+        if (bin == -1) break;
+
+        size_t begin_idx = hash_table_cell_splits[bin];
+        size_t end_idx = hash_table_cell_splits[bin + 1];
+
+        for (size_t j = begin_idx; j < end_idx; ++j) {
+            uint32_t idx = point_index_table[j];
+
+            sycl::float3 p = sycl::float3(points[idx].x, points[idx].y, points[idx].z);
+            if (IGNORE_QUERY_POINT) {
+                if (sycl::all(sycl::isequal(query_pos, p))) continue;
+            }
+
+            T dist;
+            if (NeighborTest<METRIC>(p, query_pos, dist, threshold)) {
+                indices[indices_offset + count] = idx;
+                if (RETURN_DISTANCES) {
+                    distances[indices_offset + count] = dist;
+                }
+                ++count;
+            }
+        }
+    }
+}
+
+/// Write indices and distances of neighbors for each query point
+///
+/// \param indices    Output array with the neighbors indices.
+///
+/// \param distances    Output array with the neighbors distances. May be null
+///        if return_distances is false.
+///
+/// \param neighbors_row_splits    This is the prefix sum which describes
+///        start and end of the neighbors and distances for each query point.
+///
+/// \param point_index_table    The array storing the point indices for all
+///        cells. Start and end of each cell is defined by \p
+///        hash_table_cell_splits
+///
+/// \param hash_table_cell_splits    The row splits array describing the start
+///        and end of each cell.
+///
+/// \param hash_table_cell_splits_size    This is the length of the
+///        hash_table_cell_splits array.
+///
+/// \param query_points    Array with the 3D query positions. This may be the
+///        same array as \p points.
+///
+/// \param num_queries    The number of query points.
+///
+/// \param points    Array with the 3D point positions.
+///
+/// \param num_points    The number of points.
+///
+/// \param inv_voxel_size    Reciproval of the voxel size
+///
+/// \param radius    The search radius.
+///
+/// \param metric    One of L1, L2, Linf. Defines the distance metric for the
+///        search.
+///
+/// \param ignore_query_point    If true then points with the same position as
+///        the query point will be ignored.
+///
+/// \param return_distances    If true then this function will return the
+///        distances for each neighbor to its query point in the same format
+///        as the indices.
+///        Note that for the L2 metric the squared distances will be returned!!
+template <class T, typename PointT>
+void WriteNeighborsIndicesAndDistances(
+        sycl::queue& q,
+        int32_t* indices,
+        T* distances,
+        const int32_t* const neighbors_row_splits,
+        const uint32_t* const point_index_table,
+        const uint32_t* const hash_table_cell_splits,
+        size_t hash_table_cell_splits_size,
+        const PointT* query_points,
+        size_t num_queries,
+        const PointT* points,
+        const T inv_voxel_size,
+        const T radius,
+        const Metric metric,
+        const bool ignore_query_point,
+        const bool return_distances) {
+    const T threshold = (metric == L2 ? radius * radius : radius);
+
+    const int BLOCKSIZE = 64;
+    sycl::range<2> block(BLOCKSIZE, 1);
+    sycl::range<2> grid(0, 1);
+    grid[0] = divUp(num_queries, block[0]);
+
+    if (grid[0]) {
+
+#define CALL_TEMPLATE(METRIC, IGNORE_QUERY_POINT, RETURN_DISTANCES)         \
+    if (METRIC == metric && IGNORE_QUERY_POINT == ignore_query_point &&     \
+        RETURN_DISTANCES == return_distances) {                             \
+                                                                            \
+        q.parallel_for(sycl::nd_range<2>(grid * block, block),              \
+          [=](sycl::nd_item<2> item_ct1) {                                  \
+            WriteNeighborsIndicesAndDistancesKernel<T, METRIC, IGNORE_QUERY_POINT, RETURN_DISTANCES>( \
+                indices, distances, neighbors_row_splits, point_index_table,\
+                hash_table_cell_splits, hash_table_cell_splits_size,        \
+                query_points, num_queries, points, inv_voxel_size,          \
+                radius, threshold, item_ct1);                               \
+        }).wait();                                                          \
+    }
+
+#define CALL_TEMPLATE2(METRIC)         \
+    CALL_TEMPLATE(METRIC, true, true)  \
+    CALL_TEMPLATE(METRIC, true, false) \
+    CALL_TEMPLATE(METRIC, false, true) \
+    CALL_TEMPLATE(METRIC, false, false)
+
+#define CALL_TEMPLATE3 \
+    CALL_TEMPLATE2(L1) \
+    CALL_TEMPLATE2(L2) \
+    CALL_TEMPLATE2(Linf)
+
+        CALL_TEMPLATE3
+
+#undef CALL_TEMPLATE
+#undef CALL_TEMPLATE2
+#undef CALL_TEMPLATE3
+    }
+}
+
+template <typename PointT>
+void BuildSpatialHashTable(sycl::queue& q,
+                           void* temp,
+                           size_t& temp_size,
+                           int texture_alignment,
+                           const size_t num_points,
+                           const PointT* points,
+                           const double radius,
+                           uint32_t* hash_table_cell_splits,
+                           const size_t hash_table_cell_splits_size,
+                           uint32_t* hash_table_index) {
+
+  const bool get_temp_size = !temp;
+
+  if (get_temp_size) {
+    temp = (char*)1;  // worst case pointer alignment
+    temp_size = std::numeric_limits<int64_t>::max();
+  }
+
+  MemoryAllocation mem_temp(temp, temp_size, texture_alignment);
+
+  std::pair<uint32_t*, size_t> count_tmp =
+    mem_temp.Alloc<uint32_t>(hash_table_cell_splits_size);
+
+  const float voxel_size = 2 * radius;
+  const float inv_voxel_size = 1 / voxel_size;
+  const size_t hash_table_size = hash_table_cell_splits_size - 1;
+
+  if (!get_temp_size) {
+    q.memset(count_tmp.first, 0, sizeof(uint32_t) * count_tmp.second).wait();
+
+    CountHashTableEntries(q, count_tmp.first, hash_table_size + 1, inv_voxel_size,
+                          points, num_points);
+
+    // compute prefix sum of the hash entry counts and store in
+    // hash_table_cell_splits
+    ::oneapi::dpl::inclusive_scan(::oneapi::dpl::execution::make_device_policy(q), count_tmp.first,
+        count_tmp.first + count_tmp.second, hash_table_cell_splits);
+
+    // now compute the global indices which allows us to lookup the point index
+    // for the entries in the hash cell
+    ComputePointIndexTable(q, hash_table_index, count_tmp.first, hash_table_cell_splits,
+        hash_table_size + 1, inv_voxel_size, points, num_points);
+
+  }
+
+  mem_temp.Free(count_tmp);
+
+  if (get_temp_size) {
+    // return the memory peak as the required temporary memory size.
+    temp_size = mem_temp.MaxUsed();
+    return;
+  }
+}
+
+/*
+template <class T>
+void SortPairs(int32_t num_segments,
+               const int32_t* query_neighbors_row_splits,
+               int32_t* indices,
+               T* distances) {
+
+
+  for (int i = 0; i < num_segments; i++)
+  {
+    const int32_t queries_start_idx = query_neighbors_row_splits[i];
+    const size_t num_queries_i = query_neighbors_row_splits[i+1] - query_neighbors_row_splits[i];
+
+    auto zipped_begin = ::oneapi::dpl::make_zip_iterator(indices + queries_start_idx,
+        distances + queries_start_idx);
+
+    std::sort(zipped_begin, zipped_begin + num_queries_i,
+              [](auto lhs, auto rhs) { return std::get<1>(lhs) < std::get<1>(rhs); });
+  }
+}
+*/
+
+template <class T, typename PointT>
+void FixedRadiusSearch(sycl::queue& q,
+                       void* temp,
+                       size_t& temp_size,
+                       int texture_alignment,
+                       int32_t* query_neighbors_row_splits,
+                       size_t num_points,
+                       const PointT* points,
+                       size_t num_queries,
+                       const PointT* queries,
+                       const T radius,
+                       const size_t queries_row_splits_size,
+                       const int32_t* const queries_row_splits,
+                       size_t hash_table_cell_splits_size,
+                       const uint32_t* const hash_table_cell_splits,
+                       const uint32_t* const hash_table_index,
+                       const Metric metric,
+                       const bool ignore_query_point,
+                       const bool return_distances,
+                       DeviceArray<int32_t>& indices_out,
+                       DeviceArray<T>& distance_out) try {
+
+    const bool get_temp_size = !temp;
+
+    if (get_temp_size) {
+        temp = (char*)1;  // worst case pointer alignment
+        temp_size = std::numeric_limits<int64_t>::max();
+    }
+
+    // return empty output arrays if there are no points
+    if ((0 == num_points || 0 == num_queries) && !get_temp_size) {
+        q.memset(query_neighbors_row_splits, 0, sizeof(int32_t) * (num_queries + 1));
+        indices_out.create(0);
+
+        distance_out.create(0);
+
+        return;
+    }
+
+    MemoryAllocation mem_temp(temp, temp_size, texture_alignment);
+
+    const int batch_size = queries_row_splits_size - 1;
+    const T voxel_size = 2 * radius;
+    const T inv_voxel_size = 1 / voxel_size;
+    const size_t hash_table_size = hash_table_cell_splits_size - 1;
+
+    std::pair<uint32_t*, size_t> query_neighbors_count =
+            mem_temp.Alloc<uint32_t>(num_queries);
+
+    // we need this value to compute the size of the index array
+    int32_t last_prefix_sum_entry = 0;
+    if (!get_temp_size) {
+      for (int i = 0; i < batch_size; ++i) {
+
+        const size_t queries_start_idx = queries_row_splits[i];
+        const PointT* queries_i = queries + queries_row_splits[i];
+        const size_t num_queries_i = queries_row_splits[i + 1] - queries_row_splits[i];
+
+        CountNeighbors(
+          q, query_neighbors_count.first + queries_start_idx,
+          hash_table_index, hash_table_cell_splits,
+          hash_table_size + 1, queries_i, num_queries_i, points,
+          inv_voxel_size, radius, metric, ignore_query_point);
+      }
+
+      q.memset(query_neighbors_row_splits, 0, sizeof(int32_t));
+
+      ::oneapi::dpl::inclusive_scan(::oneapi::dpl::execution::make_device_policy(q),
+                  query_neighbors_count.first,
+                  query_neighbors_count.first + num_queries,
+                  query_neighbors_row_splits + 1);
+
+      q.memcpy(&last_prefix_sum_entry, (query_neighbors_row_splits + num_queries),
+          sizeof(int32_t)).wait();
+    }
+
+    if (get_temp_size) {
+        // return the memory peak as the required temporary memory size.
+        temp_size = mem_temp.MaxUsed();
+        return;
+    }
+
+    if (!get_temp_size) {
+      // allocate the output array for the neighbor indices
+      const size_t num_indices = last_prefix_sum_entry;
+
+      indices_out.create(num_indices);
+      distance_out.create(num_indices);
+
+      for (int i = 0; i < batch_size; ++i) {
+        const size_t queries_start_idx = queries_row_splits[i];
+        const PointT* queries_i = queries + queries_row_splits[i];
+        const size_t num_queries_i = queries_row_splits[i + 1] - queries_row_splits[i];
+
+        WriteNeighborsIndicesAndDistances(
+          q, indices_out.ptr(), distance_out.ptr(),
+          query_neighbors_row_splits + queries_start_idx,
+          hash_table_index, hash_table_cell_splits,
+          hash_table_size, queries_i, num_queries_i, points,
+          inv_voxel_size, radius, metric, ignore_query_point,
+          return_distances);
+      }
+    }
+}
+catch (sycl::exception const& exc) {
+  std::cerr << exc.what() << "Exception caught at file:" << __FILE__
+            << ", line:" << __LINE__ << std::endl;
+  std::exit(1);
+}
+
+
+
+} // namespace impl
+} // namespace oneapi
+} // namespace pcl
+
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/kdtree_flann.hpp b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/kdtree_flann.hpp
new file mode 100644
index 000000000..bb94e0095
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/impl/kdtree_flann.hpp
@@ -0,0 +1,1042 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef PCL_ONEAPI_KDTREE_IMPL_FLANN_H_
+#define PCL_ONEAPI_KDTREE_IMPL_FLANN_H_
+
+#include <flann/algorithms/dpcpp/kdtree_dpcpp_3d_index_params.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+#include <pcl/console/print.h>
+#include <pcl/oneapi/kdtree/fixed_radius_index.h>
+#include <pcl/oneapi/utils/segmented_sort.h>
+#include <numeric>
+#include <type_traits>
+
+#include <tbb/tbb.h>
+
+#include <chrono>
+using time_point = decltype(std::chrono::steady_clock::now());
+static inline time_point get_time_point() {
+  return std::chrono::steady_clock::now();
+}
+static inline double get_duration(const time_point& from, const time_point& to) {
+  return std::chrono::duration_cast<std::chrono::duration<double>>(to - from).count();
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::KdTreeFLANN (bool sorted)
+  : pcl::KdTree<PointT> (sorted)
+  , flann_index_ ()
+  , identity_mapping_ (false)
+  , dim_ (0), total_nr_points_ (0)
+  , param_k_ (::flann::SearchParams (-1 , epsilon_))
+  , param_radius_ (::flann::SearchParams (-1, epsilon_, sorted))
+  , flann_dp_index_()
+  , fixed_radius_index_()
+{
+  sorted_ = sorted;
+  if (!std::is_same<std::size_t, pcl::index_t>::value) {
+    const auto message = "FLANN is not optimized for current index type. Will incur "
+                         "extra allocations and copy\n";
+    if (std::is_same<int, pcl::index_t>::value) {
+      PCL_DEBUG(message); // since this has been the default behavior till PCL 1.12
+    }
+    else {
+      PCL_WARN(message);
+    }
+  }
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::KdTreeFLANN (const KdTreeFLANN<PointT, Dist> &k)
+  : pcl::KdTree<PointT> (false)
+  , flann_index_ ()
+  , identity_mapping_ (false)
+  , dim_ (0), total_nr_points_ (0)
+  , param_k_ (::flann::SearchParams (-1 , epsilon_))
+  , param_radius_ (::flann::SearchParams (-1, epsilon_, false))
+{
+  *this = k;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setEpsilon (float eps)
+{
+  epsilon_ = eps;
+  param_k_ =  ::flann::SearchParams (-1 , epsilon_);
+  param_radius_ = ::flann::SearchParams (-1 , epsilon_, sorted_);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setSortedResults (bool sorted)
+{
+  sorted_ = sorted;
+  param_k_ = ::flann::SearchParams (-1, epsilon_);
+  param_radius_ = ::flann::SearchParams (-1, epsilon_, sorted_);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+template <typename PointCloudType, typename IndicesType> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloudImpl (const PointCloudType &cloud, const IndicesType &indices)
+{
+  cleanup ();   // Perform an automatic cleanup of structures
+
+  epsilon_ = 0.0f;   // default error bound value
+  dim_ = point_representation_->getNumberOfDimensions (); // Number of dimensions - default is 3 = xyz
+
+  if constexpr (std::is_same<PointCloudType, PointCloudConstPtr>::value)
+    input_ = cloud;
+  else if constexpr (std::is_same<PointCloudType, PointCloudDevConstPtr>::value)
+    input_device_ = cloud;
+
+  indices_ = indices;
+
+  // Allocate enough data
+  if (cloud->empty())
+  {
+    PCL_ERROR ("[pcl::KdTreeFLANN::setInputCloud] Invalid input!\n");
+    return;
+  }
+  if (indices != nullptr)
+  {
+    convertCloudToArray (cloud, *indices_);
+  }
+  else
+  {
+    convertCloudToArray (*cloud);
+  }
+  total_nr_points_ = static_cast<uindex_t> (index_mapping_.size ());
+  if (total_nr_points_ == 0)
+  {
+    PCL_ERROR ("[pcl::KdTreeFLANN::setInputCloud] Cannot create a KDTree with an empty input cloud!\n");
+    return;
+  }
+
+  flann_dp_index_.reset(new FLANNIndex(::flann::Matrix<float>(cloud_.get(),
+                                                              index_mapping_.size(),
+                                                              dim_),
+                                       ::flann::KDTreeDpcpp3dIndexParams(64, "GPU")));
+
+  flann_dp_index_->buildIndex();
+}
+
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloud (const PointCloudConstPtr &cloud, const IndicesConstPtr &indices)
+{
+    setInputCloudImpl(cloud, indices);
+}
+
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloud (const PointCloudDevConstPtr &cloud, const IndicesConstPtr &indices)
+{
+    setInputCloudImpl(cloud, indices);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+template <typename PointCloudType> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloudImpl (const PointCloudType &cloud, const double radius)
+{
+  cleanup ();   // Perform an automatic cleanup of structures
+
+  /* Fixed radius search haven't support Indices */
+  /* Search full cloud */
+
+  if constexpr (std::is_same<PointCloudType, PointCloudConstPtr>::value)
+    input_ = cloud;
+  else if constexpr (std::is_same<PointCloudType, PointCloudDevConstPtr>::value)
+    input_device_ = cloud;
+
+  if (cloud->empty())
+  {
+    PCL_ERROR ("[pcl::KdTreeFLANN::setInputCloud] Invalid input!\n");
+    return;
+  }
+
+  fixed_radius_index_ = std::make_shared<pcl::oneapi::FixedRadiusIndex<PointT>>(cloud, radius);
+}
+
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloud (const PointCloudConstPtr &cloud, const double radius)
+{
+  setInputCloudImpl(cloud, radius);
+}
+
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::setInputCloud (const PointCloudDevConstPtr &cloud, const double radius)
+{
+  setInputCloudImpl(cloud, radius);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+namespace pcl {
+namespace oneapi{
+namespace detail {
+// Replace using constexpr in C++17
+template <class IndexT,
+          class A,
+          class B,
+          class C,
+          class D,
+          class F,
+          CompatWithFlann<IndexT> = true>
+int
+knn_search(A& index, B& query, C& k_indices, D& dists, unsigned int k, F& params)
+{
+  // Wrap k_indices vector (no data allocation)
+  ::flann::Matrix<index_t> k_indices_mat(&k_indices[0], 1, k);
+  return index.knnSearch(query, k_indices_mat, dists, k, params);
+}
+
+template <class IndexT,
+          class A,
+          class B,
+          class C,
+          class D,
+          class F,
+          NotCompatWithFlann<IndexT> = true>
+int
+knn_search(A& index, B& query, C& k_indices, D& dists, unsigned int k, F& params)
+{
+  std::vector<std::size_t> indices(k);
+  k_indices.resize(k);
+  // Wrap indices vector (no data allocation)
+  ::flann::Matrix<std::size_t> indices_mat(&indices[0], 1, k);
+  auto ret = index.knnSearch(query, indices_mat, dists, k, params);
+  std::copy(indices.cbegin(), indices.cend(), k_indices.begin());
+  return ret;
+}
+
+template <class IndexT, class A, class B, class F, CompatWithFlann<IndexT> = true>
+int
+knn_search(A& index,
+           B& query,
+           std::vector<Indices>& k_indices,
+           std::vector<std::vector<float>>& dists,
+           unsigned int k,
+           F& params)
+{
+  return index.knnSearch(query, k_indices, dists, k, params);
+}
+
+template <class IndexT, class A, class B, class F, NotCompatWithFlann<IndexT> = true>
+int
+knn_search(A& index,
+           B& query,
+           std::vector<Indices>& k_indices,
+           std::vector<std::vector<float>>& dists,
+           unsigned int k,
+           F& params)
+{
+  std::vector<std::vector<std::size_t>> indices;
+  // flann will resize accordingly
+  auto ret = index.knnSearch(query, indices, dists, k, params);
+
+  k_indices.resize(indices.size());
+  {
+    auto it = indices.cbegin();
+    auto jt = k_indices.begin();
+    for (; it != indices.cend(); ++it, ++jt) {
+      jt->resize(it->size());
+      std::copy(it->cbegin(), it->cend(), jt->begin());
+    }
+  }
+  return ret;
+}
+} // namespace detail
+template <class FlannIndex,
+          class Query,
+          class Indices,
+          class Distances,
+          class SearchParams>
+int
+knn_search(const FlannIndex& index,
+           const Query& query,
+           Indices& indices,
+           Distances& dists,
+           unsigned int k,
+           const SearchParams& params)
+{
+  return detail::knn_search<pcl::index_t>(index, query, indices, dists, k, params);
+}
+} // namespace oneapi
+} // namespace pcl
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch (const PointT &point, unsigned int k,
+                                                Indices &k_indices,
+                                                std::vector<float> &k_distances) const
+{
+  assert (point_representation_->isValid (point) && "Invalid (NaN, Inf) point coordinates given to nearestKSearch!");
+
+  if (k > total_nr_points_)
+    k = total_nr_points_;
+
+  k_indices.resize (k);
+  k_distances.resize (k);
+
+  if (k==0)
+    return 0;
+
+  std::vector<float> query (dim_);
+  point_representation_->vectorize (static_cast<PointT> (point), query);
+
+  // Wrap the k_distances vector (no data copy)
+  ::flann::Matrix<float> k_distances_mat (&k_distances[0], 1, k);
+
+  knn_search(*flann_index_,
+             ::flann::Matrix<float>(&query[0], 1, dim_),
+             k_indices,
+             k_distances_mat,
+             k,
+             param_k_);
+
+  // Do mapping to original point cloud
+  if (!identity_mapping_)
+  {
+    for (std::size_t i = 0; i < static_cast<std::size_t> (k); ++i)
+    {
+      auto& neighbor_index = k_indices[i];
+      neighbor_index = index_mapping_[neighbor_index];
+    }
+  }
+
+  return (k);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+namespace pcl {
+namespace oneapi{
+namespace detail {
+// Replace using constexpr in C++17
+template <class IndexT,
+          class A,
+          class B,
+          class C,
+          class D,
+          class F,
+          CompatWithFlann<IndexT> = true>
+int
+radius_search(A& index, B& query, C& k_indices, D& dists, float radius, F& params)
+{
+  std::vector<pcl::Indices> indices(1);
+  int neighbors_in_radius = index.radiusSearch(query, indices, dists, radius, params);
+  k_indices = std::move(indices[0]);
+  return neighbors_in_radius;
+}
+
+template <class IndexT,
+          class A,
+          class B,
+          class C,
+          class D,
+          class F,
+          NotCompatWithFlann<IndexT> = true>
+int
+radius_search(A& index, B& query, C& k_indices, D& dists, float radius, F& params)
+{
+  std::vector<std::vector<std::size_t>> indices(1);
+  int neighbors_in_radius = index.radiusSearch(query, indices, dists, radius, params);
+  k_indices.resize(indices[0].size());
+  std::copy(indices[0].cbegin(), indices[0].cend(), k_indices.begin());
+  return neighbors_in_radius;
+}
+
+template <class IndexT, class A, class B, class F, CompatWithFlann<IndexT> = true>
+int
+radius_search(A& index,
+              B& query,
+              std::vector<Indices>& k_indices,
+              std::vector<std::vector<float>>& dists,
+              float radius,
+              F& params)
+{
+  return index.radiusSearch(query, k_indices, dists, radius, params);
+}
+
+template <class IndexT, class A, class B, class F, NotCompatWithFlann<IndexT> = true>
+int
+radius_search(A& index,
+              B& query,
+              std::vector<Indices>& k_indices,
+              std::vector<std::vector<float>>& dists,
+              float radius,
+              F& params)
+{
+  std::vector<std::vector<std::size_t>> indices;
+  // flann will resize accordingly
+  auto ret = index.radiusSearch(query, indices, dists, radius, params);
+
+  k_indices.resize(indices.size());
+  {
+    auto it = indices.cbegin();
+    auto jt = k_indices.begin();
+    for (; it != indices.cend(); ++it, ++jt) {
+      jt->resize(it->size());
+      std::copy(it->cbegin(), it->cend(), jt->begin());
+    }
+  }
+  return ret;
+}
+} // namespace detail
+template <class FlannIndex,
+          class Query,
+          class Indices,
+          class Distances,
+          class SearchParams>
+int
+radius_search(const FlannIndex& index,
+              const Query& query,
+              Indices& indices,
+              Distances& dists,
+              float radius,
+              const SearchParams& params)
+{
+  return detail::radius_search<pcl::index_t>(
+      index, query, indices, dists, radius, params);
+}
+} // namespace oneapi
+} // namespace pcl
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearch (const PointT &point, double radius, Indices &k_indices,
+                                              std::vector<float> &k_sqr_dists, unsigned int max_nn) const
+{
+  assert (point_representation_->isValid (point) && "Invalid (NaN, Inf) point coordinates given to radiusSearch!");
+
+  std::vector<float> query (dim_);
+  point_representation_->vectorize (static_cast<PointT> (point), query);
+
+  // Has max_nn been set properly?
+  if (max_nn == 0 || max_nn > total_nr_points_)
+    max_nn = total_nr_points_;
+
+  std::vector<std::vector<float> > dists(1);
+
+  ::flann::SearchParams params (param_radius_);
+  if (max_nn == total_nr_points_)
+    params.max_neighbors = -1;  // return all neighbors in radius
+  else
+    params.max_neighbors = max_nn;
+
+  auto query_mat = ::flann::Matrix<float>(&query[0], 1, dim_);
+  int neighbors_in_radius = radius_search(*flann_index_,
+                                          query_mat,
+                                          k_indices,
+                                          dists,
+                                          static_cast<float>(radius * radius),
+                                          params);
+
+  k_sqr_dists = dists[0];
+
+  // Do mapping to original point cloud
+  if (!identity_mapping_)
+  {
+    for (int i = 0; i < neighbors_in_radius; ++i)
+    {
+      auto& neighbor_index = k_indices[i];
+      neighbor_index = index_mapping_[neighbor_index];
+    }
+  }
+
+  return (neighbors_in_radius);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist> void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::cleanup ()
+{
+  // Data array cleanup
+  index_mapping_.clear ();
+
+  if (indices_)
+    indices_.reset ();
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+template <typename CloudT>
+void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::convertCloudToArray (const CloudT &cloud)
+{
+  // No point in doing anything if the array is empty
+  if (cloud.empty ())
+  {
+    cloud_.reset ();
+    return;
+  }
+
+  const auto original_no_of_points = cloud.size ();
+
+  cloud_.reset (new float[original_no_of_points * dim_], std::default_delete<float[]> ());
+  float* cloud_ptr = cloud_.get ();
+  index_mapping_.reserve (original_no_of_points);
+  identity_mapping_ = true;
+
+  for (std::size_t cloud_index = 0; cloud_index < original_no_of_points; ++cloud_index)
+  {
+    // Check if the point is invalid
+    if (!point_representation_->isValid (cloud[cloud_index]))
+    {
+      identity_mapping_ = false;
+      continue;
+    }
+
+    index_mapping_.push_back (cloud_index);
+
+    point_representation_->vectorize (cloud[cloud_index], cloud_ptr);
+    cloud_ptr += dim_;
+  }
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+template <typename CloudT>
+void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::convertCloudToArray (const CloudT &cloud, ::flann::Matrix<float> &device_cloud)
+{
+  const auto original_no_of_points = cloud->size ();
+
+  pcl::oneapi::DeviceArray<int> valid_indices (original_no_of_points);
+  int cur_ptr = 0;
+  for (int i = 0; i < valid_indices.size(); ++i)
+  {
+    if (!point_representation_->isValid((*cloud)[i]))
+    {
+      valid_indices[i] = -1;
+    }
+    else
+    {
+      valid_indices[i] = cur_ptr;
+      cur_ptr += dim_;
+    }
+  }
+
+  tbb::parallel_for(tbb::blocked_range<size_t>(0, cloud->size()),
+    [&](const tbb::blocked_range<size_t> &range) {
+       for (int cloud_index = range.begin(); cloud_index < range.end(); cloud_index++)
+  {
+    if (valid_indices[cloud_index] != -1)
+    {
+      float *cloud_ptr = device_cloud.ptr() + valid_indices[cloud_index];
+      point_representation_->vectorize((*cloud)[cloud_index], cloud_ptr);
+    }
+  }
+  });
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, typename Dist>
+template <typename CloudT>
+void
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::convertCloudToArray (const CloudT &cloud, const Indices &indices)
+{
+  // No point in doing anything if the array is empty
+  if (cloud->empty ())
+  {
+    cloud_.reset ();
+    return;
+  }
+
+  int original_no_of_points = static_cast<int> (indices.size ());
+
+  cloud_.reset (new float[original_no_of_points * dim_], std::default_delete<float[]> ());
+  float* cloud_ptr = cloud_.get ();
+  index_mapping_.reserve (original_no_of_points);
+  // its a subcloud -> false
+  // true only identity:
+  //     - indices size equals cloud size
+  //     - indices only contain values between 0 and cloud.size - 1
+  //     - no index is multiple times in the list
+  //     => index is complete
+  // But we can not guarantee that => identity_mapping_ = false
+  identity_mapping_ = false;
+
+  for (const auto &index : indices)
+  {
+    // Check if the point is invalid
+    if (!point_representation_->isValid ((*cloud)[index]))
+      continue;
+
+    // map from 0 - N -> indices [0] - indices [N]
+    index_mapping_.push_back (index);  // If the returned index should be for the indices vector
+
+    point_representation_->vectorize ((*cloud)[index], cloud_ptr);
+    cloud_ptr += dim_;
+  }
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearchImpl(const PointCloudType &cloud,
+  int k, std::vector<std::vector<int>> &indices, std::vector<std::vector<float>> &distances)
+{
+  pcl::oneapi::DeviceArray<float> device_query(cloud->size() * dim_);
+  ::flann::Matrix<float> query_mat(device_query.ptr(), cloud->size(), dim_);
+
+  convertCloudToArray(cloud, query_mat);
+
+  int num;
+  int buffer_size = cloud->size() * k;
+  pcl::oneapi::DeviceArray<int> device_ind(buffer_size);
+  ::flann::Matrix<int> device_indices(device_ind.ptr(), cloud->size(), k);
+  pcl::oneapi::DeviceArray<float> device_dist(buffer_size);
+  ::flann::Matrix<float> device_distances(device_dist.ptr(), cloud->size(), k);
+  param_k_.matrices_in_gpu_ram = true;
+  param_k_.use_heap = flann::FLANN_True;
+  num = flann_dp_index_->knnSearch(query_mat, device_indices, device_distances, k, param_k_);
+
+  indices.resize(cloud->size());
+  distances.resize(cloud->size());
+
+  int rows = cloud->size();
+  for (size_t i = 0; i < rows; i++)
+  {
+    indices[i].resize(k);
+    distances[i].resize(k);
+    for (size_t j = 0; j < k; j++)
+    {
+      indices[i][j] = device_indices[i][j];
+      distances[i][j] = device_distances[i][j];
+    }
+  }
+
+  return num;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudConstPtr &cloud,
+  int k, std::vector<std::vector<int>> &indices, std::vector<std::vector<float>> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudDevConstPtr &cloud,
+  int k, std::vector<std::vector<int>> &indices, std::vector<std::vector<float>> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearchImpl(const PointCloudType &cloud,
+  int k, std::vector<int> &indices, std::vector<float> &distances)
+{
+  pcl::oneapi::DeviceArray<float> device_query(cloud->size() * dim_);
+  flann::Matrix<float> query_mat(device_query.ptr(), cloud->size(), dim_);
+
+  convertCloudToArray(cloud, query_mat);
+
+  int num;
+  int buffer_size = cloud->size() * k;
+  pcl::oneapi::DeviceArray<int> device_ind(buffer_size);
+  flann::Matrix<int> device_indices(device_ind.ptr(), cloud->size(), k);
+  pcl::oneapi::DeviceArray<float> device_dist(buffer_size);
+  flann::Matrix<float> device_distances(device_dist.ptr(), cloud->size(), k);
+  param_k_.matrices_in_gpu_ram = true;
+  param_k_.use_heap = flann::FLANN_True;
+  num = flann_dp_index_->knnSearch(query_mat, device_indices, device_distances, k, param_k_);
+
+  indices.insert(indices.end(), device_indices[0], device_indices[0] + buffer_size);
+  distances.insert(distances.end(), device_distances[0], device_distances[0] + buffer_size);
+
+  return num;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudConstPtr &cloud,
+  int k, std::vector<int> &indices, std::vector<float> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudDevConstPtr &cloud,
+  int k, std::vector<int> &indices, std::vector<float> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearchImpl(const PointCloudType &cloud,
+  int k, pcl::oneapi::DeviceArray2D<int> &indices, pcl::oneapi::DeviceArray2D<float> &distances)
+{
+  pcl::oneapi::DeviceArray<float> device_query(cloud->size() * dim_);
+  flann::Matrix<float> query_mat(device_query.ptr(), cloud->size(), dim_);
+
+  convertCloudToArray(cloud, query_mat);
+
+  int num;
+
+  pcl::oneapi::DeviceArray2D<int> device_ind;
+  device_ind.create(cloud->size(), k, sizeof(int));
+  pcl::oneapi::DeviceArray2D<float> device_dist;
+  device_dist.create(cloud->size(), k, sizeof(float));
+
+  flann::Matrix<float> flann_distances(device_dist.ptr(), cloud->size(), k);
+  flann::Matrix<int> flann_indices(device_ind.ptr(), cloud->size(), k);
+
+  param_k_.matrices_in_gpu_ram = true;
+  param_k_.use_heap = flann::FLANN_True;
+  num = flann_dp_index_->knnSearch(query_mat, flann_indices, flann_distances, k, param_k_);
+  indices = device_ind;
+  distances = device_dist;
+
+  return num;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudConstPtr &cloud,
+  int k, pcl::oneapi::DeviceArray2D<int> &indices, pcl::oneapi::DeviceArray2D<float> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudDevConstPtr &cloud,
+  int k, pcl::oneapi::DeviceArray2D<int> &indices, pcl::oneapi::DeviceArray2D<float> &distances)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances);
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearchImpl(const PointCloudType &cloud, int k,
+    pcl::oneapi::DeviceArray<int> &indices, pcl::oneapi::DeviceArray<float> &distances,
+    pcl::oneapi::DeviceArray<int> &splits)
+{
+  pcl::oneapi::DeviceArray<float> device_query(cloud->size() * dim_);
+  flann::Matrix<float> query_mat(device_query.ptr(), cloud->size(), dim_);
+
+  convertCloudToArray(cloud, query_mat);
+
+  int num;
+  int buffer_size = cloud->size() * k;
+  pcl::oneapi::DeviceArray<int> device_ind(buffer_size);
+  pcl::oneapi::DeviceArray<float> device_dist(buffer_size);
+  flann::Matrix<int> flann_indices(device_ind.ptr(), cloud->size(), k);
+  flann::Matrix<float> flann_distances(device_dist.ptr(), cloud->size(), k);
+  param_k_.matrices_in_gpu_ram = true;
+  param_k_.use_heap = flann::FLANN_True;
+  num = flann_dp_index_->knnSearch(query_mat, flann_indices, flann_distances, k, param_k_);
+
+  splits.resize(cloud->size()+1);
+  std::fill(splits.begin(), splits.end(), k);
+  std::exclusive_scan(splits.begin(), splits.end(), splits.begin(), 0);
+
+  indices = device_ind;
+  distances = device_dist;
+
+  return num;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudConstPtr &cloud, int k,
+    pcl::oneapi::DeviceArray<int> &indices, pcl::oneapi::DeviceArray<float> &distances,
+    pcl::oneapi::DeviceArray<int> &splits)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances, splits);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointCloudDevConstPtr &cloud, int k,
+    pcl::oneapi::DeviceArray<int> &indices, pcl::oneapi::DeviceArray<float> &distances,
+    pcl::oneapi::DeviceArray<int> &splits)
+{
+  return nearestKSearchImpl(cloud, k, indices, distances, splits);
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearchImpl (const PointCloudType &cloud, double radius, std::vector<std::vector<int>> &k_indices,
+                                              std::vector<std::vector<float>> &k_sqr_dists, unsigned int max_nn)
+{
+
+  ::flann::Matrix<float> query_mat(new float[cloud->size() * dim_], cloud->size(), dim_);
+
+  convertCloudToArray(cloud, query_mat);
+
+  // Has max_nn been set properly?
+  if (max_nn == 0 || max_nn > total_nr_points_)
+    max_nn = total_nr_points_;
+
+  ::flann::SearchParams params (param_radius_);
+  if (max_nn == total_nr_points_)
+    params.max_neighbors = -1;  // return all neighbors in radius
+  else
+    params.max_neighbors = max_nn;
+
+  int neighbors_in_radius;
+  sycl::queue q = dpct::get_default_queue();
+
+  if (params.sorted)
+  {
+    // FLANN sort is very slow.  Use internal segmented sort
+    params.sorted = false;
+    if (q.get_device().is_gpu())
+    {
+      ::flann::Matrix<int> non_sort_indices;
+      ::flann::Matrix<float> non_sort_distances;
+      ::flann::Matrix<int> splits;
+
+      neighbors_in_radius = flann_dp_index_->radiusSearch(
+                                          query_mat,
+                                          non_sort_indices,
+                                          non_sort_distances,
+                                          splits,
+                                          static_cast<float>(radius * radius),
+                                          params);
+
+      /*  Need manually free it as this memory alloc from flann */
+      pcl::oneapi::DeviceArray<int> device_indices(&non_sort_indices[0][0], non_sort_indices.rows);
+      pcl::oneapi::DeviceArray<float> device_distances(&non_sort_distances[0][0], non_sort_distances.rows);
+      //pcl::oneapi::DeviceArray<int> device_splits(&splits[0][0], splits.rows -1);
+      pcl::oneapi::DeviceArray<int> device_splits(&splits[0][0], splits.rows);
+
+      pcl::oneapi::DeviceArray<int> sorted_indices(non_sort_indices.rows);
+      pcl::oneapi::DeviceArray<float> sorted_distances(non_sort_distances.rows);
+
+      pcl::oneapi::SegmentedSortPairs(device_distances,
+                                        device_indices,
+                                        sorted_distances,
+                                        sorted_indices,
+                                        device_splits,
+                                        device_indices.size(),
+                                        device_splits.size());
+
+      k_indices.resize(cloud->size());
+      k_sqr_dists.resize(cloud->size());
+
+      for (int i = 0; i < cloud->size(); i++)
+      {
+        int counts;
+        counts = splits[0][i+1] - splits[0][i];
+
+        k_indices[i].assign(sorted_indices.begin() + device_splits[i],
+            sorted_indices.begin() + device_splits[i] + counts);
+
+        k_sqr_dists[i].assign(sorted_distances.begin() + device_splits[i],
+            sorted_distances.begin() + device_splits[i] + counts);
+
+      }
+
+      sycl::free(&non_sort_indices[0][0], q);
+      sycl::free(&non_sort_distances[0][0], q);
+      sycl::free(&splits[0][0], q);
+    }
+    else
+    {
+      neighbors_in_radius = flann_dp_index_->radiusSearch(
+                                          query_mat,
+                                          k_indices,
+                                          k_sqr_dists,
+                                          static_cast<float>(radius * radius),
+                                          params);
+
+      tbb::parallel_for(tbb::blocked_range<size_t>(0, cloud->size()),
+        [&](const tbb::blocked_range<size_t> &range) {
+          for (int i = range.begin(); i < range.end(); i++)
+          {
+            auto input_begin = ::oneapi::dpl::make_zip_iterator(k_sqr_dists[i].data(),
+              k_indices[i].data());
+
+            tbb::parallel_sort(input_begin, input_begin + k_indices[i].size(),
+              [](auto lhs, auto rhs) { return std::get<0>(lhs) < std::get<0>(rhs); });
+          }
+      });
+    }
+  }
+  else
+  {
+    // No sort option
+    neighbors_in_radius = flann_dp_index_->radiusSearch(
+                                          query_mat,
+                                          k_indices,
+                                          k_sqr_dists,
+                                          static_cast<float>(radius * radius),
+                                          params);
+
+  }
+
+  free(query_mat.ptr());
+  return neighbors_in_radius;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearch (const PointCloudConstPtr &cloud, double radius, std::vector<std::vector<int>> &k_indices,
+                                              std::vector<std::vector<float>> &k_sqr_dists, unsigned int max_nn)
+{
+    return radiusSearchImpl(cloud, radius, k_indices, k_sqr_dists, max_nn);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearch (const PointCloudDevConstPtr &cloud, double radius, std::vector<std::vector<int>> &k_indices,
+                                              std::vector<std::vector<float>> &k_sqr_dists, unsigned int max_nn)
+{
+    return radiusSearchImpl(cloud, radius, k_indices, k_sqr_dists, max_nn);
+}
+
+template <typename PointT, typename Dist>
+template <typename PointCloudType> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearchImpl (const PointCloudType &cloud, double radius, std::vector<int> &k_indices,
+                                              std::vector<float> &k_sqr_dists, std::vector<int> &k_segments, 
+                                              unsigned int start, unsigned int end, unsigned int max_nn)
+{
+  auto process_size = end - start;
+  ::flann::Matrix<float> query_mat(new float[process_size * dim_], process_size, dim_);
+  float *cloud_ptr = query_mat.ptr();
+  for (std::size_t cloud_index = start; cloud_index < end; ++cloud_index)
+  {
+    // Check if the point is invalid
+    if (!point_representation_->isValid((*cloud)[cloud_index]))
+    {
+      continue;
+    }
+    point_representation_->vectorize((*cloud)[cloud_index], cloud_ptr);
+    cloud_ptr += dim_;
+  }
+
+  // Has max_nn been set properly?
+  if (max_nn == 0 || max_nn > total_nr_points_)
+    max_nn = total_nr_points_;
+
+  ::flann::SearchParams params (param_radius_);
+  if (max_nn == total_nr_points_)
+    params.max_neighbors = -1;  // return all neighbors in radius
+  else
+    params.max_neighbors = max_nn;
+
+  int neighbors_in_radius = flann_dp_index_->radiusSearch(
+                                          query_mat,
+                                          k_indices,
+                                          k_sqr_dists,
+                                          k_segments,
+                                          static_cast<float>(radius * radius),
+                                          params);
+
+  free(query_mat.ptr());
+  return neighbors_in_radius;
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearch (const PointCloudConstPtr &cloud, double radius, std::vector<int> &k_indices,
+                                              std::vector<float> &k_sqr_dists, std::vector<int> &k_segments, 
+                                              unsigned int start, unsigned int end, unsigned int max_nn)
+{
+  return radiusSearchImpl(cloud, radius, k_indices, k_sqr_dists, k_segments, start, end, max_nn);
+}
+
+template <typename PointT, typename Dist>
+int pcl::oneapi::KdTreeFLANN<PointT, Dist>::radiusSearch (const PointCloudDevConstPtr &cloud, double radius, std::vector<int> &k_indices,
+                                              std::vector<float> &k_sqr_dists, std::vector<int> &k_segments, 
+                                              unsigned int start, unsigned int end, unsigned int max_nn)
+{
+  return radiusSearchImpl(cloud, radius, k_indices, k_sqr_dists, k_segments, start, end, max_nn);
+}
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::fixedRadiusSearch (const PointCloudConstPtr &query,
+                                              std::vector<int> &k_indices,
+                                              std::vector<float> &k_sqr_dists,
+                                              std::vector<int> &k_segments)
+{
+  if (fixed_radius_index_ == nullptr)
+    return -1;
+
+  return fixed_radius_index_->radiusSearch(query, k_indices, k_sqr_dists, k_segments,
+      0, query->size(), sorted_);
+}
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::fixedRadiusSearch (const PointCloudDevConstPtr &query,
+                                             // double radius,
+                                              DeviceArray<int> &k_indices,
+                                              DeviceArray<float> &k_sqr_dists,
+                                              DeviceArray<int> &k_segments)
+{
+  if (fixed_radius_index_ == nullptr)
+    return -1;
+
+  // radius param will ignore
+  //(void) radius;
+
+  return fixed_radius_index_->radiusSearch(query, k_indices, k_sqr_dists, k_segments,
+      0, query->size(), sorted_);
+}
+
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::fixedRadiusSearch (const PointCloudDevConstPtr &query,
+                                              DeviceArray<int> &k_indices,
+                                              DeviceArray<float> &k_sqr_dists,
+                                              DeviceArray<int> &k_segments,
+                                              const int start,
+                                              const int end)
+{
+  if (fixed_radius_index_ == nullptr)
+    return -1;
+  return fixed_radius_index_->radiusSearch(query, k_indices, k_sqr_dists, k_segments,
+      start, end, sorted_);
+}
+
+template <typename PointT, typename Dist> int
+pcl::oneapi::KdTreeFLANN<PointT, Dist>::fixedRadiusSearch (const PointCloudDevConstPtr &query,
+                                              const std::vector<int32_t>& query_row_splits,
+                                              DeviceArray<int> &k_indices,
+                                              DeviceArray<float> &k_sqr_dists,
+                                              DeviceArray<int> &k_segments)
+{
+  if (fixed_radius_index_ == nullptr)
+    return -1;
+
+  return fixed_radius_index_->radiusSearch(query, query_row_splits, k_indices,
+                              k_sqr_dists, k_segments, sorted_);
+}
+
+
+
+#define PCL_INSTANTIATE_OneAPI_KdTreeFLANN(T) template class PCL_EXPORTS pcl::oneapi::KdTreeFLANN<T>;
+
+#endif //#ifndef _PCL_ONEAPI_KDTREE_IMPL_FLANN_H_
+
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/kdtree_flann.h b/oneapi/kdtree/include/pcl/oneapi/kdtree/kdtree_flann.h
new file mode 100644
index 000000000..20fb33ba6
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/kdtree_flann.h
@@ -0,0 +1,524 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id: kdtree_flann.h 36261 2011-02-26 01:34:42Z mariusm $
+ *
+ */
+
+#pragma once
+
+#include <flann/flann.hpp>
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/kdtree/kdtree.h>
+#include <flann/util/params.h>
+
+// Forward declarations
+namespace flann
+{
+  template <typename T> struct L2_Simple;
+  template <typename T> class Index;
+}
+
+namespace pcl
+{
+namespace oneapi {
+namespace detail {
+// Helper struct to create a compatible Matrix and copy data back when needed
+// Replace using if constexpr in C++17
+template <typename IndexT>
+struct compat_with_flann : std::false_type {};
+
+template <>
+struct compat_with_flann<std::size_t> : std::true_type {};
+
+template <typename IndexT>
+using CompatWithFlann = std::enable_if_t<compat_with_flann<IndexT>::value, bool>;
+template <typename IndexT>
+using NotCompatWithFlann = std::enable_if_t<!compat_with_flann<IndexT>::value, bool>;
+} // namespace detail
+
+template <typename PointT> class FixedRadiusIndex;
+/**
+ * @brief Comaptibility template function to allow use of various types of indices with
+ * FLANN
+ * @details Template is used for all params to not constrain any FLANN side capability
+ * @param[in,out] index A index searcher, of type ::flann::Index<Dist> or similar, where
+ * Dist is a template for computing distance between 2 points
+ * @param[in] query A ::flann::Matrix<float> or compatible matrix representation of the
+ * query point
+ * @param[out] indices Indices found in radius
+ * @param[out] dists Computed distance matrix
+ * @param[in] radius Threshold for consideration
+ * @param[in] params Any parameters to pass to the radius_search call
+ */
+template <class FlannIndex,
+          class Query,
+          class Indices,
+          class Distances,
+          class SearchParams>
+int
+radius_search(const FlannIndex& index,
+              const Query& query,
+              Indices& indices,
+              Distances& dists,
+              float radius,
+              const SearchParams& params);
+
+/**
+ * @brief Comaptibility template function to allow use of various types of indices with
+ * FLANN
+ * @details Template is used for all params to not constrain any FLANN side capability
+ * @param[in,out] index A index searcher, of type ::flann::Index<Dist> or similar, where
+ * Dist is a template for computing distance between 2 points
+ * @param[in] query A ::flann::Matrix<float> or compatible matrix representation of the
+ * query point
+ * @param[out] indices Neighboring k indices found
+ * @param[out] dists Computed distance matrix
+ * @param[in] k Number of neighbors to search for
+ * @param[in] params Any parameters to pass to the knn_search call
+ */
+template <class FlannIndex,
+          class Query,
+          class Indices,
+          class Distances,
+          class SearchParams>
+int
+knn_search(const FlannIndex& index,
+           const Query& query,
+           Indices& indices,
+           Distances& dists,
+           unsigned int k,
+           const SearchParams& params);
+
+/** \brief KdTreeFLANN is a generic type of 3D spatial locator using kD-tree structures.
+ * The class is making use of the FLANN (Fast Library for Approximate Nearest Neighbor)
+ * project by Marius Muja and David Lowe.
+ *
+ * \author Radu B. Rusu, Marius Muja
+ * \ingroup kdtree
+ */
+template <typename PointT, typename Dist = ::flann::L2_Simple<float>>
+class PCL_EXPORTS KdTreeFLANN : public pcl::KdTree<PointT> {
+public:
+  using KdTree<PointT>::input_;
+  using KdTree<PointT>::indices_;
+  using KdTree<PointT>::epsilon_;
+  using KdTree<PointT>::sorted_;
+  using KdTree<PointT>::point_representation_;
+  using KdTree<PointT>::nearestKSearch;
+  using KdTree<PointT>::radiusSearch;
+
+  using PointCloud = typename KdTree<PointT>::PointCloud;
+  using PointCloudConstPtr = typename KdTree<PointT>::PointCloudConstPtr;
+  using PointCloudDev = pcl::oneapi::PointCloudDev<PointT>;
+  using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+  using IndicesPtr = shared_ptr<Indices>;
+  using IndicesConstPtr = shared_ptr<const Indices>;
+
+  using IndicesDev = typename pcl::oneapi::DeviceArray<index_t>;
+  using IndicesDevPtr = shared_ptr<IndicesDev>;
+  using IndicesDevConstPtr = shared_ptr<const IndicesDev>;
+
+  using FLANNIndex = ::flann::Index<Dist>;
+
+  using FixedIndex = pcl::oneapi::FixedRadiusIndex<PointT>;
+  // Boost shared pointers
+  using Ptr = shared_ptr<KdTreeFLANN<PointT, Dist>>;
+  using ConstPtr = shared_ptr<const KdTreeFLANN<PointT, Dist>>;
+
+  /** \brief Default Constructor for KdTreeFLANN.
+   * \param[in] sorted set to true if the application that the tree will be used for
+   * requires sorted nearest neighbor indices (default). False otherwise.
+   *
+   * By setting sorted to false, the \ref radiusSearch operations will be faster.
+   */
+  KdTreeFLANN(bool sorted = true);
+
+  /** \brief Copy constructor
+   * \param[in] k the tree to copy into this
+   */
+  KdTreeFLANN(const KdTreeFLANN<PointT, Dist>& k);
+
+  /** \brief Copy operator
+   * \param[in] k the tree to copy into this
+   */
+  inline KdTreeFLANN<PointT, Dist>&
+  operator=(const KdTreeFLANN<PointT, Dist>& k)
+  {
+    KdTree<PointT>::operator=(k);
+    flann_index_ = k.flann_index_;
+    cloud_ = k.cloud_;
+    index_mapping_ = k.index_mapping_;
+    identity_mapping_ = k.identity_mapping_;
+    dim_ = k.dim_;
+    total_nr_points_ = k.total_nr_points_;
+    param_k_ = k.param_k_;
+    param_radius_ = k.param_radius_;
+    flann_dp_index_ = k.flann_dp_index_;
+    return (*this);
+  }
+
+  /** \brief Set the search epsilon precision (error bound) for nearest neighbors
+   * searches. \param[in] eps precision (error bound) for nearest neighbors searches
+   */
+  void
+  setEpsilon(float eps) override;
+
+  void
+  setSortedResults(bool sorted);
+
+  inline Ptr
+  makeShared()
+  {
+    return Ptr(new KdTreeFLANN<PointT, Dist>(*this));
+  }
+
+  /** \brief Destructor for KdTreeFLANN.
+   * Deletes all allocated data arrays and destroys the kd-tree structures.
+   */
+  ~KdTreeFLANN() { cleanup(); }
+
+
+  /** \brief Get a pointer to the input point cloud dataset. */
+  inline PointCloudDevConstPtr
+  getInputCloudDev () const
+  {
+    return (input_device_);
+  }
+
+
+
+
+  /** \brief Provide a pointer to the input dataset.
+   * \param[in] cloud the const boost shared pointer to a PointCloud message
+   * \param[in] indices the point indices subset that is to be used from \a cloud - if
+   * NULL the whole cloud is used
+   */
+  void
+  setInputCloud(const PointCloudConstPtr& cloud,
+                const IndicesConstPtr& indices = IndicesConstPtr()) override;
+  void
+  setInputCloud(const PointCloudDevConstPtr& cloud,
+                const IndicesConstPtr& indices = IndicesConstPtr());
+
+  void
+  setInputCloud(const PointCloudConstPtr& cloud, const double radius);
+
+  void
+  setInputCloud(const PointCloudDevConstPtr& cloud, const double radius);
+
+  /** \brief Search for k-nearest neighbors for the given query point.
+   *
+   * \attention This method does not do any bounds checking for the input index
+   * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+   *
+   * \param[in] point a given \a valid (i.e., finite) query point
+   * \param[in] k the number of neighbors to search for
+   * \param[out] k_indices the resultant indices of the neighboring points (must be
+   * resized to \a k a priori!) \param[out] k_sqr_distances the resultant squared
+   * distances to the neighboring points (must be resized to \a k a priori!) \return
+   * number of neighbors found
+   *
+   * \exception asserts in debug mode if the index is not between 0 and the maximum
+   * number of points
+   */
+  int
+  nearestKSearch(const PointT& point,
+                 unsigned int k,
+                 Indices& k_indices,
+                 std::vector<float>& k_sqr_distances) const override;
+
+  int
+  nearestKSearch(const PointCloudConstPtr &cloud,
+                 int k,
+                 std::vector<std::vector<int>>& indices,
+                 std::vector<std::vector<float>>& distance);
+
+  int
+  nearestKSearch(const PointCloudDevConstPtr &cloud,
+                 int k,
+                 std::vector<std::vector<int>>& indices,
+                 std::vector<std::vector<float>>& distance);
+
+  int
+  nearestKSearch(const PointCloudConstPtr &cloud,
+                 int k,
+                 std::vector<int>& indices,
+                 std::vector<float>& distance);
+
+  int
+  nearestKSearch(const PointCloudDevConstPtr &cloud,
+                 int k,
+                 std::vector<int>& indices,
+                 std::vector<float>& distance);
+
+  int
+  nearestKSearch(const PointCloudConstPtr &cloud,
+                 int k,
+                 pcl::oneapi::DeviceArray2D<int>& indices,
+                 pcl::oneapi::DeviceArray2D<float>& distance);
+
+  int
+  nearestKSearch(const PointCloudDevConstPtr &cloud,
+                 int k,
+                 pcl::oneapi::DeviceArray2D<int>& indices,
+                 pcl::oneapi::DeviceArray2D<float>& distance);
+
+  int
+  nearestKSearch(const PointCloudConstPtr &cloud,
+                 int k,
+                 pcl::oneapi::DeviceArray<int>& indices,
+                 pcl::oneapi::DeviceArray<float>& distance,
+                 pcl::oneapi::DeviceArray<int> & splits);
+
+  int
+  nearestKSearch(const PointCloudDevConstPtr &cloud,
+                 int k,
+                 pcl::oneapi::DeviceArray<int>& indices,
+                 pcl::oneapi::DeviceArray<float>& distance,
+                 pcl::oneapi::DeviceArray<int> & splits);
+
+  /** \brief Search for all the nearest neighbors of the query point in a given radius.
+   *
+   * \attention This method does not do any bounds checking for the input index
+   * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+   *
+   * \param[in] point a given \a valid (i.e., finite) query point
+   * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+   * \param[out] k_indices the resultant indices of the neighboring points
+   * \param[out] k_sqr_distances the resultant squared distances to the neighboring
+   * points \param[in] max_nn if given, bounds the maximum returned neighbors to this
+   * value. If \a max_nn is set to 0 or to a number higher than the number of points in
+   * the input cloud, all neighbors in \a radius will be returned. \return number of
+   * neighbors found in radius
+   *
+   * \exception asserts in debug mode if the index is not between 0 and the maximum
+   * number of points
+   */
+  int
+  radiusSearch(const PointT& point,
+               double radius,
+               Indices& k_indices,
+               std::vector<float>& k_sqr_distances,
+               unsigned int max_nn = 0) const override;
+  int
+  radiusSearch(const PointCloudConstPtr &cloud,
+               double radius,
+               std::vector<std::vector<int>> &k_indices,
+               std::vector<std::vector<float>> &k_sqr_dists,
+               unsigned int max_nn = 0);
+
+  int
+  radiusSearch(const PointCloudDevConstPtr &cloud,
+               double radius,
+               std::vector<std::vector<int>> &k_indices,
+               std::vector<std::vector<float>> &k_sqr_dists,
+               unsigned int max_nn = 0);
+
+  int
+  radiusSearch(const PointCloudConstPtr &cloud,
+               double radius,
+               std::vector<int> &k_indices,
+               std::vector<float> &k_sqr_dists,
+               std::vector<int> &k_segments,
+               unsigned int start,
+               unsigned int end,
+               unsigned int max_nn = 0);
+
+  int
+  radiusSearch(const PointCloudDevConstPtr &cloud,
+               double radius,
+               std::vector<int> &k_indices,
+               std::vector<float> &k_sqr_dists,
+               std::vector<int> &k_segments,
+               unsigned int start,
+               unsigned int end,
+               unsigned int max_nn = 0);
+
+  int
+  fixedRadiusSearch (const PointCloudConstPtr &query,
+                std::vector<int> &k_indices,
+                std::vector<float> &k_sqr_dists,
+                std::vector<int> &k_segments);
+
+  int
+  fixedRadiusSearch (const PointCloudDevConstPtr &query,
+              //  double radius,
+                DeviceArray<int> &k_indices,
+                DeviceArray<float> &k_sqr_dists,
+                DeviceArray<int> &k_segments);
+
+  int
+  fixedRadiusSearch (const PointCloudDevConstPtr &query,
+                DeviceArray<int> &k_indices,
+                DeviceArray<float> &k_sqr_dists,
+                DeviceArray<int> &k_segments,
+                const int start,
+                const int end);
+
+  int
+  fixedRadiusSearch (const PointCloudDevConstPtr &query,
+                const std::vector<int>& query_splits,
+                DeviceArray<int> &k_indices,
+                DeviceArray<float> &k_sqr_dists,
+                DeviceArray<int> &k_segments);
+private:
+  /** \brief Internal cleanup method. */
+  void
+  cleanup();
+
+  template <typename PointCloudType, typename IndicesType>
+  void setInputCloudImpl(const PointCloudType& cloud, const IndicesType& indices);
+
+  template <typename PointCloudType>
+  void setInputCloudImpl(const PointCloudType& cloud, const double radius);
+
+  /** \brief Converts a PointCloud to the internal FLANN point array representation.
+   * Returns the number of points. \param cloud the PointCloud
+   */
+  template <typename CloudT>
+  void
+  convertCloudToArray(const CloudT& cloud);
+
+  /** \brief Converts a PointCloud with a given set of indices to the internal FLANN
+   * point array representation. Returns the number of points. \param[in] cloud the
+   * PointCloud data \param[in] indices the point cloud indices
+   */
+  template <typename CloudT>
+  void
+  convertCloudToArray(const CloudT& cloud, const Indices& indices);
+
+  /** \brief Converts a PointCloud to the internal FLANN point array representation.
+   * Returns the number of points. \param cloud the PointCloud
+   */
+  template <typename CloudT>
+  void
+  convertCloudToArray(const CloudT& cloud, ::flann::Matrix<float>& device_cloud);
+
+  template <typename PointCloudType>
+  int radiusSearchImpl(const PointCloudType &cloud,
+              double radius,
+              std::vector<std::vector<int>> &k_indices,
+              std::vector<std::vector<float>> &k_sqr_dists,
+              unsigned int max_nn = 0);
+
+  template <typename PointCloudType>
+  int radiusSearchImpl(const PointCloudType &cloud,
+              double radius,
+              std::vector<int> &k_indices,
+              std::vector<float> &k_sqr_dists,
+              std::vector<int> &k_segments,
+              unsigned int start,
+              unsigned int end,
+              unsigned int max_nn = 0);
+
+  template <typename PointCloudType>
+  int nearestKSearchImpl(const PointCloudType &cloud,
+              int k,
+              std::vector<std::vector<int>>& indices,
+              std::vector<std::vector<float>>& distance);
+
+  template <typename PointCloudType>
+  int nearestKSearchImpl(const PointCloudType &cloud,
+              int k,
+              std::vector<int>& indices,
+              std::vector<float>& distance);
+
+  template <typename PointCloudType>
+  int nearestKSearchImpl(const PointCloudType &cloud,
+              int k,
+              pcl::oneapi::DeviceArray2D<int>& indices,
+              pcl::oneapi::DeviceArray2D<float>& distance);
+
+  template <typename PointCloudType>
+  int nearestKSearchImpl(const PointCloudType &cloud,
+                 int k,
+                 pcl::oneapi::DeviceArray<int>& indices,
+                 pcl::oneapi::DeviceArray<float>& distance,
+                 pcl::oneapi::DeviceArray<int> & splits);
+private:
+
+
+
+  /** \brief Class getName method. */
+  std::string
+  getName() const override
+  {
+    return ("KdTreeFLANN");
+  }
+
+  /** \brief A FLANN index object. */
+  std::shared_ptr<FLANNIndex> flann_index_;
+
+
+  PointCloudDevConstPtr input_device_;
+
+  /** \brief Internal pointer to data. TODO: replace with std::shared_ptr<float[]> with
+   * C++17*/
+  std::shared_ptr<float> cloud_;
+
+  /** \brief mapping between internal and external indices. */
+  std::vector<int> index_mapping_;
+
+  /** \brief whether the mapping between internal and external indices is identity */
+  bool identity_mapping_;
+
+  /** \brief Tree dimensionality (i.e. the number of dimensions per point). */
+  int dim_;
+
+  /** \brief The total size of the data (either equal to the number of points in the
+   * input cloud or to the number of indices - if passed). */
+  uindex_t total_nr_points_;
+
+  /** \brief The KdTree search parameters for K-nearest neighbors. */
+  ::flann::SearchParams param_k_;
+
+  /** \brief The KdTree search parameters for radius search. */
+  ::flann::SearchParams param_radius_;
+
+  /** \brief An FLANN_DPCPP index object. */
+  std::shared_ptr<FLANNIndex> flann_dp_index_;
+  std::shared_ptr<FixedIndex> fixed_radius_index_;
+};
+
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/kdtree/impl/kdtree_flann.hpp>
+#endif
diff --git a/oneapi/kdtree/include/pcl/oneapi/kdtree/memory_allocation.h b/oneapi/kdtree/include/pcl/oneapi/kdtree/memory_allocation.h
new file mode 100644
index 000000000..d5ef5d2ca
--- /dev/null
+++ b/oneapi/kdtree/include/pcl/oneapi/kdtree/memory_allocation.h
@@ -0,0 +1,207 @@
+// ----------------------------------------------------------------------------
+// -                        Open3D: www.open3d.org                            -
+// ----------------------------------------------------------------------------
+// The MIT License (MIT)
+//
+// Copyright (c) 2018-2021 www.open3d.org
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+// IN THE SOFTWARE.
+// ----------------------------------------------------------------------------
+
+#pragma once
+
+#include <iostream>
+#include <memory>
+#include <stdexcept>
+#include <utility>
+#include <vector>
+
+namespace pcl {
+namespace oneapi {
+
+/// A class for managing memory segments within a memory allocation.
+class MemoryAllocation {
+public:
+    /// Creates a MemoryAllocation object that manages memory segments within
+    /// a memory allocation.
+    ///
+    /// \param ptr          Pointer to the beginning of the memory.
+    /// \param size         Size of the memory.
+    /// \param alignment    The alignment for returned segments.
+    ///
+    MemoryAllocation(void* ptr, size_t size, size_t alignment = 1)
+        : _ptr(ptr),
+          _size(size),
+          _alignment(alignment),
+          _max_size_ptr((char*)ptr),
+          _free_segments {} {
+        // align start and end of memory segment
+        void* aligned_ptr = std::align(_alignment, 1, ptr, size);
+        size_t size_after_align =
+                (((char*)ptr + size) - (char*)aligned_ptr) / _alignment;
+        size_after_align *= _alignment;
+        _free_segments.push_back(
+                std::pair<void*, size_t>(aligned_ptr, size_after_align));
+    }
+
+    /// Returns a memory segment with size for type T.
+    /// Returns the pointer and the size in number of elements T.
+    /// May return the pair (nullptr,0) if the allocation is not possible.
+    template <class T>
+    std::pair<T*, size_t> Alloc(size_t size) {
+        std::pair<void*, size_t> tmp = Alloc(size * sizeof(T));
+        return std::pair<T*, size_t>((T*)tmp.first, tmp.first ? size : 0);
+    }
+
+    /// Returns a memory segment with size in bytes.
+    /// May return the pair (nullptr,0) if the allocation is not possible.
+    std::pair<void*, size_t> Alloc(size_t size) {
+        // round up to alignment
+        if (size % _alignment) size += _alignment - size % _alignment;
+
+        for (size_t i = 0; i < _free_segments.size(); ++i) {
+            void* ptr = std::align(_alignment, size, _free_segments[i].first,
+                                   _free_segments[i].second);
+            if (ptr) {
+                char* end_ptr = (char*)ptr + size;
+                if (end_ptr > _max_size_ptr) _max_size_ptr = end_ptr;
+
+                _free_segments[i].first = end_ptr;
+                _free_segments[i].second -= size;
+                return std::pair<void*, size_t>(ptr, size);
+            }
+        }
+        return std::pair<void*, size_t>(nullptr, 0);
+    }
+
+    /// Returns the largest free segment.
+    std::pair<void*, size_t> AllocLargestSegment() {
+        size_t size = 0;
+        for (const auto& s : _free_segments)
+            if (s.second > size) size = s.second;
+
+        return Alloc(size);
+    }
+
+    /// Frees a previously returned segment.
+    template <class T>
+    void Free(const std::pair<T*, size_t>& segment) {
+        size_t size = sizeof(T) * segment.second;
+        if (size % _alignment) size += _alignment - size % _alignment;
+
+        Free(std::pair<void*, size_t>(segment.first, size));
+    }
+
+    /// Frees a previously returned segment.
+    void Free(const std::pair<void*, size_t>& segment) {
+        if (DEBUG) {
+            if ((char*)segment.first < (char*)_ptr ||
+                (char*)segment.first + segment.second > (char*)_ptr + _size)
+                throw std::runtime_error("free(): segment is out of bounds");
+        }
+        {
+            size_t i;
+            for (i = 0; i < _free_segments.size(); ++i) {
+                if ((char*)segment.first < (char*)_free_segments[i].first)
+                    break;
+            }
+            _free_segments.insert(_free_segments.begin() + i, segment);
+        }
+
+        // merge adjacent segments
+        auto seg = _free_segments[0];
+        char* end_ptr = (char*)seg.first + seg.second;
+        size_t count = 0;
+        for (size_t i = 1; i < _free_segments.size(); ++i) {
+            const auto& seg_i = _free_segments[i];
+
+            if (end_ptr == (char*)seg_i.first) {
+                // merge with adjacent following segment
+                seg.second += seg_i.second;
+                end_ptr = (char*)seg.first + seg.second;
+            } else {
+                _free_segments[count] = seg;
+                seg = _free_segments[i];
+                end_ptr = (char*)seg.first + seg.second;
+                ++count;
+            }
+        }
+        _free_segments[count] = seg;
+        ++count;
+        _free_segments.resize(count);
+
+        if (DEBUG) {
+            // check if there are overlapping segments
+            for (size_t i = 1; i < _free_segments.size(); ++i) {
+                char* prev_end_ptr = (char*)_free_segments[i - 1].first +
+                                     _free_segments[i - 1].second;
+                if (prev_end_ptr > (char*)_free_segments[i].first) {
+                    throw std::runtime_error(
+                            "free(): Overlapping free segments found after "
+                            "call to free");
+                }
+            }
+        }
+    }
+
+    /// Returns the peak memory usage in bytes.
+    size_t MaxUsed() const { return _max_size_ptr - (char*)_ptr; }
+
+    /// Returns the alignment in bytes.
+    size_t Alignment() const { return _alignment; }
+
+    /// Returns the list of free segments.
+    const std::vector<std::pair<void*, size_t>>& FreeSegments() const {
+        return _free_segments;
+    }
+
+    /// Prints the segment. Meant for debugging.
+    template <class T>
+    static void PrintSegment(const std::pair<T*, size_t>& s) {
+        std::cerr << "ptr " << (void*)s.first << "\t size " << s.second
+                  << "\t end " << (void*)((char*)s.first + s.second) << "\n";
+    }
+
+    /// Prints all free segments. Meant for debugging.
+    void PrintFreeSegments() const {
+        for (const auto& s : _free_segments) PrintSegment(s);
+    }
+
+private:
+    enum internal_config { DEBUG = 0 };  /// for internal debugging use
+
+    /// Pointer to the beginning of the memory
+    const void* _ptr;
+
+    /// Size of the memory
+    const size_t _size;
+
+    /// The alignment for returned segments
+    const size_t _alignment;
+
+    /// Tracks the largest end ptr of all allocated memory segments.
+    char* _max_size_ptr;
+
+    /// List of free segments with begin ptr and size. May contain segments
+    /// with zero size.
+    std::vector<std::pair<void*, size_t>> _free_segments;
+};
+
+}  // namespace oneapi
+}  // namespace pcl
diff --git a/oneapi/kdtree/src/kdtree_flann.cpp b/oneapi/kdtree/src/kdtree_flann.cpp
new file mode 100644
index 000000000..2f2047cfb
--- /dev/null
+++ b/oneapi/kdtree/src/kdtree_flann.cpp
@@ -0,0 +1,49 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+#include <pcl/oneapi/kdtree/impl/kdtree_flann.hpp>
+#include <pcl/oneapi/kdtree/impl/fixed_radius_index.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_KdTreeFLANN, PCL_XYZ_POINT_TYPES)
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/octree/CMakeLists.txt b/oneapi/octree/CMakeLists.txt
new file mode 100755
index 000000000..26842b723
--- /dev/null
+++ b/oneapi/octree/CMakeLists.txt
@@ -0,0 +1,41 @@
+set(SUBSYS_NAME oneapi_octree)
+set(SUBSYS_PATH oneapi/octree)
+set(SUBSYS_DESC "Point cloud oneAPI octree library")
+set(SUBSYS_DEPS common oneapi_common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include" "${CMAKE_CURRENT_SOURCE_DIR}/src" "${CMAKE_CURRENT_SOURCE_DIR}/src/utils")
+
+set(srcs
+  src/dpcpp/radius_search.cpp
+  src/dpcpp/octree_host.cpp
+  src/dpcpp/octree_builder.cpp
+  src/dpcpp/octree_iterator.hpp
+  src/dpcpp/approx_nsearch.cpp
+  src/dpcpp/knn_search.cpp
+  src/octree.cpp
+)
+
+set(incs
+  include/pcl/oneapi/octree/octree.hpp
+  include/pcl/oneapi/octree/device_format.hpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs})
+target_link_libraries("${LIB_NAME}" pcl_common pcl_oneapi_common)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include"  "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/octree/include/pcl/oneapi/octree/device_format.hpp b/oneapi/octree/include/pcl/oneapi/octree/device_format.hpp
new file mode 100755
index 000000000..95191be68
--- /dev/null
+++ b/oneapi/octree/include/pcl/oneapi/octree/device_format.hpp
@@ -0,0 +1,89 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef _PCL_ONEAPI_OCTREE_DEVICE_FORMAT_HPP_
+#define _PCL_ONEAPI_OCTREE_DEVICE_FORMAT_HPP_
+
+#include <pcl/oneapi/containers/device_array.h>
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        struct NeighborIndices
+        {
+            DeviceArray<int> data;
+            DeviceArray<int> sizes;
+            int max_elems;  
+
+            NeighborIndices() : max_elems(0) {}
+            NeighborIndices(int query_number, int max_elements) : max_elems(0)
+            {
+                create(query_number, max_elements);
+            }
+
+            void create(int query_number, int max_elements)
+            {
+                max_elems = max_elements;
+                data.create (query_number * max_elems);
+
+                if (max_elems != 1)
+                    sizes.create(query_number);                
+            }
+
+            void upload(const std::vector<int>& data, const std::vector<int>& sizes, int max_elements)
+            {
+                this->data.upload(data);
+                this->sizes.upload(sizes);
+                max_elems = max_elements;
+            }
+
+            bool validate(std::size_t cloud_size) const
+            {
+                return (sizes.size() == cloud_size) && (cloud_size * max_elems == data.size());
+            }
+
+            operator PtrStep<int>() const
+            {
+                return {(int*)data.ptr(), max_elems * sizeof(int)};
+            }            
+
+            std::size_t neighboors_size() const { return data.size()/max_elems; }
+        };
+    }
+}
+
+#endif /* _PCL_ONEAPI_OCTREE_DEVICE_FORMAT_HPP_ */
diff --git a/oneapi/octree/include/pcl/oneapi/octree/octree.hpp b/oneapi/octree/include/pcl/oneapi/octree/octree.hpp
new file mode 100755
index 000000000..aaa0814ca
--- /dev/null
+++ b/oneapi/octree/include/pcl/oneapi/octree/octree.hpp
@@ -0,0 +1,196 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef _PCL_ONEAPI_OCTREE_
+#define _PCL_ONEAPI_OCTREE_
+
+#include <vector>
+
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/octree/device_format.hpp>
+#include <pcl/memory.h>
+#include <pcl/point_types.h>
+#include <pcl/pcl_macros.h>
+
+namespace pcl
+{
+    namespace oneapi
+    {   
+        /**
+         * \brief   Octree implementation on GPU. It suppors parallel building and parallel batch search as well .       
+         * \author  Anaoly Baksheev, Itseez, myname.mysurname@mycompany.com
+         */
+
+        class PCL_EXPORTS Octree
+        {
+        public:
+
+            /** \brief Default constructor.*/             
+            Octree();
+            
+            /** \brief Copy constructor.*/
+            Octree(const Octree& src);
+            
+            /** \brief Denstructor.*/             
+            virtual ~Octree();
+            
+            /** \brief = operator overloading.*/
+            Octree& operator=(const Octree& src);
+            
+            /** \brief Types */
+            using Ptr = shared_ptr<Octree>;
+            using ConstPtr = shared_ptr<const Octree>;
+
+            /** \brief Point typwe supported */
+            using PointType = pcl::PointXYZ;
+
+            /** \brief Point cloud supported */
+            using PointCloud = DeviceArray<PointType>;
+            
+            /** \brief Point Batch query cloud type */
+            using Queries = DeviceArray<PointType>;
+
+            /** \brief Point Radiuses for batch query  */
+            using Radiuses = DeviceArray<float>;            
+
+            /** \brief Point Indices for batch query  */
+            using Indices = DeviceArray<int>;    
+            
+            /** \brief Point Sqrt distances array type */
+            using ResultSqrDists = DeviceArray<float>;
+            
+            const PointCloud*   cloud_;
+            
+            /** \brief Sets cloud for which octree is built */            
+            void setCloud(const PointCloud& cloud_arg);
+
+            /** \brief Performs parallel octree building */
+			void build();
+
+            /** \brief Returns true if tree has been built */
+            bool isBuilt() const;
+
+            /** \brief Downloads Octree from GPU to search using CPU function. It use useful for single (not-batch) search */
+            void internalDownload();
+
+            /** \brief Performs search of all points within given radius on CPU. It call \a internalDownload if necessary
+              * \param[in] center center of sphere
+              * \param[in] radius radious of sphere
+              * \param[out] out indeces of points within give sphere
+              * \param[in] max_nn maximum numver of results returned
+              */
+            void radiusSearchHost(const PointType& center, float radius, std::vector<int>& out, int max_nn = INT_MAX);
+
+            /** \brief Performs approximate nearest neighbor search on CPU. It call \a internalDownload if necessary
+              * \param[in]  query 3D point for which neighbour is be fetched             
+              * \param[out] out_index neighbour index
+              * \param[out] sqr_dist square distance to the neighbour returned
+              */
+            void approxNearestSearchHost(const PointType& query, int& out_index, float& sqr_dist);
+
+            /** \brief Performs batch radius search on GPU
+              * \param[in] centers array of centers 
+              * \param[in] radius radius for all queries
+              * \param[in] max_results max number of returned points for each querey
+              * \param[out] result results packed to single array
+              */
+            void radiusSearch(const Queries& centers, float radius, int max_results, NeighborIndices& result) const;
+
+            /** \brief Performs batch radius search on GPU
+              * \param[in] centers array of centers 
+              * \param[in] radiuses array of radiuses
+              * \param[in] max_results max number of returned points for each querey
+              * \param[out] result results packed to single array
+              */
+            void radiusSearch(const Queries& centers, const Radiuses& radiuses, int max_results, NeighborIndices& result) const;
+
+            /** \brief Performs batch radius search on GPU
+              * \param[in] centers array of centers  
+              * \param[in] indices indices for centers array (only for these points search is performed)
+              * \param[in] radius radius for all queries
+              * \param[in] max_results max number of returned points for each querey
+              * \param[out] result results packed to single array
+              */
+            void radiusSearch(const Queries& centers, const Indices& indices, float radius, int max_results, NeighborIndices& result) const;
+
+            /** \brief Batch approximate nearest search on GPU
+              * \param[in] queries array of centers
+              * \param[out] result array of results ( one index for each query ) 
+              */
+            PCL_DEPRECATED(1, 14, "use approxNearestSearch() which returns square distances instead")
+            void approxNearestSearch(const Queries& queries, NeighborIndices& result) const;
+
+            /** \brief Batch approximate nearest search on GPU
+              * \param[in] queries array of centers
+              * \param[out] result array of results ( one index for each query )
+              * \param[out] sqr_distance corresponding square distances to results from query point
+              */
+            void approxNearestSearch(const Queries& queries, NeighborIndices& result, ResultSqrDists& sqr_distance) const;
+
+            /** \brief Batch exact k-nearest search on GPU
+              * \param[in] queries array of centers
+              * \param[in] k number of neighbors
+              * \param[out] results array of results
+              */
+            void nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results) const;
+
+            /** \brief Batch exact k-nearest search on GPU
+              * \param[in] queries array of centers
+              * \param[in] k number of neighbors
+              * \param[out] results array of results
+              * \param[out] sqr_distances square distances to results
+              */
+            void nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results, ResultSqrDists& sqr_distances) const;
+
+            /** \brief Desroys octree and release all resources */
+            void clear();            
+        private:
+            void *impl;            
+            bool built_;
+        };        
+
+      /** \brief Performs brute force radius search on GPU
+        * \param[in] cloud cloud where to search
+        * \param[in] query query point
+        * \param[in] radius radius
+        * \param[out] result indeces of points within give sphere
+        * \param[in] buffer buffer for intermediate results. Keep reference to it between calls to eliminate internal allocations
+        */             
+        PCL_EXPORTS void bruteForceRadiusSearchGPU(const Octree::PointCloud& cloud, const Octree::PointType& query, float radius, DeviceArray<int>& result, DeviceArray<int>& buffer);
+    }
+}
+
+#endif /* _PCL_ONEAPI_OCTREE_ */
diff --git a/oneapi/octree/octree.doxy b/oneapi/octree/octree.doxy
new file mode 100755
index 000000000..a68de5461
--- /dev/null
+++ b/oneapi/octree/octree.doxy
@@ -0,0 +1,34 @@
+/**
+  \addtogroup octree Module octree
+
+  \section secOctreePresentation Overview
+
+The <b>pcl_octree</b> library provides efficient methods for creating a hierarchical tree 
+data structure from point cloud data. This enables spatial partitioning, 
+downsampling and search operations on the point data set. 
+Each octree node has either eight children or no children. The root node describes 
+a cubic bounding box which encapsulates all points. At every tree level, this space 
+becomes subdivided by a factor of 2 which  results in an increased voxel resolution. 
+
+The <b>pcl_octree</b> implementation provides efficient nearest neighbor search routines,
+such as "Neighbors within Voxel Search, K Nearest Neighbor Search and 
+Neighbors within Radius Search. It automatically adjusts its dimension to the point 
+data set. A set of leaf node classes provide additional functionality, such as 
+spacial "occupancy" and "point density per voxel" checks. Functions for serialization 
+and deserialization enable to efficiently encode the octree structure into a binary format.
+Furthermore, a memory pool implementation reduces expensive memory allocation and 
+deallocation operations in scenarios where octrees needs to be created at high rate. 
+
+The following figure illustrates the voxel bounding boxes of an octree nodes at lowest tree level. 
+The octree voxels are surrounding every 3D point from the bunny's surface. The red dots represent the point data. 
+This image is created with the octree_viewer (visualization/tools/octree_viewer).
+
+For examples how to use the <b>pcl_octree</b> library, please visit the <a href="http://www.pointclouds.org/documentation/tutorials/">pcl tutorial page</a>.
+
+\image html http://www.pointclouds.org/assets/images/contents/documentation/octree_bunny.png
+
+
+	\section secOctreeRequirements Requirements
+	- \ref common "common"
+
+*/
diff --git a/oneapi/octree/src/dpcpp/approx_nsearch.cpp b/oneapi/octree/src/dpcpp/approx_nsearch.cpp
new file mode 100644
index 000000000..da0a2448d
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/approx_nsearch.cpp
@@ -0,0 +1,286 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "internal.hpp"
+#include "pcl/oneapi/utils/common.h"
+#include "utils/approx_nearest_utils.hpp"
+#include <assert.h>
+
+#include <limits>
+#include <tuple>
+
+namespace pcl {
+namespace oneapi {
+namespace device {
+namespace appnearest_search {
+using PointType = OctreeImpl::PointType;
+
+struct Batch {
+  const PointType* queries;
+
+  const int* indices;
+  const float* points;
+  int points_step; // elem step
+
+  OctreeGlobalWithBox octree;
+
+  int queries_num;
+  mutable int* output;
+  mutable float* sqr_distance;
+};
+
+struct KernelPolicy {
+  enum {
+    CTA_SIZE = 16,
+
+    LOG_WARP_SIZE = 3,
+    WARP_SIZE = 1 << LOG_WARP_SIZE,
+    WARPS_COUNT = CTA_SIZE / WARP_SIZE,
+  };
+};
+
+struct Warp_appNearestSearch {
+public:
+  const Batch& batch;
+
+  int query_index;
+  sycl::float3 query = {0.0f, 0.0f, 0.0f};
+  int result_idx = 0;
+  float sqr_dist = 0.0f;
+
+  __dpct_inline__
+  Warp_appNearestSearch(const Batch& batch_arg, int query_index_arg)
+  : batch(batch_arg), query_index(query_index_arg)
+  {}
+
+  __dpct_inline__ void
+  launch(bool active, sycl::nd_item<1>& item_ct1)
+  {
+    int node_idx = -1;
+    if (active) {
+      PointType q = batch.queries[query_index];
+      query = sycl::float3(q.x(), q.y(), q.z());
+
+      const sycl::float3& minp = batch.octree.minp;
+      const sycl::float3& maxp = batch.octree.maxp;
+
+      node_idx = pcl::oneapi::device::findNode(minp, maxp, query, batch.octree.nodes);
+
+    }
+
+    processNode(node_idx, item_ct1);
+
+
+    if (active)
+    {
+      batch.output[query_index] = batch.indices[result_idx];
+      batch.sqr_distance[query_index] = sqr_dist;
+    }
+  }
+
+private:
+  __dpct_inline__ int __ffs(int v){
+     static const int MultiplyDeBruijnBitPosition[32] =
+     {
+       0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
+       31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
+     };
+     if(v == 0){
+        return 0;
+     }
+     else{
+        return 1 + MultiplyDeBruijnBitPosition[((uint32_t)((v & -v) * 0x077CB531U)) >> 27];
+     }
+
+  };
+
+  __dpct_inline__ void
+  processNode(const int node_idx,
+              sycl::nd_item<1>& item_ct1)
+  {
+
+    int mask = sycl::reduce_over_group(
+        item_ct1.get_sub_group(),
+        (0xFFFFFFFF & (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                node_idx != -1
+            ? (0x1 << item_ct1.get_sub_group().get_local_linear_id())
+            : 0,
+        sycl::ext::oneapi::plus<>());
+
+    while (mask) {
+      const unsigned int laneId = item_ct1.get_sub_group().get_local_id()[0];
+      const int active_lane = __ffs(mask) - 1; //[0..31]
+      mask &= ~(1 << active_lane);
+
+      // broadcast beg and end
+      int fbeg = 0, fend = 0;
+      if (active_lane == laneId) {
+        fbeg = batch.octree.begs[node_idx];
+        fend = batch.octree.ends[node_idx];
+      }
+
+      const int beg =
+          sycl::select_from_group(item_ct1.get_sub_group(), fbeg, active_lane);
+      const int end =
+          sycl::select_from_group(item_ct1.get_sub_group(), fend, active_lane);
+
+      // broadcast warp_query
+      const sycl::float3 active_query =
+          sycl::float3(
+              sycl::select_from_group(item_ct1.get_sub_group(), query.x(), active_lane),
+              sycl::select_from_group(item_ct1.get_sub_group(), query.y(), active_lane),
+              sycl::select_from_group(item_ct1.get_sub_group(), query.z(), active_lane));
+
+      const auto nearestPoint = NearestWarpKernel<KernelPolicy::CTA_SIZE>(
+          beg, batch.points_step, end - beg, active_query, item_ct1);
+
+      if (active_lane == laneId)
+      {
+        result_idx = beg + nearestPoint.first;
+        sqr_dist = nearestPoint.second;
+      }
+    }
+  }
+
+  template <int CTA_SIZE>
+  std::pair<int, float>
+  NearestWarpKernel(const int beg,
+                    const int field_step,
+                    const int length,
+                    const sycl::float3& active_query,
+                    sycl::nd_item<1>& item_ct1)
+
+  {
+    int index = 0;
+    float dist_squared = std::numeric_limits<float>::max();
+
+    // serial step
+    int laneId = item_ct1.get_sub_group().get_local_id()[0];
+    for (int idx = laneId; idx < length; idx += KernelPolicy::WARP_SIZE) {
+      const float dx = batch.points[beg + idx] - active_query.x();
+      const float dy = batch.points[beg + idx + field_step] - active_query.y();
+      const float dz = batch.points[beg + idx + field_step * 2] - active_query.z();
+
+      const float d2 = dx * dx + dy * dy + dz * dz;
+
+      if (dist_squared > d2) {
+        dist_squared = d2;
+        index = idx;
+      }
+    }
+
+    // find minimum distance among warp threads
+    constexpr unsigned FULL_MASK = 0xFFFFFFFF;
+    static_assert(KernelPolicy::WARP_SIZE <= 8 * sizeof(FULL_MASK),
+                  "WARP_SIZE exceeds size of bit_offset.");
+
+    for (unsigned int bit_offset = KernelPolicy::WARP_SIZE / 2; bit_offset > 0;
+         bit_offset /= 2) {
+      const float next =
+          sycl::shift_group_left(item_ct1.get_sub_group(), dist_squared, bit_offset);
+      const int next_index =
+          sycl::shift_group_left(item_ct1.get_sub_group(), index, bit_offset);
+
+      if (dist_squared > next) {
+        dist_squared = next;
+        index = next_index;
+      }
+    }
+
+    // retrieve index and distance
+    index = sycl::select_from_group(item_ct1.get_sub_group(), index, 0);
+    dist_squared = sycl::select_from_group(item_ct1.get_sub_group(), dist_squared, 0);
+
+    return {index, dist_squared};
+  }
+};
+
+void
+KernelAN(const Batch &batch, sycl::nd_item<1>& item_ct1)
+{
+  const int query_index = item_ct1.get_global_linear_id();
+
+  const bool active = query_index < batch.queries_num;
+
+  if (sycl::all_of_group(
+          item_ct1.get_sub_group(),
+          (~0xFFFFFFFF & (0x1 << item_ct1.get_sub_group().get_local_linear_id())) ||
+              active == false))
+    return;
+
+  Warp_appNearestSearch search(batch, query_index);
+  search.launch(active, item_ct1);
+}
+
+} // namespace appnearest_search
+} // namespace device
+} // namespace oneapi
+} // namespace pcl
+
+void
+pcl::oneapi::device::OctreeImpl::approxNearestSearch(const Queries& queries,
+                                             NeighborIndices& results,
+                                             BatchResultSqrDists& sqr_distance) const
+{
+  using BatchType = pcl::oneapi::device::appnearest_search::Batch;
+
+  BatchType batch;
+  batch.indices = indices;
+  batch.octree = octreeGlobal;
+
+  batch.queries_num = (int)queries.size();
+  batch.output = results.data;
+  batch.sqr_distance = sqr_distance;
+
+  batch.points = points_sorted;
+  batch.points_step = (int)points_sorted.elem_step();
+  batch.queries = queries;
+
+  int block = pcl::oneapi::device::appnearest_search::KernelPolicy::CTA_SIZE;
+  int grid = (batch.queries_num + block - 1) / block;
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+    cgh.parallel_for(
+        sycl::nd_range(sycl::range<1>(grid) * sycl::range<1>(block),
+                          sycl::range<1>(block)),
+        [=](sycl::nd_item<1> item_ct1) [[intel::reqd_sub_group_size(appnearest_search::KernelPolicy::WARP_SIZE)]] {
+          pcl::oneapi::device::appnearest_search::KernelAN(
+              batch, item_ct1);
+        });
+  }).wait();
+}
diff --git a/oneapi/octree/src/dpcpp/knn_search.cpp b/oneapi/octree/src/dpcpp/knn_search.cpp
new file mode 100644
index 000000000..fc3001e8d
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/knn_search.cpp
@@ -0,0 +1,332 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+*/
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <limits>
+
+#include "internal.hpp"
+#include "pcl/oneapi/utils/device/warp.hpp"
+#include "pcl/oneapi/utils/common.h"
+#include "utils/copygen.hpp"
+#include "utils/boxutils.hpp"
+#include "octree_iterator.hpp"
+#include <tuple>
+
+#define BOUND_CHECK
+
+namespace pcl { namespace oneapi { namespace device { namespace knn_search
+{
+    using PointType = OctreeImpl::PointType;
+
+    struct Batch
+    {
+        const PointType* queries;
+
+        int k;
+
+        const int *indices;
+
+        // X1 X2 X3 X4 ..
+        // Y1 Y2 Y3 Y4 ..
+        // Z1 Z2 Z3 Z4 ..
+        const float* points;
+        int points_step; // elem step
+
+        OctreeGlobalWithBox octree;
+
+        int queries_num;
+        mutable int* output;
+        mutable int* sizes;
+        mutable float* sqr_distances;
+    };
+
+    struct KernelPolicyGPU
+    {
+        enum
+        {
+            CTA_SIZE = 128,
+        };
+    };
+
+    struct KernelPolicyCPU
+    {
+        enum
+        {
+            CTA_SIZE = 1,
+        };
+    };
+
+    struct Warp_knnSearch
+    {
+    public:
+        using OctreeIterator = OctreeIteratorDeviceNS;
+
+        const Batch& batch;
+
+        int query_index;
+        sycl::float3 query;
+
+        int candidate_cnt;
+        float candidate_max_dist;
+        int candidate_replace;
+
+        OctreeIterator iterator;
+
+        __dpct_inline__
+        Warp_knnSearch(const Batch& batch_arg, const int query_index_arg)
+        : batch(batch_arg)
+        , query_index(query_index_arg)
+        , query(sycl::float3(0.0f, 0.0f, 0.0f))
+        , candidate_cnt(0)
+        , candidate_max_dist(0.0f)
+        , candidate_replace(0)
+        , iterator(batch.octree) {}
+
+        __dpct_inline__ void
+        launch(bool active)
+        {
+            if (active)
+            {
+                PointType q = batch.queries[query_index];
+                query = sycl::float3(q.x(), q.y(), q.z());
+            }
+            else
+                query_index = -1;
+
+            while (active)
+            {
+                int leaf = -1;
+
+                if (active)
+                    leaf = examineNode(iterator);
+
+                processLeaf(leaf);
+
+                active = active && iterator.level >= 0;
+            }
+
+            if (query_index != -1)
+            {
+                if (batch.sizes)
+                    batch.sizes[query_index]  = batch.k;
+            }
+        }
+    private:
+        __dpct_inline__ int
+        examineNode(OctreeIterator& iterator)
+        {
+            const int node_idx = *iterator;
+
+#ifdef BOUND_CHECK
+           // bound check may affect performance, with small points inputs, without bound
+           // check performance may get a little better, but with large points like 167198
+           // points, without bound check performance will be much worse.
+            if (candidate_cnt == batch.k)
+            {
+                float max_dist_sqrt = sqrt(candidate_max_dist);
+                const int code = batch.octree.codes[node_idx];
+
+                sycl::float3 node_minp = batch.octree.minp;
+                sycl::float3 node_maxp = batch.octree.maxp;
+
+                calcBoundingBox(iterator.level, code, node_minp, node_maxp);
+
+                //if true, take nothing, and go to next
+                if (checkIfNodeOutsideSphere(node_minp, node_maxp, query, max_dist_sqrt))
+                {
+                    ++iterator;
+                    return -1;
+                }
+            }
+#endif
+
+            //need to go to next level
+            const int node = batch.octree.nodes[node_idx];
+            const int children_mask = node & 0xFF;
+            const bool isLeaf = children_mask == 0;
+
+            if (isLeaf)
+            {
+                ++iterator;
+                return node_idx;
+            }
+
+            //goto next level
+            const int first = node >> 8;
+            const int len = sycl::popcount(children_mask);
+            iterator.gotoNextLevel(first, len);
+            return -1;
+        };
+
+        __dpct_inline__ void
+        processLeaf(const int node_idx
+                    )
+        {
+            if (node_idx == -1)
+                return;
+
+            int fbeg = 0, fend = 0;
+            fbeg = batch.octree.begs[node_idx];
+            fend = batch.octree.ends[node_idx];
+
+            NearestWarpKernel(fbeg, batch.points_step, fend - fbeg, query);
+        }
+
+        void
+        NearestWarpKernel(const int beg,
+                          const int field_step,
+                          const int length,
+                          const sycl::float3& active_query)
+
+        {
+            int k = batch.k;
+
+            // serial step
+            for (int idx = 0; idx < length; idx ++) {
+                const float dx = batch.points[beg + idx] - active_query.x();
+                const float dy = batch.points[beg + idx + field_step] - active_query.y();
+                const float dz =
+                    batch.points[beg + idx + field_step * 2] - active_query.z();
+
+                const float d2 = dx * dx + dy * dy + dz * dz;
+
+                if (candidate_cnt < k)
+                {
+                    // first k points as candidates
+                    if (query_index != -1)
+                    {
+                        batch.output[query_index * k + candidate_cnt] = batch.indices[beg + idx];
+                        batch.sqr_distances[query_index * k + candidate_cnt] = d2;
+
+                        candidate_cnt ++;
+                    }
+
+                    //  when candidates count first reach to k, find candidate with max dist
+                    //  and keep its position.
+                    if (candidate_cnt == k)
+                    {
+                         candidate_max_dist = batch.sqr_distances[query_index * k];
+                         candidate_replace = 0;
+
+                         for (int i = 0; i < k; i ++)
+                         {
+                             if (batch.sqr_distances[query_index*k + i] > candidate_max_dist)
+                             {
+                                 candidate_max_dist = batch.sqr_distances[query_index * k + i];
+                                 candidate_replace = i;
+                             }
+                         }
+                     }
+                 }
+                 else if (d2 < candidate_max_dist)
+                 {
+                     if (query_index != -1)
+                     {
+                         batch.output[query_index * k + candidate_replace] = batch.indices[beg + idx];
+                         batch.sqr_distances[query_index * k + candidate_replace] = d2;
+                     }
+
+                     // calculate candidate with max dist again, and keep its position.
+                     candidate_max_dist = batch.sqr_distances[query_index * k];
+                     candidate_replace = 0;
+
+                     for (int i = 0; i < k; i ++)
+                     {
+                         if (batch.sqr_distances[query_index * k + i] > candidate_max_dist)
+                         {
+                             candidate_max_dist = batch.sqr_distances[query_index * k + i];
+                             candidate_replace = i;
+                         }
+                     }
+                 }
+             }
+         }
+    };
+
+    void KernelKNN(const Batch &batch, sycl::nd_item<1>& item_ct1)
+    {
+        const int query_index = item_ct1.get_global_linear_id();
+
+        const bool active = query_index < batch.queries_num;
+
+        Warp_knnSearch search(batch, query_index);
+        search.launch(active);
+    }
+
+} } } }
+
+
+void pcl::oneapi::device::OctreeImpl::nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results, BatchResultSqrDists& sqr_distances) const
+{
+    using BatchType = pcl::oneapi::device::knn_search::Batch;
+
+    BatchType batch;
+    batch.octree = octreeGlobal;
+    batch.indices = indices;
+
+    batch.queries_num = (int)queries.size();
+    batch.queries = queries;
+
+    batch.output = results.data;
+    batch.sizes  = results.sizes;
+    batch.sqr_distances = sqr_distances;
+
+    batch.points = points_sorted;
+    batch.points_step = points_sorted.step()/points_sorted.elem_size;
+
+    batch.k = k;
+
+    int block;
+
+    if (dpct::get_default_queue().get_device().is_gpu())
+      block = pcl::oneapi::device::knn_search::KernelPolicyGPU::CTA_SIZE;
+    else
+      block = pcl::oneapi::device::knn_search::KernelPolicyCPU::CTA_SIZE;
+
+    int grid = (batch.queries_num + block - 1) / block;
+
+    dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+
+        cgh.parallel_for(
+            sycl::nd_range(sycl::range<1>(grid) * sycl::range<1>(block), sycl::range<1>(block)),
+            [=](sycl::nd_item<1> item_ct1) {
+                pcl::oneapi::device::knn_search::KernelKNN(
+                    batch, item_ct1);
+            });
+    }).wait();
+}
+
diff --git a/oneapi/octree/src/dpcpp/octree_builder.cpp b/oneapi/octree/src/dpcpp/octree_builder.cpp
new file mode 100755
index 000000000..46faefe5f
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/octree_builder.cpp
@@ -0,0 +1,458 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cfloat>
+#include "internal.hpp"
+
+#include "pcl/oneapi/utils/device/funcattrib.hpp"
+#include "pcl/oneapi/utils/device/algorithm.hpp"
+#include "pcl/oneapi/utils/device/static_check.hpp"
+#include "pcl/oneapi/utils/common.h"
+#include "utils/scan_block.hpp"
+#include "utils/morton.hpp"
+
+#include <dpct/dpl_utils.hpp>
+
+using namespace pcl::oneapi;
+using namespace std;
+// using namespace thrust;
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            template<typename PointType>
+            struct SelectMinPoint
+            {
+                __dpct_inline__ PointType operator()(const PointType &e1,
+                                                     const PointType &e2) const
+                {
+                    PointType result;
+                    result.x() = sycl::fmin(e1.x(), e2.x());
+                    result.y() = sycl::fmin(e1.y(), e2.y());
+                    result.z() = sycl::fmin(e1.z(), e2.z());
+                    return result;
+                }
+            };
+
+            template<typename PointType>
+            struct SelectMaxPoint
+            {
+                    __dpct_inline__ PointType operator()(const PointType &e1,
+                                                         const PointType &e2) const
+                    {
+                    PointType result;
+                    result.x() = sycl::fmax(e1.x(), e2.x());
+                    result.y() = sycl::fmax(e1.y(), e2.y());
+                    result.z() = sycl::fmax(e1.z(), e2.z());
+                    return result;
+                    }
+            };
+
+            template<typename PointType>
+            struct PointType_to_tuple
+            {
+                __dpct_inline__ std::tuple<float, float, float>
+                operator()(const PointType &arg) const
+                {
+                    std::tuple<float, float, float> res;
+                    std::get<0>(res) = arg.x();
+                    std::get<1>(res) = arg.y();
+                    std::get<2>(res) = arg.z();
+                    return res;
+                }
+            };
+        }
+    }
+}
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            const static int max_points_per_leaf = 96;
+
+            enum
+            {
+                GRID_SIZE = 1,
+                //The number of work-items in each dimension of a work-group cannot
+                //exceed {512, 512, 512} for Intel Tiger Lake CPU.
+                CTA_SIZE = 512,
+                STRIDE = CTA_SIZE,
+
+                LEVEL_BITS_NUM = 3,
+                ARITY = 1 << LEVEL_BITS_NUM
+            };
+
+            struct SingleStepBuild
+            {
+                const int* codes;
+                int points_number;
+                mutable OctreeGlobal octree;
+
+                __dpct_inline__ int FindCells(int task, int level, int cell_begs[],
+                                              char cell_code[]) const
+                {
+                    int cell_count = 0;
+
+                    int beg = octree.begs[task];
+                    int end = octree.ends[task];
+
+                    if (end - beg < max_points_per_leaf)
+                    {
+                        //cell_count == 0;
+                    }
+                    else
+                    {
+                        int cur_code = Morton::extractLevelCode(codes[beg], level);
+
+                        cell_begs[cell_count] = beg;
+                        cell_code[cell_count] = cur_code;
+                        ++cell_count;
+
+                        int last_code = Morton::extractLevelCode(codes[end - 1], level);
+
+                        if (last_code == cur_code)
+                        {
+                            cell_begs[cell_count] = end;
+                        }
+                        else
+                        {
+                            for(;;)
+                            {
+                                int search_code = cur_code + 1;
+                                if (search_code == 8)
+                                {
+                                    cell_begs[cell_count] = end;
+                                    break;
+                                }
+
+                                int morton_code = Morton::shiftLevelCode(search_code, level);
+                                int pos = lower_bound(codes + beg, codes + end, morton_code, CompareByLevelCode(level)) - codes;
+
+                                if (pos == end)
+                                {
+                                    cell_begs[cell_count] = end;
+                                    break;
+                                }
+                                cur_code = Morton::extractLevelCode(codes[pos], level);
+
+                                cell_begs[cell_count] = pos;
+                                cell_code[cell_count] = cur_code;
+                                ++cell_count;
+                                beg = pos;
+                            }
+                        }
+                    }
+                    return cell_count;
+                }
+
+                __dpct_inline__ void operator()(sycl::nd_item<1> item_ct1,
+                                                int *nodes_num, int *tasks_beg,
+                                                int *tasks_end, int *total_new,
+                                                volatile int *offsets) const
+                {
+                    //32 is a performance penalty step for search
+                    Static<(max_points_per_leaf % 32) == 0>::check();
+
+                    if (item_ct1.get_local_id(0) == 0)
+                    {
+                        //init root
+                        octree.codes[0] = 0;
+                        octree.nodes[0] = 0;
+                        octree. begs[0] = 0;
+                        octree. ends[0] = points_number;
+                        octree.parent[0] = -1;
+
+                        //init shared
+                        *nodes_num = 1;
+                        *tasks_beg = 0;
+                        *tasks_end = 1;
+                        *total_new = 0;
+                    }
+
+                    int level = 0;
+
+                    int  cell_begs[ARITY + 1];
+                    char cell_code[ARITY];
+
+                    item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                    while (*tasks_beg < *tasks_end && level < Morton::levels)
+                    {
+                        int task_count = *tasks_end - *tasks_beg;
+
+                        int iters = divUp(task_count, CTA_SIZE);
+
+                        int task = *tasks_beg + item_ct1.get_local_id(0);
+
+                        //__syncthreads(); // extra??
+
+                        for(int it = 0; it < iters; ++it, task += STRIDE)
+                        {
+                            int cell_count =
+                                (task < *tasks_end)
+                                    ? FindCells(task, level, cell_begs, cell_code)
+                                    : 0;
+
+                            offsets[item_ct1.get_local_id(0)] = cell_count;
+                            item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                            scan_block<pcl::oneapi::device::exclusive>(offsets, item_ct1);
+
+                            //__syncthreads();  //because sync is inside the scan above
+
+                            if (task < *tasks_end)
+                            {
+                                if (cell_count > 0)
+                                {
+                                    int parent_code_shifted = octree.codes[task] << LEVEL_BITS_NUM;
+                                    int offset = *nodes_num + offsets[item_ct1.get_local_id(0)];
+
+
+                                    int mask = 0;
+                                    for(int i = 0; i < cell_count; ++i)
+                                    {
+                                        octree.begs [offset + i] = cell_begs[i];
+                                        octree.ends [offset + i] = cell_begs[i + 1];
+                                        octree.codes[offset + i] = parent_code_shifted + cell_code[i];
+                                        octree.nodes[offset + i] = 0;
+                                        octree.parent[offset + i] = task;
+                                        mask |= (1 << cell_code[i]);
+                                    }
+                                    octree.nodes[task] = (offset << 8) + mask;
+                                }
+                                else
+                                    octree.nodes[task] = 0;
+                            }
+
+                            item_ct1.barrier(sycl::access::fence_space::local_space);
+                            if (item_ct1.get_local_id(0) == CTA_SIZE - 1)
+                            {
+                                *total_new += cell_count + offsets[item_ct1.get_local_id(0)];
+                                *nodes_num += cell_count + offsets[item_ct1.get_local_id(0)];
+                            }
+                            item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                        } /* for(int it = 0; it < iters; ++it, task += STRIDE) */
+
+                        //__syncthreads(); //extra ??
+
+                        if (item_ct1.get_local_id(0) == CTA_SIZE - 1)
+                        {
+                            *tasks_beg = *tasks_end;
+                            *tasks_end += *total_new;
+                            *total_new = 0;
+                        }
+                        ++level;
+                        item_ct1.barrier(sycl::access::fence_space::local_space);
+                    }
+
+                    if (item_ct1.get_local_id(0) == CTA_SIZE - 1)
+                        *octree.nodes_num = *nodes_num;
+                }
+            };
+
+            void singleStepKernel(const SingleStepBuild ssb,
+                                  sycl::nd_item<1> item_ct1,
+                                  sycl::local_ptr<int>& nodes_num,
+                                  sycl::local_ptr<int>& tasks_beg,
+                                  sycl::local_ptr<int>& tasks_end,
+                                  sycl::local_ptr<int>& total_new,
+                                  sycl::local_ptr<volatile int>& offsets) {
+              ssb(item_ct1, nodes_num, tasks_beg, tasks_end, total_new, offsets);
+            }
+        }
+    }
+}
+
+void pcl::oneapi::device::OctreeImpl::build()
+{
+    dpct::device_ext& dev_ct1 = dpct::get_current_device();
+    sycl::queue& q_ct1 = dev_ct1.default_queue();
+    using namespace pcl::oneapi::device;
+    host_octree.downloaded = false;
+
+    int points_num = (int)points.size();
+
+    //allocatations
+    {
+        //ScopeTimer timer("new_allocs"); 
+        //+1 codes               * points_num * sizeof(int)
+        //+1 indices             * points_num * sizeof(int)
+        //+1 octreeGlobal.nodes  * points_num * sizeof(int)
+
+        //+1 octreeGlobal.codes  * points_num * sizeof(int)
+        //+1 octreeGlobal.begs   * points_num * sizeof(int)
+        //+1 octreeGlobal.ends   * points_num * sizeof(int)
+
+        //+1 octreeGlobal.parent * points_num * sizeof(int)
+
+        //+3 points_sorted       * points_num * sizeof(float)
+        //==
+        // 10 rows   
+
+        //left 
+        //octreeGlobal.nodes_num * 1 * sizeof(int)          
+        //==
+        // 3 * sizeof(int) => +1 row        
+
+        const int transaction_size = 128 / sizeof(int);
+        int cols = std::max<int>(points_num, transaction_size * 4);
+        int rows = 10 + 1; // = 13
+                           //
+        storage.create(rows, cols);
+
+        codes   = DeviceArray<int>(storage.ptr(0), points_num);
+        indices = DeviceArray<int>(storage.ptr(1), points_num);
+
+        octreeGlobal.nodes   = storage.ptr(2);
+        octreeGlobal.codes   = storage.ptr(3);
+        octreeGlobal.begs    = storage.ptr(4);
+        octreeGlobal.ends    = storage.ptr(5);
+        octreeGlobal.parent  = storage.ptr(6);
+
+        octreeGlobal.nodes_num = storage.ptr(7);
+
+        points_sorted = DeviceArray2D<float>(3, points_num, storage.ptr(8), storage.step());
+    }
+    {
+        //ScopeTimer timer("reduce-morton-sort-permutations"); 
+         PointType* beg(points.ptr());
+         PointType* end = beg + points.size();
+
+        {
+            PointType atmax, atmin;
+            atmax.x() = atmax.y() = atmax.z() = FLT_MAX;
+            atmin.x() = atmin.y() = atmin.z() = -FLT_MAX;
+            atmax.w() = atmin.w() = 0;
+
+            //ScopeTimer timer("reduce");
+            PointType minp =
+                std::reduce(//dpl::execution::make_device_policy(q_ct1),
+                            beg, end, atmax, SelectMinPoint<PointType>());
+            PointType maxp =
+                std::reduce(//dpl::execution::make_device_policy(q_ct1),
+                            beg, end, atmin, SelectMaxPoint<PointType>());            
+
+            octreeGlobal.minp = sycl::float3(minp.x(), minp.y(), minp.z());
+            octreeGlobal.maxp = sycl::float3(maxp.x(), maxp.y(), maxp.z());
+        }
+
+        int* codes_beg = codes.ptr();
+        int* codes_end = codes_beg + codes.size();
+        {
+            // Turn off using oneDPL for transform.  CPU generate wrong data
+            //ScopeTimer timer("morton");
+                std::transform(
+                    //dpl::execution::make_device_policy(q_ct1),
+                    beg, end, codes_beg,
+                    CalcMorton(octreeGlobal.minp, octreeGlobal.maxp));
+        }
+
+        int* indices_beg =indices.ptr();
+        int* indices_end = indices_beg + indices.size();
+        {
+            //ScopeTimer timer("sort");
+            dpct::iota(dpl::execution::make_device_policy(q_ct1),
+                       indices_beg, indices_end);
+            dpct::sort(dpl::execution::make_device_policy(q_ct1),
+                       codes_beg, codes_end, indices_beg);
+        }
+
+        {
+            ////ScopeTimer timer("perm"); 
+            //thrust::copy(make_permutation_iterator(beg, indices_beg),
+            //                  make_permutation_iterator(end, indices_end), device_ptr<float3>(points_sorted.ptr()));    
+
+        }
+
+        {
+           float* xs = points_sorted.ptr(0);
+           float* ys = points_sorted.ptr(1);
+           float* zs = points_sorted.ptr(2);
+
+           auto permutation_first = dpl::make_permutation_iterator(beg, indices_beg);
+           auto permutation_last = permutation_first + points_num;//oneapi::dpl::make_permutation_iterator(end, indices_end);
+            //ScopeTimer timer("perm2");
+                std::transform(
+                //dpl::execution::make_device_policy(q_ct1),
+                permutation_first,
+                permutation_last,
+                dpl::make_zip_iterator(xs, ys, zs),
+                PointType_to_tuple<PointType>());
+        }
+    }
+
+    SingleStepBuild ssb;
+    ssb.octree = octreeGlobal;
+    ssb.codes  = codes;
+    ssb.points_number = (int)codes.size();
+    //printFuncAttrib(singleStepKernel);
+
+    q_ct1.submit([&](sycl::handler& cgh) {
+      sycl::local_accessor<int, 0> nodes_num_acc_ct1(cgh);
+      sycl::local_accessor<int, 0> tasks_beg_acc_ct1(cgh);
+      sycl::local_accessor<int, 0> tasks_end_acc_ct1(cgh);
+      sycl::local_accessor<int, 0> total_new_acc_ct1(cgh);
+      sycl::local_accessor<volatile int> offsets_acc_ct1(sycl::range<1>(CTA_SIZE), cgh);
+
+      cgh.parallel_for(
+        sycl::nd_range(sycl::range<1>(GRID_SIZE* CTA_SIZE),
+                          sycl::range<1>(CTA_SIZE)),
+        //subgroup size has to be 32 to match original CUDA implementation.
+        [=](sycl::nd_item<1> item_ct1)[[intel::reqd_sub_group_size(32)]] {
+          sycl::local_ptr<int> nodes_num_ptr = nodes_num_acc_ct1;
+          sycl::local_ptr<int> tasks_beg_ptr = tasks_beg_acc_ct1;
+          sycl::local_ptr<int> tasks_end_ptr = tasks_end_acc_ct1;
+          sycl::local_ptr<int> total_new_ptr = total_new_acc_ct1;
+          sycl::local_ptr<volatile int> offsets_ptr = offsets_acc_ct1;
+          pcl::oneapi::device::singleStepKernel(
+              ssb, item_ct1, nodes_num_ptr, tasks_beg_ptr, tasks_end_ptr,
+              total_new_ptr, offsets_ptr);
+        });
+    }).wait();
+}
diff --git a/oneapi/octree/src/dpcpp/octree_host.cpp b/oneapi/octree/src/dpcpp/octree_host.cpp
new file mode 100755
index 000000000..d9b7c79cd
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/octree_host.cpp
@@ -0,0 +1,257 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+*/
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "pcl/oneapi/utils/safe_call.hpp"
+
+#include "internal.hpp"
+#include "utils/approx_nearest_utils.hpp"
+#include "utils/boxutils.hpp"
+
+#include<algorithm>
+#include<limits>
+#include <tuple>
+
+using namespace pcl::oneapi;
+using namespace pcl::oneapi::device;
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            void get_cc_kernel(int *data, sycl::nd_item<3>& item_ct1)
+            {
+                data[item_ct1.get_local_id(2) +
+                     item_ct1.get_local_range().get(2) * item_ct1.get_group(2)] =
+                    item_ct1.get_local_id(2);
+            }
+        }
+    }
+}
+
+void  pcl::oneapi::device::OctreeImpl::get_gpu_arch_compiled_for(int& bin, int& ptx)
+{
+    dpct::kernel_function_info attrs;
+    cudaSafeCall(
+        (dpct::get_kernel_function_info(&attrs, (const void *)get_cc_kernel),
+         0));
+    // bin = attrs.binaryVersion;
+    // ptx = attrs.ptxVersion;
+}
+
+void pcl::oneapi::device::OctreeImpl::setCloud(const PointCloud& input_points)
+{
+    points = input_points;
+}
+
+void pcl::oneapi::device::OctreeImpl::internalDownload()
+{
+    int number;
+    DeviceArray<int>(octreeGlobal.nodes_num, 1).download(&number); 
+
+    DeviceArray<int>(octreeGlobal.begs,  number).download(host_octree.begs);    
+    DeviceArray<int>(octreeGlobal.ends,  number).download(host_octree.ends);    
+    DeviceArray<int>(octreeGlobal.nodes, number).download(host_octree.nodes);    
+    DeviceArray<int>(octreeGlobal.codes, number).download(host_octree.codes); 
+
+    points_sorted.download(host_octree.points_sorted, host_octree.points_sorted_step);    
+    indices.download(host_octree.indices);    
+
+    host_octree.downloaded = true;
+}
+
+namespace 
+{
+    struct OctreeIteratorHost
+    {        
+        const static int MAX_LEVELS_PLUS_ROOT = 11;
+        int paths[MAX_LEVELS_PLUS_ROOT];          
+        int level;
+
+        OctreeIteratorHost()
+        {
+            level = 0; // root level
+            paths[level] = (0 << 8) + 1;                    
+        }
+
+        void gotoNextLevel(int first, std::size_t len) 
+        {   
+            ++level;
+            paths[level] = (first << 8) + len;        
+        }       
+
+        int operator*() const 
+        { 
+            return paths[level] >> 8; 
+        }        
+
+        void operator++()
+        {
+            while(level >= 0)
+            {
+                int data = paths[level];
+
+                if ((data & 0xFF) > 1) // there are another siblings, can goto there
+                {                           
+                    data += (1 << 8) - 1;  // +1 to first and -1 from len
+                    paths[level] = data;
+                    break;
+                }
+                else
+                    --level; //goto parent;            
+            }        
+        }        
+    };
+
+}
+
+void pcl::oneapi::device::OctreeImpl::radiusSearchHost(const PointType& query, float radius, std::vector<int>& out, int max_nn) const
+{            
+    out.clear();
+
+    sycl::float3 center = sycl::float3(query.x(), query.y(), query.z());
+
+    OctreeIteratorHost iterator;
+
+    while(iterator.level >= 0)
+    {        
+        int node_idx = *iterator;
+        int code = host_octree.codes[node_idx];
+
+        sycl::float3 node_minp = octreeGlobal.minp;
+        sycl::float3 node_maxp = octreeGlobal.maxp;
+        calcBoundingBox(iterator.level, code, node_minp, node_maxp);
+
+        //if true, take nothing, and go to next
+        if (checkIfNodeOutsideSphere(node_minp, node_maxp, center, radius))        
+        {                
+            ++iterator;            
+            continue;
+        }
+
+        //if true, take all, and go to next
+        if (checkIfNodeInsideSphere(node_minp, node_maxp, center, radius))
+        {            
+            int beg = host_octree.begs[node_idx];
+            int end = host_octree.ends[node_idx];
+
+            end = beg + std::min((int)out.size() + end - beg, max_nn) -
+                  (int)out.size();
+
+            out.insert(out.end(), host_octree.indices.begin() + beg, host_octree.indices.begin() + end);
+            if (out.size() == (std::size_t)max_nn)
+                return;
+
+            ++iterator;
+            continue;
+        }
+
+        // test children
+        int children_mask = host_octree.nodes[node_idx] & 0xFF;
+
+        bool isLeaf = children_mask == 0;
+
+        if (isLeaf)
+        {            
+            const int beg = host_octree.begs[node_idx];
+            const int end = host_octree.ends[node_idx];                                    
+
+            for(int j = beg; j < end; ++j)
+            {
+                int index = host_octree.indices[j];
+                float point_x = host_octree.points_sorted[j                                     ];
+                float point_y = host_octree.points_sorted[j + host_octree.points_sorted_step    ];
+                float point_z = host_octree.points_sorted[j + host_octree.points_sorted_step * 2];
+
+                float dx = (point_x - center.x());
+                float dy = (point_y - center.y());
+                float dz = (point_z - center.z());
+
+                float dist2 = dx * dx + dy * dy + dz * dz;
+
+                if (dist2 < radius * radius)
+                    out.push_back(index);
+
+                if (out.size() == (std::size_t)max_nn)
+                    return;
+            }               
+            ++iterator;               
+            continue;
+        }
+
+        int first  = host_octree.nodes[node_idx] >> 8;
+        iterator.gotoNextLevel(first, getBitsNum_host_ct5(children_mask));
+    }
+}
+
+void  pcl::oneapi::device::OctreeImpl::approxNearestSearchHost(const PointType& query, int& out_index, float& sqr_dist) const
+{
+    const sycl::float3 &minp = octreeGlobal.minp;
+    const sycl::float3 &maxp = octreeGlobal.maxp;
+    const sycl::float3 query_point =
+        sycl::float3(query.x(), query.y(), query.z());
+
+    const int node_idx = pcl::oneapi::device::findNode(minp, maxp, query_point, host_octree.nodes);
+
+    int beg = host_octree.begs[node_idx];
+    int end = host_octree.ends[node_idx];
+
+    sqr_dist = std::numeric_limits<float>::max();
+
+    for(int i = beg; i < end; ++i)
+    {
+        float point_x = host_octree.points_sorted[i                                     ];
+        float point_y = host_octree.points_sorted[i + host_octree.points_sorted_step    ];
+        float point_z = host_octree.points_sorted[i + host_octree.points_sorted_step * 2];
+
+        float dx = (point_x - query.x());
+        float dy = (point_y - query.y());
+        float dz = (point_z - query.z());
+
+        float d2 = dx * dx + dy * dy + dz * dz;
+
+        if (sqr_dist > d2)
+        {
+            sqr_dist = d2;
+            out_index = i;
+        }
+    }
+
+    out_index = host_octree.indices[out_index];
+}
diff --git a/oneapi/octree/src/dpcpp/octree_iterator.hpp b/oneapi/octree/src/dpcpp/octree_iterator.hpp
new file mode 100755
index 000000000..8eb77d286
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/octree_iterator.hpp
@@ -0,0 +1,169 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_OCTREE_ITERATOR
+#define PCL_ONEAPI_OCTREE_ITERATOR
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+
+            template<int CTA_SIZE, int STACK_DEPTH>
+            struct OctreeIteratorDevice
+            {
+                using Storage = int[STACK_DEPTH][CTA_SIZE];
+
+                int level;
+                Storage& storage;
+                //Need to initialize
+                sycl::nd_item<3> item_ct1;
+            
+                __dpct_inline__
+                OctreeIteratorDevice(Storage& storage_arg)
+                : storage(storage_arg)
+                {
+                    level = 0; // root level
+                    storage[level][item_ct1.get_local_id(2)] = (0 << 8) + 1;
+                }
+
+                __dpct_inline__ void
+                gotoNextLevel(int first, int len)
+                {
+                    ++level;
+                    storage[level][item_ct1.get_local_id(2)] = (first << 8) + len;
+                }
+
+                __dpct_inline__ int
+                operator*() const
+                {
+                    return storage[level][item_ct1.get_local_id(2)] >> 8;
+                }
+
+                __dpct_inline__ void
+                operator++()
+                {
+                    while(level >= 0)
+                    {
+                        int data = storage[level][item_ct1.get_local_id(2)];
+
+                        if ((data & 0xFF) > 1) // there are another siblings, can goto there
+                        {
+                            data += (1 << 8) - 1;  // +1 to first and -1 from len
+                            storage[level][item_ct1.get_local_id(2)] = data;
+                            break;
+                        }
+                        else
+                            --level; //goto parent;
+                    }
+                }
+            };
+
+            struct OctreeIteratorDeviceNS
+            {
+                int level;
+                int node_idx;
+                int length;
+                const OctreeGlobalWithBox& octree;
+
+                __dpct_inline__
+                OctreeIteratorDeviceNS(const OctreeGlobalWithBox &octree_arg)
+                    : octree(octree_arg)
+                {
+                    node_idx = 0;
+                    level = 0;
+                    length = 1;
+                }
+
+                __dpct_inline__ void gotoNextLevel(int first, int len)
+                {
+                    node_idx = first;
+                    length = len;
+                    ++level;
+                }
+
+                __dpct_inline__ int operator*() const
+                {
+                    return node_idx;
+                }
+
+                __dpct_inline__ void operator++()
+                {
+#if 1
+                    while(level >= 0)
+                    {
+                        if (length > 1)
+                        {
+                            length--;
+                            node_idx++;
+                            break;
+                        }
+
+                        if (node_idx == 0)
+                        {
+                            level = -1;
+                            return;
+                        }
+
+                        node_idx = octree.parent[node_idx];
+                        --level;
+                        if (node_idx == 0)
+                        {
+                            level = -1;
+                            return;
+                        }
+
+                        int parent = octree.nodes[octree.parent[node_idx]];
+                        int parent_first = parent >> 8;
+                        int parent_len = sycl::popcount(parent & 0xFF);
+
+                        int pos = node_idx - parent_first;
+
+                        length = parent_len - pos;
+                    }
+#endif
+                }
+
+            };
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_OCTREE_ITERATOR */
diff --git a/oneapi/octree/src/dpcpp/radius_search.cpp b/oneapi/octree/src/dpcpp/radius_search.cpp
new file mode 100755
index 000000000..312932402
--- /dev/null
+++ b/oneapi/octree/src/dpcpp/radius_search.cpp
@@ -0,0 +1,514 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+*/
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "internal.hpp"
+
+#include "pcl/oneapi/utils/device/warp.hpp"
+#include "pcl/oneapi/utils/common.h"
+#include "utils/copygen.hpp"
+#include "utils/boxutils.hpp"
+#include "utils/scan_block.hpp"
+
+#include "octree_iterator.hpp"
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            using PointType = OctreeImpl::PointType;
+
+            template<typename RadiusStrategy, typename FetchStrategy>
+            struct Batch : public RadiusStrategy, public FetchStrategy
+            {
+                const int *indices;
+                PtrStep<float> points;
+                OctreeGlobalWithBox octree;
+
+                int max_results;
+                mutable int* output;
+                mutable int* output_sizes;
+            };
+
+            struct DirectQuery
+            {
+                PtrSz<PointType> queries;
+                __dpct_inline__ sycl::float3 fetch(const int query_index) const
+                {
+                    const PointType& q = queries.data[query_index];
+                    return sycl::float3(q.x(), q.y(), q.z());
+                }
+            };
+
+
+            struct IndicesQuery : public DirectQuery
+            {
+                const int* queries_indices;
+                __dpct_inline__ sycl::float3 fetch(const int query_index) const
+                {
+                    const PointType& q = queries[queries_indices[query_index]];
+                    return sycl::float3(q.x(), q.y(), q.z());
+                }
+            };
+
+            struct SharedRadius
+            {
+                float radius;
+                __dpct_inline__ float getRadius(const int /*index*/) const { return radius; }
+            };
+
+            struct IndividualRadius
+            {
+                const float* radiuses;
+                __dpct_inline__ float getRadius(const int index) const {
+                  return radiuses[index];
+                }
+            };
+
+            struct KernelPolicy
+            {
+                enum
+                {
+                    CTA_SIZE = Warp::WARP_SIZE,
+
+                    WARP_SIZE = Warp::WARP_SIZE,
+                    WARPS_COUNT = CTA_SIZE/WARP_SIZE,
+
+                    MAX_LEVELS_PLUS_ROOT = 11,
+
+                    CHECK_FLAG = 1 << 31
+                    //CHECK_FLAG = 1 << 15
+
+                };
+
+                struct SmemStorage
+                {
+                    volatile int per_warp_buffer[WARPS_COUNT];
+                    volatile int cta_buffer[CTA_SIZE];
+                };
+            };
+
+            template<typename BatchType>
+            struct Warp_radiusSearch
+            {
+            public:
+                using OctreeIterator = OctreeIteratorDeviceNS;
+
+                const BatchType& batch;
+                OctreeIterator iterator;
+
+                int found_count;
+                int query_index;
+                sycl::float3 query;
+                float radius;
+
+                __dpct_inline__ Warp_radiusSearch(const BatchType &batch_arg,
+                                                  const int query_index_arg)
+                    : batch(batch_arg),
+                      iterator(/**/ batch.octree /*storage.paths*/), found_count(0),
+                      query_index(query_index_arg), radius(0.0f) {}
+
+                __dpct_inline__ void launch(bool active, sycl::nd_item<1>& item_ct1,
+                                            KernelPolicy::SmemStorage* storage)
+                {
+                    if (active)
+                    {
+                        query = batch.fetch(query_index);
+                        /*
+                        DPCT1084:72: The function call has multiple migration
+                        results in different template instantiations that could not
+                        be unified. You may need to adjust the code.
+                        */
+                        radius = batch.getRadius(query_index);
+                    }
+                    else
+                        query_index = -1;
+
+                    while (sycl::any_of_group(
+                        item_ct1.get_sub_group(),
+                        (0xFFFFFFFF &
+                         (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                            active))
+                    {
+                        int leaf = -1;
+
+                        if (active)
+                            leaf = examineNode(iterator);
+
+                        processLeaf(leaf, item_ct1, storage);
+
+                        active = active && iterator.level >= 0 && found_count < batch.max_results;
+                    }
+
+                    if (query_index != -1)
+                        batch.output_sizes[query_index] = found_count;
+                }
+
+            private:
+                __dpct_inline__ int examineNode(OctreeIterator &iterator)
+                {
+                    const int node_idx = *iterator;
+                    const int code = batch.octree.codes[node_idx];
+
+                    sycl::float3 node_minp = batch.octree.minp;
+                    sycl::float3 node_maxp = batch.octree.maxp;
+                    calcBoundingBox(iterator.level, code, node_minp, node_maxp);
+
+                    //if true, take nothing, and go to next
+                    if (checkIfNodeOutsideSphere(node_minp, node_maxp, query, radius))
+                    {
+                        ++iterator;
+                        return -1;
+                    }
+
+                    if (checkIfNodeInsideSphere(node_minp, node_maxp, query, radius))
+                    {
+                        ++iterator;
+                        return node_idx; //return node to copy
+                    }
+
+
+                    //need to go to next level
+                    const int node = batch.octree.nodes[node_idx];
+                    const int children_mask = node & 0xFF;
+                    const bool isLeaf = children_mask == 0;
+
+                    if (isLeaf)
+                    {
+                        ++iterator;
+                        return (node_idx | KernelPolicy::CHECK_FLAG); // return node to check                                                              
+                    }
+
+                    //goto next level
+                    const int first = node >> 8;
+                    const int len = sycl::popcount(children_mask);
+                    iterator.gotoNextLevel(first, len);
+                    return -1;
+                };
+
+                __dpct_inline__ int __ffs(int v){
+                   static const int MultiplyDeBruijnBitPosition[32] = 
+                   {
+                     0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8, 
+                     31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
+                   };
+                   if(v == 0){
+                      return 0;
+                   }
+                   else{
+                      return 1 + MultiplyDeBruijnBitPosition[((uint32_t)((v & -v) * 0x077CB531U)) >> 27];
+                   }
+                };
+
+                __dpct_inline__ void processLeaf(int leaf,
+                                                 sycl::nd_item<1>& item_ct1,
+                                                 KernelPolicy::SmemStorage *storage)
+                {
+                    int mask = sycl::reduce_over_group(
+                        item_ct1.get_sub_group(),
+                        (0xFFFFFFFF &
+                         (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                                leaf != -1
+                            ? (0x1
+                               << item_ct1.get_sub_group().get_local_linear_id())
+                            : 0,
+                        sycl::ext::oneapi::plus<>());
+
+                    while(mask)
+                    {
+                        const unsigned int laneId = item_ct1.get_sub_group().get_local_linear_id();
+
+                        /*
+                        DPCT1004:63: Compatible DPC++ code could not be generated.
+                        */
+                        int active_lane = __ffs(mask) - 1; //[0..31]
+
+                        mask &= ~(1 << active_lane);
+
+                        //broadcast active_found_count
+                        /*
+                        DPCT1023:64: The DPC++ sub-group does not support mask
+                        options for sycl::select_from_group.
+                        */
+                        const int active_found_count = select_from_group(item_ct1.get_sub_group(),
+                            found_count, active_lane);
+
+                        const int node_idx = leaf & ~KernelPolicy::CHECK_FLAG;
+
+                        //broadcast beg and end
+                        int fbeg = 0, fend = 0;
+                        if (active_lane == laneId)
+                        {
+                          fbeg = batch.octree.begs[node_idx];
+                          fend = batch.octree.ends[node_idx];
+                        }
+                        /*
+                        DPCT1023:65: The DPC++ sub-group does not support mask
+                        options for sycl::select_from_group.
+                        */
+                        const int beg = sycl::select_from_group(
+                            item_ct1.get_sub_group(), fbeg, active_lane);
+                        /*
+                        DPCT1023:66: The DPC++ sub-group does not support mask
+                        options for sycl::select_from_group.
+                        */
+                        const int end = sycl::select_from_group(
+                            item_ct1.get_sub_group(), fend, active_lane);
+
+                        //broadcast active_query_index
+                        /*
+                        DPCT1023:67: The DPC++ sub-group does not support mask
+                        options for sycl::select_from_group.
+                        */
+                        const int active_query_index = sycl::select_from_group(
+                            item_ct1.get_sub_group(), query_index, active_lane);
+
+                        int length = end - beg;
+
+                        int *out = batch.output + active_query_index * batch.max_results + active_found_count;                    
+                        const int length_left = batch.max_results - active_found_count;
+
+                        const int test = sycl::any_of_group(
+                            item_ct1.get_sub_group(),
+                            (0xFFFFFFFF &
+                             (0x1
+                              << item_ct1.get_sub_group().get_local_linear_id())) &&
+                                active_lane == laneId &&
+                                (leaf & KernelPolicy::CHECK_FLAG));
+
+                        if (test)
+                        {
+                            //broadcast warp_radius
+                            /*
+                            DPCT1023:68: The DPC++ sub-group does not support mask
+                            options for sycl::select_from_group.
+                            */
+                            const float radius2 = sycl::select_from_group(
+                                item_ct1.get_sub_group(), radius * radius,
+                                active_lane);
+
+                            //broadcast warp_query
+                            const sycl::float3 active_query = sycl::float3(
+                                /*
+                                DPCT1023:69: The DPC++ sub-group does not support
+                                mask options for sycl::select_from_group.
+                                */
+                                sycl::select_from_group(item_ct1.get_sub_group(),
+                                                        query.x(), active_lane),
+                                /*
+                                DPCT1023:70: The DPC++ sub-group does not support
+                                mask options for sycl::select_from_group.
+                                */
+                                sycl::select_from_group(item_ct1.get_sub_group(),
+                                                        query.y(), active_lane),
+                                /*
+                                DPCT1023:71: The DPC++ sub-group does not support
+                                mask options for sycl::select_from_group.
+                                */
+                                sycl::select_from_group(item_ct1.get_sub_group(),
+                                                        query.z(), active_lane));
+
+                            length =
+                                TestWarpKernel(beg, active_query, radius2, length,
+                                               out, length_left, item_ct1, storage);
+                        }
+                        else
+                        {
+                            length = sycl::min(length, length_left);
+                            Warp::copy(batch.indices + beg, batch.indices + beg + length, out, laneId);
+                        }
+
+                        if (active_lane == laneId)
+                            found_count += length;
+                    }
+                }
+
+                __dpct_inline__ int
+                TestWarpKernel(const int beg, const sycl::float3 &active_query,
+                               const float radius2, const int length, int *out,
+                               const int length_left, sycl::nd_item<1>& item_ct1,
+                               KernelPolicy::SmemStorage *storage)
+                {
+                    unsigned int idx = item_ct1.get_sub_group().get_local_linear_id();
+                    const int last_threadIdx = item_ct1.get_local_linear_id() - idx + KernelPolicy::WARP_SIZE - 1;
+
+                    int total_new = 0;
+
+                    for(;;)
+                    {
+                        int take = 0;
+
+                        if (idx < length)
+                        {
+                            const float dx = batch.points.ptr(0)[beg + idx] - active_query.x();
+                            const float dy = batch.points.ptr(1)[beg + idx] - active_query.y();
+                            const float dz = batch.points.ptr(2)[beg + idx] - active_query.z();
+
+                            const float d2 = dx * dx + dy * dy + dz * dz;
+
+                            if (d2 < radius2)
+                                take = 1;
+                        }
+
+                        storage->cta_buffer[item_ct1.get_local_linear_id()] = take;
+
+                        const int offset = scan_warp<exclusive>(storage->cta_buffer, item_ct1);
+
+                        //ensure that we copy
+                        const bool out_of_bounds = (offset + total_new) >= length_left;
+
+                        if (take && !out_of_bounds)
+                            out[offset] = batch.indices[beg + idx];
+
+                        const int new_nodes = storage->cta_buffer[last_threadIdx];
+
+                        idx += Warp::STRIDE;
+
+                        total_new += new_nodes;
+                        out += new_nodes;
+
+                        if (sycl::all_of_group(
+                                item_ct1.get_sub_group(),
+                                (~0xFFFFFFFF & (0x1 <<
+                                                item_ct1.get_sub_group().get_local_linear_id())) ||
+                                    idx >= length) ||
+                            sycl::any_of_group(
+                                item_ct1.get_sub_group(),
+                                (0xFFFFFFFF & (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                                    out_of_bounds) ||
+                            total_new == length_left)
+                            break;
+                    }
+                    return sycl::min(total_new, length_left);
+                }
+            };
+//Larry
+            template<typename BatchType>
+            void KernelRS(const BatchType &batch, sycl::nd_item<1>& item_ct1,
+                          sycl::local_ptr<KernelPolicy::SmemStorage>& storage)
+            {
+                const int query_index = item_ct1.get_global_linear_id();
+
+                const bool active = query_index < batch.queries.size;
+
+                if (sycl::all_of_group(
+                        item_ct1.get_sub_group(),
+                        (~0xFFFFFFFF &
+                         (0x1 << item_ct1.get_sub_group().get_local_linear_id())) ||
+                            active == false))
+                    return;
+
+                Warp_radiusSearch<BatchType> search(batch, query_index);
+                search.launch(active, item_ct1, storage);
+            }
+        }
+    }
+}
+
+template<typename BatchType>
+void pcl::oneapi::device::OctreeImpl::radiusSearchEx(BatchType& batch, const Queries& queries, NeighborIndices& results)
+{
+    batch.indices = indices;
+    batch.octree = octreeGlobal;
+
+    batch.max_results = results.max_elems;
+    batch.output = results.data;
+    batch.output_sizes = results.sizes;
+
+    batch.points = points_sorted;
+
+    /*
+    DPCT1027:60: The call to cudaFuncSetCacheConfig was replaced with 0 because
+    DPC++ currently does not support configuring shared memory on devices.
+    */
+    cudaSafeCall(0);
+
+    int block = KernelPolicy::CTA_SIZE;
+    int grid = divUp((int)batch.queries.size, block);
+    dpct::device_ext& dev_ct1 = dpct::get_current_device();
+    sycl::queue& q_ct1 = dev_ct1.default_queue();
+
+    q_ct1.submit([&](sycl::handler& cgh) {
+      sycl::local_accessor<KernelPolicy::SmemStorage, 0> storage_acc_ct1(cgh);
+
+      cgh.parallel_for(
+        sycl::nd_range<1>(sycl::range<1>(grid) *
+                              sycl::range<1>(block),
+                          sycl::range<1>(block)),
+        [=](sycl::nd_item<1> item_ct1) [[intel::reqd_sub_group_size(Warp::WARP_SIZE)]] {
+          sycl::local_ptr<KernelPolicy::SmemStorage> storage_ptr = storage_acc_ct1;
+          KernelRS(batch, item_ct1, storage_ptr);
+      });
+    }).wait();
+}
+
+
+void pcl::oneapi::device::OctreeImpl::radiusSearch(const Queries& queries, float radius, NeighborIndices& results)
+{
+    using BatchType = Batch<SharedRadius, DirectQuery>;
+
+    BatchType batch;
+    batch.radius = radius;
+    batch.queries = queries;
+    radiusSearchEx(batch, queries, results);
+}
+
+void pcl::oneapi::device::OctreeImpl::radiusSearch(const Queries& queries, const Radiuses& radiuses, NeighborIndices& results)
+{
+    using BatchType = Batch<IndividualRadius, DirectQuery>;
+
+    BatchType batch;
+    batch.radiuses = radiuses;
+    batch.queries = queries;
+    radiusSearchEx(batch, queries, results);
+}
+
+void pcl::oneapi::device::OctreeImpl::radiusSearch(const Queries& queries, const Indices& indices, float radius, NeighborIndices& results)
+{
+    using BatchType = Batch<SharedRadius, IndicesQuery>;
+
+    BatchType batch;
+    batch.radius = radius;
+
+    batch.queries = queries;
+    batch.queries_indices = indices;
+    batch.queries.size = indices.size();
+
+    radiusSearchEx(batch, queries, results);
+}
diff --git a/oneapi/octree/src/internal.hpp b/oneapi/octree/src/internal.hpp
new file mode 100755
index 000000000..e0c95965a
--- /dev/null
+++ b/oneapi/octree/src/internal.hpp
@@ -0,0 +1,150 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_OCTREE_INTERNAL_HPP_
+#define PCL_ONEAPI_OCTREE_INTERNAL_HPP_
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/octree/device_format.hpp>
+#include <pcl/oneapi/utils/safe_call.hpp>
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {   
+            struct OctreeGlobal
+            {             
+                int *nodes;
+                int *codes;
+                int *begs;
+                int *ends;
+    
+                int *nodes_num;
+    
+                int *parent;
+    
+                OctreeGlobal() : nodes(nullptr), codes(nullptr), begs(nullptr), ends(nullptr), nodes_num(nullptr), parent(nullptr) {}
+            };
+
+            struct OctreeGlobalWithBox : public OctreeGlobal
+            {
+                sycl::float3 minp, maxp;
+            };
+
+            class OctreeImpl
+            {
+            public:
+                using PointType = sycl::float4;
+                using PointArray = DeviceArray<PointType>;
+
+                using PointCloud = PointArray;
+                using Queries = PointArray;
+
+                using Radiuses = DeviceArray<float>;
+                using BatchResult = DeviceArray<int>;            
+                using BatchResultSizes = DeviceArray<int>;
+                using BatchResultSqrDists = DeviceArray<float>;
+                using Indices = DeviceArray<int>;
+
+                using NeighborIndices = pcl::oneapi::NeighborIndices;
+
+                static void get_gpu_arch_compiled_for(int& bin, int& ptr);
+
+                OctreeImpl(){ host_octree.downloaded = 0; host_octree.points_sorted_step = 0; };
+                ~OctreeImpl() {};
+
+                void setCloud(const PointCloud& input_points);           
+                void build();
+                void radiusSearchHost(const PointType& center, float radius, std::vector<int>& out, int max_nn) const;
+                void approxNearestSearchHost(const PointType& query, int& out_index, float& sqr_dist) const;
+
+                void radiusSearch(const Queries& queries, float radius, NeighborIndices& results);
+                void radiusSearch(const Queries& queries, const Radiuses& radiuses, NeighborIndices& results);
+
+                void radiusSearch(const Queries& queries, const Indices& indices, float radius, NeighborIndices& results);
+
+                void approxNearestSearch(const Queries& queries, NeighborIndices& results, BatchResultSqrDists& sqr_distance) const;
+
+                void nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results, BatchResultSqrDists& sqr_distances) const;
+
+                //just reference 
+                PointCloud points;
+
+                // data
+                DeviceArray2D<float> points_sorted;
+                DeviceArray<int> codes;
+                DeviceArray<int> indices;
+
+                OctreeGlobalWithBox octreeGlobal;    
+
+                //storage
+                DeviceArray2D<int> storage;            
+
+                struct OctreeDataHost
+                {
+                    std::vector<int> nodes;
+                    std::vector<int> codes;	
+
+                    std::vector<int> begs;
+                    std::vector<int> ends;	
+
+
+                    std::vector<int> indices;	
+
+                    std::vector<float> points_sorted;
+                    int points_sorted_step;
+
+                    int downloaded;
+
+                } host_octree;
+
+
+                void internalDownload(); 
+            private:
+                template<typename BatchType>
+                void radiusSearchEx(BatchType& batch, const Queries& queries, NeighborIndices& results);
+            };
+
+            void bruteForceRadiusSearch(const OctreeImpl::PointCloud& cloud, const OctreeImpl::PointType& query, float radius, DeviceArray<int>& result, DeviceArray<int>& buffer);
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_OCTREE_INTERNAL_HPP_ */
diff --git a/oneapi/octree/src/octree.cpp b/oneapi/octree/src/octree.cpp
new file mode 100755
index 000000000..2404ba399
--- /dev/null
+++ b/oneapi/octree/src/octree.cpp
@@ -0,0 +1,217 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <pcl/oneapi/octree/octree.hpp>
+#include <pcl/oneapi/utils/safe_call.hpp>
+
+#include "internal.hpp"
+#include <pcl/oneapi/utils/device/static_check.hpp>
+#include <pcl/exceptions.h>
+
+#include<cassert>
+
+using namespace pcl::oneapi::device;
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////// Octree Host Interface implementation ////////////////////////////////
+
+pcl::oneapi::Octree::Octree() : cloud_(nullptr), impl(nullptr)
+{
+    Static<sizeof(PointType) == sizeof(OctreeImpl::PointType)>::check();
+
+    impl = new OctreeImpl();        
+    built_ = false;
+}
+
+pcl::oneapi::Octree::Octree(const pcl::oneapi::Octree& src) : cloud_(nullptr), impl(nullptr)
+{
+    Static<sizeof(PointType) == sizeof(OctreeImpl::PointType)>::check();
+
+    impl = new OctreeImpl();        
+    built_ = false;
+
+    memcpy(impl, src.impl, sizeof(OctreeImpl));
+}
+
+pcl::oneapi::Octree::~Octree() { clear(); }
+
+void pcl::oneapi::Octree::clear()
+{
+    delete static_cast<OctreeImpl*>(impl);
+}
+
+pcl::oneapi::Octree& pcl::oneapi::Octree::operator=(const pcl::oneapi::Octree& src){
+    if (&src == this){
+        return *this;
+    }
+    memcpy(impl, src.impl, sizeof(OctreeImpl));
+    return *this;
+}
+
+void pcl::oneapi::Octree::setCloud(const PointCloud& cloud_arg)
+{    
+    const OctreeImpl::PointCloud& cloud = (const OctreeImpl::PointCloud&)cloud_arg;
+    cloud_ =  &cloud_arg;
+    static_cast<OctreeImpl*>(impl)->setCloud(cloud);
+}
+
+void pcl::oneapi::Octree::build()
+{
+    static_cast<OctreeImpl*>(impl)->build();    
+    built_ = true;
+}
+
+bool pcl::oneapi::Octree::isBuilt() const
+{
+    return built_;
+}
+
+void pcl::oneapi::Octree::internalDownload()
+{
+    static_cast<OctreeImpl*>(impl)->internalDownload();
+}
+
+void pcl::oneapi::Octree::radiusSearchHost(const PointType& center, float radius, std::vector<int>& out, int max_nn)
+{
+    if (!static_cast<OctreeImpl*>(impl)->host_octree.downloaded)
+        internalDownload();
+
+    OctreeImpl::PointType query;
+    query.x() = center.x;
+    query.y() = center.y;
+    query.z() = center.z;
+
+    static_cast<OctreeImpl*>(impl)->radiusSearchHost(query, radius, out, max_nn);
+}
+
+void  pcl::oneapi::Octree::approxNearestSearchHost(const PointType& query, int& out_index, float& sqr_dist)
+{
+    if (!static_cast<OctreeImpl*>(impl)->host_octree.downloaded)
+        internalDownload();
+
+    OctreeImpl::PointType q;
+    q.x() = query.x;
+    q.y() = query.y;
+    q.z() = query.z;
+
+    static_cast<OctreeImpl*>(impl)->approxNearestSearchHost(q, out_index, sqr_dist);
+
+}
+                        
+void pcl::oneapi::Octree::radiusSearch(const Queries& queries, float radius, int max_results, NeighborIndices& results) const
+{
+    assert(queries.size() > 0);
+    results.create(static_cast<int> (queries.size()), max_results);
+    results.sizes.create(queries.size());
+    
+    const OctreeImpl::Queries& q = (const OctreeImpl::Queries&)queries;
+    static_cast<OctreeImpl*>(impl)->radiusSearch(q, radius, results);
+}
+
+void pcl::oneapi::Octree::radiusSearch(const Queries& queries, const Radiuses& radiuses, int max_results, NeighborIndices& results) const
+{
+    assert(queries.size() > 0);
+    assert(queries.size() == radiuses.size());
+    results.create(static_cast<int> (queries.size()), max_results);
+    results.sizes.create(queries.size());
+    
+    const OctreeImpl::Queries& q = (const OctreeImpl::Queries&)queries;
+    static_cast<OctreeImpl*>(impl)->radiusSearch(q, radiuses, results);
+}
+
+void pcl::oneapi::Octree::radiusSearch(const Queries& queries, const Indices& indices, float radius, int max_results, NeighborIndices& results) const
+{
+    assert(queries.size() > 0 && indices.size() > 0);
+    results.create(static_cast<int> (indices.size()), max_results);
+    results.sizes.create(indices.size());
+    
+    const OctreeImpl::Queries& q = (const OctreeImpl::Queries&)queries;
+    static_cast<OctreeImpl*>(impl)->radiusSearch(q, indices, radius, results);
+}
+
+void pcl::oneapi::Octree::approxNearestSearch(const Queries& queries, NeighborIndices& results) const
+{
+    ResultSqrDists sqr_distance;
+    approxNearestSearch(queries, results, sqr_distance);
+}
+
+void pcl::oneapi::Octree::approxNearestSearch(const Queries& queries, NeighborIndices& results, ResultSqrDists& sqr_distance) const
+{
+    assert(queries.size() > 0);
+    results.create(static_cast<int> (queries.size()), 1);
+    sqr_distance.create(queries.size());
+    
+    const OctreeImpl::Queries& q = (const OctreeImpl::Queries&)queries;
+    static_cast<OctreeImpl*>(impl)->approxNearestSearch(q, results, sqr_distance);
+}
+
+void pcl::oneapi::Octree::nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results) const
+{
+    ResultSqrDists sqr_distances;
+    nearestKSearchBatch(queries, k, results, sqr_distances);
+}
+
+void pcl::oneapi::Octree::nearestKSearchBatch(const Queries& queries, int k, NeighborIndices& results, ResultSqrDists& sqr_distances) const
+{
+    assert(queries.size() > 0);
+    results.create(static_cast<int> (queries.size()), k);
+    sqr_distances.create(queries.size() * k);
+
+    const OctreeImpl::Queries& q = (const OctreeImpl::Queries&)queries;
+
+    static_cast<OctreeImpl*>(impl)->nearestKSearchBatch(q, k, results, sqr_distances);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////
+//////////////// Brute Force Radius Search Mediator //////////////////////////////////
+
+// void pcl::oneapi::bruteForceRadiusSearchGPU(const Octree::PointCloud& cloud, const PointXYZ& query,  float radius,  DeviceArray<int>& result,  DeviceArray<int>& buffer)
+// {
+    // using PointType = OctreeImpl::PointType;
+    // using PointCloud = OctreeImpl::PointCloud;    
+    
+    // PointType query_local;
+    // query_local.x() = query.x;
+    // query_local.y() = query.y;
+    // query_local.z() = query.z;
+
+    // Static<sizeof(PointType) == sizeof(OctreeImpl::PointType)>::check();
+
+    // PointCloud cloud_local((PointType*)cloud.ptr(), cloud.size());
+    // bruteForceRadiusSearch(cloud_local, query_local, radius, result, buffer);
+// }
diff --git a/oneapi/octree/src/utils/approx_nearest_utils.hpp b/oneapi/octree/src/utils/approx_nearest_utils.hpp
new file mode 100755
index 000000000..e3e9930ae
--- /dev/null
+++ b/oneapi/octree/src/utils/approx_nearest_utils.hpp
@@ -0,0 +1,135 @@
+/*
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2020-, Open Perception
+ *
+ *  All rights reserved
+ */
+
+#pragma once
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "morton.hpp"
+#include <assert.h>
+
+#include <limits>
+#include <tuple>
+#include <bitset>
+
+namespace pcl {
+namespace oneapi {
+namespace device {
+
+__dpct_inline__ unsigned getBitsNum(const unsigned integer)
+{
+
+    return sycl::popcount(integer);
+}
+__dpct_inline__ std::size_t getBitsNum_host_ct5(const unsigned integer)
+{
+
+    return std::bitset<8 * sizeof(integer)>(integer).count();
+}
+
+__dpct_inline__ std::pair<sycl::uint3, std::uint8_t>
+nearestVoxel(const sycl::float3 query, const unsigned &level,
+             const std::uint8_t &mask, const sycl::float3 &minp,
+             const sycl::float3 &maxp, const sycl::uint3 &index)
+{
+  assert(mask != 0);
+  // identify closest voxel
+  float closest_distance = std::numeric_limits<float>::max();
+  unsigned closest_index = 0;
+  sycl::uint3 closest = sycl::uint3(0, 0, 0);
+
+  for (unsigned i = 0; i < 8; ++i) {
+    if ((mask & (1 << i)) == 0) // no child
+      continue;
+
+    const sycl::uint3 child = sycl::uint3((index.x() << 1) + (i & 1),
+                                          (index.y() << 1) + ((i >> 1) & 1),
+                                          (index.z() << 1) + ((i >> 2) & 1));
+
+    // find center of child cell
+    const unsigned voxel_width_scale_factor = 1 << (level + 2);
+    const sycl::float3 voxel_center =
+        sycl::float3(minp.x() + (maxp.x() - minp.x()) * (2 * child.x() + 1) /
+                                    voxel_width_scale_factor,
+                     minp.y() + (maxp.y() - minp.y()) * (2 * child.y() + 1) /
+                                    voxel_width_scale_factor,
+                     minp.z() + (maxp.z() - minp.z()) * (2 * child.z() + 1) /
+                                    voxel_width_scale_factor);
+
+    // compute distance to centroid
+    const sycl::float3 dist =
+        sycl::float3(voxel_center.x() - query.x(), voxel_center.y() - query.y(),
+                     voxel_center.z() - query.z());
+
+    const float distance_to_query =
+        dist.x() * dist.x() + dist.y() * dist.y() + dist.z() * dist.z();
+
+    // compare distance
+    if (distance_to_query < closest_distance) {
+      closest_distance = distance_to_query;
+      closest_index = i;
+      closest = child;
+    }
+  }
+
+  return {closest, 1 << closest_index};
+}
+
+#pragma hd_warning_disable
+template <typename T>
+int findNode(const sycl::float3 minp, const sycl::float3 maxp,
+             const sycl::float3 query, const T nodes)
+{
+  size_t node_idx = 0;
+  const auto code = CalcMorton(minp, maxp)(query);
+  unsigned level = 0;
+
+  bool voxel_traversal = false;
+  sycl::uint3 index = Morton::decomposeCode(code);
+  std::uint8_t mask_pos;
+
+  while (true) {
+    const auto node = nodes[node_idx];
+    const std::uint8_t mask = node & 0xFF;
+
+    if (!mask) // leaf
+      return node_idx;
+
+    if (voxel_traversal) // empty voxel already encountered, performing nearest-centroid
+                         // based traversal
+    {
+      const auto nearest_voxel = nearestVoxel(query, level, mask, minp, maxp, index);
+      index = nearest_voxel.first;
+      mask_pos = nearest_voxel.second;
+    }
+    else {
+      mask_pos = 1 << Morton::extractLevelCode(code, level);
+
+      if (!(mask & mask_pos)) // child doesn't exist
+      {
+        const auto remaining_depth = Morton::levels - level;
+        index.x() >>= remaining_depth;
+        index.y() >>= remaining_depth;
+        index.z() >>= remaining_depth;
+
+        voxel_traversal = true;
+        const auto nearest_voxel = nearestVoxel(query, level, mask, minp, maxp, index);
+        index = nearest_voxel.first;
+        mask_pos = nearest_voxel.second;
+      }
+    }
+
+    unsigned mask_internal = mask & (mask_pos - 1);
+    node_idx = (node >> 8) + getBitsNum(mask_internal);
+    ++level;
+  }
+}
+} // namespace device
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/octree/src/utils/boxutils.hpp b/oneapi/octree/src/utils/boxutils.hpp
new file mode 100755
index 000000000..177e4304c
--- /dev/null
+++ b/oneapi/octree/src/utils/boxutils.hpp
@@ -0,0 +1,133 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef _PCL_ONEAPI_OCTREE_BOXUTILS_HPP_
+#define _PCL_ONEAPI_OCTREE_BOXUTILS_HPP_
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "utils/morton.hpp"
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            __dpct_inline__ static bool
+            checkIfNodeInsideSphere(const sycl::float3 &minp,
+                                    const sycl::float3 &maxp, const sycl::float3 &c,
+                                    float r)
+            {
+                r *= r;
+
+                float d2_xmin = (minp.x() - c.x()) * (minp.x() - c.x());
+                float d2_ymin = (minp.y() - c.y()) * (minp.y() - c.y());
+                float d2_zmin = (minp.z() - c.z()) * (minp.z() - c.z());
+
+                if (d2_xmin + d2_ymin + d2_zmin > r)
+                    return false;
+
+                float d2_zmax = (maxp.z() - c.z()) * (maxp.z() - c.z());
+
+                if (d2_xmin + d2_ymin + d2_zmax > r)
+                    return false;
+
+                float d2_ymax = (maxp.y() - c.y()) * (maxp.y() - c.y());
+
+                if (d2_xmin + d2_ymax + d2_zmin > r)
+                    return false;
+
+                if (d2_xmin + d2_ymax + d2_zmax > r)
+                    return false;
+
+                float d2_xmax = (maxp.x() - c.x()) * (maxp.x() - c.x());
+
+                if (d2_xmax + d2_ymin + d2_zmin > r)
+                    return false;
+
+                if (d2_xmax + d2_ymin + d2_zmax > r)
+                    return false;
+
+                if (d2_xmax + d2_ymax + d2_zmin > r)
+                    return false;
+
+                if (d2_xmax + d2_ymax + d2_zmax > r)
+                    return false;
+
+                return true;
+            }
+
+            __dpct_inline__ static bool
+            checkIfNodeOutsideSphere(const sycl::float3 &minp,
+                                     const sycl::float3 &maxp,
+                                     const sycl::float3 &c, float r)
+            {
+                if (maxp.x() < (c.x() - r) || maxp.y() < (c.y() - r) ||
+                    maxp.z() < (c.z() - r))
+                    return true;
+
+                if ((c.x() + r) < minp.x() || (c.y() + r) < minp.y() ||
+                    (c.z() + r) < minp.z())
+                    return true;
+
+                return false;
+            }
+
+            __dpct_inline__ static void calcBoundingBox(int level, int code,
+                                                        sycl::float3 &res_minp,
+                                                        sycl::float3 &res_maxp)
+            {        
+                int cell_x, cell_y, cell_z;
+                Morton::decomposeCode(code, cell_x, cell_y, cell_z);
+
+                float cell_size_x = (res_maxp.x() - res_minp.x()) / (1 << level);
+                float cell_size_y = (res_maxp.y() - res_minp.y()) / (1 << level);
+                float cell_size_z = (res_maxp.z() - res_minp.z()) / (1 << level);
+
+                res_minp.x() += cell_x * cell_size_x;
+                res_minp.y() += cell_y * cell_size_y;
+                res_minp.z() += cell_z * cell_size_z;
+
+                res_maxp.x() = res_minp.x() + cell_size_x;
+                res_maxp.y() = res_minp.y() + cell_size_y;
+                res_maxp.z() = res_minp.z() + cell_size_z;
+            }
+        }
+    }
+}
+
+#endif /* _PCL_ONEAPI_OCTREE_BOXUTILS_HPP_ */
diff --git a/oneapi/octree/src/utils/copygen.hpp b/oneapi/octree/src/utils/copygen.hpp
new file mode 100755
index 000000000..2483f4183
--- /dev/null
+++ b/oneapi/octree/src/utils/copygen.hpp
@@ -0,0 +1,97 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+*/
+
+#ifndef PCL_ONEAPI_OCTREE_COPYGE_HPP
+#define PCL_ONEAPI_OCTREE_COPYGE_HPP
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <pcl/oneapi/utils/device/warp.hpp>
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+
+            template <typename T>
+            void CopyKernel(const T* in, T *out, int length,
+                            sycl::nd_item<3> item_ct1)
+            {
+                int STRIDE = item_ct1.get_group_range(2) * item_ct1.get_local_range().get(2);
+                for (int idx = (item_ct1.get_group(2) *
+                                item_ct1.get_local_range().get(2)) +
+                               item_ct1.get_local_id(2);
+                     idx < length; idx += STRIDE)
+                {
+                    out[idx] = in[idx];
+                }
+            }
+
+            template <typename T>
+            void GenerateKernel(T* out, int beg, int end, sycl::nd_item<3> item_ct1)
+            {
+                int length = end - beg;
+                int pos = beg;
+
+                int STRIDE = item_ct1.get_local_range().get(2);
+                for (int idx = item_ct1.get_local_id(2); idx < length;
+                     idx += STRIDE, pos += STRIDE)
+                {
+                    out[idx] = pos + item_ct1.get_local_id(2);
+                }
+            }
+
+            template <typename T>
+            void GenerateTasksKernel(T* out, int beg, int end, int level,
+                                     sycl::nd_item<3> item_ct1)
+            {
+                int length = end - beg;
+                int pos = beg;
+
+                int STRIDE = item_ct1.get_local_range().get(2);
+                for (int idx = item_ct1.get_local_id(2); idx < length;
+                     idx += STRIDE, pos += STRIDE)
+                {
+                    out[idx] = ((pos + item_ct1.get_local_id(2)) << 8) + level;
+                }
+            }
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_OCTREE_COPYGE_HPP */
diff --git a/oneapi/octree/src/utils/morton.hpp b/oneapi/octree/src/utils/morton.hpp
new file mode 100755
index 000000000..80eab9a42
--- /dev/null
+++ b/oneapi/octree/src/utils/morton.hpp
@@ -0,0 +1,176 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_OCTREE_MORTON_HPP
+#define PCL_ONEAPI_OCTREE_MORTON_HPP
+
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            struct Morton
+            {   
+                const static int levels = 10;
+                const static int bits_per_level = 3;
+                const static int nbits = levels * bits_per_level;    
+
+                using code_t = int;
+
+                __dpct_inline__ static int spreadBits(int x, int offset)
+                {
+                    //......................9876543210
+                    x = (x | (x << 10)) & 0x000f801f; //............98765..........43210
+                    x = (x | (x <<  4)) & 0x00e181c3; //........987....56......432....10
+                    x = (x | (x <<  2)) & 0x03248649; //......98..7..5..6....43..2..1..0
+                    x = (x | (x <<  2)) & 0x09249249; //....9..8..7..5..6..4..3..2..1..0
+
+                    return x << offset;
+                }
+
+                __dpct_inline__ static int compactBits(int x, int offset)
+                {                                      
+                    x = ( x >> offset ) & 0x09249249;  //....9..8..7..5..6..4..3..2..1..0
+                    x = (x | (x >>  2)) & 0x03248649;  //......98..7..5..6....43..2..1..0                                          
+                    x = (x | (x >>  2)) & 0x00e181c3;  //........987....56......432....10                                       
+                    x = (x | (x >>  4)) & 0x000f801f;  //............98765..........43210                                          
+                    x = (x | (x >> 10)) & 0x000003FF;  //......................9876543210        
+
+                    return x;
+                }
+
+                __dpct_inline__ static code_t createCode(int cell_x, int cell_y, int cell_z)
+                { 
+                    return spreadBits(cell_x, 0) | spreadBits(cell_y, 1) | spreadBits(cell_z, 2); 
+                }
+
+                __dpct_inline__ static void decomposeCode(code_t code, int &cell_x,
+                                                          int &cell_y, int &cell_z)
+                { 
+                    cell_x = compactBits(code, 0);
+                    cell_y = compactBits(code, 1);
+                    cell_z = compactBits(code, 2);        
+                }
+
+                __dpct_inline__ static sycl::uint3 decomposeCode(code_t code)
+                {
+                    return sycl::uint3(compactBits(code, 0), compactBits(code, 1),
+                                       compactBits(code, 2));
+                }
+
+                __dpct_inline__ static code_t extractLevelCode(code_t code, int level)
+                {
+                    return (code >> (nbits - 3 * (level + 1) )) & 7; 
+                }
+
+                __dpct_inline__ static code_t shiftLevelCode(code_t level_code, int level)
+                {
+                    return level_code << (nbits - 3 * (level + 1));
+                }
+            };
+
+            struct CalcMorton
+            {   
+                const static int depth_mult = 1 << Morton::levels;
+
+                sycl::float3 minp_;
+                sycl::float3 dims_;
+
+                __dpct_inline__ CalcMorton(sycl::float3 minp, sycl::float3 maxp) : minp_(minp)
+                {
+                    dims_.x() = maxp.x() - minp.x();
+                    dims_.y() = maxp.y() - minp.y();
+                    dims_.z() = maxp.z() - minp.z();
+                }
+
+                __dpct_inline__ Morton::code_t operator()(const sycl::float3 &p) const
+                {
+                    //Using floorf due to changes to MSVC 16.9. See details here: https://devtalk.blender.org/t/cuda-compile-error-windows-10/17886/4
+                    //floorf is without std:: see why here: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=79700
+                    const int cellx = sycl::min(
+                        (int)sycl::floor(
+                            (float)(depth_mult *
+                                    sycl::min(
+                                        1.f,
+                                        sycl::max(0.f, (float)((p.x() - minp_.x()) /
+                                                               dims_.x()))))),
+                        (int)(depth_mult - 1));
+                    const int celly = sycl::min(
+                        (int)sycl::floor(
+                            (float)(depth_mult *
+                                    sycl::min(
+                                        1.f,
+                                        sycl::max(0.f, (float)((p.y() - minp_.y()) /
+                                                               dims_.y()))))),
+                        (int)(depth_mult - 1));
+                    const int cellz = sycl::min(
+                        (int)sycl::floor(
+                            (float)(depth_mult *
+                                    sycl::min(
+                                        1.f,
+                                        sycl::max(0.f, (float)((p.z() - minp_.z()) /
+                                                               dims_.z()))))),
+                        (int)(depth_mult - 1));
+
+                    return Morton::createCode(cellx, celly, cellz);
+                }
+                 __dpct_inline__ Morton::code_t operator()(const sycl::float4 &p) const
+                {
+                    return (*this)(sycl::float3(p.x(), p.y(), p.z()));
+                }	
+            };
+
+            struct CompareByLevelCode
+            {
+                int level;
+
+                __dpct_inline__ CompareByLevelCode(int level_arg) : level(level_arg) {}
+
+                __dpct_inline__ bool operator()(Morton::code_t code1,
+                                                Morton::code_t code2) const
+                {                  
+                    return Morton::extractLevelCode(code1, level) < Morton::extractLevelCode(code2, level);  
+                }	
+            };
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_OCTREE_MORTON_HPP */
diff --git a/oneapi/octree/src/utils/scan_block.hpp b/oneapi/octree/src/utils/scan_block.hpp
new file mode 100755
index 000000000..eac8e8ccd
--- /dev/null
+++ b/oneapi/octree/src/utils/scan_block.hpp
@@ -0,0 +1,146 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_OCTREE_SCAN_BLOCK_HPP
+#define PCL_ONEAPI_OCTREE_SCAN_BLOCK_HPP
+
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            enum ScanKind { exclusive,  inclusive } ;
+
+            template <ScanKind Kind, class T>
+            __dpct_inline__ T
+            scan_warp(volatile T* ptr, sycl::nd_item<1> item_ct1)
+            {
+                const unsigned int idx = item_ct1.get_local_id(0);
+                const unsigned int lane = idx & 31; // index of thread in warp (0..31)
+
+                if ( lane >=  1) ptr [idx ] = ptr [idx -  1] + ptr [idx];
+                if ( lane >=  2) ptr [idx ] = ptr [idx -  2] + ptr [idx];
+                if ( lane >=  4) ptr [idx ] = ptr [idx -  4] + ptr [idx];
+                if ( lane >=  8) ptr [idx ] = ptr [idx -  8] + ptr [idx];
+                if ( lane >= 16) ptr [idx ] = ptr [idx - 16] + ptr [idx];
+
+                if( Kind == inclusive ) 
+                    return ptr [idx ];
+                else 
+                    return (lane > 0) ? ptr [idx - 1] : 0;
+            }
+
+            template <ScanKind Kind, class T>
+            __dpct_inline__ T
+            scan_block(volatile T* ptr,
+                       sycl::nd_item<1> item_ct1)
+            {
+                const unsigned int idx = item_ct1.get_local_id(0);     
+                const unsigned int lane = idx & 31;
+                const unsigned int warpid = idx >> 5;
+
+                // Step 1: Intra - warp scan in each warp
+                T val = scan_warp <Kind>( ptr , item_ct1);
+
+                /*
+                DPCT1065:6: Consider replacing sycl::nd_item::barrier() with
+                sycl::nd_item::barrier(sycl::access::fence_space::local_space) for
+                better performance if there is no access to global memory.
+                */
+                item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                // Step 2: Collect per - warp partial results
+
+                /*  if( warpid == 0 ) 
+                if( lane == 31 ) 
+                ptr [ warpid ] = ptr [idx ];    
+
+                __syncthreads ();
+
+                if( warpid > 0 ) */
+                if( lane == 31 ) 
+                    ptr [ warpid ] = ptr [idx ];
+
+                /*
+                DPCT1065:7: Consider replacing sycl::nd_item::barrier() with
+                sycl::nd_item::barrier(sycl::access::fence_space::local_space) for
+                better performance if there is no access to global memory.
+                */
+                item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                // Step 3: Use 1st warp to scan per - warp results
+                if( warpid == 0 )
+                    scan_warp<inclusive>(ptr, item_ct1);
+
+                /*
+                 DPCT1065:8: Consider replacing sycl::nd_item::barrier() with
+                 sycl::nd_item::barrier(sycl::access::fence_space::local_space) for
+                 better performance if there is no access to global memory.
+                */
+                item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                // Step 4: Accumulate results from Steps 1 and 3
+                if ( warpid > 0) 
+                    val = ptr [warpid -1] + val;
+
+                /*
+                DPCT1065:9: Consider replacing sycl::nd_item::barrier() with
+                sycl::nd_item::barrier(sycl::access::fence_space::local_space) for
+                better performance if there is no access to global memory.
+                */
+                item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                // Step 5: Write and return the final result
+                ptr[idx] = val;
+
+                /*
+                DPCT1065:10: Consider replacing sycl::nd_item::barrier() with
+                sycl::nd_item::barrier(sycl::access::fence_space::local_space) for
+                better performance if there is no access to global memory.
+                */
+                item_ct1.barrier(sycl::access::fence_space::local_space);
+
+                return val ;
+            }
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_OCTREE_SCAN_BLOCK_HPP */
diff --git a/oneapi/pcl_config.h.in b/oneapi/pcl_config.h.in
new file mode 100644
index 000000000..fcf8a22ee
--- /dev/null
+++ b/oneapi/pcl_config.h.in
@@ -0,0 +1,88 @@
+/* pcl_config.h. Generated by CMake for @PROJECT_NAME@. */
+
+// Ensure the compiler is meeting the minimum C++ standard
+// MSVC is not checked via __cplusplus due to
+// https://developercommunity.visualstudio.com/content/problem/120156/-cplusplus-macro-still-defined-as-pre-c11-value.html
+#if (!defined(_MSC_VER) && __cplusplus < 201402L) || (defined(_MSC_VER) && _MSC_VER < 1900)
+  #error PCL requires C++14 or above
+#endif
+
+#define BUILD_@CMAKE_BUILD_TYPE@
+/* PCL version information */
+#define PCL_MAJOR_VERSION ${PCL_VERSION_MAJOR}
+#define PCL_MINOR_VERSION ${PCL_VERSION_MINOR}
+#define PCL_REVISION_VERSION ${PCL_VERSION_PATCH}
+#define PCL_DEV_VERSION ${PCL_DEV_VERSION}
+#define PCL_VERSION_PRETTY "${PCL_VERSION_PRETTY}"
+#define PCL_VERSION_CALC(MAJ, MIN, PATCH) (MAJ*100000+MIN*100+PATCH)
+#define PCL_VERSION \
+    PCL_VERSION_CALC(PCL_MAJOR_VERSION, PCL_MINOR_VERSION, PCL_REVISION_VERSION)
+#define PCL_VERSION_COMPARE(OP, MAJ, MIN, PATCH) \
+    (PCL_VERSION*10+PCL_DEV_VERSION OP PCL_VERSION_CALC(MAJ, MIN, PATCH)*10)
+
+/* Index type and signed/unsigned property */
+#define PCL_INDEX_SIGNED ${PCL_INDEX_SIGNED_STR}
+
+#if (${PCL_INDEX_SIZE} > 0)
+  #define PCL_INDEX_SIZE ${PCL_INDEX_SIZE}
+#else
+  #if PCL_MINOR_VERSION <= 11
+    // sizeof returns bytes, while we measure size by bits in the template
+    #define PCL_INDEX_SIZE (sizeof(int) * 8)
+  #else
+    #define PCL_INDEX_SIZE 32
+  #endif //PCL_MINOR_VERSION
+#endif 
+
+#cmakedefine HAVE_TBB 1
+
+#cmakedefine HAVE_OPENNI 1
+
+#cmakedefine HAVE_OPENNI2 1
+
+#cmakedefine HAVE_QHULL 1
+
+#cmakedefine HAVE_CUDA 1
+
+#cmakedefine HAVE_ENSENSO 1
+
+#cmakedefine HAVE_DAVIDSDK 1
+
+// SSE macros
+#cmakedefine HAVE_POSIX_MEMALIGN
+#cmakedefine HAVE_MM_MALLOC
+
+#cmakedefine HAVE_PNG
+
+/* Precompile for a minimal set of point types instead of all. */
+#cmakedefine PCL_ONLY_CORE_POINT_TYPES
+
+/* Do not precompile for any point types at all. */
+#cmakedefine PCL_NO_PRECOMPILE
+
+#ifdef DISABLE_OPENNI
+#undef HAVE_OPENNI
+#endif
+
+#ifdef DISABLE_OPENNI2
+#undef HAVE_OPENNI2
+#endif
+
+#ifdef DISABLE_QHULL
+#undef HAVE_QHULL
+#endif
+
+/* Verbosity level defined by user through ccmake. */
+#cmakedefine VERBOSITY_LEVEL_ALWAYS
+#cmakedefine VERBOSITY_LEVEL_ERROR
+#cmakedefine VERBOSITY_LEVEL_WARN
+#cmakedefine VERBOSITY_LEVEL_INFO
+#cmakedefine VERBOSITY_LEVEL_DEBUG
+#cmakedefine VERBOSITY_LEVEL_VERBOSE
+
+/* Address the cases where on MacOS and OpenGL and GLUT are not frameworks */
+#cmakedefine OPENGL_IS_A_FRAMEWORK
+#cmakedefine GLUT_IS_A_FRAMEWORK
+
+#cmakedefine HAVE_QVTK 1
+
diff --git a/oneapi/registration/CMakeLists.txt b/oneapi/registration/CMakeLists.txt
new file mode 100755
index 000000000..f1dcca284
--- /dev/null
+++ b/oneapi/registration/CMakeLists.txt
@@ -0,0 +1,48 @@
+set(SUBSYS_NAME oneapi_registration)
+set(SUBSYS_PATH oneapi/registration)
+set(SUBSYS_DESC "Point cloud oneAPI registration library")
+set(SUBSYS_DEPS common registration oneapi_kdtree kdtree oneapi_search search oneapi_common)
+string(APPEND CMAKE_CXX_FLAGS " -Wno-dtor-name")
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/oneapi/registration/registration.h"
+  "include/pcl/oneapi/registration/correspondence_estimation.h"
+  "include/pcl/oneapi/registration/icp.h"
+  "include/pcl/oneapi/registration/ia_ransac.h"
+)
+
+set(impl_incs
+  "include/pcl/oneapi/registration/impl/registration.hpp"
+  "include/pcl/oneapi/registration/impl/correspondence_estimation.hpp"
+  "include/pcl/oneapi/registration/impl/icp.hpp"
+  "include/pcl/oneapi/registration/impl/ia_ransac.hpp"
+)
+
+set(srcs
+  src/correspondence_estimation.cpp
+  src/icp.cpp
+  src/registration.cpp
+  src/ia_ransac.cpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+find_package(TBB REQUIRED)
+
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs} )
+target_link_libraries("${LIB_NAME}" pcl_registration pcl_oneapi_kdtree pcl_kdtree pcl_oneapi_search pcl_search TBB::tbb)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include"  "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/registration/include/pcl/oneapi/registration/correspondence_estimation.h b/oneapi/registration/include/pcl/oneapi/registration/correspondence_estimation.h
new file mode 100644
index 000000000..5b04d7799
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/correspondence_estimation.h
@@ -0,0 +1,454 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/search/kdtree.h>
+#include <pcl/common/io.h> // for getFields
+#include <pcl/registration/correspondence_types.h>
+#include <pcl/memory.h>
+#include <pcl/pcl_base.h>
+#include <pcl/pcl_macros.h>
+
+#include <string>
+
+namespace pcl {
+namespace oneapi {
+namespace registration {
+/** \brief Abstract @b CorrespondenceEstimationBase class.
+ * All correspondence estimation methods should inherit from this.
+ * \author Radu B. Rusu
+ * \ingroup registration
+ */
+template <typename PointSource, typename PointTarget, typename Scalar = float>
+class CorrespondenceEstimationBase : public PCLBase<PointSource> {
+public:
+  using Ptr =
+      shared_ptr<CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>>;
+  using ConstPtr =
+      shared_ptr<const CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>>;
+
+  // using PCLBase<PointSource>::initCompute;
+  using PCLBase<PointSource>::deinitCompute;
+  using PCLBase<PointSource>::input_;
+  using PCLBase<PointSource>::indices_;
+  using PCLBase<PointSource>::setIndices;
+
+  using KdTree = pcl::oneapi::search::KdTree<PointTarget>;
+  using KdTreePtr = typename KdTree::Ptr;
+
+  using KdTreeReciprocal = pcl::oneapi::search::KdTree<PointSource>;
+  using KdTreeReciprocalPtr = typename KdTree::Ptr;
+
+  using PointCloudSource = pcl::PointCloud<PointSource>;
+  using PointCloudSourcePtr = typename PointCloudSource::Ptr;
+  using PointCloudSourceConstPtr = typename PointCloudSource::ConstPtr;
+
+  using PointCloudTarget = pcl::PointCloud<PointTarget>;
+  using PointCloudTargetPtr = typename PointCloudTarget::Ptr;
+  using PointCloudTargetConstPtr = typename PointCloudTarget::ConstPtr;
+
+  using PointRepresentationConstPtr = typename KdTree::PointRepresentationConstPtr;
+
+  /** \brief Empty constructor. */
+  CorrespondenceEstimationBase()
+  : corr_name_("CorrespondenceEstimationBase")
+  , tree_(new pcl::oneapi::search::KdTree<PointTarget>)
+  , tree_reciprocal_(new pcl::oneapi::search::KdTree<PointSource>)
+  , target_()
+  , point_representation_()
+  , input_transformed_()
+  , target_cloud_updated_(true)
+  , source_cloud_updated_(true)
+  , force_no_recompute_(false)
+  , force_no_recompute_reciprocal_(false)
+  {}
+
+  /** \brief Empty destructor */
+  ~CorrespondenceEstimationBase() {}
+
+  /** \brief Provide a pointer to the input source
+   * (e.g., the point cloud that we want to align to the target)
+   *
+   * \param[in] cloud the input point cloud source
+   */
+  inline void
+  setInputSource(const PointCloudSourceConstPtr& cloud)
+  {
+    source_cloud_updated_ = true;
+    PCLBase<PointSource>::setInputCloud(cloud);
+    input_fields_ = pcl::getFields<PointSource>();
+  }
+
+  /** \brief Get a pointer to the input point cloud dataset target. */
+  inline PointCloudSourceConstPtr const
+  getInputSource()
+  {
+    return (input_);
+  }
+
+  /** \brief Provide a pointer to the input target
+   * (e.g., the point cloud that we want to align the input source to)
+   * \param[in] cloud the input point cloud target
+   */
+  void
+  setInputTarget(const PointCloudTargetConstPtr& cloud);
+
+  /** \brief Get a pointer to the input point cloud dataset target. */
+  inline PointCloudTargetConstPtr const
+  getInputTarget()
+  {
+    return (target_);
+  }
+
+  /** \brief See if this rejector requires source normals */
+  virtual bool
+  requiresSourceNormals() const
+  {
+    return (false);
+  }
+
+  /** \brief Abstract method for setting the source normals */
+  virtual void setSourceNormals(pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
+  {
+    PCL_WARN("[pcl::registration::%s::setSourceNormals] This class does not require "
+             "input source normals\n",
+             getClassName().c_str());
+  }
+
+  /** \brief See if this rejector requires target normals */
+  virtual bool
+  requiresTargetNormals() const
+  {
+    return (false);
+  }
+
+  /** \brief Abstract method for setting the target normals */
+  virtual void setTargetNormals(pcl::PCLPointCloud2::ConstPtr /*cloud2*/)
+  {
+    PCL_WARN("[pcl::registration::%s::setTargetNormals] This class does not require "
+             "input target normals\n",
+             getClassName().c_str());
+  }
+
+  /** \brief Provide a pointer to the vector of indices that represent the
+   * input source point cloud.
+   * \param[in] indices a pointer to the vector of indices
+   */
+  inline void
+  setIndicesSource(const IndicesPtr& indices)
+  {
+    setIndices(indices);
+  }
+
+  /** \brief Get a pointer to the vector of indices used for the source dataset. */
+  inline IndicesPtr const
+  getIndicesSource()
+  {
+    return (indices_);
+  }
+
+  /** \brief Provide a pointer to the vector of indices that represent the input target
+   * point cloud. \param[in] indices a pointer to the vector of indices
+   */
+  inline void
+  setIndicesTarget(const IndicesPtr& indices)
+  {
+    target_cloud_updated_ = true;
+    target_indices_ = indices;
+  }
+
+  /** \brief Get a pointer to the vector of indices used for the target dataset. */
+  inline IndicesPtr const
+  getIndicesTarget()
+  {
+    return (target_indices_);
+  }
+
+  /** \brief Provide a pointer to the search object used to find correspondences in
+   * the target cloud.
+   * \param[in] tree a pointer to the spatial search object.
+   * \param[in] force_no_recompute If set to true, this tree will NEVER be
+   * recomputed, regardless of calls to setInputTarget. Only use if you are
+   * confident that the tree will be set correctly.
+   */
+  inline void
+  setSearchMethodTarget(const KdTreePtr& tree, bool force_no_recompute = false)
+  {
+    tree_ = tree;
+    force_no_recompute_ = force_no_recompute;
+    // Since we just set a new tree, we need to check for updates
+    target_cloud_updated_ = true;
+  }
+
+  /** \brief Get a pointer to the search method used to find correspondences in the
+   * target cloud. */
+  inline KdTreePtr
+  getSearchMethodTarget() const
+  {
+    return (tree_);
+  }
+
+  /** \brief Provide a pointer to the search object used to find correspondences in
+   * the source cloud (usually used by reciprocal correspondence finding).
+   * \param[in] tree a pointer to the spatial search object.
+   * \param[in] force_no_recompute If set to true, this tree will NEVER be
+   * recomputed, regardless of calls to setInputSource. Only use if you are
+   * extremely confident that the tree will be set correctly.
+   */
+  inline void
+  setSearchMethodSource(const KdTreeReciprocalPtr& tree,
+                        bool force_no_recompute = false)
+  {
+    tree_reciprocal_ = tree;
+    force_no_recompute_reciprocal_ = force_no_recompute;
+    // Since we just set a new tree, we need to check for updates
+    source_cloud_updated_ = true;
+  }
+
+  /** \brief Get a pointer to the search method used to find correspondences in the
+   * source cloud. */
+  inline KdTreeReciprocalPtr
+  getSearchMethodSource() const
+  {
+    return (tree_reciprocal_);
+  }
+
+  /** \brief Determine the correspondences between input and target cloud.
+   * \param[out] correspondences the found correspondences (index of query point, index
+   * of target point, distance) \param[in] max_distance maximum allowed distance between
+   * correspondences
+   */
+  virtual void
+  determineCorrespondences(
+      pcl::Correspondences& correspondences,
+      double max_distance = std::numeric_limits<double>::max()) = 0;
+
+  /** \brief Determine the reciprocal correspondences between input and target cloud.
+   * A correspondence is considered reciprocal if both Src_i has Tgt_i as a
+   * correspondence, and Tgt_i has Src_i as one.
+   *
+   * \param[out] correspondences the found correspondences (index of query and target
+   * point, distance) \param[in] max_distance maximum allowed distance between
+   * correspondences
+   */
+  virtual void
+  determineReciprocalCorrespondences(
+      pcl::Correspondences& correspondences,
+      double max_distance = std::numeric_limits<double>::max()) = 0;
+
+  /** \brief Provide a boost shared pointer to the PointRepresentation to be used
+   * when searching for nearest neighbors.
+   *
+   * \param[in] point_representation the PointRepresentation to be used by the
+   * k-D tree for nearest neighbor search
+   */
+  inline void
+  setPointRepresentation(const PointRepresentationConstPtr& point_representation)
+  {
+    point_representation_ = point_representation;
+  }
+
+  /** \brief Clone and cast to CorrespondenceEstimationBase */
+  virtual typename CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::Ptr
+  clone() const = 0;
+
+protected:
+  /** \brief The correspondence estimation method name. */
+  std::string corr_name_;
+
+  /** \brief A pointer to the spatial search object used for the target dataset. */
+  KdTreePtr tree_;
+
+  /** \brief A pointer to the spatial search object used for the source dataset. */
+  KdTreeReciprocalPtr tree_reciprocal_;
+
+  /** \brief The input point cloud dataset target. */
+  PointCloudTargetConstPtr target_;
+
+  /** \brief The target point cloud dataset indices. */
+  IndicesPtr target_indices_;
+
+  /** \brief The point representation used (internal). */
+  PointRepresentationConstPtr point_representation_;
+
+  /** \brief The transformed input source point cloud dataset. */
+  PointCloudTargetPtr input_transformed_;
+
+  /** \brief The types of input point fields available. */
+  std::vector<pcl::PCLPointField> input_fields_;
+
+  /** \brief Abstract class get name method. */
+  inline const std::string&
+  getClassName() const
+  {
+    return (corr_name_);
+  }
+
+  /** \brief Internal computation initialization. */
+  bool
+  initCompute();
+
+  /** \brief Internal computation initialization for reciprocal correspondences. */
+  bool
+  initComputeReciprocal();
+
+  /** \brief Variable that stores whether we have a new target cloud, meaning we need to
+   * pre-process it again. This way, we avoid rebuilding the kd-tree for the target
+   * cloud every time the determineCorrespondences () method is called. */
+  bool target_cloud_updated_;
+  /** \brief Variable that stores whether we have a new source cloud, meaning we need to
+   * pre-process it again. This way, we avoid rebuilding the reciprocal kd-tree for the
+   * source cloud every time the determineCorrespondences () method is called. */
+  bool source_cloud_updated_;
+  /** \brief A flag which, if set, means the tree operating on the target cloud
+   * will never be recomputed*/
+  bool force_no_recompute_;
+
+  /** \brief A flag which, if set, means the tree operating on the source cloud
+   * will never be recomputed*/
+  bool force_no_recompute_reciprocal_;
+};
+
+/** \brief @b CorrespondenceEstimation represents the base class for
+ * determining correspondences between target and query point
+ * sets/features.
+ *
+ * Code example:
+ *
+ * \code
+ * pcl::PointCloud<pcl::PointXYZRGBA>::Ptr source, target;
+ * // ... read or fill in source and target
+ * pcl::CorrespondenceEstimation<pcl::PointXYZ, pcl::PointXYZ> est;
+ * est.setInputSource (source);
+ * est.setInputTarget (target);
+ *
+ * pcl::Correspondences all_correspondences;
+ * // Determine all reciprocal correspondences
+ * est.determineReciprocalCorrespondences (all_correspondences);
+ * \endcode
+ *
+ * \author Radu B. Rusu, Michael Dixon, Dirk Holz
+ * \ingroup registration
+ */
+template <typename PointSource, typename PointTarget, typename Scalar = float>
+class CorrespondenceEstimation
+: public CorrespondenceEstimationBase<PointSource, PointTarget, Scalar> {
+public:
+  using Ptr = shared_ptr<CorrespondenceEstimation<PointSource, PointTarget, Scalar>>;
+  using ConstPtr =
+      shared_ptr<const CorrespondenceEstimation<PointSource, PointTarget, Scalar>>;
+
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::
+      point_representation_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::
+      input_transformed_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::tree_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::
+      tree_reciprocal_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::target_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::corr_name_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::target_indices_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::getClassName;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::initCompute;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::
+      initComputeReciprocal;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::input_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::indices_;
+  using CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::input_fields_;
+  using PCLBase<PointSource>::deinitCompute;
+
+  using KdTree = pcl::oneapi::search::KdTree<PointTarget>;
+  using KdTreePtr = typename KdTree::Ptr;
+
+  using PointCloudSource = pcl::PointCloud<PointSource>;
+  using PointCloudSourcePtr = typename PointCloudSource::Ptr;
+  using PointCloudSourceConstPtr = typename PointCloudSource::ConstPtr;
+
+  using PointCloudTarget = pcl::PointCloud<PointTarget>;
+  using PointCloudTargetPtr = typename PointCloudTarget::Ptr;
+  using PointCloudTargetConstPtr = typename PointCloudTarget::ConstPtr;
+
+  using PointRepresentationConstPtr = typename KdTree::PointRepresentationConstPtr;
+
+  /** \brief Empty constructor. */
+  CorrespondenceEstimation() { corr_name_ = "CorrespondenceEstimation"; }
+
+  /** \brief Empty destructor */
+  ~CorrespondenceEstimation() {}
+
+  /** \brief Determine the correspondences between input and target cloud.
+   * \param[out] correspondences the found correspondences (index of query point, index
+   * of target point, distance) \param[in] max_distance maximum allowed distance between
+   * correspondences
+   */
+  void
+  determineCorrespondences(
+      pcl::Correspondences& correspondences,
+      double max_distance = std::numeric_limits<double>::max()) override;
+
+  /** \brief Determine the reciprocal correspondences between input and target cloud.
+   * A correspondence is considered reciprocal if both Src_i has Tgt_i as a
+   * correspondence, and Tgt_i has Src_i as one.
+   *
+   * \param[out] correspondences the found correspondences (index of query and target
+   * point, distance) \param[in] max_distance maximum allowed distance between
+   * correspondences
+   */
+  void
+  determineReciprocalCorrespondences(
+      pcl::Correspondences& correspondences,
+      double max_distance = std::numeric_limits<double>::max()) override;
+
+  /** \brief Clone and cast to CorrespondenceEstimationBase */
+  typename CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::Ptr
+  clone() const override
+  {
+    Ptr copy(new CorrespondenceEstimation<PointSource, PointTarget, Scalar>(*this));
+    return (copy);
+  }
+};
+} // namespace registration
+} // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/registration/impl/correspondence_estimation.hpp>
+#endif
diff --git a/oneapi/registration/include/pcl/oneapi/registration/ia_ransac.h b/oneapi/registration/include/pcl/oneapi/registration/ia_ransac.h
new file mode 100644
index 000000000..d5a67a997
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/ia_ransac.h
@@ -0,0 +1,377 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/registration/registration.h>
+#include <pcl/registration/registration.h>
+#include <pcl/registration/transformation_estimation_svd.h>
+#include <pcl/memory.h>
+
+namespace pcl {
+namespace oneapi {
+
+/** \brief @b SampleConsensusInitialAlignment is an implementation of the initial
+ * alignment algorithm described in section IV of "Fast Point Feature Histograms (FPFH)
+ * for 3D Registration," Rusu et al. \author Michael Dixon, Radu B. Rusu
+ * \ingroup registration
+ */
+template <typename PointSource, typename PointTarget, typename FeatureT>
+class SampleConsensusInitialAlignment : public Registration<PointSource, PointTarget> {
+public:
+  using Registration<PointSource, PointTarget>::reg_name_;
+  using Registration<PointSource, PointTarget>::input_;
+  using Registration<PointSource, PointTarget>::indices_;
+  using Registration<PointSource, PointTarget>::target_;
+  using Registration<PointSource, PointTarget>::final_transformation_;
+  using Registration<PointSource, PointTarget>::transformation_;
+  using Registration<PointSource, PointTarget>::corr_dist_threshold_;
+  using Registration<PointSource, PointTarget>::min_number_correspondences_;
+  using Registration<PointSource, PointTarget>::max_iterations_;
+  using Registration<PointSource, PointTarget>::tree_;
+  using Registration<PointSource, PointTarget>::transformation_estimation_;
+  using Registration<PointSource, PointTarget>::converged_;
+  using Registration<PointSource, PointTarget>::getClassName;
+
+  using PointCloudSource =
+      typename Registration<PointSource, PointTarget>::PointCloudSource;
+  using PointCloudSourcePtr = typename PointCloudSource::Ptr;
+  using PointCloudSourceConstPtr = typename PointCloudSource::ConstPtr;
+
+  using PointCloudTarget =
+      typename Registration<PointSource, PointTarget>::PointCloudTarget;
+
+  using PointIndicesPtr = PointIndices::Ptr;
+  using PointIndicesConstPtr = PointIndices::ConstPtr;
+
+  using FeatureCloud = pcl::PointCloud<FeatureT>;
+  using FeatureCloudPtr = typename FeatureCloud::Ptr;
+  using FeatureCloudConstPtr = typename FeatureCloud::ConstPtr;
+
+  using Ptr =
+      shared_ptr<SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>>;
+  using ConstPtr = shared_ptr<
+      const SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>>;
+
+  class ErrorFunctor {
+  public:
+    using Ptr = shared_ptr<ErrorFunctor>;
+    using ConstPtr = shared_ptr<const ErrorFunctor>;
+
+    virtual ~ErrorFunctor() = default;
+    virtual float
+    operator()(float d) const = 0;
+  };
+
+  class HuberPenalty : public ErrorFunctor {
+  private:
+    HuberPenalty() {}
+
+  public:
+    HuberPenalty(float threshold) : threshold_(threshold) {}
+    float
+    operator()(float e) const override
+    {
+      if (e <= threshold_)
+        return (0.5 * e * e);
+      return (0.5 * threshold_ * (2.0 * std::fabs(e) - threshold_));
+    }
+
+  protected:
+    float threshold_;
+  };
+
+  class TruncatedError : public ErrorFunctor {
+  private:
+    TruncatedError() {}
+
+  public:
+    ~TruncatedError() {}
+
+    TruncatedError(float threshold) : threshold_(threshold) {}
+    float
+    operator()(float e) const override
+    {
+      if ((threshold_ != 0.0f) && (e <= threshold_))
+        return (e / threshold_);
+      return (1.0);
+    }
+
+  protected:
+    float threshold_;
+  };
+
+  using ErrorFunctorPtr = typename ErrorFunctor::Ptr;
+
+  using FeatureKdTreePtr = typename pcl::KdTreeFLANN<FeatureT>::Ptr;
+  /** \brief Constructor. */
+  SampleConsensusInitialAlignment()
+  : input_features_()
+  , target_features_()
+  , nr_samples_(3)
+  , min_sample_distance_(0.0f)
+  , k_correspondences_(10)
+  , feature_tree_(new pcl::KdTreeFLANN<FeatureT>)
+  , error_functor_()
+  , input_memory_()
+  , target_memory_()
+  , all_distance_memory_()
+  , all_indice_memory_()
+  , sorted_distance_memory_()
+  , sorted_indice_memory_()
+  , segment_offset_memory_()
+  , k_indice_memory_()
+  {
+    reg_name_ = "SampleConsensusInitialAlignment";
+    max_iterations_ = 1000;
+
+    // Setting a non-std::numeric_limits<double>::max () value to corr_dist_threshold_
+    // to make it play nicely with TruncatedError
+    corr_dist_threshold_ = 100.0f;
+    transformation_estimation_.reset(
+        new pcl::registration::TransformationEstimationSVD<PointSource, PointTarget>);
+  };
+
+  /** \brief Provide a shared pointer to the source point cloud's feature descriptors
+   * \param features the source point cloud's features
+   */
+  void
+  setSourceFeatures(const FeatureCloudConstPtr& features);
+
+  /** \brief Get a pointer to the source point cloud's features */
+  inline FeatureCloudConstPtr const
+  getSourceFeatures()
+  {
+    return (input_features_);
+  }
+
+  /** \brief Provide a shared pointer to the target point cloud's feature descriptors
+   * \param features the target point cloud's features
+   */
+  void
+  setTargetFeatures(const FeatureCloudConstPtr& features);
+
+  /** \brief Get a pointer to the target point cloud's features */
+  inline FeatureCloudConstPtr const
+  getTargetFeatures()
+  {
+    return (target_features_);
+  }
+
+  /** \brief Set the minimum distances between samples
+   * \param min_sample_distance the minimum distances between samples
+   */
+  void
+  setMinSampleDistance(float min_sample_distance)
+  {
+    min_sample_distance_ = min_sample_distance;
+  }
+
+  /** \brief Get the minimum distances between samples, as set by the user */
+  float
+  getMinSampleDistance()
+  {
+    return (min_sample_distance_);
+  }
+
+  /** \brief Set the number of samples to use during each iteration
+   * \param nr_samples the number of samples to use during each iteration
+   */
+  void
+  setNumberOfSamples(int nr_samples)
+  {
+    nr_samples_ = nr_samples;
+
+    if (nr_samples <= 0)
+      PCL_ERROR("[pcl::%s::setNumberSamples must be greater than 0!\n", getClassName().c_str());
+  }
+
+  /** \brief Get the number of samples to use during each iteration, as set by the user
+   */
+  int
+  getNumberOfSamples()
+  {
+    return (nr_samples_);
+  }
+
+  /** \brief Set the number of neighbors to use when selecting a random feature
+   * correspondence.  A higher value will add more randomness to the feature matching.
+   * \param k the number of neighbors to use when selecting a random feature
+   * correspondence.
+   */
+  void
+  setCorrespondenceRandomness(int k)
+  {
+    k_correspondences_ = k;
+
+    if (k <= 0)
+      PCL_ERROR("[pcl::%s::setCorrespondneceRandomness must be greater than 0!\n", getClassName().c_str());
+  }
+
+  /** \brief Get the number of neighbors used when selecting a random feature
+   * correspondence, as set by the user */
+  int
+  getCorrespondenceRandomness()
+  {
+    return (k_correspondences_);
+  }
+
+  /** \brief Specify the error function to minimize
+   * \note This call is optional.  TruncatedError will be used by default
+   * \param[in] error_functor a shared pointer to a subclass of
+   * SampleConsensusInitialAlignment::ErrorFunctor
+   */
+  void
+  setErrorFunction(const ErrorFunctorPtr& error_functor)
+  {
+    error_functor_ = error_functor;
+  }
+
+  /** \brief Get a shared pointer to the ErrorFunctor that is to be minimized
+   * \return A shared pointer to a subclass of
+   * SampleConsensusInitialAlignment::ErrorFunctor
+   */
+  ErrorFunctorPtr
+  getErrorFunction()
+  {
+    return (error_functor_);
+  }
+
+protected:
+  /** \brief Choose a random index between 0 and n-1
+   * \param n the number of possible indices to choose from
+   */
+  inline pcl::index_t getRandomIndex(int n)
+  {
+    return (static_cast<pcl::index_t>(n * (rand() / (RAND_MAX + 1.0))));
+  };
+
+  /** \brief Select \a nr_samples sample points from cloud while making sure that their
+   * pairwise distances are greater than a user-defined minimum distance, \a
+   * min_sample_distance. \param cloud the input point cloud \param nr_samples the
+   * number of samples to select \param min_sample_distance the minimum distance between
+   * any two samples \param sample_indices the resulting sample indices
+   */
+  void
+  selectSamples(const PointCloudSource& cloud,
+                unsigned int nr_samples,
+                float min_sample_distance,
+                pcl::Indices& sample_indices);
+
+  /** \brief For each of the sample points, find a list of points in the target cloud
+   * whose features are similar to the sample points' features. From these, select one
+   * randomly which will be considered that sample point's correspondence. \param
+   * input_features a cloud of feature descriptors \param sample_indices the indices of
+   * each sample point \param corresponding_indices the resulting indices of each
+   * sample's corresponding point in the target cloud
+   */
+  void
+  findSimilarFeatures(const FeatureCloud& input_features,
+                      const pcl::Indices& sample_indices,
+                      pcl::Indices& corresponding_indices);
+  void
+  findSimilarFeatures(const pcl::Indices& sample_indices,
+                      pcl::Indices& corresponding_indices,
+                      int* k_indice);
+
+  /** \brief An error metric for that computes the quality of the alignment between the
+   * given cloud and the target. \param cloud the input cloud \param threshold distances
+   * greater than this value are capped
+   */
+  float
+  computeErrorMetric(const PointCloudSource& cloud, float threshold);
+
+  std::vector<float>
+  computeErrorMetric(const PointCloudSource& cloud, int individual_cloud_size, float threshold);
+
+  // Calculate all possible distance between input feature and output feature
+  // for each input feature, sort first K out.
+  void calculateAllDistanceAndSortK();
+
+  /** \brief Rigid transformation computation method.
+   * \param output the transformed input point cloud dataset using the rigid
+   * transformation found \param guess The computed transforamtion
+   */
+  void
+  computeTransformation(PointCloudSource& output,
+                        const Eigen::Matrix4f& guess) override;
+
+  /** \brief The source point cloud's feature descriptors. */
+  FeatureCloudConstPtr input_features_;
+
+  /** \brief The target point cloud's feature descriptors. */
+  FeatureCloudConstPtr target_features_;
+
+  /** \brief The number of samples to use during each iteration. */
+  int nr_samples_;
+
+  /** \brief The minimum distances between samples. */
+  float min_sample_distance_;
+
+  /** \brief The number of neighbors to use when selecting a random feature
+   * correspondence. */
+  int k_correspondences_;
+
+  /** \brief The KdTree used to compare feature descriptors. */
+  FeatureKdTreePtr feature_tree_;
+
+  ErrorFunctorPtr error_functor_;
+
+  // GPU Device memory
+  pcl::oneapi::DeviceArray<float> input_memory_;
+  pcl::oneapi::DeviceArray<float> target_memory_;
+  pcl::oneapi::DeviceArray<float> all_distance_memory_;
+  pcl::oneapi::DeviceArray<int> all_indice_memory_;
+  pcl::oneapi::DeviceArray<float> sorted_distance_memory_;
+  pcl::oneapi::DeviceArray<int> sorted_indice_memory_;
+  pcl::oneapi::DeviceArray<int> segment_offset_memory_;
+  pcl::oneapi::DeviceArray<int> k_indice_memory_;
+
+#define LOCAL_WORK_ITEM_SIZE 20
+
+public:
+  PCL_MAKE_ALIGNED_OPERATOR_NEW
+};
+} // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/registration/impl/ia_ransac.hpp>
+#endif
diff --git a/oneapi/registration/include/pcl/oneapi/registration/icp.h b/oneapi/registration/include/pcl/oneapi/registration/icp.h
new file mode 100644
index 000000000..7267b5fe0
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/icp.h
@@ -0,0 +1,418 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+// PCL includes
+#include <pcl/oneapi/registration/correspondence_estimation.h>
+#include <pcl/registration/default_convergence_criteria.h>
+#include <pcl/oneapi/registration/registration.h>
+#include <pcl/registration/transformation_estimation_point_to_plane_lls.h>
+#include <pcl/registration/transformation_estimation_svd.h>
+#include <pcl/registration/transformation_estimation_symmetric_point_to_plane_lls.h>
+#include <pcl/memory.h> // for dynamic_pointer_cast, pcl::make_shared, shared_ptr
+
+namespace pcl {
+namespace oneapi {
+
+template <typename PointSource, typename PointTarget, typename Scalar = float>
+class IterativeClosestPoint : public pcl::oneapi::Registration<PointSource, PointTarget, Scalar> {
+public:
+  using PointCloudSource =
+      typename pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::PointCloudSource;
+  using PointCloudSourcePtr = typename PointCloudSource::Ptr;
+  using PointCloudSourceConstPtr = typename PointCloudSource::ConstPtr;
+
+  using PointCloudTarget =
+      typename pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::PointCloudTarget;
+  using PointCloudTargetPtr = typename PointCloudTarget::Ptr;
+  using PointCloudTargetConstPtr = typename PointCloudTarget::ConstPtr;
+
+  using PointIndicesPtr = PointIndices::Ptr;
+  using PointIndicesConstPtr = PointIndices::ConstPtr;
+
+  using Ptr = shared_ptr<IterativeClosestPoint<PointSource, PointTarget, Scalar>>;
+  using ConstPtr =
+      shared_ptr<const IterativeClosestPoint<PointSource, PointTarget, Scalar>>;
+
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::reg_name_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::getClassName;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::input_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::indices_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::target_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::nr_iterations_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::max_iterations_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::previous_transformation_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::final_transformation_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::transformation_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::transformation_epsilon_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::
+      transformation_rotation_epsilon_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::converged_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::corr_dist_threshold_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::inlier_threshold_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::min_number_correspondences_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::update_visualizer_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::euclidean_fitness_epsilon_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::correspondences_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::transformation_estimation_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::correspondence_estimation_;
+  using pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::correspondence_rejectors_;
+
+  typename pcl::registration::DefaultConvergenceCriteria<Scalar>::Ptr
+      convergence_criteria_;
+  using Matrix4 = typename pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::Matrix4;
+
+  /** \brief Empty constructor. */
+  IterativeClosestPoint()
+  : x_idx_offset_(0)
+  , y_idx_offset_(0)
+  , z_idx_offset_(0)
+  , nx_idx_offset_(0)
+  , ny_idx_offset_(0)
+  , nz_idx_offset_(0)
+  , use_reciprocal_correspondence_(false)
+  , source_has_normals_(false)
+  , target_has_normals_(false)
+  {
+    reg_name_ = "IterativeClosestPoint";
+    transformation_estimation_.reset(
+        new pcl::registration::
+            TransformationEstimationSVD<PointSource, PointTarget, Scalar>());
+    correspondence_estimation_.reset(
+        new pcl::oneapi::registration::
+            CorrespondenceEstimation<PointSource, PointTarget, Scalar>);
+    convergence_criteria_.reset(
+        new pcl::registration::DefaultConvergenceCriteria<Scalar>(
+            nr_iterations_, transformation_, *correspondences_));
+  };
+
+  /**
+   * \brief Due to `convergence_criteria_` holding references to the class members,
+   * it is tricky to correctly implement its copy and move operations correctly. This
+   * can result in subtle bugs and to prevent them, these operations for ICP have
+   * been disabled.
+   *
+   * \todo: remove deleted ctors and assignments operations after resolving the issue
+   */
+  IterativeClosestPoint(const IterativeClosestPoint&) = delete;
+  IterativeClosestPoint(IterativeClosestPoint&&) = delete;
+  IterativeClosestPoint&
+  operator=(const IterativeClosestPoint&) = delete;
+  IterativeClosestPoint&
+  operator=(IterativeClosestPoint&&) = delete;
+
+  /** \brief Empty destructor */
+  ~IterativeClosestPoint() {}
+
+  /** \brief Returns a pointer to the DefaultConvergenceCriteria used by the
+   * IterativeClosestPoint class. This allows to check the convergence state after the
+   * align() method as well as to configure DefaultConvergenceCriteria's parameters not
+   * available through the ICP API before the align() method is called. Please note that
+   * the align method sets max_iterations_, euclidean_fitness_epsilon_ and
+   * transformation_epsilon_ and therefore overrides the default / set values of the
+   * DefaultConvergenceCriteria instance. \return Pointer to the IterativeClosestPoint's
+   * DefaultConvergenceCriteria.
+   */
+  inline typename pcl::registration::DefaultConvergenceCriteria<Scalar>::Ptr
+  getConvergeCriteria()
+  {
+    return convergence_criteria_;
+  }
+
+  /** \brief Provide a pointer to the input source
+   * (e.g., the point cloud that we want to align to the target)
+   *
+   * \param[in] cloud the input point cloud source
+   */
+  void
+  setInputSource(const PointCloudSourceConstPtr& cloud) override
+  {
+    pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::setInputSource(cloud);
+    const auto fields = pcl::getFields<PointSource>();
+    source_has_normals_ = false;
+    for (const auto& field : fields) {
+      if (field.name == "x")
+        x_idx_offset_ = field.offset;
+      else if (field.name == "y")
+        y_idx_offset_ = field.offset;
+      else if (field.name == "z")
+        z_idx_offset_ = field.offset;
+      else if (field.name == "normal_x") {
+        source_has_normals_ = true;
+        nx_idx_offset_ = field.offset;
+      }
+      else if (field.name == "normal_y") {
+        source_has_normals_ = true;
+        ny_idx_offset_ = field.offset;
+      }
+      else if (field.name == "normal_z") {
+        source_has_normals_ = true;
+        nz_idx_offset_ = field.offset;
+      }
+    }
+  }
+
+  /** \brief Provide a pointer to the input target
+   * (e.g., the point cloud that we want to align to the target)
+   *
+   * \param[in] cloud the input point cloud target
+   */
+  void
+  setInputTarget(const PointCloudTargetConstPtr& cloud) override
+  {
+    pcl::oneapi::Registration<PointSource, PointTarget, Scalar>::setInputTarget(cloud);
+    const auto fields = pcl::getFields<PointSource>();
+    target_has_normals_ = false;
+    for (const auto& field : fields) {
+      if (field.name == "normal_x" || field.name == "normal_y" ||
+          field.name == "normal_z") {
+        target_has_normals_ = true;
+        break;
+      }
+    }
+  }
+
+  /** \brief Set whether to use reciprocal correspondence or not
+   *
+   * \param[in] use_reciprocal_correspondence whether to use reciprocal correspondence
+   * or not
+   */
+  inline void
+  setUseReciprocalCorrespondences(bool use_reciprocal_correspondence)
+  {
+    use_reciprocal_correspondence_ = use_reciprocal_correspondence;
+  }
+
+  /** \brief Obtain whether reciprocal correspondence are used or not */
+  inline bool
+  getUseReciprocalCorrespondences() const
+  {
+    return (use_reciprocal_correspondence_);
+  }
+
+protected:
+  /** \brief Apply a rigid transform to a given dataset. Here we check whether
+   * the dataset has surface normals in addition to XYZ, and rotate normals as well.
+   * \param[in] input the input point cloud
+   * \param[out] output the resultant output point cloud
+   * \param[in] transform a 4x4 rigid transformation
+   * \note Can be used with cloud_in equal to cloud_out
+   */
+  virtual void
+  transformCloud(const PointCloudSource& input,
+                 PointCloudSource& output,
+                 const Matrix4& transform);
+
+  /** \brief Rigid transformation computation method  with initial guess.
+   * \param output the transformed input point cloud dataset using the rigid
+   * transformation found \param guess the initial guess of the transformation to
+   * compute
+   */
+  void
+  computeTransformation(PointCloudSource& output, const Matrix4& guess) override;
+
+  /** \brief Looks at the Estimators and Rejectors and determines whether their
+   * blob-setter methods need to be called */
+  virtual void
+  determineRequiredBlobData();
+
+  /** \brief XYZ fields offset. */
+  std::size_t x_idx_offset_, y_idx_offset_, z_idx_offset_;
+
+  /** \brief Normal fields offset. */
+  std::size_t nx_idx_offset_, ny_idx_offset_, nz_idx_offset_;
+
+  /** \brief The correspondence type used for correspondence estimation. */
+  bool use_reciprocal_correspondence_;
+
+  /** \brief Internal check whether source dataset has normals or not. */
+  bool source_has_normals_;
+  /** \brief Internal check whether target dataset has normals or not. */
+  bool target_has_normals_;
+
+  /** \brief Checks for whether estimators and rejectors need various data */
+  bool need_source_blob_, need_target_blob_;
+};
+
+/** \brief @b IterativeClosestPointWithNormals is a special case of
+ * IterativeClosestPoint, that uses a transformation estimated based on
+ * Point to Plane distances by default.
+ *
+ * By default, this implementation uses the traditional point to plane objective
+ * and computes point to plane distances using the normals of the target point
+ * cloud. It also provides the option (through setUseSymmetricObjective) of
+ * using the symmetric objective function of [Rusinkiewicz 2019]. This objective
+ * uses the normals of both the source and target point cloud and has a similar
+ * computational cost to the traditional point to plane objective while also
+ * offering improved convergence speed and a wider basin of convergence.
+ *
+ * Note that this implementation not demean the point clouds which can lead
+ * to increased numerical error. If desired, a user can demean the point cloud,
+ * run iterative closest point, and composite the resulting ICP transformation
+ * with the translations from demeaning to obtain a transformation between
+ * the original point clouds.
+ *
+ * \author Radu B. Rusu, Matthew Cong
+ * \ingroup registration
+ */
+template <typename PointSource, typename PointTarget, typename Scalar = float>
+class IterativeClosestPointWithNormals
+: public IterativeClosestPoint<PointSource, PointTarget, Scalar> {
+public:
+  using PointCloudSource = typename IterativeClosestPoint<PointSource,
+                                                          PointTarget,
+                                                          Scalar>::PointCloudSource;
+  using PointCloudTarget = typename IterativeClosestPoint<PointSource,
+                                                          PointTarget,
+                                                          Scalar>::PointCloudTarget;
+  using Matrix4 =
+      typename IterativeClosestPoint<PointSource, PointTarget, Scalar>::Matrix4;
+
+  using IterativeClosestPoint<PointSource, PointTarget, Scalar>::reg_name_;
+  using IterativeClosestPoint<PointSource, PointTarget, Scalar>::
+      transformation_estimation_;
+  using IterativeClosestPoint<PointSource, PointTarget, Scalar>::
+      correspondence_rejectors_;
+
+  using Ptr = shared_ptr<IterativeClosestPoint<PointSource, PointTarget, Scalar>>;
+  using ConstPtr =
+      shared_ptr<const IterativeClosestPoint<PointSource, PointTarget, Scalar>>;
+
+  /** \brief Empty constructor. */
+  IterativeClosestPointWithNormals()
+  {
+    reg_name_ = "IterativeClosestPointWithNormals";
+    setUseSymmetricObjective(false);
+    setEnforceSameDirectionNormals(true);
+    // correspondence_rejectors_.add
+  };
+
+  /** \brief Empty destructor */
+  virtual ~IterativeClosestPointWithNormals() {}
+
+  /** \brief Set whether to use a symmetric objective function or not
+   *
+   * \param[in] use_symmetric_objective whether to use a symmetric objective function or
+   * not
+   */
+  inline void
+  setUseSymmetricObjective(bool use_symmetric_objective)
+  {
+    use_symmetric_objective_ = use_symmetric_objective;
+    if (use_symmetric_objective_) {
+      auto symmetric_transformation_estimation = pcl::make_shared<
+          pcl::registration::TransformationEstimationSymmetricPointToPlaneLLS<
+              PointSource,
+              PointTarget,
+              Scalar>>();
+      symmetric_transformation_estimation->setEnforceSameDirectionNormals(
+          enforce_same_direction_normals_);
+      transformation_estimation_ = symmetric_transformation_estimation;
+    }
+    else {
+      transformation_estimation_.reset(
+          new pcl::registration::TransformationEstimationPointToPlaneLLS<PointSource,
+                                                                         PointTarget,
+                                                                         Scalar>());
+    }
+  }
+
+  /** \brief Obtain whether a symmetric objective is used or not */
+  inline bool
+  getUseSymmetricObjective() const
+  {
+    return use_symmetric_objective_;
+  }
+
+  /** \brief Set whether or not to negate source or target normals on a per-point basis
+   * such that they point in the same direction. Only applicable to the symmetric
+   * objective function.
+   *
+   * \param[in] enforce_same_direction_normals whether to negate source or target
+   * normals on a per-point basis such that they point in the same direction.
+   */
+  inline void
+  setEnforceSameDirectionNormals(bool enforce_same_direction_normals)
+  {
+    enforce_same_direction_normals_ = enforce_same_direction_normals;
+    auto symmetric_transformation_estimation = dynamic_pointer_cast<
+        pcl::registration::TransformationEstimationSymmetricPointToPlaneLLS<PointSource,
+                                                                            PointTarget,
+                                                                            Scalar>>(
+        transformation_estimation_);
+    if (symmetric_transformation_estimation)
+      symmetric_transformation_estimation->setEnforceSameDirectionNormals(
+          enforce_same_direction_normals_);
+  }
+
+  /** \brief Obtain whether source or target normals are negated on a per-point basis
+   * such that they point in the same direction or not */
+  inline bool
+  getEnforceSameDirectionNormals() const
+  {
+    return enforce_same_direction_normals_;
+  }
+
+protected:
+  /** \brief Apply a rigid transform to a given dataset
+   * \param[in] input the input point cloud
+   * \param[out] output the resultant output point cloud
+   * \param[in] transform a 4x4 rigid transformation
+   * \note Can be used with cloud_in equal to cloud_out
+   */
+  virtual void
+  transformCloud(const PointCloudSource& input,
+                 PointCloudSource& output,
+                 const Matrix4& transform);
+
+  /** \brief Type of objective function (asymmetric vs. symmetric) used for transform
+   * estimation */
+  bool use_symmetric_objective_;
+  /** \brief Whether or not to negate source and/or target normals such that they point
+   * in the same direction in the symmetric objective function */
+  bool enforce_same_direction_normals_;
+};
+} // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/registration/impl/icp.hpp>
+#endif
diff --git a/oneapi/registration/include/pcl/oneapi/registration/impl/correspondence_estimation.hpp b/oneapi/registration/include/pcl/oneapi/registration/impl/correspondence_estimation.hpp
new file mode 100644
index 000000000..3208202c4
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/impl/correspondence_estimation.hpp
@@ -0,0 +1,191 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_
+#define PCL_ONEAPI_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_
+
+#include <pcl/oneapi/registration/correspondence_estimation.h>
+#include <pcl/common/copy_point.h>
+#include <pcl/common/io.h>
+
+namespace pcl {
+namespace oneapi {
+namespace registration {
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::setInputTarget(
+    const PointCloudTargetConstPtr& cloud)
+{
+  if (cloud->points.empty()) {
+    PCL_ERROR("[pcl::registration::%s::setInputTarget] Invalid or empty point cloud "
+              "dataset given!\n",
+              getClassName().c_str());
+    return;
+  }
+  target_ = cloud;
+
+  // Set the internal point representation of choice
+  if (point_representation_)
+    tree_->setPointRepresentation(point_representation_);
+
+  target_cloud_updated_ = true;
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+bool
+CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::initCompute()
+{
+  if (!target_) {
+    PCL_ERROR("[pcl::registration::%s::compute] No input target dataset was given!\n",
+              getClassName().c_str());
+    return (false);
+  }
+
+  // Only update target kd-tree if a new target cloud was set
+  if (target_cloud_updated_ && !force_no_recompute_) {
+    // If the target indices have been given via setIndicesTarget
+    if (target_indices_)
+      tree_->setInputCloud(target_, target_indices_);
+    else
+      tree_->setInputCloud(target_);
+
+    target_cloud_updated_ = false;
+  }
+
+  return (PCLBase<PointSource>::initCompute());
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+bool
+CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>::initComputeReciprocal()
+{
+  // Only update source kd-tree if a new target cloud was set
+  if (source_cloud_updated_ && !force_no_recompute_reciprocal_) {
+    if (point_representation_)
+      tree_reciprocal_->setPointRepresentation(point_representation_);
+    // If the target indices have been given via setIndicesTarget
+    if (indices_)
+      tree_reciprocal_->setInputCloud(getInputSource(), getIndicesSource());
+    else
+      tree_reciprocal_->setInputCloud(getInputSource());
+
+    source_cloud_updated_ = false;
+  }
+
+  return (true);
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+CorrespondenceEstimation<PointSource, PointTarget, Scalar>::determineCorrespondences(
+    pcl::Correspondences& correspondences, double max_distance)
+{
+  if (!initCompute())
+    return;
+
+  double max_dist_sqr = max_distance * max_distance;
+  pcl::Correspondence corr;
+  unsigned int nr_valid_correspondences = 0;
+
+  correspondences.resize (indices_->size ());
+
+  if (!tree_) return;
+  // Check if the template types are the same. If true, avoid a copy.
+  // Both point types MUST be registered using the POINT_CLOUD_REGISTER_POINT_STRUCT macro!
+  if (isSamePointType<PointSource, PointTarget> ())
+  {
+    pcl::oneapi::DeviceArray2D<int> indices;
+    pcl::oneapi::DeviceArray2D<float> distances;
+
+    tree_->nearestKSearch (input_, 1, indices, distances);
+
+    for (const auto& idx : (*indices_))
+    {
+      if (distances[idx][0] > max_dist_sqr)
+        continue;
+
+      corr.index_query = idx;
+      corr.index_match = indices[idx][0];
+      corr.distance = distances[idx][0];
+      correspondences[nr_valid_correspondences++] = corr;
+    }
+  }
+  else {
+    PointCloud<PointTarget> output;
+    copyPointCloud(*input_, *indices_, output);
+
+    pcl::oneapi::DeviceArray2D<int> indices;
+    pcl::oneapi::DeviceArray2D<float> distances;
+    tree_->nearestKSearch (output.makeShared(), 1, indices, distances);
+
+    // Iterate over the input set of source indices
+    for (const auto& idx : (*indices_)) {
+      if (distances[idx][0] > max_dist_sqr)
+        continue;
+
+      corr.index_query = idx;
+      corr.index_match = indices[idx][0];
+      corr.distance = distances[idx][0];
+      correspondences[nr_valid_correspondences++] = corr;
+    }
+  }
+  correspondences.resize(nr_valid_correspondences);
+  deinitCompute();
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+CorrespondenceEstimation<PointSource, PointTarget, Scalar>::
+    determineReciprocalCorrespondences(pcl::Correspondences& correspondences,
+                                       double max_distance)
+{
+  throw std::runtime_error("OneAPI optimized Reciprocal Correspondences are currently not supported. \
+      Please use the standard pcl registration module.");
+}
+
+} // namespace registration
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_CorrespondenceEstimationBase(T,U) template class PCL_EXPORTS pcl::oneapi::registration::CorrespondenceEstimationBase<T,U>;
+#define PCL_INSTANTIATE_CorrespondenceEstimation(T,U) template class PCL_EXPORTS pcl::oneapi::registration::CorrespondenceEstimation<T,U>;
+
+#endif /* PCL_ONEAPI_REGISTRATION_IMPL_CORRESPONDENCE_ESTIMATION_H_ */
diff --git a/oneapi/registration/include/pcl/oneapi/registration/impl/ia_ransac.hpp b/oneapi/registration/include/pcl/oneapi/registration/impl/ia_ransac.hpp
new file mode 100644
index 000000000..c3603b5c8
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/impl/ia_ransac.hpp
@@ -0,0 +1,607 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_REGISTRATION_IMPL_IA_RANSAC_HPP_
+#define PCL_ONEAPI_REGISTRATION_IMPL_IA_RANSAC_HPP_
+
+#include <pcl/oneapi/registration/ia_ransac.h>
+#include <pcl/oneapi/utils/segmented_sort.h>
+#include <pcl/common/distances.h>
+
+#include <tbb/tbb.h>
+
+#include <chrono>
+using time_point = decltype(std::chrono::steady_clock::now());
+static inline time_point get_time_point() {
+	return std::chrono::steady_clock::now();
+}
+static inline double get_duration(const time_point& from, const time_point& to) {
+	return std::chrono::duration_cast<std::chrono::duration<double>>(to - from).count();
+}
+
+namespace pcl {
+namespace oneapi {
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::setSourceFeatures(
+    const FeatureCloudConstPtr& features)
+{
+  if (features == nullptr || features->empty()) {
+    PCL_ERROR(
+        "[pcl::%s::setSourceFeatures] Invalid or empty point cloud dataset given!\n",
+        getClassName().c_str());
+    return;
+  }
+  input_features_ = features;
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::setTargetFeatures(
+    const FeatureCloudConstPtr& features)
+{
+  if (features == nullptr || features->empty()) {
+    PCL_ERROR(
+        "[pcl::%s::setTargetFeatures] Invalid or empty point cloud dataset given!\n",
+        getClassName().c_str());
+    return;
+  }
+  target_features_ = features;
+  feature_tree_->setInputCloud(target_features_);
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::selectSamples(
+    const PointCloudSource& cloud,
+    unsigned int nr_samples,
+    float min_sample_distance,
+    pcl::Indices& sample_indices)
+{
+  if (nr_samples > cloud.size()) {
+    PCL_ERROR("[pcl::%s::selectSamples] ", getClassName().c_str());
+    PCL_ERROR("The number of samples (%u) must not be greater than the number of "
+              "points (%zu)!\n",
+              nr_samples,
+              static_cast<std::size_t>(cloud.size()));
+    return;
+  }
+
+  // Iteratively draw random samples until nr_samples is reached
+  index_t iterations_without_a_sample = 0;
+  const auto max_iterations_without_a_sample = 3 * cloud.size();
+  sample_indices.clear();
+  while (sample_indices.size() < nr_samples) {
+    // Choose a sample at random
+    const auto sample_index = getRandomIndex(cloud.size());
+
+    // Check to see if the sample is 1) unique and 2) far away from the other samples
+    bool valid_sample = true;
+    for (const auto& sample_idx : sample_indices) {
+      float distance_between_samples =
+          euclideanDistance(cloud[sample_index], cloud[sample_idx]);
+
+      if (sample_index == sample_idx ||
+          distance_between_samples < min_sample_distance) {
+        valid_sample = false;
+        break;
+      }
+    }
+
+    // If the sample is valid, add it to the output
+    if (valid_sample) {
+      sample_indices.push_back(sample_index);
+      iterations_without_a_sample = 0;
+    }
+    else
+      ++iterations_without_a_sample;
+
+    // If no valid samples can be found, relax the inter-sample distance requirements
+    if (static_cast<std::size_t>(iterations_without_a_sample) >=
+        max_iterations_without_a_sample) {
+      PCL_WARN("[pcl::%s::selectSamples] ", getClassName().c_str());
+      PCL_WARN("No valid sample found after %zu iterations. Relaxing "
+               "min_sample_distance_ to %f\n",
+               static_cast<std::size_t>(iterations_without_a_sample),
+               0.5 * min_sample_distance);
+
+      min_sample_distance_ *= 0.5f;
+      min_sample_distance = min_sample_distance_;
+      iterations_without_a_sample = 0;
+    }
+  }
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::
+    findSimilarFeatures(const FeatureCloud& input_features,
+                        const pcl::Indices& sample_indices,
+                        pcl::Indices& corresponding_indices)
+{
+  pcl::Indices nn_indices(k_correspondences_);
+  std::vector<float> nn_distances(k_correspondences_);
+
+  corresponding_indices.resize(sample_indices.size());
+  for (std::size_t i = 0; i < sample_indices.size(); ++i) {
+    // Find the k features nearest to input_features[sample_indices[i]]
+    feature_tree_->nearestKSearch(input_features,
+                                  sample_indices[i],
+                                  k_correspondences_,
+                                  nn_indices,
+                                  nn_distances);
+
+    // Select one at random and add it to corresponding_indices
+    const auto random_correspondence = getRandomIndex(k_correspondences_);
+    corresponding_indices[i] = nn_indices[random_correspondence];
+  }
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::
+    findSimilarFeatures(const pcl::Indices& sample_indices,
+                        pcl::Indices& corresponding_indices,
+                        int* k_indice)
+{
+  corresponding_indices.resize(sample_indices.size());
+  for (std::size_t i = 0; i < sample_indices.size(); ++i) {
+    // Select one at random and add it to corresponding_indices
+    const int random_correspondence = getRandomIndex(k_correspondences_);
+    corresponding_indices[i] = k_indice[sample_indices[i]*k_correspondences_+random_correspondence];
+  }
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+float
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::computeErrorMetric(
+    const PointCloudSource& cloud, float)
+{
+  pcl::Indices nn_index(1);
+  std::vector<float> nn_distance(1);
+
+  const ErrorFunctor& compute_error = *error_functor_;
+  float error = 0;
+
+  pcl::oneapi::DeviceArray2D<int> nn_indices;
+  pcl::oneapi::DeviceArray2D<float> nn_dists;
+
+  if (!tree_) return (std::numeric_limits<double>::max());
+  tree_->nearestKSearch (cloud.makeShared(), 1, nn_indices, nn_dists);
+
+  for (int i = 0; i < nn_dists.rows (); i++)
+    error += compute_error(nn_dists[i][0]);
+
+  return (error);
+}
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+std::vector<float>
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::computeErrorMetric(
+    const PointCloudSource& cloud, int individual_cloud_size, float)
+{
+  const ErrorFunctor& compute_error = *error_functor_;
+
+  pcl::oneapi::DeviceArray<int> nn_indices;
+  pcl::oneapi::DeviceArray<float> nn_dists;
+  pcl::oneapi::DeviceArray<int> splits;
+
+  if (!tree_) return (std::vector<float>(std::numeric_limits<float>::max(), max_iterations_));
+  tree_->nearestKSearch (cloud.makeShared(), 1, nn_indices, nn_dists, splits);
+
+  std::vector<float> res;
+  res.reserve(nn_dists.size());
+  int num = 0;
+  float error = 0;
+  for (int i = 0; i < nn_dists.size (); i++) {
+    if (num == individual_cloud_size) {
+      res.push_back(error);
+      num = 0;
+      error = 0;
+    }
+
+    num++;
+    error += compute_error(nn_dists[i]);
+  }
+  res.push_back(error);  // last one
+
+  return (res);
+}
+
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::
+    calculateAllDistanceAndSortK()
+{
+  // use algorithm like matrix multiply
+  // caculate all possible distance and sort the first K distance
+
+  int input_num  = input_features_ ->size();
+  int target_num = target_features_->size();
+  int feature_size = sizeof(FeatureT) / sizeof(float); // normally 33 floats
+
+  // malloc device memory
+  input_memory_.create(input_num * feature_size);
+  target_memory_.create(target_num * feature_size);
+  all_indice_memory_.create(target_num * input_num);
+  k_indice_memory_.create(k_correspondences_ * input_num);
+  all_distance_memory_.create(target_num * input_num); // row = input_num, col = target_num.
+
+  // memory pointer
+  float* input_memory = input_memory_.ptr();
+  float* target_memory = target_memory_.ptr();
+  int* all_indice_memory = all_indice_memory_.ptr();
+  int* k_indice_memory = k_indice_memory_.ptr();
+  float* all_distance_memory = all_distance_memory_.ptr();
+
+  // copy to device memory
+  input_memory_.upload((float *) input_features_->points.data(), input_num * feature_size);
+  target_memory_.upload((float *) target_features_->points.data(), target_num * feature_size);
+
+  // calculate distance
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+
+    const int thread_x = target_num;
+    const int thread_y = input_num;
+    const int const_feature_size = feature_size;
+
+    const int thread_x_group_size = LOCAL_WORK_ITEM_SIZE;
+    const int thread_y_group_size = LOCAL_WORK_ITEM_SIZE;
+    const int thread_x_pitched = align(thread_x, thread_x_group_size);
+    const int thread_y_pitched = align(thread_y, thread_y_group_size);
+
+    sycl::local_accessor<float, 2> slm_input_memory(sycl::range<2>(40, 20), h);
+    sycl::local_accessor<float, 2> slm_target_memory(sycl::range<2>(20, 40), h);
+
+    h.parallel_for(sycl::nd_range<2>(sycl::range<2>(thread_x_pitched, thread_y_pitched),
+                                     sycl::range<2>(thread_x_group_size, thread_y_group_size)
+                                    ), [=](auto i) {
+      int index_x = i.get_global_id(0);
+      int index_y = i.get_global_id(1);
+
+      int local_index_x = i.get_local_id(0);
+      int local_index_y = i.get_local_id(1);
+
+      slm_input_memory[local_index_x][local_index_y] = input_memory[index_y * const_feature_size + local_index_x];
+      slm_input_memory[local_index_x+20][local_index_y] = input_memory[index_y * const_feature_size + local_index_x+20];
+      slm_target_memory[local_index_x][local_index_y] = target_memory[index_x * const_feature_size + local_index_y];
+      slm_target_memory[local_index_x][local_index_y+20] = target_memory[index_x * const_feature_size + local_index_y+20];
+      i.barrier(sycl::access::fence_space::local_space);
+
+      if (index_x >= thread_x || index_y >= thread_y)
+        return;
+
+      float distance = 0.0f;
+      for (int i = 0; i < const_feature_size; i++) {
+        // GPU SLM access
+        distance += (slm_input_memory[i][local_index_y] - slm_target_memory[local_index_x][i]) *
+                    (slm_input_memory[i][local_index_y] - slm_target_memory[local_index_x][i]);
+      }
+
+      all_distance_memory[index_x+index_y*thread_x] = distance;
+    });
+  }).wait();
+
+  /////////////////////////////////////
+  // oneapi/utils/segmentedsortpairs //
+  /////////////////////////////////////
+
+  sorted_distance_memory_.create(input_num*target_num);
+  sorted_indice_memory_.create(input_num*target_num);
+  segment_offset_memory_.create(input_num+1);
+
+  // assign unsort_indice
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+    const int thread_x = target_num;
+    const int thread_y = input_num;
+    const int width = thread_x;
+
+    h.parallel_for(sycl::range<2>(thread_x, thread_y), [=](auto id) {
+      int index_x = id[0];
+      int index_y = id[1];
+      int index_out = index_y*width + index_x;
+      all_indice_memory[index_out] = index_x;
+    });
+  }).wait();
+
+  // assign segment_offset
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+    const int thread_num = input_num+1;
+    int* device_offset = segment_offset_memory_.ptr();
+
+    h.parallel_for(thread_num, [=](auto id) {
+      device_offset[id] = id*target_num;
+    });
+  }).wait();
+
+  // auto tt1 = get_time_point();
+  pcl::oneapi::SegmentedSortPairs(all_distance_memory_,
+                                  all_indice_memory_,
+                                  sorted_distance_memory_,
+                                  sorted_indice_memory_,
+                                  segment_offset_memory_,
+                                  input_num*target_num,
+                                  input_num);
+  // auto tt2 = get_time_point();
+  // std::cout << " ------------------------------ " << std::endl;
+  // std::cout << " SegmentedSortPairs: " << get_duration(tt1, tt2) * 1e3 << "ms" << std::endl;
+
+  // copy first k distance
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+
+    const int thread_num = input_num;
+    const int const_width = target_num;
+    const int k = k_correspondences_;
+    int* sorted_indice_ptr = sorted_indice_memory_.ptr();
+
+    h.parallel_for(thread_num, [=](auto i) {
+      int start_index_from = i*const_width;
+      int start_index_to = i*k;
+
+      int * indice_ptr_from = sorted_indice_ptr + start_index_from;
+      int * indice_ptr_to = k_indice_memory + start_index_to;
+
+      for (int i=0; i<k; ++i) {
+        indice_ptr_to[i] = indice_ptr_from[i];
+      }
+    });
+  }).wait();
+
+#if 0
+  // auto ttt1 = get_time_point();
+  // sort first k distance
+  e = dpct::get_default_queue().submit([&](sycl::handler &h) {
+
+    const int thread_num = input_num;
+    const int const_width = target_num;
+    const int k = k_correspondences_;
+
+    h.parallel_for(thread_num, [=](auto i) {
+      int start_index = i*const_width;
+      int query_index = i;
+
+      float* distance_ptr = all_distance_memory + start_index;
+      int * indice_ptr = all_indice_memory + start_index;
+
+      float last_num = distance_ptr[k-1];
+      indice_ptr[0] = 0; // start from 0
+      for (int i=1; i<const_width; ++i) { // loop from 1
+
+          float current_distance = distance_ptr[i];
+          int   current_indice  = i; // i-th indice
+
+          if (i >= k && current_distance >= last_num) {
+              continue; // if current_distance is larger than k-th distance, and current indice is bigger than k, skip it
+          }
+
+          // insert sort
+          int j = sycl::min(i, (k - 1));
+          while (j > 0 && distance_ptr[j-1] > current_distance) {
+              distance_ptr[j] = distance_ptr[j-1];
+              indice_ptr[j] = indice_ptr[j-1];
+              --j;
+          }
+
+          // Write done the current distance and indice
+          distance_ptr[j]   = current_distance;
+          indice_ptr[j] = current_indice;
+          last_num = distance_ptr[k-1];
+      }
+    });
+  });
+  e.wait();
+
+  // copy first k distance
+  e = dpct::get_default_queue().submit([&](sycl::handler &h) {
+
+    const int thread_num = input_num;
+    const int const_width = target_num;
+    const int k = k_correspondences_;
+
+    h.parallel_for(thread_num, [=](auto i) {
+      int start_index_from = i*const_width;
+      int start_index_to = i*k;
+
+      int * indice_ptr_from = all_indice_memory + start_index_from;
+      int * indice_ptr_to = k_indice_memory + start_index_to;
+
+      for (int i=0; i<k; ++i) {
+        indice_ptr_to[i] = indice_ptr_from[i];
+      }
+    });
+  });
+  e.wait();
+  // auto ttt2 = get_time_point();
+  // std::cout << " ------------------------------ " << std::endl;
+  // std::cout << " Original Insertion Sort: " << get_duration(ttt1, ttt2) * 1e3 << "ms" << std::endl;
+#endif
+
+}
+
+
+template <typename PointSource, typename PointTarget, typename FeatureT>
+void
+SampleConsensusInitialAlignment<PointSource, PointTarget, FeatureT>::
+    computeTransformation(PointCloudSource& output, const Eigen::Matrix4f& guess)
+{
+  // Some sanity checks first
+  if (!input_features_) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR(
+        "No source features were given! Call setSourceFeatures before aligning.\n");
+    return;
+  }
+  if (!target_features_) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR(
+        "No target features were given! Call setTargetFeatures before aligning.\n");
+    return;
+  }
+
+  if (input_->size() != input_features_->size()) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR("The source points and source feature points need to be in a one-to-one "
+              "relationship! Current input cloud sizes: %ld vs %ld.\n",
+              input_->size(),
+              input_features_->size());
+    return;
+  }
+
+  if (target_->size() != target_features_->size()) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR("The target points and target feature points need to be in a one-to-one "
+              "relationship! Current input cloud sizes: %ld vs %ld.\n",
+              target_->size(),
+              target_features_->size());
+    return;
+  }
+
+  if (nr_samples_ <= 0) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR("Invalid number of samples  %d\n", nr_samples_);
+    return;
+  }
+
+  if (k_correspondences_ <= 0) {
+    PCL_ERROR("[pcl::%s::computeTransformation] ", getClassName().c_str());
+    PCL_ERROR("Invalid number of correspondence randomness  %d\n", k_correspondences_);
+    return;
+  }
+
+  if (!error_functor_)
+    error_functor_.reset(new TruncatedError(static_cast<float>(corr_dist_threshold_)));
+
+  pcl::Indices sample_indices(nr_samples_);
+  pcl::Indices corresponding_indices(nr_samples_);
+  PointCloudSource input_transformed;
+  float lowest_error(0);
+
+  final_transformation_ = guess;
+  int i_iter = 0;
+  converged_ = false;
+  if (!guess.isApprox(Eigen::Matrix4f::Identity(), 0.01f)) {
+    // If guess is not the Identity matrix we check it.
+    transformPointCloud(*input_, input_transformed, final_transformation_);
+    lowest_error =
+        computeErrorMetric(input_transformed, static_cast<float>(corr_dist_threshold_));
+    i_iter = 1;
+  }
+
+  // Optimization for this loop iteration.
+  // Original:
+  //    for (i:max_iterations) {
+  //      1. select input sample indice;
+  //      2. find the cloest feature points in target sample;
+  //      3. estimation transformation matrix
+  //      4. transform input cloud to input_transformed cloud
+  //      5. Calculate align error between (target, input_transformed)
+  //    }
+  //
+  // Optimized:
+  //    1. Calculate call possible distance between (input_feature, target_feature), and sort first K out for each point
+  //
+  //    for (i:max_iterations) {
+  //      2. select input sample indice;
+  //      3. find the cloest feature points in distance_results(already calculated from step1);
+  //      4. estimation transformation matrix
+  //      5. transform input cloud to input_transformed cloud
+  //      6. sum input_transformed into sum_input_transformed (sum_input_transformed += input_transformed)
+  //    }
+  //
+  //    7. Compute all error between (target, input_transformed) in one shoot.
+
+  // OPTIMIZE step 1
+  // Get Corresponding indice k_indice_memory_
+  calculateAllDistanceAndSortK();
+
+  // OPTIMIZE step 2~6
+  std::vector<Eigen::Matrix<float, 4, 4>> total_transformation;
+  PointCloudSource sum_input_transformed;
+  for (int i=i_iter; i < max_iterations_; i++) {
+
+    // Draw nr_samples_ random samples
+    selectSamples(*input_, nr_samples_, min_sample_distance_, sample_indices);
+
+    // Find corresponding features in the target cloud
+    findSimilarFeatures(sample_indices, corresponding_indices, k_indice_memory_.ptr());
+
+    // Estimate the transform from the samples to their corresponding points
+    transformation_estimation_->estimateRigidTransformation(
+        *input_, sample_indices, *target_, corresponding_indices, transformation_);
+
+    // Transform the data and compute the error
+    transformPointCloud(*input_, input_transformed, transformation_);
+
+    total_transformation.push_back(transformation_);
+    sum_input_transformed += input_transformed;
+  }
+
+  // OPTIMIZE step 7
+  // compute error, 3-d kdtree k=1 nn search, is done by once.
+  int individual_cloud_size = input_transformed.points.size();
+  std::vector<float> error_results =
+    computeErrorMetric(sum_input_transformed, individual_cloud_size, static_cast<float>(corr_dist_threshold_));
+
+  // find the smallest error, best transformation matrix.
+  int n=0;
+  for (; i_iter < max_iterations_; ++i_iter) {
+    float error = error_results[n];
+
+    // If the new error is lower, update the final transformation
+    if (i_iter == 0 || error < lowest_error) {
+      lowest_error = error;
+      final_transformation_ = transformation_ = total_transformation[n];
+      converged_ = true;
+    }
+    n++;
+  }
+
+  // Apply the final transformation
+  transformPointCloud(*input_, output, final_transformation_);
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_SampleConsensusInitialAlignment(T,U,F) template class PCL_EXPORTS pcl::oneapi::SampleConsensusInitialAlignment<T,U,F>;
+
+#endif //#ifndef PCL_ONEAPI_REGISTRATION_IMPL_IA_RANSAC_HPP_
diff --git a/oneapi/registration/include/pcl/oneapi/registration/impl/icp.hpp b/oneapi/registration/include/pcl/oneapi/registration/impl/icp.hpp
new file mode 100644
index 000000000..6dfc71532
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/impl/icp.hpp
@@ -0,0 +1,320 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_REGISTRATION_IMPL_ICP_HPP_
+#define PCL_ONEAPI_REGISTRATION_IMPL_ICP_HPP_
+
+#include <pcl/oneapi/registration/icp.h>
+#include <pcl/correspondence.h>
+
+namespace pcl {
+namespace oneapi {
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+IterativeClosestPoint<PointSource, PointTarget, Scalar>::transformCloud(
+    const PointCloudSource& input, PointCloudSource& output, const Matrix4& transform)
+{
+  Eigen::Vector4f pt(0.0f, 0.0f, 0.0f, 1.0f), pt_t;
+  Eigen::Matrix4f tr = transform.template cast<float>();
+
+  // XYZ is ALWAYS present due to the templatization, so we only have to check for
+  // normals
+  if (source_has_normals_) {
+    Eigen::Vector3f nt, nt_t;
+    Eigen::Matrix3f rot = tr.block<3, 3>(0, 0);
+
+    for (std::size_t i = 0; i < input.size(); ++i) {
+      const std::uint8_t* data_in = reinterpret_cast<const std::uint8_t*>(&input[i]);
+      std::uint8_t* data_out = reinterpret_cast<std::uint8_t*>(&output[i]);
+      memcpy(&pt[0], data_in + x_idx_offset_, sizeof(float));
+      memcpy(&pt[1], data_in + y_idx_offset_, sizeof(float));
+      memcpy(&pt[2], data_in + z_idx_offset_, sizeof(float));
+
+      if (!std::isfinite(pt[0]) || !std::isfinite(pt[1]) || !std::isfinite(pt[2]))
+        continue;
+
+      pt_t = tr * pt;
+
+      memcpy(data_out + x_idx_offset_, &pt_t[0], sizeof(float));
+      memcpy(data_out + y_idx_offset_, &pt_t[1], sizeof(float));
+      memcpy(data_out + z_idx_offset_, &pt_t[2], sizeof(float));
+
+      memcpy(&nt[0], data_in + nx_idx_offset_, sizeof(float));
+      memcpy(&nt[1], data_in + ny_idx_offset_, sizeof(float));
+      memcpy(&nt[2], data_in + nz_idx_offset_, sizeof(float));
+
+      if (!std::isfinite(nt[0]) || !std::isfinite(nt[1]) || !std::isfinite(nt[2]))
+        continue;
+
+      nt_t = rot * nt;
+
+      memcpy(data_out + nx_idx_offset_, &nt_t[0], sizeof(float));
+      memcpy(data_out + ny_idx_offset_, &nt_t[1], sizeof(float));
+      memcpy(data_out + nz_idx_offset_, &nt_t[2], sizeof(float));
+    }
+  }
+  else {
+    for (std::size_t i = 0; i < input.size(); ++i) {
+      const std::uint8_t* data_in = reinterpret_cast<const std::uint8_t*>(&input[i]);
+      std::uint8_t* data_out = reinterpret_cast<std::uint8_t*>(&output[i]);
+      memcpy(&pt[0], data_in + x_idx_offset_, sizeof(float));
+      memcpy(&pt[1], data_in + y_idx_offset_, sizeof(float));
+      memcpy(&pt[2], data_in + z_idx_offset_, sizeof(float));
+
+      if (!std::isfinite(pt[0]) || !std::isfinite(pt[1]) || !std::isfinite(pt[2]))
+        continue;
+
+      pt_t = tr * pt;
+
+      memcpy(data_out + x_idx_offset_, &pt_t[0], sizeof(float));
+      memcpy(data_out + y_idx_offset_, &pt_t[1], sizeof(float));
+      memcpy(data_out + z_idx_offset_, &pt_t[2], sizeof(float));
+    }
+  }
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+IterativeClosestPoint<PointSource, PointTarget, Scalar>::computeTransformation(
+    PointCloudSource& output, const Matrix4& guess)
+{
+  // Point cloud containing the correspondences of each point in <input, indices>
+  PointCloudSourcePtr input_transformed(new PointCloudSource);
+
+  nr_iterations_ = 0;
+  converged_ = false;
+
+  // Initialise final transformation to the guessed one
+  final_transformation_ = guess;
+
+  // If the guessed transformation is non identity
+  if (guess != Matrix4::Identity()) {
+    input_transformed->resize(input_->size());
+    // Apply guessed transformation prior to search for neighbours
+    transformCloud(*input_, *input_transformed, guess);
+  }
+  else
+    *input_transformed = *input_;
+
+  transformation_ = Matrix4::Identity();
+
+  // Make blobs if necessary
+  determineRequiredBlobData();
+  PCLPointCloud2::Ptr target_blob(new PCLPointCloud2);
+  if (need_target_blob_)
+    pcl::toPCLPointCloud2(*target_, *target_blob);
+
+  // Pass in the default target for the Correspondence Estimation/Rejection code
+  correspondence_estimation_->setInputTarget(target_);
+  if (correspondence_estimation_->requiresTargetNormals())
+    correspondence_estimation_->setTargetNormals(target_blob);
+  // Correspondence Rejectors need a binary blob
+  for (std::size_t i = 0; i < correspondence_rejectors_.size(); ++i) {
+    pcl::registration::CorrespondenceRejector::Ptr& rej = correspondence_rejectors_[i];
+    if (rej->requiresTargetPoints())
+      rej->setTargetPoints(target_blob);
+    if (rej->requiresTargetNormals() && target_has_normals_)
+      rej->setTargetNormals(target_blob);
+  }
+
+  convergence_criteria_->setMaximumIterations(max_iterations_);
+  convergence_criteria_->setRelativeMSE(euclidean_fitness_epsilon_);
+  convergence_criteria_->setTranslationThreshold(transformation_epsilon_);
+  if (transformation_rotation_epsilon_ > 0)
+    convergence_criteria_->setRotationThreshold(transformation_rotation_epsilon_);
+  else
+    convergence_criteria_->setRotationThreshold(1.0 - transformation_epsilon_);
+
+  // Repeat until convergence
+  do {
+    // Get blob data if needed
+    PCLPointCloud2::Ptr input_transformed_blob;
+    if (need_source_blob_) {
+      input_transformed_blob.reset(new PCLPointCloud2);
+      toPCLPointCloud2(*input_transformed, *input_transformed_blob);
+    }
+    // Save the previously estimated transformation
+    previous_transformation_ = transformation_;
+
+    // Set the source each iteration, to ensure the dirty flag is updated
+    correspondence_estimation_->setInputSource(input_transformed);
+    if (correspondence_estimation_->requiresSourceNormals())
+      correspondence_estimation_->setSourceNormals(input_transformed_blob);
+    // Estimate correspondences
+    if (use_reciprocal_correspondence_)
+      correspondence_estimation_->determineReciprocalCorrespondences(
+          *correspondences_, corr_dist_threshold_);
+    else
+      correspondence_estimation_->determineCorrespondences(*correspondences_,
+                                                           corr_dist_threshold_);
+
+    // if (correspondence_rejectors_.empty ())
+    CorrespondencesPtr temp_correspondences(new Correspondences(*correspondences_));
+    for (std::size_t i = 0; i < correspondence_rejectors_.size(); ++i) {
+      pcl::registration::CorrespondenceRejector::Ptr& rej = correspondence_rejectors_[i];
+      PCL_DEBUG("Applying a correspondence rejector method: %s.\n",
+                rej->getClassName().c_str());
+      if (rej->requiresSourcePoints())
+        rej->setSourcePoints(input_transformed_blob);
+      if (rej->requiresSourceNormals() && source_has_normals_)
+        rej->setSourceNormals(input_transformed_blob);
+      rej->setInputCorrespondences(temp_correspondences);
+      rej->getCorrespondences(*correspondences_);
+      // Modify input for the next iteration
+      if (i < correspondence_rejectors_.size() - 1)
+        *temp_correspondences = *correspondences_;
+    }
+
+    std::size_t cnt = correspondences_->size();
+    // Check whether we have enough correspondences
+    if (static_cast<int>(cnt) < min_number_correspondences_) {
+      PCL_ERROR("[pcl::%s::computeTransformation] Not enough correspondences found. "
+                "Relax your threshold parameters.\n",
+                getClassName().c_str());
+      convergence_criteria_->setConvergenceState(
+          pcl::registration::DefaultConvergenceCriteria<
+              Scalar>::CONVERGENCE_CRITERIA_NO_CORRESPONDENCES);
+      converged_ = false;
+      break;
+    }
+
+    // Estimate the transform
+    transformation_estimation_->estimateRigidTransformation(
+        *input_transformed, *target_, *correspondences_, transformation_);
+
+    // Transform the data
+    transformCloud(*input_transformed, *input_transformed, transformation_);
+
+    // Obtain the final transformation
+    final_transformation_ = transformation_ * final_transformation_;
+
+    ++nr_iterations_;
+
+    // Update the vizualization of icp convergence
+    // if (update_visualizer_ != 0)
+    //  update_visualizer_(output, source_indices_good, *target_, target_indices_good );
+
+    converged_ = static_cast<bool>((*convergence_criteria_));
+  } while (convergence_criteria_->getConvergenceState() ==
+           pcl::registration::DefaultConvergenceCriteria<
+               Scalar>::CONVERGENCE_CRITERIA_NOT_CONVERGED);
+
+  // Transform the input cloud using the final transformation
+  PCL_DEBUG("Transformation "
+            "is:\n\t%5f\t%5f\t%5f\t%5f\n\t%5f\t%5f\t%5f\t%5f\n\t%5f\t%5f\t%5f\t%5f\n\t%"
+            "5f\t%5f\t%5f\t%5f\n",
+            final_transformation_(0, 0),
+            final_transformation_(0, 1),
+            final_transformation_(0, 2),
+            final_transformation_(0, 3),
+            final_transformation_(1, 0),
+            final_transformation_(1, 1),
+            final_transformation_(1, 2),
+            final_transformation_(1, 3),
+            final_transformation_(2, 0),
+            final_transformation_(2, 1),
+            final_transformation_(2, 2),
+            final_transformation_(2, 3),
+            final_transformation_(3, 0),
+            final_transformation_(3, 1),
+            final_transformation_(3, 2),
+            final_transformation_(3, 3));
+
+  // Copy all the values
+  output = *input_;
+  // Transform the XYZ + normals
+  transformCloud(*input_, output, final_transformation_);
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+IterativeClosestPoint<PointSource, PointTarget, Scalar>::determineRequiredBlobData()
+{
+  need_source_blob_ = false;
+  need_target_blob_ = false;
+  // Check estimator
+  need_source_blob_ |= correspondence_estimation_->requiresSourceNormals();
+  need_target_blob_ |= correspondence_estimation_->requiresTargetNormals();
+  // Add warnings if necessary
+  if (correspondence_estimation_->requiresSourceNormals() && !source_has_normals_) {
+    PCL_WARN("[pcl::%s::determineRequiredBlobData] Estimator expects source normals, "
+             "but we can't provide them.\n",
+             getClassName().c_str());
+  }
+  if (correspondence_estimation_->requiresTargetNormals() && !target_has_normals_) {
+    PCL_WARN("[pcl::%s::determineRequiredBlobData] Estimator expects target normals, "
+             "but we can't provide them.\n",
+             getClassName().c_str());
+  }
+  // Check rejectors
+  for (std::size_t i = 0; i < correspondence_rejectors_.size(); i++) {
+    pcl::registration::CorrespondenceRejector::Ptr& rej = correspondence_rejectors_[i];
+    need_source_blob_ |= rej->requiresSourcePoints();
+    need_source_blob_ |= rej->requiresSourceNormals();
+    need_target_blob_ |= rej->requiresTargetPoints();
+    need_target_blob_ |= rej->requiresTargetNormals();
+    if (rej->requiresSourceNormals() && !source_has_normals_) {
+      PCL_WARN("[pcl::%s::determineRequiredBlobData] Rejector %s expects source "
+               "normals, but we can't provide them.\n",
+               getClassName().c_str(),
+               rej->getClassName().c_str());
+    }
+    if (rej->requiresTargetNormals() && !target_has_normals_) {
+      PCL_WARN("[pcl::%s::determineRequiredBlobData] Rejector %s expects target "
+               "normals, but we can't provide them.\n",
+               getClassName().c_str(),
+               rej->getClassName().c_str());
+    }
+  }
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+void
+IterativeClosestPointWithNormals<PointSource, PointTarget, Scalar>::transformCloud(
+    const PointCloudSource& input, PointCloudSource& output, const Matrix4& transform)
+{
+  pcl::transformPointCloudWithNormals(input, output, transform);
+}
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_IterativeClosestPoint(T,U) template class PCL_EXPORTS pcl::oneapi::IterativeClosestPoint<T,U>;
+
+#endif /* PCL_ONEAPI_REGISTRATION_IMPL_ICP_HPP_ */
diff --git a/oneapi/registration/include/pcl/oneapi/registration/impl/registration.hpp b/oneapi/registration/include/pcl/oneapi/registration/impl/registration.hpp
new file mode 100644
index 000000000..c2c3c94a1
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/impl/registration.hpp
@@ -0,0 +1,223 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_REGISTRATION_IMPL_REGISTRATION_HPP_
+#define PCL_ONEAPI_REGISTRATION_IMPL_REGISTRATION_HPP_
+
+#include <pcl/oneapi/registration/registration.h>
+
+namespace pcl {
+namespace oneapi {
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline void
+Registration<PointSource, PointTarget, Scalar>::setInputSource(
+    const PointCloudSourceConstPtr& cloud)
+{
+  if (cloud->points.empty()) {
+    PCL_ERROR("[pcl::%s::setInputSource] Invalid or empty point cloud dataset given!\n",
+              getClassName().c_str());
+    return;
+  }
+  source_cloud_updated_ = true;
+  pcl::PCLBase<PointSource>::setInputCloud(cloud);
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline void
+Registration<PointSource, PointTarget, Scalar>::setInputTarget(
+    const PointCloudTargetConstPtr& cloud)
+{
+  if (cloud->points.empty()) {
+    PCL_ERROR("[pcl::%s::setInputTarget] Invalid or empty point cloud dataset given!\n",
+              getClassName().c_str());
+    return;
+  }
+  target_ = cloud;
+  target_cloud_updated_ = true;
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+bool
+Registration<PointSource, PointTarget, Scalar>::initCompute()
+{
+  if (!target_) {
+    PCL_ERROR("[pcl::registration::%s::compute] No input target dataset was given!\n",
+              getClassName().c_str());
+    return (false);
+  }
+
+  // Only update target kd-tree if a new target cloud was set
+  if (target_cloud_updated_ && !force_no_recompute_) {
+    tree_->setInputCloud(target_);
+    target_cloud_updated_ = false;
+  }
+
+  // Update the correspondence estimation
+  if (correspondence_estimation_) {
+    correspondence_estimation_->setSearchMethodTarget(tree_, force_no_recompute_);
+    correspondence_estimation_->setSearchMethodSource(tree_reciprocal_,
+                                                      force_no_recompute_reciprocal_);
+  }
+
+  // Note: we /cannot/ update the search method on all correspondence rejectors, because
+  // we know nothing about them. If they should be cached, they must be cached
+  // individually.
+
+  return (pcl::PCLBase<PointSource>::initCompute());
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+bool
+Registration<PointSource, PointTarget, Scalar>::initComputeReciprocal()
+{
+  if (!input_) {
+    PCL_ERROR("[pcl::registration::%s::compute] No input source dataset was given!\n",
+              getClassName().c_str());
+    return (false);
+  }
+
+  if (source_cloud_updated_ && !force_no_recompute_reciprocal_) {
+    tree_reciprocal_->setInputCloud(input_);
+    source_cloud_updated_ = false;
+  }
+  return (true);
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline double
+Registration<PointSource, PointTarget, Scalar>::getFitnessScore(
+    const std::vector<float>& distances_a, const std::vector<float>& distances_b)
+{
+  unsigned int nr_elem =
+      static_cast<unsigned int>(std::min(distances_a.size(), distances_b.size()));
+  Eigen::VectorXf map_a = Eigen::VectorXf::Map(&distances_a[0], nr_elem);
+  Eigen::VectorXf map_b = Eigen::VectorXf::Map(&distances_b[0], nr_elem);
+  return (static_cast<double>((map_a - map_b).sum()) / static_cast<double>(nr_elem));
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline double
+Registration<PointSource, PointTarget, Scalar>::getFitnessScore(double max_range)
+{
+  double fitness_score = 0.0;
+
+  // Transform the input dataset using the final transformation
+  PointCloudSource input_transformed;
+  transformPointCloud(*input_, input_transformed, final_transformation_);
+
+  int nr = 0;
+  pcl::oneapi::DeviceArray2D<int> nn_indices;
+  pcl::oneapi::DeviceArray2D<float> nn_dists;
+
+  if (!tree_) return (std::numeric_limits<double>::max());
+  tree_->nearestKSearch (input_transformed.makeShared(), 1, nn_indices, nn_dists);
+
+  for (int i = 0; i < nn_dists.rows(); i++)
+  {
+    if (nn_dists[i][0] <= max_range)
+    {
+      fitness_score += nn_dists[i][0];
+      nr++;
+    }
+  }
+
+  if (nr > 0)
+    return (fitness_score / nr);
+  return (std::numeric_limits<double>::max());
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline void
+Registration<PointSource, PointTarget, Scalar>::align(PointCloudSource& output)
+{
+  align(output, Matrix4::Identity());
+}
+
+template <typename PointSource, typename PointTarget, typename Scalar>
+inline void
+Registration<PointSource, PointTarget, Scalar>::align(PointCloudSource& output,
+                                                      const Matrix4& guess)
+{
+  if (!initCompute())
+    return;
+
+  // Resize the output dataset
+  output.resize(indices_->size());
+  // Copy the header
+  output.header = input_->header;
+  // Check if the output will be computed for all points or only a subset
+  if (indices_->size() != input_->size()) {
+    output.width = indices_->size();
+    output.height = 1;
+  }
+  else {
+    output.width = static_cast<std::uint32_t>(input_->width);
+    output.height = input_->height;
+  }
+  output.is_dense = input_->is_dense;
+
+  // Copy the point data to output
+  for (std::size_t i = 0; i < indices_->size(); ++i)
+    output[i] = (*input_)[(*indices_)[i]];
+
+  // Set the internal point representation of choice unless otherwise noted
+  if (point_representation_ && !force_no_recompute_)
+    tree_->setPointRepresentation(point_representation_);
+
+  // Perform the actual transformation computation
+  converged_ = false;
+  final_transformation_ = transformation_ = previous_transformation_ =
+      Matrix4::Identity();
+
+  // Right before we estimate the transformation, we set all the point.data[3] values to
+  // 1 to aid the rigid transformation
+  for (std::size_t i = 0; i < indices_->size(); ++i)
+    output[i].data[3] = 1.0;
+
+  computeTransformation(output, guess);
+
+  deinitCompute();
+}
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_Registration(T,U) template class PCL_EXPORTS pcl::oneapi::Registration<T,U>;
+
+#endif /* PCL_ONEAPI_REGISTRATION_IMPL_REGISTRATION_HPP_ */
diff --git a/oneapi/registration/include/pcl/oneapi/registration/registration.h b/oneapi/registration/include/pcl/oneapi/registration/registration.h
new file mode 100644
index 000000000..04df9a295
--- /dev/null
+++ b/oneapi/registration/include/pcl/oneapi/registration/registration.h
@@ -0,0 +1,717 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+// PCL includes
+#include <pcl/oneapi/registration/correspondence_estimation.h>
+#include <pcl/registration/correspondence_rejection.h>
+#include <pcl/registration/transformation_estimation.h>
+#include <pcl/oneapi/search/kdtree.h>
+#include <pcl/memory.h>
+#include <pcl/pcl_base.h>
+#include <pcl/pcl_macros.h>
+
+namespace pcl {
+namespace oneapi {
+/** \brief @b Registration represents the base registration class for general purpose,
+ * ICP-like methods. \author Radu B. Rusu, Michael Dixon \ingroup registration
+ */
+template <typename PointSource, typename PointTarget, typename Scalar = float>
+class Registration : public pcl::PCLBase<PointSource> {
+public:
+  using Matrix4 = Eigen::Matrix<Scalar, 4, 4>;
+
+  // using PCLBase<PointSource>::initCompute;
+  using pcl::PCLBase<PointSource>::deinitCompute;
+  using pcl::PCLBase<PointSource>::input_;
+  using pcl::PCLBase<PointSource>::indices_;
+
+  using Ptr = shared_ptr<Registration<PointSource, PointTarget, Scalar>>;
+  using ConstPtr = shared_ptr<const Registration<PointSource, PointTarget, Scalar>>;
+
+  using CorrespondenceRejectorPtr = pcl::registration::CorrespondenceRejector::Ptr;
+  using KdTree = pcl::oneapi::search::KdTree<PointTarget>;
+  using KdTreePtr = typename KdTree::Ptr;
+
+  using KdTreeReciprocal = pcl::oneapi::search::KdTree<PointSource>;
+  using KdTreeReciprocalPtr = typename KdTreeReciprocal::Ptr;
+
+  using PointCloudSource = pcl::PointCloud<PointSource>;
+  using PointCloudSourcePtr = typename PointCloudSource::Ptr;
+  using PointCloudSourceConstPtr = typename PointCloudSource::ConstPtr;
+
+  using PointCloudTarget = pcl::PointCloud<PointTarget>;
+  using PointCloudTargetPtr = typename PointCloudTarget::Ptr;
+  using PointCloudTargetConstPtr = typename PointCloudTarget::ConstPtr;
+
+  using PointRepresentationConstPtr = typename KdTree::PointRepresentationConstPtr;
+
+  using TransformationEstimation = typename pcl::registration::
+      TransformationEstimation<PointSource, PointTarget, Scalar>;
+  using TransformationEstimationPtr = typename TransformationEstimation::Ptr;
+  using TransformationEstimationConstPtr = typename TransformationEstimation::ConstPtr;
+
+  using CorrespondenceEstimation =
+      pcl::oneapi::registration::CorrespondenceEstimationBase<PointSource, PointTarget, Scalar>;
+  using CorrespondenceEstimationPtr = typename CorrespondenceEstimation::Ptr;
+  using CorrespondenceEstimationConstPtr = typename CorrespondenceEstimation::ConstPtr;
+
+  /** \brief The callback signature to the function updating intermediate source point
+   * cloud position during it's registration to the target point cloud. \param[in]
+   * cloud_src - the point cloud which will be updated to match target \param[in]
+   * indices_src - a selector of points in cloud_src \param[in] cloud_tgt - the point
+   * cloud we want to register against \param[in] indices_tgt - a selector of points in
+   * cloud_tgt
+   */
+  using UpdateVisualizerCallbackSignature = void(const pcl::PointCloud<PointSource>&,
+                                                 const pcl::Indices&,
+                                                 const pcl::PointCloud<PointTarget>&,
+                                                 const pcl::Indices&);
+
+  /** \brief Empty constructor. */
+  Registration()
+  : reg_name_("")
+  , tree_(new KdTree)
+  , tree_reciprocal_(new KdTreeReciprocal)
+  , nr_iterations_(0)
+  , max_iterations_(10)
+  , ransac_iterations_(0)
+  , target_()
+  , final_transformation_(Matrix4::Identity())
+  , transformation_(Matrix4::Identity())
+  , previous_transformation_(Matrix4::Identity())
+  , transformation_epsilon_(0.0)
+  , transformation_rotation_epsilon_(0.0)
+  , euclidean_fitness_epsilon_(-std::numeric_limits<double>::max())
+  , corr_dist_threshold_(std::sqrt(std::numeric_limits<double>::max()))
+  , inlier_threshold_(0.05)
+  , converged_(false)
+  , min_number_correspondences_(3)
+  , correspondences_(new Correspondences)
+  , transformation_estimation_()
+  , correspondence_estimation_()
+  , correspondence_rejectors_()
+  , target_cloud_updated_(true)
+  , source_cloud_updated_(true)
+  , force_no_recompute_(false)
+  , force_no_recompute_reciprocal_(false)
+  , update_visualizer_(nullptr)
+  , point_representation_()
+  {}
+
+  /** \brief destructor. */
+  ~Registration() {}
+
+  /** \brief Provide a pointer to the transformation estimation object.
+   * (e.g., SVD, point to plane etc.)
+   *
+   * \param[in] te is the pointer to the corresponding transformation estimation object
+   *
+   * Code example:
+   *
+   * \code
+   * TransformationEstimationPointToPlaneLLS<PointXYZ, PointXYZ>::Ptr trans_lls
+   *   (new TransformationEstimationPointToPlaneLLS<PointXYZ, PointXYZ>);
+   * icp.setTransformationEstimation (trans_lls);
+   * // or...
+   * TransformationEstimationSVD<PointXYZ, PointXYZ>::Ptr trans_svd
+   *   (new TransformationEstimationSVD<PointXYZ, PointXYZ>);
+   * icp.setTransformationEstimation (trans_svd);
+   * \endcode
+   */
+  void
+  setTransformationEstimation(const TransformationEstimationPtr& te)
+  {
+    transformation_estimation_ = te;
+  }
+
+  /** \brief Provide a pointer to the correspondence estimation object.
+   * (e.g., regular, reciprocal, normal shooting etc.)
+   *
+   * \param[in] ce is the pointer to the corresponding correspondence estimation object
+   *
+   * Code example:
+   *
+   * \code
+   * CorrespondenceEstimation<PointXYZ, PointXYZ>::Ptr
+   *   ce (new CorrespondenceEstimation<PointXYZ, PointXYZ>);
+   * ce->setInputSource (source);
+   * ce->setInputTarget (target);
+   * icp.setCorrespondenceEstimation (ce);
+   * // or...
+   * CorrespondenceEstimationNormalShooting<PointNormal, PointNormal, PointNormal>::Ptr
+   *   cens (new CorrespondenceEstimationNormalShooting<PointNormal, PointNormal>);
+   * ce->setInputSource (source);
+   * ce->setInputTarget (target);
+   * ce->setSourceNormals (source);
+   * ce->setTargetNormals (target);
+   * icp.setCorrespondenceEstimation (cens);
+   * \endcode
+   */
+  void
+  setCorrespondenceEstimation(const CorrespondenceEstimationPtr& ce)
+  {
+    correspondence_estimation_ = ce;
+  }
+
+  /** \brief Provide a pointer to the input source
+   * (e.g., the point cloud that we want to align to the target)
+   *
+   * \param[in] cloud the input point cloud source
+   */
+  virtual void
+  setInputSource(const PointCloudSourceConstPtr& cloud);
+
+  /** \brief Get a pointer to the input point cloud dataset target. */
+  inline PointCloudSourceConstPtr const
+  getInputSource()
+  {
+    return (input_);
+  }
+
+  /** \brief Provide a pointer to the input target (e.g., the point cloud that we want
+   * to align the input source to) \param[in] cloud the input point cloud target
+   */
+  virtual void
+  setInputTarget(const PointCloudTargetConstPtr& cloud);
+
+  /** \brief Get a pointer to the input point cloud dataset target. */
+  inline PointCloudTargetConstPtr const
+  getInputTarget()
+  {
+    return (target_);
+  }
+
+  /** \brief Provide a pointer to the search object used to find correspondences in
+   * the target cloud.
+   * \param[in] tree a pointer to the spatial search object.
+   * \param[in] force_no_recompute If set to true, this tree will NEVER be
+   * recomputed, regardless of calls to setInputTarget. Only use if you are
+   * confident that the tree will be set correctly.
+   */
+  inline void
+  setSearchMethodTarget(const KdTreePtr& tree, bool force_no_recompute = false)
+  {
+    tree_ = tree;
+    force_no_recompute_ = force_no_recompute;
+    // Since we just set a new tree, we need to check for updates
+    target_cloud_updated_ = true;
+  }
+
+  /** \brief Get a pointer to the search method used to find correspondences in the
+   * target cloud. */
+  inline KdTreePtr
+  getSearchMethodTarget() const
+  {
+    return (tree_);
+  }
+
+  /** \brief Provide a pointer to the search object used to find correspondences in
+   * the source cloud (usually used by reciprocal correspondence finding).
+   * \param[in] tree a pointer to the spatial search object.
+   * \param[in] force_no_recompute If set to true, this tree will NEVER be
+   * recomputed, regardless of calls to setInputSource. Only use if you are
+   * extremely confident that the tree will be set correctly.
+   */
+  inline void
+  setSearchMethodSource(const KdTreeReciprocalPtr& tree,
+                        bool force_no_recompute = false)
+  {
+    tree_reciprocal_ = tree;
+    force_no_recompute_reciprocal_ = force_no_recompute;
+    // Since we just set a new tree, we need to check for updates
+    source_cloud_updated_ = true;
+  }
+
+  /** \brief Get a pointer to the search method used to find correspondences in the
+   * source cloud. */
+  inline KdTreeReciprocalPtr
+  getSearchMethodSource() const
+  {
+    return (tree_reciprocal_);
+  }
+
+  /** \brief Get the final transformation matrix estimated by the registration method.
+   */
+  inline Matrix4
+  getFinalTransformation()
+  {
+    return (final_transformation_);
+  }
+
+  /** \brief Get the last incremental transformation matrix estimated by the
+   * registration method. */
+  inline Matrix4
+  getLastIncrementalTransformation()
+  {
+    return (transformation_);
+  }
+
+  /** \brief Set the maximum number of iterations the internal optimization should run
+   * for. \param[in] nr_iterations the maximum number of iterations the internal
+   * optimization should run for
+   */
+  inline void
+  setMaximumIterations(int nr_iterations)
+  {
+    max_iterations_ = nr_iterations;
+  }
+
+  /** \brief Get the maximum number of iterations the internal optimization should run
+   * for, as set by the user. */
+  inline int
+  getMaximumIterations()
+  {
+    return (max_iterations_);
+  }
+
+  /** \brief Set the number of iterations RANSAC should run for.
+   * \param[in] ransac_iterations is the number of iterations RANSAC should run for
+   */
+  inline void
+  setRANSACIterations(int ransac_iterations)
+  {
+    ransac_iterations_ = ransac_iterations;
+  }
+
+  /** \brief Get the number of iterations RANSAC should run for, as set by the user. */
+  inline double
+  getRANSACIterations()
+  {
+    return (ransac_iterations_);
+  }
+
+  /** \brief Set the inlier distance threshold for the internal RANSAC outlier rejection
+   * loop.
+   *
+   * The method considers a point to be an inlier, if the distance between the target
+   * data index and the transformed source index is smaller than the given inlier
+   * distance threshold. The value is set by default to 0.05m. \param[in]
+   * inlier_threshold the inlier distance threshold for the internal RANSAC outlier
+   * rejection loop
+   */
+  inline void
+  setRANSACOutlierRejectionThreshold(double inlier_threshold)
+  {
+    inlier_threshold_ = inlier_threshold;
+  }
+
+  /** \brief Get the inlier distance threshold for the internal outlier rejection loop
+   * as set by the user. */
+  inline double
+  getRANSACOutlierRejectionThreshold()
+  {
+    return (inlier_threshold_);
+  }
+
+  /** \brief Set the maximum distance threshold between two correspondent points in
+   * source <-> target. If the distance is larger than this threshold, the points will
+   * be ignored in the alignment process. \param[in] distance_threshold the maximum
+   * distance threshold between a point and its nearest neighbor correspondent in order
+   * to be considered in the alignment process
+   */
+  inline void
+  setMaxCorrespondenceDistance(double distance_threshold)
+  {
+    corr_dist_threshold_ = distance_threshold;
+  }
+
+  /** \brief Get the maximum distance threshold between two correspondent points in
+   * source <-> target. If the distance is larger than this threshold, the points will
+   * be ignored in the alignment process.
+   */
+  inline double
+  getMaxCorrespondenceDistance()
+  {
+    return (corr_dist_threshold_);
+  }
+
+  /** \brief Set the transformation epsilon (maximum allowable translation squared
+   * difference between two consecutive transformations) in order for an optimization to
+   * be considered as having converged to the final solution. \param[in] epsilon the
+   * transformation epsilon in order for an optimization to be considered as having
+   * converged to the final solution.
+   */
+  inline void
+  setTransformationEpsilon(double epsilon)
+  {
+    transformation_epsilon_ = epsilon;
+  }
+
+  /** \brief Get the transformation epsilon (maximum allowable translation squared
+   * difference between two consecutive transformations) as set by the user.
+   */
+  inline double
+  getTransformationEpsilon()
+  {
+    return (transformation_epsilon_);
+  }
+
+  /** \brief Set the transformation rotation epsilon (maximum allowable rotation
+   * difference between two consecutive transformations) in order for an optimization to
+   * be considered as having converged to the final solution. \param[in] epsilon the
+   * transformation rotation epsilon in order for an optimization to be considered as
+   * having converged to the final solution (epsilon is the cos(angle) in a axis-angle
+   * representation).
+   */
+  inline void
+  setTransformationRotationEpsilon(double epsilon)
+  {
+    transformation_rotation_epsilon_ = epsilon;
+  }
+
+  /** \brief Get the transformation rotation epsilon (maximum allowable difference
+   * between two consecutive transformations) as set by the user (epsilon is the
+   * cos(angle) in a axis-angle representation).
+   */
+  inline double
+  getTransformationRotationEpsilon()
+  {
+    return (transformation_rotation_epsilon_);
+  }
+
+  /** \brief Set the maximum allowed Euclidean error between two consecutive steps in
+   * the ICP loop, before the algorithm is considered to have converged. The error is
+   * estimated as the sum of the differences between correspondences in an Euclidean
+   * sense, divided by the number of correspondences. \param[in] epsilon the maximum
+   * allowed distance error before the algorithm will be considered to have converged
+   */
+  inline void
+  setEuclideanFitnessEpsilon(double epsilon)
+  {
+    euclidean_fitness_epsilon_ = epsilon;
+  }
+
+  /** \brief Get the maximum allowed distance error before the algorithm will be
+   * considered to have converged, as set by the user. See \ref
+   * setEuclideanFitnessEpsilon
+   */
+  inline double
+  getEuclideanFitnessEpsilon()
+  {
+    return (euclidean_fitness_epsilon_);
+  }
+
+  /** \brief Provide a boost shared pointer to the PointRepresentation to be used when
+   * comparing points \param[in] point_representation the PointRepresentation to be used
+   * by the k-D tree
+   */
+  inline void
+  setPointRepresentation(const PointRepresentationConstPtr& point_representation)
+  {
+    point_representation_ = point_representation;
+  }
+
+  /** \brief Register the user callback function which will be called from registration
+   * thread in order to update point cloud obtained after each iteration \param[in]
+   * visualizerCallback reference of the user callback function
+   */
+  inline bool
+  registerVisualizationCallback(
+      std::function<UpdateVisualizerCallbackSignature>& visualizerCallback)
+  {
+    if (visualizerCallback) {
+      update_visualizer_ = visualizerCallback;
+      return (true);
+    }
+    return (false);
+  }
+
+  /** \brief Obtain the Euclidean fitness score (e.g., mean of squared distances from
+   * the source to the target) \param[in] max_range maximum allowable distance between a
+   * point and its correspondence in the target (default: double::max)
+   */
+  double
+  getFitnessScore(double max_range = std::numeric_limits<double>::max());
+
+  /** \brief Obtain the Euclidean fitness score (e.g., mean of squared distances from
+   * the source to the target) from two sets of correspondence distances (distances
+   * between source and target points) \param[in] distances_a the first set of distances
+   * between correspondences \param[in] distances_b the second set of distances between
+   * correspondences
+   */
+  double
+  getFitnessScore(const std::vector<float>& distances_a,
+                  const std::vector<float>& distances_b);
+
+  /** \brief Return the state of convergence after the last align run */
+  inline bool
+  hasConverged() const
+  {
+    return (converged_);
+  }
+
+  /** \brief Call the registration algorithm which estimates the transformation and
+   * returns the transformed source (input) as \a output. \param[out] output the
+   * resultant input transformed point cloud dataset
+   */
+  void
+  align(PointCloudSource& output);
+
+  /** \brief Call the registration algorithm which estimates the transformation and
+   * returns the transformed source (input) as \a output. \param[out] output the
+   * resultant input transformed point cloud dataset \param[in] guess the initial gross
+   * estimation of the transformation
+   */
+  void
+  align(PointCloudSource& output, const Matrix4& guess);
+
+  /** \brief Abstract class get name method. */
+  inline const std::string&
+  getClassName() const
+  {
+    return (reg_name_);
+  }
+
+  /** \brief Internal computation initialization. */
+  bool
+  initCompute();
+
+  /** \brief Internal computation when reciprocal lookup is needed */
+  bool
+  initComputeReciprocal();
+
+  /** \brief Add a new correspondence rejector to the list
+   * \param[in] rejector the new correspondence rejector to concatenate
+   *
+   * Code example:
+   *
+   * \code
+   * CorrespondenceRejectorDistance rej;
+   * rej.setInputCloud<PointXYZ> (keypoints_src);
+   * rej.setInputTarget<PointXYZ> (keypoints_tgt);
+   * rej.setMaximumDistance (1);
+   * rej.setInputCorrespondences (all_correspondences);
+   *
+   * // or...
+   *
+   * \endcode
+   */
+  inline void
+  addCorrespondenceRejector(const CorrespondenceRejectorPtr& rejector)
+  {
+    correspondence_rejectors_.push_back(rejector);
+  }
+
+  /** \brief Get the list of correspondence rejectors. */
+  inline std::vector<CorrespondenceRejectorPtr>
+  getCorrespondenceRejectors()
+  {
+    return (correspondence_rejectors_);
+  }
+
+  /** \brief Remove the i-th correspondence rejector in the list
+   * \param[in] i the position of the correspondence rejector in the list to remove
+   */
+  inline bool
+  removeCorrespondenceRejector(unsigned int i)
+  {
+    if (i >= correspondence_rejectors_.size())
+      return (false);
+    correspondence_rejectors_.erase(correspondence_rejectors_.begin() + i);
+    return (true);
+  }
+
+  /** \brief Clear the list of correspondence rejectors. */
+  inline void
+  clearCorrespondenceRejectors()
+  {
+    correspondence_rejectors_.clear();
+  }
+
+protected:
+  /** \brief The registration method name. */
+  std::string reg_name_;
+
+  /** \brief A pointer to the spatial search object. */
+  KdTreePtr tree_;
+
+  /** \brief A pointer to the spatial search object of the source. */
+  KdTreeReciprocalPtr tree_reciprocal_;
+
+  /** \brief The number of iterations the internal optimization ran for (used
+   * internally). */
+  int nr_iterations_;
+
+  /** \brief The maximum number of iterations the internal optimization should run for.
+   * The default value is 10.
+   */
+  int max_iterations_;
+
+  /** \brief The number of iterations RANSAC should run for. */
+  int ransac_iterations_;
+
+  /** \brief The input point cloud dataset target. */
+  PointCloudTargetConstPtr target_;
+
+  /** \brief The final transformation matrix estimated by the registration method after
+   * N iterations. */
+  Matrix4 final_transformation_;
+
+  /** \brief The transformation matrix estimated by the registration method. */
+  Matrix4 transformation_;
+
+  /** \brief The previous transformation matrix estimated by the registration method
+   * (used internally). */
+  Matrix4 previous_transformation_;
+
+  /** \brief The maximum difference between two consecutive transformations in order to
+   * consider convergence (user defined).
+   */
+  double transformation_epsilon_;
+
+  /** \brief The maximum rotation difference between two consecutive transformations in
+   * order to consider convergence (user defined).
+   */
+  double transformation_rotation_epsilon_;
+
+  /** \brief The maximum allowed Euclidean error between two consecutive steps in the
+   * ICP loop, before the algorithm is considered to have converged. The error is
+   * estimated as the sum of the differences between correspondences in an Euclidean
+   * sense, divided by the number of correspondences.
+   */
+  double euclidean_fitness_epsilon_;
+
+  /** \brief The maximum distance threshold between two correspondent points in source
+   * <-> target. If the distance is larger than this threshold, the points will be
+   * ignored in the alignment process.
+   */
+  double corr_dist_threshold_;
+
+  /** \brief The inlier distance threshold for the internal RANSAC outlier rejection
+   * loop. The method considers a point to be an inlier, if the distance between the
+   * target data index and the transformed source index is smaller than the given inlier
+   * distance threshold. The default value is 0.05.
+   */
+  double inlier_threshold_;
+
+  /** \brief Holds internal convergence state, given user parameters. */
+  bool converged_;
+
+  /** \brief The minimum number of correspondences that the algorithm needs before
+   * attempting to estimate the transformation. The default value is 3.
+   */
+  int min_number_correspondences_;
+
+  /** \brief The set of correspondences determined at this ICP step. */
+  CorrespondencesPtr correspondences_;
+
+  /** \brief A TransformationEstimation object, used to calculate the 4x4 rigid
+   * transformation. */
+  TransformationEstimationPtr transformation_estimation_;
+
+  /** \brief A CorrespondenceEstimation object, used to estimate correspondences between
+   * the source and the target cloud. */
+  CorrespondenceEstimationPtr correspondence_estimation_;
+
+  /** \brief The list of correspondence rejectors to use. */
+  std::vector<CorrespondenceRejectorPtr> correspondence_rejectors_;
+
+  /** \brief Variable that stores whether we have a new target cloud, meaning we need to
+   * pre-process it again. This way, we avoid rebuilding the kd-tree for the target
+   * cloud every time the determineCorrespondences () method is called. */
+  bool target_cloud_updated_;
+  /** \brief Variable that stores whether we have a new source cloud, meaning we need to
+   * pre-process it again. This way, we avoid rebuilding the reciprocal kd-tree for the
+   * source cloud every time the determineCorrespondences () method is called. */
+  bool source_cloud_updated_;
+  /** \brief A flag which, if set, means the tree operating on the target cloud
+   * will never be recomputed*/
+  bool force_no_recompute_;
+
+  /** \brief A flag which, if set, means the tree operating on the source cloud
+   * will never be recomputed*/
+  bool force_no_recompute_reciprocal_;
+
+  /** \brief Callback function to update intermediate source point cloud position during
+   * it's registration to the target point cloud.
+   */
+  std::function<UpdateVisualizerCallbackSignature> update_visualizer_;
+
+  /** \brief Search for the closest nearest neighbor of a given point.
+   * \param cloud the point cloud dataset to use for nearest neighbor search
+   * \param index the index of the query point
+   * \param indices the resultant vector of indices representing the k-nearest neighbors
+   * \param distances the resultant distances from the query point to the k-nearest
+   * neighbors
+   */
+  inline bool
+  searchForNeighbors(const PointCloudSource& cloud,
+                     int index,
+                     pcl::Indices& indices,
+                     std::vector<float>& distances)
+  {
+    int k = tree_->nearestKSearch(cloud, index, 1, indices, distances);
+    if (k == 0)
+      return (false);
+    return (true);
+  }
+
+  /** \brief Abstract transformation computation method with initial guess */
+  virtual void
+  computeTransformation(PointCloudSource& output, const Matrix4& guess) = 0;
+
+private:
+  /** \brief The point representation used (internal). */
+  PointRepresentationConstPtr point_representation_;
+
+  /**
+   * \brief Remove from public API in favor of \ref setInputSource
+   *
+   * Still gives the correct result (with a warning)
+   */
+  void
+  setInputCloud(const PointCloudSourceConstPtr& cloud) override
+  {
+    PCL_WARN("[pcl::registration::Registration] setInputCloud is deprecated."
+             "Please use setInputSource instead.\n");
+    setInputSource(cloud);
+  }
+
+public:
+  PCL_MAKE_ALIGNED_OPERATOR_NEW
+};
+} // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/registration/impl/registration.hpp>
+#endif
diff --git a/oneapi/registration/src/correspondence_estimation.cpp b/oneapi/registration/src/correspondence_estimation.cpp
new file mode 100644
index 000000000..3a1a95a34
--- /dev/null
+++ b/oneapi/registration/src/correspondence_estimation.cpp
@@ -0,0 +1,51 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/registration/impl/correspondence_estimation.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+PCL_INSTANTIATE_PRODUCT(CorrespondenceEstimation,
+    ((pcl::PointXYZ))
+    ((pcl::PointXYZ)))
+PCL_INSTANTIATE_PRODUCT(CorrespondenceEstimationBase,
+    ((pcl::PointXYZ))
+    ((pcl::PointXYZ)))
+#endif    // PCL_NO_PRECOMPILE
diff --git a/oneapi/registration/src/ia_ransac.cpp b/oneapi/registration/src/ia_ransac.cpp
new file mode 100644
index 000000000..9ad9f3deb
--- /dev/null
+++ b/oneapi/registration/src/ia_ransac.cpp
@@ -0,0 +1,49 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/registration/impl/ia_ransac.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+PCL_INSTANTIATE_PRODUCT(SampleConsensusInitialAlignment,
+    ((pcl::PointXYZ))
+    ((pcl::PointXYZ))
+    ((pcl::FPFHSignature33)))
+#endif    // PCL_NO_PRECOMPILE
diff --git a/oneapi/registration/src/icp.cpp b/oneapi/registration/src/icp.cpp
new file mode 100644
index 000000000..c33c406f4
--- /dev/null
+++ b/oneapi/registration/src/icp.cpp
@@ -0,0 +1,48 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/registration/impl/icp.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+PCL_INSTANTIATE_PRODUCT(IterativeClosestPoint,
+    ((pcl::PointXYZ))
+    ((pcl::PointXYZ)))
+#endif    // PCL_NO_PRECOMPILE
diff --git a/oneapi/registration/src/registration.cpp b/oneapi/registration/src/registration.cpp
new file mode 100644
index 000000000..d0359883a
--- /dev/null
+++ b/oneapi/registration/src/registration.cpp
@@ -0,0 +1,48 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/registration/impl/registration.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+PCL_INSTANTIATE_PRODUCT(Registration,
+    ((pcl::PointXYZ))
+    ((pcl::PointXYZ)))
+#endif    // PCL_NO_PRECOMPILE
diff --git a/oneapi/sample_consensus/CMakeLists.txt b/oneapi/sample_consensus/CMakeLists.txt
new file mode 100644
index 000000000..5afb58a17
--- /dev/null
+++ b/oneapi/sample_consensus/CMakeLists.txt
@@ -0,0 +1,39 @@
+set(SUBSYS_NAME oneapi_sample_consensus)
+set(SUBSYS_PATH oneapi/sample_consensus)
+set(SUBSYS_DESC "Point cloud oneAPI sample consensus library")
+set(SUBSYS_DEPS common oneapi_common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/oneapi/sample_consensus/ransac.h"
+  "include/pcl/oneapi/sample_consensus/sac.h"
+  "include/pcl/oneapi/sample_consensus/sac_model.h"
+  "include/pcl/oneapi/sample_consensus/sac_model_plane.h"
+  "include/pcl/oneapi/sample_consensus/model_types.h"
+  "include/pcl/oneapi/sample_consensus/method_types.h"
+)
+
+set(srcs
+  src/sac.cpp
+  src/sac_model_plane.cpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} )
+target_link_libraries("${LIB_NAME}" pcl_common pcl_oneapi_common)
+target_include_directories(${LIB_NAME} PUBLIC  "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include" "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/ransac.hpp b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/ransac.hpp
new file mode 100644
index 000000000..b3582b46b
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/ransac.hpp
@@ -0,0 +1,154 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_SAMPLE_CONSENSUS_IMPL_RANSAC_H_
+#define PCL_ONEAPI_SAMPLE_CONSENSUS_IMPL_RANSAC_H_
+
+#include <pcl/oneapi/sample_consensus/ransac.h>
+
+#include <chrono>
+inline double getTimeStamp()
+{
+  namespace sc = std::chrono;
+  sc::system_clock::duration d = sc::system_clock::now().time_since_epoch();
+  sc::seconds s = sc::duration_cast<sc::seconds>(d);
+  return s.count() + (sc::duration_cast<sc::microseconds>(d - s).count()) / 1e6;
+}
+
+namespace pcl
+{
+namespace oneapi
+{
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+RandomSampleConsensus<PointT>::computeModel (int)
+{
+  // Warn and exit if no threshold was set
+  if (threshold_ == std::numeric_limits<double>::max())
+  {
+    PCL_ERROR ("[pcl::RandomSampleConsensus::computeModel] No threshold set!\n");
+    return (false);
+  }
+
+  iterations_ = 0;
+  std::size_t n_best_inliers_count = 0;
+  double k = std::numeric_limits<double>::max();
+
+  IndicesDev selection;
+  Eigen::VectorXf model_coefficients (sac_model_->getModelSize ());
+
+  const double log_probability  = std::log (1.0 - probability_);
+  const double one_over_indices = 1.0 / static_cast<double> (sac_model_->getIndices ()->size ());
+
+  DeviceArray<std::size_t> inlier_count_buffer(1);
+
+  while (iterations_ < k)
+  {
+    sac_model_->getSamples (iterations_, selection); // The random number generator used when choosing the samples should not be called in parallel
+    if (selection.empty ())
+    {
+      PCL_ERROR ("[pcl::RandomSampleConsensus::computeModel] No samples could be selected!\n");
+      break;
+    }
+
+    // Search for inliers in the point cloud for the current plane model M
+    if (!sac_model_->computeModelCoefficients (selection, model_coefficients)) // This function has to be thread-safe
+    {
+      iterations_++;
+      if (iterations_ > max_iterations_)
+      {
+        PCL_DEBUG("[pcl::oneapi::sample_consensus::RandomSampleConsensus::computeModel] RANSAC reached the maximum number of trials.\n");
+        break;
+      }
+      continue;
+    }
+
+    sac_model_->countWithinDistance (model_coefficients, threshold_, inlier_count_buffer); // This functions has to be thread-safe. Most work is done here
+
+    std::size_t n_inliers_count = inlier_count_buffer[0];
+
+    if (n_inliers_count > n_best_inliers_count) // This condition is false most of the time, and the critical region is not entered, hopefully leading to more efficient concurrency
+    {
+      n_best_inliers_count = n_inliers_count; // This write and the previous read of n_best_inliers_count must be consecutive and must not be interrupted!
+
+      // Save the current model/inlier/coefficients selection as being the best so far
+      model_              = selection;
+      model_coefficients_ = model_coefficients;
+
+      // Compute the k parameter (k=std::log(z)/std::log(1-w^n))
+      const double w = static_cast<double> (n_best_inliers_count) * one_over_indices;
+      double p_no_outliers = 1.0 - std::pow (w, static_cast<double> (selection.size ()));
+      p_no_outliers = (std::max) (std::numeric_limits<double>::epsilon (), p_no_outliers);       // Avoid division by -Inf
+      p_no_outliers = (std::min) (1.0 - std::numeric_limits<double>::epsilon (), p_no_outliers);   // Avoid division by 0.
+      k = log_probability / std::log (p_no_outliers);
+    }
+
+    ++iterations_;
+    if (iterations_ > max_iterations_)
+    {
+        PCL_DEBUG("[pcl::oneapi::sample_consensus::RandomSampleConsensus::computeModel] RANSAC reached the maximum number of trials.\n");
+      break;
+    }
+  }
+
+
+  PCL_DEBUG ("[pcl::RandomSampleConsensus::computeModel] Model: %lu size, %u inliers.\n", model_.size (), n_best_inliers_count);
+
+  if (model_.empty ())
+  {
+    PCL_ERROR ("[pcl::RandomSampleConsensus::computeModel] RANSAC found no model.\n");
+    inliers_.clear ();
+    return (false);
+  }
+
+  // Get the set of inliers that correspond to the best model found so far
+  sac_model_->selectWithinDistance (model_coefficients_, threshold_, inliers_);
+
+  return (true);
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_RandomSampleConsensus(T) template class PCL_EXPORTS pcl::oneapi::RandomSampleConsensus<T>;
+
+#endif    // PCL_SAMPLE_CONSENSUS_IMPL_RANSAC_H_
+
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/sac_model_plane.hpp b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/sac_model_plane.hpp
new file mode 100644
index 000000000..7b92a13d3
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/impl/sac_model_plane.hpp
@@ -0,0 +1,543 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_SAMPLE_CONSENSUS_IMPL_SAC_MODEL_PLANE_H_
+#define PCL_ONEAPI_SAMPLE_CONSENSUS_IMPL_SAC_MODEL_PLANE_H_
+
+#include <pcl/oneapi/sample_consensus/sac_model_plane.h>
+#include <pcl/oneapi/common/centroid.h>
+#include <pcl/oneapi/utils/common.h>
+#include <pcl/common/eigen.h>
+#include <pcl/common/concatenate.h>
+#include <pcl/for_each_type.h>
+#include <dpct/dpct.hpp>
+#include <cmath>
+
+namespace pcl
+{
+namespace oneapi
+{
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+SampleConsensusModelPlane<PointT>::isSampleGood (const IndicesDev &samples) const
+{
+  if (samples.size () != sample_size_)
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::isSampleGood] Wrong number of samples (is %lu, should be %lu)!\n", samples.size (), sample_size_);
+    return (false);
+  }
+  // Get the values at the two points
+  pcl::Vector3fMapConst p0 = (*input_)[samples[0]].getVector3fMap ();
+  pcl::Vector3fMapConst p1 = (*input_)[samples[1]].getVector3fMap ();
+  pcl::Vector3fMapConst p2 = (*input_)[samples[2]].getVector3fMap ();
+
+  float norm;
+  const Eigen::Vector3f cross = (p1 - p0).cross(p2 - p0);
+
+  if (sycl::isnan(cross.x()) || sycl::isnan(cross.y()) || sycl::isnan(cross.z()))
+  {
+    return true;
+  }
+  else
+  {
+    norm = cross.stableNorm();
+  }
+
+  if ( norm < Eigen::NumTraits<float>::dummy_precision ())
+  {
+    PCL_ERROR ("[pcl::SampleConsensusModelPlane::isSampleGood] Sample points too similar or collinear!\n");
+    return (false);
+  }
+
+  return (true);
+
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+SampleConsensusModelPlane<PointT>::computeModelCoefficients (
+      const IndicesDev &samples, Eigen::VectorXf &model_coefficients) const
+{
+  // Need 3 samples
+  if (samples.size () != sample_size_)
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::computeModelCoefficients] Invalid set of samples given (%lu)!\n", samples.size ());
+    return (false);
+  }
+
+
+  pcl::Vector3fMapConst p0 = (*input_)[samples[0]].getVector3fMap ();
+  pcl::Vector3fMapConst p1 = (*input_)[samples[1]].getVector3fMap ();
+  pcl::Vector3fMapConst p2 = (*input_)[samples[2]].getVector3fMap ();
+
+  const Eigen::Vector3f cross = (p1 - p0).cross(p2 - p0);
+
+  if (sycl::isnan(cross.x()) || sycl::isnan(cross.y()) || sycl::isnan(cross.z()))
+  {
+     model_coefficients.resize (model_size_);
+     model_coefficients.setConstant(std::numeric_limits<float>::quiet_NaN());
+
+     return false;
+  }
+  const float crossNorm = cross.stableNorm();
+
+  // Checking for collinearity here
+  if (crossNorm < Eigen::NumTraits<float>::dummy_precision ())
+  {
+    PCL_ERROR ("[pcl::SampleConsensusModelPlane::computeModelCoefficients] Chosen samples are collinear!\n");
+    return (false);
+  }
+
+  // Compute the plane coefficients from the 3 given points in a straightforward manner
+  // calculate the plane normal n = (p2-p1) x (p3-p1) = cross (p2-p1, p3-p1)
+  model_coefficients.resize (model_size_);
+  model_coefficients.template head<3>() = cross / crossNorm;
+
+  // ... + d = 0
+  model_coefficients[3] = -1.0f * (model_coefficients.template head<3>().dot (p0));
+  /*
+  std::cout << "samples=" << samples[0] << "," << samples[1] << "," << samples[2] << "\n";
+
+  pcl::Array4fMapConst p0 = (*input_)[samples[0]].getArray4fMap ();
+  pcl::Array4fMapConst p1 = (*input_)[samples[1]].getArray4fMap ();
+  pcl::Array4fMapConst p2 = (*input_)[samples[2]].getArray4fMap ();
+
+  //std::cout << "p0=" << p0[0] << "," << p0[1] << "," << p0[2] << "\n";
+  //std::cout << "p1=" << p1[0] << "," << p1[1] << "," << p1[2] << "\n";
+  //std::cout << "p2=" << p2[0] << "," << p2[1] << "," << p2[2] << "\n";
+
+  // Compute the segment values (in 3d) between p1 and p0
+  Eigen::Array4f p1p0 = p1 - p0;
+  // Compute the segment values (in 3d) between p2 and p0
+  Eigen::Array4f p2p0 = p2 - p0;
+
+  // Avoid some crashes by checking for collinearity here
+  Eigen::Array4f dy1dy2 = p1p0 / p2p0;
+
+//   std::cout << "dy1dy2=" << dy1dy2[0] << "," << dy1dy2[1] << "," << dy1dy2[3] << "\n";
+  if ( (dy1dy2[0] == dy1dy2[1]) && (dy1dy2[2] == dy1dy2[1]) )          // Check for collinearity
+  {
+    return (false);
+  }
+
+  // Compute the plane coefficients from the 3 given points in a straightforward manner
+  // calculate the plane normal n = (p2-p1) x (p3-p1) = cross (p2-p1, p3-p1)
+  model_coefficients.resize (model_size_);
+  model_coefficients[0] = p1p0[1] * p2p0[2] - p1p0[2] * p2p0[1];
+  model_coefficients[1] = p1p0[2] * p2p0[0] - p1p0[0] * p2p0[2];
+  model_coefficients[2] = p1p0[0] * p2p0[1] - p1p0[1] * p2p0[0];
+  model_coefficients[3] = 0.0f;
+
+  // Normalize
+  model_coefficients.normalize ();
+
+  // ... + d = 0
+  model_coefficients[3] = -1.0f * (model_coefficients.template head<4>().dot (p0.matrix ()));
+  */
+
+  PCL_DEBUG ("[pcl::oneapi::SampleConsensusModelPlane::computeModelCoefficients] Model is (%g,%g,%g,%g).\n",
+             model_coefficients[0], model_coefficients[1], model_coefficients[2], model_coefficients[3]);
+  return (true);
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SampleConsensusModelPlane<PointT>::getDistancesToModel (
+      const Eigen::VectorXf &model_coefficients, std::vector<double> &distances) const
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::getDistancesToModel] Given model is invalid!\n");
+    return;
+  }
+
+  distances.resize (indices_->size ());
+
+  // Iterate through the 3d points and calculate the distances from them to the plane
+  for (std::size_t i = 0; i < indices_->size (); ++i)
+  {
+    // Calculate the distance from the point to the plane normal as the dot product
+    // D = (P-A).N/|N|
+    /*distances[i] = std::abs (model_coefficients[0] * (*input_)[(*indices_)[i]].x +
+                         model_coefficients[1] * (*input_)[(*indices_)[i]].y +
+                         model_coefficients[2] * (*input_)[(*indices_)[i]].z +
+                         model_coefficients[3]);*/
+    Eigen::Vector4f pt ((*input_)[(*indices_)[i]].x,
+                        (*input_)[(*indices_)[i]].y,
+                        (*input_)[(*indices_)[i]].z,
+                        1.0f);
+    distances[i] = std::abs (model_coefficients.dot (pt));
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SampleConsensusModelPlane<PointT>::selectWithinDistance (
+      const Eigen::VectorXf &model_coefficients, const double threshold, IndicesDev &inliers)
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::selectWithinDistance] Given model is invalid!\n");
+    return;
+  }
+
+  inliers.clear();
+  error_sqr_dists_.clear ();
+
+  sycl::float4 coefficients;
+  coefficients.x() = model_coefficients[0];
+  coefficients.y() = model_coefficients[1];
+  coefficients.z() = model_coefficients[2];
+  coefficients.w() = model_coefficients[3];
+
+  const int total_size = input_->size();
+  const int BZ = 128;
+  const int thread_num = (total_size + BZ - 1) / BZ;
+
+  DeviceArray<std::size_t> counter_buffer (1);
+  counter_buffer[0] = 0;
+
+  DeviceArray<int> indices_out (indices_->size());
+  DeviceArray<float> err_sqr_dists_out (indices_->size());
+
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+    auto input_ptr = input_->points.ptr();
+    auto indices_ptr = indices_->ptr();
+    auto counter_ptr = counter_buffer.ptr();
+    float threshold_float = (float) threshold;
+    auto indices_out_ptr = indices_out.ptr();
+    auto err_sqr_dists_out_ptr = err_sqr_dists_out.ptr();
+
+    h.parallel_for(thread_num, [=](auto & i) {
+
+      int process_element =  ((i + 1) * BZ < total_size) ? BZ : (total_size - i * BZ);
+
+      for (int index = 0; index < process_element; index++)
+      {
+        auto current_idx = i * BZ + index;
+        sycl::float4 pt (input_ptr[indices_ptr[current_idx]].x,
+                         input_ptr[indices_ptr[current_idx]].y,
+                         input_ptr[indices_ptr[current_idx]].z,
+                         1.0f);
+        float distance = sycl::fabs(sycl::dot(pt, coefficients));
+        if (distance < threshold_float)
+        {
+          sycl::atomic_ref<size_t, sycl::memory_order::relaxed, sycl::memory_scope::system,
+                       sycl::access::address_space::global_space> counter(counter_ptr[0]);
+          auto out_idx = counter.fetch_add(1);
+          indices_out_ptr[out_idx] = current_idx;
+          err_sqr_dists_out_ptr[out_idx] = distance;
+        }
+      }
+    });
+  }).wait();
+
+  const auto total_inliers = counter_buffer[0];
+  inliers.resize(total_inliers);
+  inliers.upload(indices_out.ptr(), total_inliers);
+
+  error_sqr_dists_.resize(total_inliers);
+  err_sqr_dists_out.download(error_sqr_dists_.data(), 0, total_inliers);
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> inline void
+SampleConsensusModelPlane<PointT>::countWithinDistance (
+      const Eigen::VectorXf &model_coefficients, const double threshold,
+      DeviceArray<std::size_t>& inlier_count_buffer) const
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::countWithinDistance] Given model is invalid!\n");
+    inlier_count_buffer[0] = 0;
+    return;
+  }
+
+  sycl::float4 coefficients;
+  coefficients.x() = model_coefficients[0];
+  coefficients.y() = model_coefficients[1];
+  coefficients.z() = model_coefficients[2];
+  coefficients.w() = model_coefficients[3];
+
+  inlier_count_buffer[0] = 0;
+
+  const int total_size = input_->size();
+
+#if 1
+  const int BZ = 128;
+  const int thread_num = (total_size + BZ - 1) / BZ;
+
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+    auto input_ptr = input_->points.ptr();
+    auto indices_ptr = indices_->ptr();
+    auto counter_ptr = inlier_count_buffer.ptr();
+    float threshold_float = (float) threshold;
+
+    h.parallel_for(thread_num, [=](auto & i) {
+
+      int sum = 0;
+      int process_element =  ((i + 1) * BZ < total_size) ? BZ : (total_size - i * BZ);
+
+      for (int index = 0; index < process_element; index++)
+      {
+        sycl::float4 pt (input_ptr[indices_ptr[i*BZ+index]].x,
+                         input_ptr[indices_ptr[i*BZ+index]].y,
+                         input_ptr[indices_ptr[i*BZ+index]].z,
+                         1.0f);
+        sum += sycl::fabs(sycl::dot(pt, coefficients)) < threshold_float;
+      }
+
+      sycl::atomic_ref<size_t, sycl::memory_order::relaxed, sycl::memory_scope::system,
+                       sycl::access::address_space::global_space> counter(counter_ptr[0]);
+      counter.fetch_add(sum);
+    });
+  }).wait();
+
+#else
+  const int BZ = 128;
+  const int ITEMS_PER_THREAD = 2;
+  const size_t thread_num = align(align(total_size, BZ), ITEMS_PER_THREAD);
+  sycl::range global { thread_num };
+  sycl::range local { BZ };
+
+  dpct::get_default_queue().submit([&](sycl::handler &h) {
+    auto input_ptr = input_->points.ptr();
+    auto indices_ptr = indices_->ptr();
+    auto counter_ptr = inlier_count_buffer.ptr();
+    float threshold_float = (float) threshold;
+
+    h.parallel_for(sycl::nd_range<1>(global, local),
+      sycl::reduction(counter_ptr, sycl::plus<>()),
+      [=](sycl::nd_item<1> it, auto &counter_ptr)  [[intel::reqd_sub_group_size(16)]]  {
+
+        auto i = it.get_global_linear_id();
+
+        int process_element =  ((i + 1) * ITEMS_PER_THREAD < total_size) ?
+                              ITEMS_PER_THREAD :  (total_size - i *  ITEMS_PER_THREAD);
+        int sum = 0;
+        for (int ii = 0; ii < process_element; ii++)
+        {
+          sycl::float4 pt (input_ptr[indices_ptr[i * ITEMS_PER_THREAD +ii]].x,
+                           input_ptr[indices_ptr[i * ITEMS_PER_THREAD +ii]].y,
+                           input_ptr[indices_ptr[i * ITEMS_PER_THREAD +ii]].z,
+                           1.0f);
+          sum += sycl::fabs(sycl::dot(pt, coefficients)) < threshold_float;
+        }
+        counter_ptr += sum;
+    });
+  }).wait();
+
+#endif
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SampleConsensusModelPlane<PointT>::optimizeModelCoefficients (
+      const IndicesDev &inliers, const Eigen::VectorXf &model_coefficients, Eigen::VectorXf &optimized_coefficients) const
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::optimizeModelCoefficients] Given model is invalid!\n");
+    optimized_coefficients = model_coefficients;
+    return;
+  }
+
+  // Need more than the minimum sample size to make a difference
+  if (inliers.size () <= sample_size_)
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::optimizeModelCoefficients] Not enough inliers found to optimize model coefficients (%lu)! Returning the same coefficients.\n", inliers.size ());
+    optimized_coefficients = model_coefficients;
+    return;
+  }
+
+  Eigen::Vector4f plane_parameters;
+
+  // Use Least-Squares to fit the plane through all the given sample points and find out its coefficients
+  EIGEN_ALIGN16 Eigen::Matrix3f covariance_matrix;
+  Eigen::Vector4f xyz_centroid;
+
+  computeMeanAndCovarianceMatrix (*input_, inliers, covariance_matrix, xyz_centroid);
+
+  // Compute the model coefficients
+  EIGEN_ALIGN16 Eigen::Vector3f::Scalar eigen_value;
+  EIGEN_ALIGN16 Eigen::Vector3f eigen_vector;
+  pcl::eigen33 (covariance_matrix, eigen_value, eigen_vector);
+
+  // Hessian form (D = nc . p_plane (centroid here) + p)
+  optimized_coefficients.resize (model_size_);
+  optimized_coefficients[0] = eigen_vector [0];
+  optimized_coefficients[1] = eigen_vector [1];
+  optimized_coefficients[2] = eigen_vector [2];
+  optimized_coefficients[3] = 0.0f;
+  optimized_coefficients[3] = -1.0f * optimized_coefficients.dot (xyz_centroid);
+
+  // Make sure it results in a valid model
+  if (!isModelValid (optimized_coefficients))
+  {
+    optimized_coefficients = model_coefficients;
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SampleConsensusModelPlane<PointT>::projectPoints (
+      const IndicesDev &inliers, const Eigen::VectorXf &model_coefficients, PointCloudDev &projected_points, bool copy_data_fields) const
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::projectPoints] Given model is invalid!\n");
+    return;
+  }
+
+  projected_points.header = input_->header;
+  projected_points.is_dense = input_->is_dense;
+
+  Eigen::Vector4f mc (model_coefficients[0], model_coefficients[1], model_coefficients[2], 0.0f);
+
+  // normalize the vector perpendicular to the plane...
+  mc.normalize ();
+  // ... and store the resulting normal as a local copy of the model coefficients
+  Eigen::Vector4f tmp_mc = model_coefficients;
+  tmp_mc[0] = mc[0];
+  tmp_mc[1] = mc[1];
+  tmp_mc[2] = mc[2];
+
+  // Copy all the data fields from the input cloud to the projected one?
+  // TODO create sycl kernel for this
+  if (copy_data_fields)
+  {
+    // Allocate enough space and copy the basics
+    projected_points.resize (input_->size ());
+    projected_points.width    = input_->width;
+    projected_points.height   = input_->height;
+
+    using FieldList = typename pcl::traits::fieldList<PointT>::type;
+    // Iterate over each point
+    for (std::size_t i = 0; i < input_->size (); ++i)
+      // Iterate over each dimension
+      pcl::for_each_type <FieldList> (NdConcatenateFunctor <PointT, PointT> ((*input_)[i], projected_points[i]));
+
+    // Iterate through the 3d points and calculate the distances from them to the plane
+    for (const auto &inlier : inliers)
+    {
+      // Calculate the distance from the point to the plane
+      Eigen::Vector4f p ((*input_)[inlier].x,
+                         (*input_)[inlier].y,
+                         (*input_)[inlier].z,
+                         1);
+      // use normalized coefficients to calculate the scalar projection
+      float distance_to_plane = tmp_mc.dot (p);
+
+      pcl::Vector4fMap pp = projected_points[inlier].getVector4fMap ();
+      pp.matrix () = p - mc * distance_to_plane;        // mc[3] = 0, therefore the 3rd coordinate is safe
+    }
+  }
+  else
+  {
+    // Allocate enough space and copy the basics
+    projected_points.resize (inliers.size ());
+    projected_points.width    = inliers.size ();
+    projected_points.height   = 1;
+
+    using FieldList = typename pcl::traits::fieldList<PointT>::type;
+    // Iterate over each point
+    for (std::size_t i = 0; i < inliers.size (); ++i)
+    {
+      // Iterate over each dimension
+      pcl::for_each_type <FieldList> (NdConcatenateFunctor <PointT, PointT> ((*input_)[inliers[i]], projected_points[i]));
+    }
+
+    // Iterate through the 3d points and calculate the distances from them to the plane
+    for (std::size_t i = 0; i < inliers.size (); ++i)
+    {
+      // Calculate the distance from the point to the plane
+      Eigen::Vector4f p ((*input_)[inliers[i]].x,
+                         (*input_)[inliers[i]].y,
+                         (*input_)[inliers[i]].z,
+                         1.0f);
+      // use normalized coefficients to calculate the scalar projection
+      float distance_to_plane = tmp_mc.dot (p);
+
+      pcl::Vector4fMap pp = projected_points[i].getVector4fMap ();
+      pp.matrix () = p - mc * distance_to_plane;        // mc[3] = 0, therefore the 3rd coordinate is safe
+    }
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+SampleConsensusModelPlane<PointT>::doSamplesVerifyModel (
+      const std::set<index_t> &indices, const Eigen::VectorXf &model_coefficients, const double threshold) const
+{
+  // Needs a valid set of model coefficients
+  if (!isModelValid (model_coefficients))
+  {
+    PCL_ERROR ("[pcl::oneapi::SampleConsensusModelPlane::doSamplesVerifyModel] Given model is invalid!\n");
+    return (false);
+  }
+
+  for (const auto &index : indices)
+  {
+    Eigen::Vector4f pt ((*input_)[index].x,
+                        (*input_)[index].y,
+                        (*input_)[index].z,
+                        1.0f);
+    if (std::abs (model_coefficients.dot (pt)) > threshold)
+    {
+      return (false);
+    }
+  }
+
+  return (true);
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+#define PCL_INSTANTIATE_SampleConsensusModelPlane(T) template class PCL_EXPORTS pcl::oneapi::SampleConsensusModelPlane<T>;
+
+#endif    // PCL_ONEAPI_SAMPLE_CONSENSUS_IMPL_SAC_MODEL_PLANE_H_
+
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/method_types.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/method_types.h
new file mode 100644
index 000000000..1b2e8a188
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/method_types.h
@@ -0,0 +1,58 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+namespace pcl
+{
+namespace oneapi
+{
+  const static int SAC_RANSAC  = 0;
+  //currently we support only SAC_RANSAC
+  /*
+    const static int SAC_LMEDS   = 1;
+    const static int SAC_MSAC    = 2;
+    const static int SAC_RRANSAC = 3;
+    const static int SAC_RMSAC   = 4;
+    const static int SAC_MLESAC  = 5;
+    const static int SAC_PROSAC  = 6;
+  */
+}
+}
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/model_types.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/model_types.h
new file mode 100644
index 000000000..45093d767
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/model_types.h
@@ -0,0 +1,72 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+namespace pcl
+{
+namespace oneapi
+{
+  enum SacModel
+  {
+    SACMODEL_PLANE,
+    //currently we support only PLANE model
+    /*
+    SACMODEL_LINE,
+    SACMODEL_CIRCLE2D,
+    SACMODEL_CIRCLE3D,
+    SACMODEL_SPHERE,
+    SACMODEL_CYLINDER,
+    SACMODEL_CONE,
+    SACMODEL_TORUS,
+    SACMODEL_PARALLEL_LINE,
+    SACMODEL_PERPENDICULAR_PLANE,
+    SACMODEL_PARALLEL_LINES,
+    SACMODEL_NORMAL_PLANE,
+    SACMODEL_NORMAL_SPHERE,
+    SACMODEL_REGISTRATION,
+    SACMODEL_REGISTRATION_2D,
+    SACMODEL_PARALLEL_PLANE,
+    SACMODEL_NORMAL_PARALLEL_PLANE,
+    SACMODEL_STICK
+    */
+  };
+}
+}
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/ransac.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/ransac.h
new file mode 100644
index 000000000..5cc4f608d
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/ransac.h
@@ -0,0 +1,114 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/sample_consensus/sac.h>
+#include <pcl/oneapi/sample_consensus/sac_model.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b RandomSampleConsensus represents an implementation of the RANSAC (RANdom SAmple Consensus) algorithm, as
+    * described in: "Random Sample Consensus: A Paradigm for Model Fitting with Applications to Image Analysis and
+    * Automated Cartography", Martin A. Fischler and Robert C. Bolles, Comm. Of the ACM 24: 381395, June 1981.
+    * A parallel variant is available, enable with setNumberOfThreads. Default is non-parallel.
+    *
+    * The algorithm works as follows:
+    * <ol>
+    *   <li> randomly select samples from the cloud, just as many as needed to determine a model
+    *   <li> compute the coefficients of the model from the samples
+    *   <li> count how many points of the cloud belong to the model, given a threshold. These are called inliers
+    *   <li> repeat until a good model has been found or a max number of iterations has been reached
+    *   <li> return the model with the most inliers
+    * </ol>
+    * \author Radu B. Rusu
+    * \ingroup sample_consensus
+    */
+  template <typename PointT>
+  class PCL_EXPORTS RandomSampleConsensus : public SampleConsensus<PointT>
+  {
+    using SampleConsensusModelPtr = typename SampleConsensusModel<PointT>::Ptr;
+
+    public:
+      using Ptr = shared_ptr<RandomSampleConsensus<PointT> >;
+      using ConstPtr = shared_ptr<const RandomSampleConsensus<PointT> >;
+
+      using SampleConsensus<PointT>::max_iterations_;
+      using SampleConsensus<PointT>::threshold_;
+      using SampleConsensus<PointT>::iterations_;
+      using SampleConsensus<PointT>::sac_model_;
+      using SampleConsensus<PointT>::model_;
+      using SampleConsensus<PointT>::model_coefficients_;
+      using SampleConsensus<PointT>::inliers_;
+      using SampleConsensus<PointT>::probability_;
+      using SampleConsensus<PointT>::threads_;
+
+      /** \brief RANSAC (RANdom SAmple Consensus) main constructor
+        * \param[in] model a Sample Consensus model
+        */
+      RandomSampleConsensus (const SampleConsensusModelPtr &model)
+        : SampleConsensus<PointT> (model)
+      {
+        // Maximum number of trials before we give up.
+        max_iterations_ = 10000;
+      }
+
+      /** \brief RANSAC (RANdom SAmple Consensus) main constructor
+        * \param[in] model a Sample Consensus model
+        * \param[in] threshold distance to model threshold
+        */
+      RandomSampleConsensus (const SampleConsensusModelPtr &model, double threshold)
+        : SampleConsensus<PointT> (model, threshold)
+      {
+        // Maximum number of trials before we give up.
+        max_iterations_ = 10000;
+      }
+
+      /** \brief Compute the actual model and find the inliers
+        * \param[in] debug_verbosity_level enable/disable on-screen debug information and set the verbosity level
+        */
+      bool
+      computeModel (int debug_verbosity_level = 0) override;
+  };
+} // namespace oneapi
+} // namespace pcl
+  //
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/sample_consensus/impl/ransac.hpp>
+#endif
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac.h
new file mode 100644
index 000000000..1a2bd30e1
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac.h
@@ -0,0 +1,366 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/pcl_base.h>
+#include <pcl/oneapi/sample_consensus/sac_model.h>
+#include <cfloat>
+
+#include <boost/random/mersenne_twister.hpp> // for mt19937
+#include <boost/random/uniform_01.hpp> // for uniform_01
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief SampleConsensus represents the base class. All sample consensus methods must inherit from this class.
+    * \author Radu Bogdan Rusu
+    * \ingroup sample_consensus
+    */
+  template <typename T>
+  class SampleConsensus
+  {
+    using SampleConsensusModelPtr = typename SampleConsensusModel<T>::Ptr;
+
+    private:
+      /** \brief Constructor for base SAC. */
+      SampleConsensus () {};
+
+    public:
+      using Ptr = shared_ptr<SampleConsensus<T> >;
+      using ConstPtr = shared_ptr<const SampleConsensus<T> >;
+
+
+      /** \brief Constructor for base SAC.
+        * \param[in] model a Sample Consensus model
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensus (const SampleConsensusModelPtr &model, bool random = false)
+        : sac_model_ (model)
+        , probability_ (0.99)
+        , iterations_ (0)
+        , threshold_ (std::numeric_limits<double>::max ())
+        , max_iterations_ (1000)
+        , threads_ (-1)
+        , rng_ (new boost::uniform_01<boost::mt19937> (rng_alg_))
+      {
+         // Create a random number generator object
+         if (random)
+           rng_->base ().seed (static_cast<unsigned> (std::time (nullptr)));
+         else
+           rng_->base ().seed (12345u);
+      };
+
+      /** \brief Constructor for base SAC.
+        * \param[in] model a Sample Consensus model
+        * \param[in] threshold distance to model threshold
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensus (const SampleConsensusModelPtr &model,
+                       double threshold,
+                       bool random = false)
+        : sac_model_ (model)
+        , probability_ (0.99)
+        , iterations_ (0)
+        , threshold_ (threshold)
+        , max_iterations_ (1000)
+        , threads_ (-1)
+        , rng_ (new boost::uniform_01<boost::mt19937> (rng_alg_))
+      {
+         // Create a random number generator object
+         if (random)
+           rng_->base ().seed (static_cast<unsigned> (std::time (nullptr)));
+         else
+           rng_->base ().seed (12345u);
+      };
+
+      /** \brief Set the Sample Consensus model to use.
+        * \param[in] model a Sample Consensus model
+        */
+      void
+      setSampleConsensusModel (const SampleConsensusModelPtr &model)
+      {
+        sac_model_ = model;
+      }
+
+      /** \brief Get the Sample Consensus model used. */
+      SampleConsensusModelPtr
+      getSampleConsensusModel () const
+      {
+        return (sac_model_);
+      }
+
+      /** \brief Destructor for base SAC. */
+      virtual ~SampleConsensus () {};
+
+      /** \brief Set the distance to model threshold.
+        * \param[in] threshold distance to model threshold
+        */
+      inline void
+      setDistanceThreshold (double threshold)  { threshold_ = threshold; }
+
+      /** \brief Get the distance to model threshold, as set by the user. */
+      inline double
+      getDistanceThreshold () const { return (threshold_); }
+
+      /** \brief Set the maximum number of iterations.
+        * \param[in] max_iterations maximum number of iterations
+        */
+      inline void
+      setMaxIterations (int max_iterations) { max_iterations_ = max_iterations; }
+
+      /** \brief Get the maximum number of iterations, as set by the user. */
+      inline int
+      getMaxIterations () const { return (max_iterations_); }
+
+      /** \brief Set the desired probability of choosing at least one sample free from outliers.
+        * \param[in] probability the desired probability of choosing at least one sample free from outliers
+        * \note internally, the probability is set to 99% (0.99) by default.
+        */
+      inline void
+      setProbability (double probability) { probability_ = probability; }
+
+      /** \brief Obtain the probability of choosing at least one sample free from outliers, as set by the user. */
+      inline double
+      getProbability () const { return (probability_); }
+
+      /** \brief Set the number of threads to use or turn off parallelization.
+        * \param[in] nr_threads the number of hardware threads to use (0 sets the value automatically, a negative number turns parallelization off)
+        * \note Not all SAC methods have a parallel implementation. Some will ignore this setting.
+        */
+      inline void
+      setNumberOfThreads (const int nr_threads = -1) { threads_ = nr_threads; }
+
+      /** \brief Get the number of threads, as set by the user. */
+      inline int
+      getNumberOfThreads () const { return (threads_); }
+
+      /** \brief Compute the actual model. Pure virtual. */
+      virtual bool
+      computeModel (int debug_verbosity_level = 0) = 0;
+
+      /** \brief Refine the model found.
+        * This loops over the model coefficients and optimizes them together
+        * with the set of inliers, until the change in the set of inliers is
+        * minimal.
+        * \param[in] sigma standard deviation multiplier for considering a sample as inlier (Mahalanobis distance)
+        * \param[in] max_iterations the maxim number of iterations to try to refine in case the inliers keep on changing
+        */
+      virtual bool
+      refineModel (const double sigma = 3.0, const unsigned int max_iterations = 1000)
+      {
+        if (!sac_model_)
+        {
+          PCL_ERROR ("[pcl::SampleConsensus::refineModel] Critical error: NULL model!\n");
+          return (false);
+        }
+
+        double inlier_distance_threshold_sqr = threshold_ * threshold_,
+               error_threshold = threshold_;
+        double sigma_sqr = sigma * sigma;
+        unsigned int refine_iterations = 0;
+        bool inlier_changed = false, oscillating = false;
+        IndicesDev new_inliers, prev_inliers = inliers_;
+        std::vector<std::size_t> inliers_sizes;
+        Eigen::VectorXf new_model_coefficients = model_coefficients_;
+        do
+        {
+          // Optimize the model coefficients
+          sac_model_->optimizeModelCoefficients (prev_inliers, new_model_coefficients, new_model_coefficients);
+          inliers_sizes.push_back (prev_inliers.size ());
+
+          // Select the new inliers based on the optimized coefficients and new threshold
+          sac_model_->selectWithinDistance (new_model_coefficients, error_threshold, new_inliers);
+          PCL_DEBUG ("[pcl::SampleConsensus::refineModel] Number of inliers found (before/after): %lu/%lu, with an error threshold of %g.\n", prev_inliers.size (), new_inliers.size (), error_threshold);
+          if (new_inliers.empty ())
+          {
+            refine_iterations++;
+            if (refine_iterations >= max_iterations)
+              break;
+            continue;
+            //return (false);
+          }
+
+          // Estimate the variance and the new threshold
+          double variance = sac_model_->computeVariance ();
+          error_threshold = sqrt (std::min (inlier_distance_threshold_sqr, sigma_sqr * variance));
+
+          PCL_DEBUG ("[pcl::SampleConsensus::refineModel] New estimated error threshold: %g on iteration %d out of %d.\n", error_threshold, refine_iterations, max_iterations);
+          inlier_changed = false;
+          std::swap (prev_inliers, new_inliers);
+          // If the number of inliers changed, then we are still optimizing
+          if (new_inliers.size () != prev_inliers.size ())
+          {
+            // Check if the number of inliers is oscillating in between two values
+            if (inliers_sizes.size () >= 4)
+            {
+              if (inliers_sizes[inliers_sizes.size () - 1] == inliers_sizes[inliers_sizes.size () - 3] &&
+                  inliers_sizes[inliers_sizes.size () - 2] == inliers_sizes[inliers_sizes.size () - 4])
+              {
+                oscillating = true;
+                break;
+              }
+            }
+            inlier_changed = true;
+            continue;
+          }
+
+          // Check the values of the inlier set
+          for (std::size_t i = 0; i < prev_inliers.size (); ++i)
+          {
+            // If the value of the inliers changed, then we are still optimizing
+            if (prev_inliers[i] != new_inliers[i])
+            {
+              inlier_changed = true;
+              break;
+            }
+          }
+        }
+        while (inlier_changed && ++refine_iterations < max_iterations);
+
+        // If the new set of inliers is empty, we didn't do a good job refining
+        if (new_inliers.empty ())
+        {
+          PCL_ERROR ("[pcl::SampleConsensus::refineModel] Refinement failed: got an empty set of inliers!\n");
+          return (false);
+        }
+
+        if (oscillating)
+        {
+          PCL_DEBUG ("[pcl::SampleConsensus::refineModel] Detected oscillations in the model refinement.\n");
+          return (true);
+        }
+
+        // If no inliers have been changed anymore, then the refinement was successful
+        if (!inlier_changed)
+        {
+          std::swap (inliers_, new_inliers);
+          model_coefficients_ = new_model_coefficients;
+          return (true);
+        }
+        return (false);
+      }
+
+      /** \brief Get a set of randomly selected indices.
+        * \param[in] indices the input indices vector
+        * \param[in] nr_samples the desired number of point indices to randomly select
+        * \param[out] indices_subset the resultant output set of randomly selected indices
+        */
+      inline void
+      getRandomSamples (const IndicesPtr &indices,
+                        std::size_t nr_samples,
+                        std::set<index_t> &indices_subset)
+      {
+        indices_subset.clear ();
+        while (indices_subset.size () < nr_samples)
+          //indices_subset.insert ((*indices)[(index_t) (indices->size () * (rand () / (RAND_MAX + 1.0)))]);
+          indices_subset.insert ((*indices)[static_cast<index_t> (static_cast<double>(indices->size ()) * rnd ())]);
+      }
+
+      /** \brief Return the best model found so far.
+        * \param[out] model the resultant model
+        */
+      inline void
+      getModel (IndicesDev &model) const { model = model_; }
+
+      /** \brief Return the best set of inliers found so far for this model.
+        * \param[out] inliers the resultant set of inliers
+        */
+      inline void
+      getInliers (IndicesDev &inliers) const { inliers = inliers_; }
+
+      /** \brief Return the best set of inliers found so far for this model.
+        * \param[out] inliers the resultant set of inliers
+        */
+      inline void
+      getInliers (Indices &inliers) const
+      {
+        inliers.resize(inliers_.size());
+        inliers_.download(inliers.data(), 0, inliers_.size());
+      }
+
+      /** \brief Return the model coefficients of the best model found so far.
+        * \param[out] model_coefficients the resultant model coefficients, as documented in \ref sample_consensus
+        */
+      inline void
+      getModelCoefficients (Eigen::VectorXf &model_coefficients) const { model_coefficients = model_coefficients_; }
+
+    protected:
+      /** \brief The underlying data model used (i.e. what is it that we attempt to search for). */
+      SampleConsensusModelPtr sac_model_;
+
+      /** \brief The model found after the last computeModel () as point cloud indices. */
+      IndicesDev model_;
+
+      /** \brief The indices of the points that were chosen as inliers after the last computeModel () call. */
+      IndicesDev inliers_;
+
+      /** \brief The coefficients of our model computed directly from the model found. */
+      Eigen::VectorXf model_coefficients_;
+
+      /** \brief Desired probability of choosing at least one sample free from outliers. */
+      double probability_;
+
+      /** \brief Total number of internal loop iterations that we've done so far. */
+      int iterations_;
+
+      /** \brief Distance to model threshold. */
+      double threshold_;
+
+      /** \brief Maximum number of iterations before giving up. */
+      int max_iterations_;
+
+      /** \brief The number of threads the scheduler should use, or a negative number if no parallelization is wanted. */
+      int threads_;
+
+      /** \brief Boost-based random number generator algorithm. */
+      boost::mt19937 rng_alg_;
+
+      /** \brief Boost-based random number generator distribution. */
+      std::shared_ptr<boost::uniform_01<boost::mt19937> > rng_;
+
+      /** \brief Boost-based random number generator. */
+      inline double
+      rnd ()
+      {
+        return ((*rng_) ());
+      }
+   };
+
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model.h
new file mode 100644
index 000000000..d62684da6
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model.h
@@ -0,0 +1,693 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/oneapi/pcl_base.h>
+#include <pcl/oneapi/sample_consensus/model_types.h>
+#include <boost/random/mersenne_twister.hpp> // for mt19937
+#include <boost/random/uniform_int.hpp> // for uniform_int
+#include <boost/random/variate_generator.hpp> // for variate_generator
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b SampleConsensusModel represents the base model class. All sample consensus models must inherit from
+    * this class.
+    */
+  template <typename PointT>
+  class PCL_EXPORTS SampleConsensusModel
+  {
+    public:
+
+      using PointCloud = pcl::PointCloud<PointT>;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+      using PointCloudPtr = typename PointCloud::Ptr;
+
+      using PointCloudDev = pcl::oneapi::PointCloudDev<PointT>;
+      using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+      using PointCloudDevPtr = typename PointCloudDev::Ptr;
+
+      using Ptr = shared_ptr<SampleConsensusModel<PointT> >;
+      using ConstPtr = shared_ptr<const SampleConsensusModel<PointT> >;
+
+      /*
+      using Indices = typename pcl::oneapi::DeviceArray<int>;
+      using IndicesPtr = shared_ptr<typename pcl::oneapi::DeviceArray<int>>;
+      using IndicesConstPtr = shared_ptr<const typename pcl::oneapi::DeviceArray<int>>;
+
+      using Coefficients = typename pcl::oneapi::DeviceArray<float>;
+      using CoefficientsPtr = shared_ptr <Coefficients>;
+      using CoefficientsConstPtr = shared_ptr <const Coefficients>;
+
+      //TODO: should be std::vector<int> instead of int. but currently, only 1point plane model supports this
+      using Samples = typename pcl::oneapi::DeviceArray<int>;
+      */
+    protected:
+      SampleConsensusModel (bool random = false)
+        : input_ ()
+        , radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.)
+        , rng_dist_ (new boost::uniform_int<> (0, std::numeric_limits<int>::max ()))
+        , custom_model_constraints_ ([](auto){return true;})
+        {
+          // Create a random number generator object
+          if (random)
+            rng_alg_.seed (static_cast<unsigned> (std::time(nullptr)));
+          else
+            rng_alg_.seed (12345u);
+
+          rng_gen_.reset (new boost::variate_generator<boost::mt19937&, boost::uniform_int<> > (rng_alg_, *rng_dist_)); 
+        }
+
+
+      /** \brief Empty constructor for base SampleConsensusModel. */
+      /*
+      SampleConsensusModel () : radius_min_ (-FLT_MAX), radius_max_ (FLT_MAX), cloud_(nullptr), block_size(16)
+      {};
+      */
+
+    public:
+      /** \brief Constructor for base SampleConsensusModel.
+        * \param[in] cloud the input point cloud dataset
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensusModel (const PointCloudConstPtr &cloud, bool random = false)
+        : radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.)
+        , rng_dist_ (new boost::uniform_int<> (0, std::numeric_limits<int>::max ()))
+        , custom_model_constraints_ ([](auto){return true;})
+      {
+        input_ = std::make_shared<PointCloudDev>(cloud);
+        if (random)
+          rng_alg_.seed (static_cast<unsigned> (std::time (nullptr)));
+        else
+          rng_alg_.seed (12345u);
+
+        // Sets the input cloud and creates a vector of "fake" indices
+        setInputCloud (input_);
+
+        // Create a random number generator object
+        rng_gen_.reset (new boost::variate_generator<boost::mt19937&, boost::uniform_int<> > (rng_alg_, *rng_dist_));
+      }
+
+      /** \brief Constructor for base SampleConsensusModel.
+        * \param[in] cloud the input point cloud dataset
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensusModel (const PointCloudDevConstPtr &cloud, bool random = false)
+        : input_ (cloud)
+        , radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.)
+        , rng_dist_ (new boost::uniform_int<> (0, std::numeric_limits<int>::max ()))
+        , custom_model_constraints_ ([](auto){return true;})
+      {
+        if (random)
+          rng_alg_.seed (static_cast<unsigned> (std::time (nullptr)));
+        else
+          rng_alg_.seed (12345u);
+
+        // Sets the input cloud and creates a vector of "fake" indices
+        setInputCloud (input_);
+
+        // Create a random number generator object
+        rng_gen_.reset (new boost::variate_generator<boost::mt19937&, boost::uniform_int<> > (rng_alg_, *rng_dist_));
+      }
+
+      /** \brief Constructor for base SampleConsensusModel.
+        * \param[in] cloud the input point cloud dataset
+        * \param[in] indices a vector of point indices to be used from \a cloud
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensusModel (const PointCloudConstPtr &cloud,
+                        const Indices &indices,
+                        bool random = false)
+        : radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.)
+        , rng_dist_ (new boost::uniform_int<> (0, std::numeric_limits<int>::max ()))
+        , custom_model_constraints_ ([](auto){return true;})
+      {
+        input_ = std::make_shared<PointCloudDev>(cloud);
+        indices_ = std::make_shared<IndicesDev>(indices.data(), indices.size());
+        if (random)
+          rng_alg_.seed (static_cast<unsigned> (std::time(nullptr)));
+        else
+          rng_alg_.seed (12345u);
+
+        if (indices_->size () > input_->size ())
+        {
+          PCL_ERROR("[pcl::oneapi::SampleConsensusModel] Invalid index vector given with size "
+              "%zu while the input PointCloud has size %zu!\n",
+              indices_->size(),
+              static_cast<std::size_t>(input_->size()));
+          indices_->clear ();
+        }
+        shuffled_indices_ = *indices_;
+
+        // Create a random number generator object
+        rng_gen_.reset (new boost::variate_generator<boost::mt19937&, boost::uniform_int<> > (rng_alg_, *rng_dist_));
+      };
+
+      /** \brief Constructor for base SampleConsensusModel.
+        * \param[in] cloud the input point cloud dataset
+        * \param[in] indices a vector of point indices to be used from \a cloud
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SampleConsensusModel (const PointCloudDevConstPtr &cloud,
+                        const IndicesDev &indices,
+                        bool random = false)
+        : input_ (cloud)
+        , indices_ (std::make_shared<IndicesDev>(indices))
+        , radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.)
+        , rng_dist_ (new boost::uniform_int<> (0, std::numeric_limits<int>::max ()))
+        , custom_model_constraints_ ([](auto){return true;})
+      {
+        if (random)
+          rng_alg_.seed (static_cast<unsigned> (std::time(nullptr)));
+        else
+          rng_alg_.seed (12345u);
+
+        if (indices_->size () > input_->size ())
+        {
+          PCL_ERROR("[pcl::oneapi::SampleConsensusModel] Invalid index vector given with size "
+              "%zu while the input PointCloud has size %zu!\n",
+              indices_->size(),
+              static_cast<std::size_t>(input_->size()));
+          indices_->clear ();
+        }
+//        shuffled_indices_ = indices;
+        indices.copyTo(shuffled_indices_);
+
+        // Create a random number generator object
+        rng_gen_.reset (new boost::variate_generator<boost::mt19937&, boost::uniform_int<> > (rng_alg_, *rng_dist_));
+      };
+
+
+      /** \brief Destructor for base SampleConsensusModel. */
+      virtual ~SampleConsensusModel () {};
+
+      /** \brief Get a set of random data samples and return them as point
+        * indices. Pure virtual.
+        * \param samples the resultant model samples, <b>stored on the device</b>
+        */
+      virtual void
+      getSamples (int &iterations, IndicesDev &samples)
+      {
+        // We're assuming that indices_ have already been set in the constructor
+        if (indices_->size () < getSampleSize ())
+        {
+          PCL_ERROR ("[pcl::oneapi::SampleConsensusModel::getSamples] Can not select %lu unique points out of %lu!\n",
+                 samples.size (), indices_->size ());
+          // one of these will make it stop :)
+          samples.clear ();
+          iterations = INT_MAX - 1;
+          return;
+        }
+
+        // Get a second point which is different than the first
+        samples.resize (getSampleSize ());
+        for (unsigned int iter = 0; iter < max_sample_checks_; ++iter)
+        {
+          // Choose the random indices
+          if (samples_radius_ < std::numeric_limits<double>::epsilon ())
+            SampleConsensusModel<PointT>::drawIndexSample (samples);
+          else
+            SampleConsensusModel<PointT>::drawIndexSampleRadius (samples);
+
+          // If it's a good sample, stop here
+          if (isSampleGood (samples))
+          {
+            PCL_DEBUG ("[pcl::oneapi::SampleConsensusModel::getSamples] Selected %lu samples.\n", samples.size ());
+            return;
+          }
+        }
+        PCL_DEBUG ("[pcl::oneapi::SampleConsensusModel::getSamples] WARNING: Could not select %d sample points in %d iterations!\n", getSampleSize (), max_sample_checks_);
+        samples.clear ();
+      }
+
+      /** \brief Check whether the given index samples can form a valid model,
+        * compute the model coefficients from these samples and store them
+        * in model_coefficients. Pure virtual.
+        * Implementations of this function must be thread-safe.
+        * \param[in] samples the point indices found as possible good candidates
+        * for creating a valid model
+        * \param[out] model_coefficients the computed model coefficients
+        */
+      virtual bool
+      computeModelCoefficients (const IndicesDev &samples,
+                                Eigen::VectorXf &model_coefficients) const = 0;
+
+      /** \brief Recompute the model coefficients using the given inlier set
+        * and return them to the user. Pure virtual.
+        *
+        * @note: these are the coefficients of the model after refinement
+        * (e.g., after a least-squares optimization)
+        *
+        * \param[in] inliers the data inliers supporting the model
+        * \param[in] model_coefficients the initial guess for the model coefficients
+        * \param[out] optimized_coefficients the resultant recomputed coefficients after non-linear optimization
+        */
+      virtual void
+      optimizeModelCoefficients (const IndicesDev &inliers,
+                                 const Eigen::VectorXf &model_coefficients,
+                                 Eigen::VectorXf &optimized_coefficients) const = 0;
+
+      /** \brief Compute all distances from the cloud data to a given model. Pure virtual.
+        *
+        * \param[in] model_coefficients the coefficients of a model that we need to compute distances to
+        * \param[out] distances the resultant estimated distances
+        */
+      virtual void
+      getDistancesToModel (const Eigen::VectorXf &model_coefficients,
+                           std::vector<double> &distances) const = 0;
+
+      /** \brief Select all the points which respect the given model
+        * coefficients as inliers. Pure virtual.
+        *
+        * \param[in] model_coefficients the coefficients of a model that we need to compute distances to
+        * \param[in] threshold a maximum admissible distance threshold for determining the inliers from
+        * the outliers
+        * \param[out] inliers the resultant model inliers
+        */
+      virtual void
+      selectWithinDistance (const Eigen::VectorXf &model_coefficients,
+                            const double threshold,
+                            IndicesDev &inliers) = 0;
+
+      /** \brief Count all the points which respect the given model
+        * coefficients as inliers. Pure virtual.
+        * Implementations of this function must be thread-safe.
+        * \param[in] model_coefficients the coefficients of a model that we need to
+        * compute distances to
+        * \param[in] threshold a maximum admissible distance threshold for
+        * determining the inliers from the outliers
+        * \return the resultant number of inliers
+        */
+      virtual void
+      countWithinDistance (const Eigen::VectorXf &model_coefficients,
+                           const double threshold, DeviceArray<size_t>& inlier_count) const = 0;
+
+      /** \brief Create a new point cloud with inliers projected onto the model. Pure virtual.
+        * \param[in] inliers the data inliers that we want to project on the model
+        * \param[in] model_coefficients the coefficients of a model
+        * \param[out] projected_points the resultant projected points
+        * \param[in] copy_data_fields set to true (default) if we want the \a
+        * projected_points cloud to be an exact copy of the input dataset minus
+        * the point projections on the plane model
+        */
+      virtual void
+      projectPoints (const IndicesDev &inliers,
+                     const Eigen::VectorXf &model_coefficients,
+                    PointCloudDev &projected_points,
+                    bool copy_data_fields = true) const = 0;
+
+      /** \brief Verify whether a subset of indices verifies a given set of
+        * model coefficients. Pure virtual.
+        *
+        * \param[in] indices the data indices that need to be tested against the model
+        * \param[in] model_coefficients the set of model coefficients
+        * \param[in] threshold a maximum admissible distance threshold for
+        * determining the inliers from the outliers
+        */
+      virtual bool
+      doSamplesVerifyModel (const std::set<index_t> &indices,
+                            const Eigen::VectorXf &model_coefficients,
+                            const double threshold) const = 0;
+
+      /** \brief Provide a pointer to the input dataset
+        * \param cloud the const boost shared pointer to a PointCloud message
+        */
+      inline virtual void
+      setInputCloud (const PointCloudDevConstPtr &cloud)
+      {
+        input_ = cloud;
+        if (!indices_)
+          indices_.reset (new IndicesDev ());
+        if (indices_->empty ())
+        {
+          // Prepare a set of indices to be used (entire cloud)
+          indices_->resize (cloud->size ());
+          std::iota(indices_->begin(), indices_->end(), 0);
+        }
+        shuffled_indices_ = *indices_;
+      }
+
+      /** \brief Get a pointer to the input point cloud dataset. */
+      inline PointCloudDevConstPtr
+      getInputCloud () const { return (input_); }
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the vector of indices that represents the input data.
+        */
+      inline void
+      setIndices (const IndicesPtr &indices)
+      {
+        indices_->resize(indices->size());
+        indices_->upload(indices->data(), indices->size());
+        shuffled_indices_ = *indices_;
+      }
+
+      /** \brief Provide the vector of indices that represents the input data.
+        * \param[out] indices the vector of indices that represents the input data.
+        */
+      inline void
+      setIndices (const Indices &indices)
+      {
+        indices_->resize(indices.size());
+        indices_->upload(indices.data(), indices.size());
+        shuffled_indices_ = *indices_;
+      }
+
+      /** \brief Provide a pointer to the vector of indices that represents the input data.
+        * \param[in] indices a pointer to the vector of indices that represents the input data.
+        */
+      inline void
+      setIndices (const IndicesDevPtr &indices)
+      {
+        indices_ = indices;
+        shuffled_indices_ = *indices_;
+      }
+
+      /** \brief Provide the vector of indices that represents the input data.
+        * \param[out] indices the vector of indices that represents the input data.
+        */
+      inline void
+      setIndices (const IndicesDev &indices)
+      {
+        indices_ = std::make_shared<IndicesDev>(indices);
+        shuffled_indices_ = *indices_;
+      }
+
+      /** \brief Get a pointer to the vector of indices used. */
+      inline IndicesPtr
+      getIndices () const
+      {
+        return std::make_shared<Indices>(indices_->begin(), indices_->end());
+      }
+
+      /** \brief Return a unique id for each type of model employed. */
+      virtual SacModel
+      getModelType () const = 0;
+
+      /** \brief Get a string representation of the name of this class. */
+      inline const std::string&
+      getClassName () const
+      {
+        return (model_name_);
+      }
+
+      /** \brief Return the size of a sample from which the model is computed. */
+      inline unsigned int
+      getSampleSize () const
+      {
+        return sample_size_;
+      }
+
+      /** \brief Return the number of coefficients in the model. */
+      inline unsigned int
+      getModelSize () const
+      {
+        return model_size_;
+      }
+
+      /** \brief Set the minimum and maximum allowable radius limits for the
+        * model (applicable to models that estimate a radius)
+        * \param[in] min_radius the minimum radius model
+        * \param[in] max_radius the maximum radius model
+        * \todo change this to set limits on the entire model
+        */
+      inline void
+      setRadiusLimits (const double min_radius, const double max_radius)
+      {
+        radius_min_ = min_radius;
+        radius_max_ = max_radius;
+      }
+
+      /** \brief Get the minimum and maximum allowable radius limits for the
+        * model as set by the user.
+        *
+        * \param min_radius the resultant minimum radius model
+        * \param max_radius the resultant maximum radius model
+        */
+      inline void
+      getRadiusLimits (double &min_radius, double &max_radius)
+      {
+        min_radius = radius_min_;
+        max_radius = radius_max_;
+      }
+
+      /** \brief This can be used to impose any kind of constraint on the model,
+        * e.g. that it has a specific direction, size, or anything else.
+        * \param[in] function A function that gets model coefficients and returns whether the model is acceptable or not.
+        */
+      inline void
+      setModelConstraints (std::function<bool(const Eigen::VectorXf &)> function)
+      {
+        if (!function)
+        {
+          PCL_ERROR ("[pcl::oneapi::SampleConsensusModel::setModelConstraints] The given function is empty (i.e. does not contain a callable target)!\n");
+          return;
+        }
+        custom_model_constraints_ = std::move (function);
+      }
+
+      /** \brief Set the maximum distance allowed when drawing random samples
+        * \param[in] radius the maximum distance (L2 norm)
+        * \param search
+        */
+      inline void
+      setSamplesMaxDist (const double &radius)//, SearchPtr search)
+      {
+        samples_radius_ = radius;
+        //samples_radius_search_ = search;
+      }
+
+      /** \brief Get maximum distance allowed when drawing random samples
+        *
+        * \param[out] radius the maximum distance (L2 norm)
+        */
+      inline void
+      getSamplesMaxDist (double &radius) const
+      {
+        radius = samples_radius_;
+      }
+
+      /** \brief Compute the variance of the errors to the model.
+        * \param[in] error_sqr_dists a vector holding the distances
+        */
+      inline double
+      computeVariance (const std::vector<float> &error_sqr_dists) const
+      {
+        std::vector<float> dists (error_sqr_dists);
+        const std::size_t medIdx = dists.size () >> 1;
+        std::nth_element (dists.begin (), dists.begin () + medIdx, dists.end ());
+        double median_error_sqr = dists[medIdx];
+        return (2.1981 * median_error_sqr);
+      }
+
+      /** \brief Compute the variance of the errors to the model from the internally
+        * estimated vector of distances. The model must be computed first (or at least
+        * selectWithinDistance must be called).
+        */
+      inline double
+      computeVariance () const
+      {
+        if (error_sqr_dists_.empty ())
+        {
+          PCL_ERROR ("[pcl::oneapi::SampleConsensusModel::computeVariance] The variance of the Sample Consensus model distances cannot be estimated, as the model has not been computed yet. Please compute the model first or at least run selectWithinDistance before continuing. Returning NAN!\n");
+          return (std::numeric_limits<double>::quiet_NaN ());
+        }
+        return (computeVariance (error_sqr_dists_));
+      }
+
+    protected:
+
+      /** \brief Fills a sample array with random samples from the indices_ vector
+       * \param[out] sample the set of indices of target_ to analyze
+       */
+      inline void
+      drawIndexSample (IndicesDev &sample)
+      {
+        std::size_t sample_size = sample.size ();
+        std::size_t index_size = shuffled_indices_.size ();
+        for (std::size_t i = 0; i < sample_size; ++i)
+          // The 1/(RAND_MAX+1.0) trick is when the random numbers are not uniformly distributed and for small modulo
+          // elements, that does not matter (and nowadays, random number generators are good)
+          //std::swap (shuffled_indices_[i], shuffled_indices_[i + (rand () % (index_size - i))]);
+          std::swap (shuffled_indices_[i], shuffled_indices_[i + (rnd() % (index_size - i))]);
+        std::copy (shuffled_indices_.begin (), shuffled_indices_.begin () + sample_size, sample.begin ());
+      }
+
+      /** \brief Fills a sample array with one random sample from the indices_ vector
+       *        and other random samples that are closer than samples_radius_
+       * \param[out] sample the set of indices of target_ to analyze
+       */
+      inline void
+      drawIndexSampleRadius (IndicesDev &sample)
+      {
+        std::size_t sample_size = sample.size ();
+        std::size_t index_size = shuffled_indices_.size ();
+
+        std::swap (shuffled_indices_[0], shuffled_indices_[0 + (rnd () % (index_size - 0))]);
+        //const PointT& pt0 = (*input_)[shuffled_indices_[0]];
+
+        IndicesDev indices;
+        std::vector<float> sqr_dists;
+
+        // If indices have been set when the search object was constructed,
+        // radiusSearch() expects an index into the indices vector as its
+        // first parameter. This can't be determined efficiently, so we use
+        // the point instead of the index.
+        // Returned indices are converted automatically.
+        // TODO only use Kdtree search
+        /*
+          samples_radius_search_->radiusSearch (input_->at(shuffled_indices_[0]),
+                                            samples_radius_, indices, sqr_dists );
+                                            */
+
+        if (indices.size () < sample_size - 1)
+        {
+          // radius search failed, make an invalid model
+          for(std::size_t i = 1; i < sample_size; ++i)
+            shuffled_indices_[i] = shuffled_indices_[0];
+        }
+        else
+        {
+          for (std::size_t i = 0; i < sample_size-1; ++i)
+            std::swap (indices[i], indices[i + (rnd () % (indices.size () - i))]);
+          for (std::size_t i = 1; i < sample_size; ++i)
+            shuffled_indices_[i] = indices[i-1];
+        }
+
+        std::copy (shuffled_indices_.begin (), shuffled_indices_.begin () + sample_size, sample.begin ());
+      }
+
+      /** \brief Check whether a model is valid given the user constraints.
+        *
+        * Default implementation verifies that the number of coefficients in the supplied model is as expected for this
+        * SAC model type. Specific SAC models should extend this function by checking the user constraints (if any).
+        *
+        * \param[in] model_coefficients the set of model coefficients
+        */
+      virtual bool
+      isModelValid (const Eigen::VectorXf &model_coefficients) const
+      {
+        if (model_coefficients.size () != model_size_)
+        {
+          PCL_ERROR ("[pcl::oneapi::%s::isModelValid] Invalid number of model coefficients given (is %lu, should be %lu)!\n", getClassName ().c_str (), model_coefficients.size (), model_size_);
+          return (false);
+        }
+        if (!custom_model_constraints_(model_coefficients))
+        {
+          PCL_DEBUG ("[pcl::oneapi::%s::isModelValid] The user defined isModelValid function returned false.\n", getClassName ().c_str ());
+          return (false);
+        }
+        return (true);
+      }
+
+      /** \brief Check if a sample of indices results in a good sample of points
+        * indices. Pure virtual.
+        * \param[in] samples the resultant index samples
+        */
+      virtual bool
+      isSampleGood (const IndicesDev &samples) const = 0;
+
+      /** \brief The model name. */
+      std::string model_name_;
+
+      /** \brief A boost shared pointer to the point cloud data array. */
+      PointCloudDevConstPtr input_;
+
+      /** \brief A pointer to the vector of point indices to use. */
+      IndicesDevPtr indices_;
+
+      /** The maximum number of samples to try until we get a good one */
+      static const unsigned int max_sample_checks_ = 1000;
+
+      /** \brief The minimum and maximum radius limits for the model.
+       * Applicable to all models that estimate a radius. 
+       */
+      double radius_min_, radius_max_;
+
+      /** \brief The maximum distance of subsequent samples from the first (radius search) */
+      double samples_radius_;
+
+      /** Data containing a shuffled version of the indices. This is used and modified when drawing samples. */
+      IndicesDev shuffled_indices_;
+
+      /** \brief Boost-based random number generator algorithm. */
+      boost::mt19937 rng_alg_;
+
+      /** \brief Boost-based random number generator distribution. */
+      std::shared_ptr<boost::uniform_int<> > rng_dist_;
+
+      /** \brief Boost-based random number generator. */
+      std::shared_ptr<boost::variate_generator< boost::mt19937&, boost::uniform_int<> > > rng_gen_;
+
+      /** \brief A vector holding the distances to the computed model. Used internally. */
+      std::vector<float> error_sqr_dists_;
+
+      /** \brief The size of a sample from which the model is computed. Every subclass should initialize this appropriately. */
+      unsigned int sample_size_;
+
+      /** \brief The number of coefficients in the model. Every subclass should initialize this appropriately. */
+      unsigned int model_size_;
+
+      /** \brief Boost-based random number generator. */
+      inline int
+      rnd ()
+      {
+        return ((*rng_gen_) ());
+      }
+
+      /** \brief A user defined function that takes model coefficients and returns whether
+        * the model is acceptable or not. */
+      std::function<bool(const Eigen::VectorXf &)> custom_model_constraints_;
+
+      //int block_size;
+      //pcl::oneapi::DeviceArray<int> inlier_sum_;
+  };
+} // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model_plane.h b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model_plane.h
new file mode 100644
index 000000000..82d2ad7e0
--- /dev/null
+++ b/oneapi/sample_consensus/include/pcl/oneapi/sample_consensus/sac_model_plane.h
@@ -0,0 +1,225 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+#include <pcl/oneapi/sample_consensus/sac_model.h>
+
+namespace pcl
+{
+  namespace oneapi
+  {
+
+    ////////////////////////////////////////////////////////////////////////////////////////////
+    /** \brief @b SampleConsensusModelPlane defines a model for 3D plane segmentation.
+      */
+    template <typename PointT>
+    class PCL_EXPORTS SampleConsensusModelPlane : public SampleConsensusModel <PointT>
+    {
+      public:
+        using SampleConsensusModel<PointT>::model_name_;
+        using SampleConsensusModel<PointT>::input_;
+        using SampleConsensusModel<PointT>::indices_;
+        using SampleConsensusModel<PointT>::error_sqr_dists_;
+        using SampleConsensusModel<PointT>::isModelValid;
+
+        using PointCloud = typename SampleConsensusModel<PointT>::PointCloud;
+        using PointCloudPtr = typename SampleConsensusModel<PointT>::PointCloudPtr;
+        using PointCloudConstPtr = typename SampleConsensusModel<PointT>::PointCloudConstPtr;
+
+        using PointCloudDev = typename SampleConsensusModel<PointT>::PointCloudDev;
+        using PointCloudDevPtr = typename SampleConsensusModel<PointT>::PointCloudDevPtr;
+        using PointCloudDevConstPtr = typename SampleConsensusModel<PointT>::PointCloudDevConstPtr;
+
+        using Ptr = shared_ptr<SampleConsensusModelPlane<PointT> >;
+        using ConstPtr = shared_ptr<const SampleConsensusModelPlane<PointT>>;
+
+        /** \brief Constructor for base SampleConsensusModelPlane.
+          * \param[in] cloud the input point cloud dataset
+          * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+          */
+        SampleConsensusModelPlane (const PointCloudConstPtr &cloud, bool random = false)
+          : SampleConsensusModel<PointT> (cloud, random)
+        {
+          model_name_ = "SampleConsensusModelPlane";
+          sample_size_ = 3;
+          model_size_ = 4;
+        }
+
+        /** \brief Constructor for base SampleConsensusModelPlane.
+          * \param[in] cloud the input point cloud dataset
+          * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+          */
+        SampleConsensusModelPlane (const PointCloudDevConstPtr &cloud, bool random = false)
+          : SampleConsensusModel<PointT> (cloud, random)
+        {
+          model_name_ = "SampleConsensusModelPlane";
+          sample_size_ = 3;
+          model_size_ = 4;
+        }
+
+        /** \brief Constructor for base SampleConsensusModelPlane.
+          * \param[in] cloud the input point cloud dataset
+          * \param[in] indices a vector of point indices to be used from \a cloud
+          * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+          */
+        SampleConsensusModelPlane (const PointCloudConstPtr &cloud,
+                                   const Indices &indices,
+                                   bool random = false)
+          : SampleConsensusModel<PointT> (cloud, indices, random)
+        {
+          model_name_ = "SampleConsensusModelPlane";
+          sample_size_ = 3;
+          model_size_ = 4;
+        }
+
+        /** \brief Constructor for base SampleConsensusModelPlane.
+          * \param[in] cloud the input point cloud dataset
+          * \param[in] indices a vector of point indices to be used from \a cloud
+          * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+          */
+        SampleConsensusModelPlane (const PointCloudDevConstPtr &cloud,
+                                   const IndicesDev &indices,
+                                   bool random = false)
+          : SampleConsensusModel<PointT> (cloud, indices, random)
+        {
+          model_name_ = "SampleConsensusModelPlane";
+          sample_size_ = 3;
+          model_size_ = 4;
+        }
+
+        /** \brief Empty destructor */
+        ~SampleConsensusModelPlane () {}
+
+        /** \brief Check whether the given index samples can form a valid plane model, compute the model coefficients from
+          * these samples and store them internally in model_coefficients_. The plane coefficients are:
+          * a, b, c, d (ax+by+cz+d=0)
+          * \param[in] samples the point indices found as possible good candidates for creating a valid model
+          * \param[out] model_coefficients the resultant model coefficients
+          */
+        bool
+        computeModelCoefficients (const IndicesDev &samples,
+                                  Eigen::VectorXf &model_coefficients) const override;
+
+        /** \brief Compute all distances from the cloud data to a given plane model.
+          * \param[in] model_coefficients the coefficients of a plane model that we need to compute distances to
+          * \param[out] distances the resultant estimated distances
+          */
+        void
+        getDistancesToModel (const Eigen::VectorXf &model_coefficients,
+                             std::vector<double> &distances) const override;
+
+        /** \brief Select all the points which respect the given model coefficients as inliers.
+          * \param[in] model_coefficients the coefficients of a plane model that we need to compute distances to
+          * \param[in] threshold a maximum admissible distance threshold for determining the inliers from the outliers
+          * \param[out] inliers the resultant model inliers
+          */
+        void
+        selectWithinDistance (const Eigen::VectorXf &model_coefficients,
+                              const double threshold,
+                              IndicesDev &inliers) override;
+
+        /** \brief Count all the points which respect the given model coefficients as inliers.
+          *
+          * \param[in] model_coefficients the coefficients of a model that we need to compute distances to
+          * \param[in] threshold maximum admissible distance threshold for determining the inliers from the outliers
+          * \return the resultant number of inliers
+          */
+        void
+        countWithinDistance (const Eigen::VectorXf &model_coefficients,
+                             const double threshold,
+                             DeviceArray<std::size_t>& counter
+                             ) const override;
+
+        /** \brief Recompute the plane coefficients using the given inlier set and return them to the user.
+          * @note: these are the coefficients of the plane model after refinement (e.g. after SVD)
+          * \param[in] inliers the data inliers found as supporting the model
+          * \param[in] model_coefficients the initial guess for the model coefficients
+          * \param[out] optimized_coefficients the resultant recomputed coefficients after non-linear optimization
+          */
+        void
+        optimizeModelCoefficients (const IndicesDev &inliers,
+                                   const Eigen::VectorXf &model_coefficients,
+                                   Eigen::VectorXf &optimized_coefficients) const override;
+
+        /** \brief Create a new point cloud with inliers projected onto the plane model.
+          * \param[in] inliers the data inliers that we want to project on the plane model
+          * \param[in] model_coefficients the *normalized* coefficients of a plane model
+          * \param[out] projected_points the resultant projected points
+          * \param[in] copy_data_fields set to true if we need to copy the other data fields
+          */
+        void
+        projectPoints (const IndicesDev &inliers,
+                       const Eigen::VectorXf &model_coefficients,
+                       PointCloudDev &projected_points,
+                       bool copy_data_fields = true) const override;
+
+        /** \brief Verify whether a subset of indices verifies the given plane model coefficients.
+          * \param[in] indices the data indices that need to be tested against the plane model
+          * \param[in] model_coefficients the plane model coefficients
+          * \param[in] threshold a maximum admissible distance threshold for determining the inliers from the outliers
+          */
+        bool
+        doSamplesVerifyModel (const std::set<index_t> &indices,
+                              const Eigen::VectorXf &model_coefficients,
+                              const double threshold) const override;
+
+        /** \brief Return a unique id for this model (SACMODEL_PLANE). */
+        inline SacModel
+        getModelType () const override { return (SACMODEL_PLANE); }
+
+      protected:
+        using SampleConsensusModel<PointT>::sample_size_;
+        using SampleConsensusModel<PointT>::model_size_;
+
+        /** This implementation uses no SIMD instructions. It is not intended for normal use.
+          * See countWithinDistance which automatically uses the fastest implementation.
+          */
+        std::size_t
+        countWithinDistanceStandard (const Eigen::VectorXf &model_coefficients,
+                                     const double threshold,
+                                     std::size_t i = 0) const;
+
+      private:
+        /** \brief Check if a sample of indices results in a good sample of points
+          * indices.
+          * \param[in] samples the resultant index samples
+          */
+        bool
+        isSampleGood (const IndicesDev &samples) const override;
+    };
+  } // namespace oneapi
+} // namespace pcl
diff --git a/oneapi/sample_consensus/src/sac.cpp b/oneapi/sample_consensus/src/sac.cpp
new file mode 100644
index 000000000..18ca5de43
--- /dev/null
+++ b/oneapi/sample_consensus/src/sac.cpp
@@ -0,0 +1,50 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/sample_consensus/impl/ransac.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+// Instantiations of specific point types
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+  PCL_INSTANTIATE(RandomSampleConsensus, (pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGBA)(pcl::PointXYZRGB)(pcl::PointNormal)(pcl::PointXYZRGBNormal))
+#else
+  PCL_INSTANTIATE(RandomSampleConsensus, PCL_XYZ_POINT_TYPES)
+#endif
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/sample_consensus/src/sac_model_plane.cpp b/oneapi/sample_consensus/src/sac_model_plane.cpp
new file mode 100644
index 000000000..5e85cb8f5
--- /dev/null
+++ b/oneapi/sample_consensus/src/sac_model_plane.cpp
@@ -0,0 +1,51 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009-2012, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/sample_consensus/impl/sac_model_plane.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+// Instantiations of specific point types
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+  PCL_INSTANTIATE(SampleConsensusModelPlane, (pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGBA)(pcl::PointXYZRGB)(pcl::PointXYZRGBNormal))
+#else
+  PCL_INSTANTIATE(SampleConsensusModelPlane, PCL_XYZ_POINT_TYPES)
+#endif
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/search/CMakeLists.txt b/oneapi/search/CMakeLists.txt
new file mode 100755
index 000000000..bf3722b33
--- /dev/null
+++ b/oneapi/search/CMakeLists.txt
@@ -0,0 +1,40 @@
+set(SUBSYS_NAME oneapi_search)
+set(SUBSYS_PATH oneapi/search)
+set(SUBSYS_DESC "Point cloud oneAPI search library")
+set(SUBSYS_DEPS common search kdtree oneapi_kdtree oneapi_common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS} EXT_DEPS flann)
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/oneapi/search/kdtree.h"
+)
+
+set(impl_incs
+  "include/pcl/oneapi/search/impl/kdtree.hpp"
+)
+
+set(srcs
+  src/kdtree.cpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+get_filename_component(INC_ONEAPI_KDTREE "${CMAKE_CURRENT_SOURCE_DIR}/../kdtree/include" REALPATH)
+
+include_directories(${INC_ONEAPI_KDTREE} "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs})
+target_link_libraries("${LIB_NAME}" pcl_common pcl_search FLANN::FLANN pcl_kdtree pcl_oneapi_kdtree)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+list(APPEND EXT_DEPS flann)
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/search/include/pcl/oneapi/search/impl/kdtree.hpp b/oneapi/search/include/pcl/oneapi/search/impl/kdtree.hpp
new file mode 100644
index 000000000..b4e9535cc
--- /dev/null
+++ b/oneapi/search/include/pcl/oneapi/search/impl/kdtree.hpp
@@ -0,0 +1,225 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef PCL_ONEAPI_SEARCH_KDTREE_IMPL_HPP_
+#define PCL_ONEAPI_SEARCH_KDTREE_IMPL_HPP_
+
+#include <pcl/oneapi/search/kdtree.h>
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree>
+pcl::oneapi::search::KdTree<PointT,Tree>::KdTree (bool sorted)
+  : pcl::search::Search<PointT> ("KdTree", sorted)
+  , tree_ (new Tree (sorted))
+{
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> void
+pcl::oneapi::search::KdTree<PointT,Tree>::setPointRepresentation (
+    const PointRepresentationConstPtr &point_representation)
+{
+  tree_->setPointRepresentation (point_representation);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> void
+pcl::oneapi::search::KdTree<PointT,Tree>::setSortedResults (bool sorted_results)
+{
+  sorted_results_ = sorted_results;
+  tree_->setSortedResults (sorted_results);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> void
+pcl::oneapi::search::KdTree<PointT,Tree>::setEpsilon (float eps)
+{
+  tree_->setEpsilon (eps);
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> void
+pcl::oneapi::search::KdTree<PointT,Tree>::setInputCloud (
+    const PointCloudConstPtr& cloud, 
+    const IndicesConstPtr& indices)
+{
+  tree_->setInputCloud (cloud, indices);
+  input_ = cloud;
+  indices_ = indices;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree>
+void pcl::oneapi::search::KdTree<PointT,Tree>::setInputCloud (const PointCloudConstPtr& cloud,
+    const double radius, const IndicesConstPtr &indices) {
+  if (tree_) {
+    tree_->setInputCloud(cloud, radius);
+  }
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT,Tree>::nearestKSearch (
+    const PointT &point, int k, Indices &k_indices,
+    std::vector<float> &k_sqr_distances) const
+{
+  return (tree_->nearestKSearch (point, k, k_indices, k_sqr_distances));
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::nearestKSearch(
+    const PointCloudConstPtr &cloud, int k, std::vector<std::vector<int>>& indices,
+    std::vector<std::vector<float>>& distances)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->nearestKSearch(cloud, k, indices, distances);
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::nearestKSearch(
+    const PointCloudConstPtr &cloud, int k, std::vector<int>& indices,
+    std::vector<float>& distances)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->nearestKSearch(cloud, k, indices, distances);
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::nearestKSearch(
+    const PointCloudConstPtr &cloud, int k, pcl::oneapi::DeviceArray2D<int>& indices,
+    pcl::oneapi::DeviceArray2D<float>& distances)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->nearestKSearch(cloud, k, indices, distances);
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::nearestKSearch(
+    const PointCloudConstPtr &cloud, int k, pcl::oneapi::DeviceArray<int>& indices,
+    pcl::oneapi::DeviceArray<float>& distances, pcl::oneapi::DeviceArray<int>& splits)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->nearestKSearch(cloud, k, indices, distances, splits);
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT,Tree>::radiusSearch (
+    const PointT& point, double radius,
+    Indices &k_indices, std::vector<float> &k_sqr_distances,
+    unsigned int max_nn) const
+{
+  return (tree_->radiusSearch (point, radius, k_indices, k_sqr_distances, max_nn));
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::radiusSearch (
+    const PointCloudConstPtr &cloud,
+    double radius,
+    std::vector<std::vector<int>> &k_indices,
+    std::vector<std::vector<float>> &k_sqr_dists,
+    unsigned int max_nn)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->radiusSearch(cloud, radius, k_indices, k_sqr_dists, max_nn);
+  }
+
+  return ret;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT, class Tree> int
+pcl::oneapi::search::KdTree<PointT, Tree>::radiusSearch (
+    const PointCloudConstPtr &cloud,
+    double radius,
+    std::vector<int> &k_indices,
+    std::vector<float> &k_sqr_dists,
+    std::vector<int> &k_splits,
+    unsigned int start,
+    unsigned int end,
+    unsigned int max_nn)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->radiusSearch(cloud, radius, k_indices, k_sqr_dists, k_splits, start, end,  max_nn);
+  }
+
+  return ret;
+}
+
+template <typename PointT, class Tree>
+int pcl::oneapi::search::KdTree<PointT, Tree>::fixedRadiusSearch (
+    const PointCloudConstPtr &cloud,
+    std::vector<int> &k_indices,
+    std::vector<float> &k_sqr_dists,
+    std::vector<int> &k_splits)
+{
+  int ret = -1;
+  if (tree_) {
+    ret = tree_->fixedRadiusSearch(cloud, k_indices, k_sqr_dists, k_splits);
+  }
+
+  return ret;
+}
+
+#define PCL_INSTANTIATE_OneAPI_KdTree(T) template class PCL_EXPORTS pcl::oneapi::search::KdTree<T>;
+
+#endif  //#ifndef PCL_ONEAPI_SEARCH_KDTREE_IMPL_HPP_
+
+
diff --git a/oneapi/search/include/pcl/oneapi/search/kdtree.h b/oneapi/search/include/pcl/oneapi/search/kdtree.h
new file mode 100644
index 000000000..090ced62d
--- /dev/null
+++ b/oneapi/search/include/pcl/oneapi/search/kdtree.h
@@ -0,0 +1,241 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ */
+
+#pragma once
+
+#include <pcl/oneapi/kdtree/kdtree_flann.h>
+#include <pcl/search/search.h>
+
+namespace pcl
+{
+  // Forward declarations
+  template <typename T> class PointRepresentation;
+namespace oneapi{
+  namespace search
+  {
+    /** \brief @b search::KdTree is a wrapper class which inherits the pcl::KdTree class for performing search 
+      * functions using KdTree structure. KdTree is a generic type of 3D spatial locator using kD-tree structures. 
+      * The class is making use of the FLANN (Fast Library for Approximate Nearest Neighbor) project 
+      * by Marius Muja and David Lowe.
+      *
+      * \author Radu B. Rusu
+      * \ingroup search
+      */
+    template<typename PointT, class Tree = pcl::oneapi::KdTreeFLANN<PointT> >
+    class KdTree: public pcl::search::Search<PointT>
+    {
+      public:
+        using PointCloud = typename pcl::search::Search<PointT>::PointCloud;
+        using PointCloudConstPtr = typename pcl::search::Search<PointT>::PointCloudConstPtr;
+        using IndicesConstPtr = shared_ptr<const Indices>;
+        using pcl::search::Search<PointT>::indices_;
+        using pcl::search::Search<PointT>::input_;
+        using pcl::search::Search<PointT>::getIndices;
+        using pcl::search::Search<PointT>::getInputCloud;
+        using pcl::search::Search<PointT>::nearestKSearch;
+        using pcl::search::Search<PointT>::radiusSearch;
+        using pcl::search::Search<PointT>::sorted_results_;
+
+        using Ptr = shared_ptr<KdTree<PointT, Tree> >;
+        using ConstPtr = shared_ptr<const KdTree<PointT, Tree> >;
+
+        using KdTreePtr = typename Tree::Ptr;
+        using KdTreeConstPtr = typename Tree::ConstPtr;
+        using PointRepresentationConstPtr = typename PointRepresentation<PointT>::ConstPtr;
+
+        /** \brief Constructor for KdTree. 
+          *
+          * \param[in] sorted set to true if the nearest neighbor search results
+          * need to be sorted in ascending order based on their distance to the
+          * query point
+          *
+          */
+        KdTree (bool sorted = true);
+
+        void
+        setInputCloud(const PointCloudConstPtr& cloud, const double radius,
+                const IndicesConstPtr& indices = IndicesConstPtr());
+
+        /** \brief Destructor for KdTree. */
+        ~KdTree ()
+        {
+        }
+
+        /** \brief Provide a pointer to the point representation to use to convert points into k-D vectors. 
+          * \param[in] point_representation the const boost shared pointer to a PointRepresentation
+          */
+        void
+        setPointRepresentation (const PointRepresentationConstPtr &point_representation);
+
+        /** \brief Get a pointer to the point representation used when converting points into k-D vectors. */
+        inline PointRepresentationConstPtr
+        getPointRepresentation () const
+        {
+          return (tree_->getPointRepresentation ());
+        }
+
+        /** \brief Sets whether the results have to be sorted or not.
+          * \param[in] sorted_results set to true if the radius search results should be sorted
+          */
+        void
+        setSortedResults (bool sorted_results) override;
+
+        /** \brief Set the search epsilon precision (error bound) for nearest neighbors searches.
+          * \param[in] eps precision (error bound) for nearest neighbors searches
+          */
+        void
+        setEpsilon (float eps);
+
+        /** \brief Get the search epsilon precision (error bound) for nearest neighbors searches. */
+        inline float
+        getEpsilon () const
+        {
+          return (tree_->getEpsilon ());
+        }
+
+        /** \brief Provide a pointer to the input dataset.
+          * \param[in] cloud the const boost shared pointer to a PointCloud message
+          * \param[in] indices the point indices subset that is to be used from \a cloud 
+          */
+        void
+        setInputCloud (const PointCloudConstPtr& cloud,
+                       const IndicesConstPtr& indices = IndicesConstPtr ()) override;
+
+        /** \brief Search for the k-nearest neighbors for the given query point.
+          * \param[in] point the given query point
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
+          * a priori!)
+          * \return number of neighbors found
+          */
+        int
+        nearestKSearch (const PointT &point, int k,
+                        Indices &k_indices,
+                        std::vector<float> &k_sqr_distances) const override;
+
+        int
+        nearestKSearch (const PointCloudConstPtr &cloud,
+                        int k,
+                        std::vector<std::vector<int>>& indices,
+                        std::vector<std::vector<float>>& distances);
+
+        int
+        nearestKSearch (const PointCloudConstPtr &cloud,
+                        int k,
+                        std::vector<int>& indices,
+                        std::vector<float>& distances);
+
+        int
+        nearestKSearch (const PointCloudConstPtr &cloud,
+                        int k,
+                        pcl::oneapi::DeviceArray<int>& indices,
+                        pcl::oneapi::DeviceArray<float>& distances,
+                        pcl::oneapi::DeviceArray<int>& splits);
+
+        int
+        nearestKSearch (const PointCloudConstPtr &cloud,
+                        int k,
+                        pcl::oneapi::DeviceArray2D<int>& indices,
+                        pcl::oneapi::DeviceArray2D<float>& distances);
+
+        template <typename PointTDiff> void
+        nearestKSearchT (const pcl::PointCloud<PointTDiff> &cloud, int k,
+          std::vector<Indices> &indices, std::vector<std::vector<float> > &distances) {
+          // Copy all the data fields from the input cloud to the output one
+          using FieldListInT = typename pcl::traits::fieldList<PointT>::type;
+          using FieldListOutT = typename pcl::traits::fieldList<PointTDiff>::type;
+          using FieldList = typename pcl::intersect<FieldListInT, FieldListOutT>::type;
+
+          pcl::PointCloud<PointT> pc;
+          pc.resize (cloud.size());
+          for (std::size_t i = 0; i < cloud.size(); i++)
+          {
+            pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (
+                                            cloud[i], pc[i]));
+          }
+          nearestKSearch (pc.makeShared(),k,indices,distances);
+        }
+        /** \brief Search for all the nearest neighbors of the query point in a given radius.
+          * \param[in] point the given query point
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \return number of neighbors found in radius
+          */
+        int
+        radiusSearch (const PointT& point, double radius,
+                      Indices &k_indices,
+                      std::vector<float> &k_sqr_distances,
+                      unsigned int max_nn = 0) const override;
+        int
+        radiusSearch (const PointCloudConstPtr &cloud,
+                      double radius,
+                      std::vector<std::vector<int>> &k_indices,
+                      std::vector<std::vector<float>> &k_sqr_dists,
+                      unsigned int max_nn = 0);
+        int fixedRadiusSearch (const PointCloudConstPtr &cloud,
+                          std::vector<int> &k_indices,
+                          std::vector<float> &k_sqr_dists,
+                          std::vector<int> &k_segments);
+        int
+        radiusSearch (const PointCloudConstPtr &cloud,
+                      double radius,
+                      std::vector<int> &k_indices,
+                      std::vector<float> &k_sqr_dists,
+                      std::vector<int> &k_segments,
+                      unsigned int start,
+                      unsigned int end,
+                      unsigned int max_nn);
+      protected:
+        /** \brief A pointer to the internal KdTree object. */
+        KdTreePtr tree_;
+    };
+  }
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/search/impl/kdtree.hpp>
+#else
+#define PCL_INSTANTIATE_OneAPI_KdTree(T) template class PCL_EXPORTS pcl::oneapi::search::KdTree<T>;
+#endif
diff --git a/oneapi/search/include/pcl/oneapi/search/search.h b/oneapi/search/include/pcl/oneapi/search/search.h
new file mode 100644
index 000000000..3d6f4ba13
--- /dev/null
+++ b/oneapi/search/include/pcl/oneapi/search/search.h
@@ -0,0 +1,453 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/pcl_base.h> // for IndicesConstPtr
+#include <pcl/oneapi/point_cloud.h>
+#include <pcl/for_each_type.h>
+#include <pcl/common/concatenate.h>
+#include <pcl/common/copy_point.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  namespace search
+  {
+    /** \brief Generic search class. All search wrappers must inherit from this.
+      *
+      * Each search method must implement 2 different types of search:
+      *   - \b nearestKSearch - search for K-nearest neighbors.
+      *   - \b radiusSearch - search for all nearest neighbors in a sphere of a given radius
+      *
+      * The input to each search method can be given in 3 different ways:
+      *   - as a query point
+      *   - as a (cloud, index) pair
+      *   - as an index
+      *
+      * For the latter option, it is assumed that the user specified the input
+      * via a \ref setInputCloud () method first.
+      *
+      * \note In case of an error, all methods are supposed to return 0 as the number of neighbors found.
+      *
+      * \note libpcl_search deals with three-dimensional search problems. For higher
+      * level dimensional search, please refer to the libpcl_kdtree module.
+      *
+      * \author Radu B. Rusu
+      * \ingroup search
+      */
+    template<typename PointT>
+    class Search
+    {
+      public:
+        using PointCloud = pcl::PointCloud<PointT>;
+        using PointCloudPtr = typename PointCloud::Ptr;
+        using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+        using PointCloudDev = pcl::PointCloudDev<PointT>;
+        using PointCloudDevPtr = typename PointCloudDev::Ptr;
+        using PointCloudDevConstPtr = typename PointCloudDev::ConstPtr;
+
+        using Ptr = shared_ptr<pcl::oneapi::search::Search<PointT> >;
+        using ConstPtr = shared_ptr<const pcl::oneapi::search::Search<PointT> >;
+
+        using IndicesPtr = pcl::IndicesPtr;
+        using IndicesConstPtr = pcl::IndicesConstPtr;
+
+        /** Constructor. */
+        Search (const std::string& name = "", bool sorted = false);
+
+        /** Destructor. */
+        virtual
+        ~Search ()
+        {
+        }
+
+        /** \brief Returns the search method name
+          */
+        virtual const std::string&
+        getName () const;
+
+        /** \brief sets whether the results should be sorted (ascending in the distance) or not
+          * \param[in] sorted should be true if the results should be sorted by the distance in ascending order.
+          * Otherwise the results may be returned in any order.
+          */
+        virtual void
+        setSortedResults (bool sorted);
+
+        /** \brief Gets whether the results should be sorted (ascending in the distance) or not
+          * Otherwise the results may be returned in any order.
+          */
+        virtual bool
+        getSortedResults ();
+
+        /** \brief Pass the input dataset that the search will be performed on.
+          * \param[in] cloud a const pointer to the PointCloud data
+          * \param[in] indices the point indices subset that is to be used from the cloud
+          */
+        virtual void
+        setInputCloud (const PointCloudConstPtr& cloud,
+                       const IndicesConstPtr &indices = IndicesConstPtr ());
+
+        /** \brief Pass the input dataset that the search will be performed on.
+          * \param[in] cloud a const pointer to the PointCloud data
+          * \param[in] indices the point indices subset that is to be used from the cloud
+          */
+        virtual void
+        setInputCloud (const PointCloudDevConstPtr& cloud,
+                       const IndicesConstPtr &indices = IndicesConstPtr ());
+
+        /** \brief Get a pointer to the input point cloud dataset. */
+        virtual PointCloudConstPtr
+        getInputCloud () const
+        {
+          return (input_);
+        }
+
+        /** \brief Get a pointer to the input point cloud dataset. */
+        virtual PointCloudDevConstPtr
+        getInputCloud () const
+        {
+          return (input_);
+        }
+
+        /** \brief Get a pointer to the vector of indices used. */
+        virtual IndicesConstPtr
+        getIndices () const
+        {
+          return (indices_);
+        }
+
+        /** \brief Search for the k-nearest neighbors for the given query point.
+          * \param[in] point the given query point
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
+          * a priori!)
+          * \return number of neighbors found
+          */
+        virtual int
+        nearestKSearch (const PointT &point, int k, Indices &k_indices,
+                        std::vector<float> &k_sqr_distances) const = 0;
+
+        /** \brief Search for k-nearest neighbors for the given query point.
+          * This method accepts a different template parameter for the point type.
+          * \param[in] point the given query point
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
+          * a priori!)
+          * \return number of neighbors found
+          */
+        template <typename PointTDiff> inline int
+        nearestKSearchT (const PointTDiff &point, int k,
+                         Indices &k_indices, std::vector<float> &k_sqr_distances) const
+        {
+          PointT p;
+          copyPoint (point, p);
+          return (nearestKSearch (p, k, k_indices, k_sqr_distances));
+        }
+
+        /** \brief Search for k-nearest neighbors for the given query point.
+          *
+          * \attention This method does not do any bounds checking for the input index
+          * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+          *
+          * \param[in] cloud the point cloud data
+          * \param[in] index a \a valid index in \a cloud representing a \a valid (i.e., finite) query point
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
+          * a priori!)
+          *
+          * \return number of neighbors found
+          *
+          * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
+          */
+        virtual int
+        nearestKSearch (const PointCloud &cloud, index_t index, int k,
+                        Indices &k_indices,
+                        std::vector<float> &k_sqr_distances) const;
+
+        /** \brief Search for k-nearest neighbors for the given query point (zero-copy).
+          *
+          * \attention This method does not do any bounds checking for the input index
+          * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+          *
+          * \param[in] index a \a valid index representing a \a valid query point in the dataset given
+          * by \a setInputCloud. If indices were given in setInputCloud, index will be the position in
+          * the indices vector.
+          *
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points (must be resized to \a k a priori!)
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points (must be resized to \a k
+          * a priori!)
+          * \return number of neighbors found
+          *
+          * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
+          */
+        virtual int
+        nearestKSearch (index_t index, int k,
+                        Indices &k_indices,
+                        std::vector<float> &k_sqr_distances) const;
+
+        /** \brief Search for the k-nearest neighbors for the given query point.
+          * \param[in] cloud the point cloud data
+          * \param[in] indices a vector of point cloud indices to query for nearest neighbors
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
+          */
+        virtual void
+        nearestKSearch (const PointCloud& cloud, const Indices& indices,
+                        int k, std::vector<Indices>& k_indices,
+                        std::vector< std::vector<float> >& k_sqr_distances) const;
+
+        /** \brief Search for the k-nearest neighbors for the given query point. Use this method if the query points are of a different type than the points in the data set (e.g. PointXYZRGBA instead of PointXYZ).
+          * \param[in] cloud the point cloud data
+          * \param[in] indices a vector of point cloud indices to query for nearest neighbors
+          * \param[in] k the number of neighbors to search for
+          * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
+          * \note This method copies the input point cloud of type PointTDiff to a temporary cloud of type PointT and performs the batch search on the new cloud. You should prefer the single-point search if you don't use a search algorithm that accelerates batch NN search.
+          */
+        template <typename PointTDiff> void
+        nearestKSearchT (const pcl::PointCloud<PointTDiff> &cloud, const Indices& indices, int k, std::vector<Indices> &k_indices,
+                         std::vector< std::vector<float> > &k_sqr_distances) const
+        {
+          // Copy all the data fields from the input cloud to the output one
+          using FieldListInT = typename pcl::traits::fieldList<PointT>::type;
+          using FieldListOutT = typename pcl::traits::fieldList<PointTDiff>::type;
+          using FieldList = typename pcl::intersect<FieldListInT, FieldListOutT>::type;
+
+          pcl::PointCloud<PointT> pc;
+          if (indices.empty ())
+          {
+            pc.resize (cloud.size());
+            for (std::size_t i = 0; i < cloud.size(); i++)
+            {
+              pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (
+                                              cloud[i], pc[i]));
+            }
+            nearestKSearch (pc,Indices(),k,k_indices,k_sqr_distances);
+          }
+          else
+          {
+            pc.resize (indices.size());
+            for (std::size_t i = 0; i < indices.size(); i++)
+            {
+              pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (
+                                              cloud[indices[i]], pc[i]));
+            }
+            nearestKSearch (pc,Indices(),k,k_indices,k_sqr_distances);
+          }
+        }
+
+        /** \brief Search for all the nearest neighbors of the query point in a given radius.
+          * \param[in] point the given query point
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \return number of neighbors found in radius
+          */
+        virtual int
+        radiusSearch (const PointT& point, double radius, Indices& k_indices,
+                      std::vector<float>& k_sqr_distances, unsigned int max_nn = 0) const = 0;
+
+        /** \brief Search for all the nearest neighbors of the query point in a given radius.
+          * \param[in] point the given query point
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \return number of neighbors found in radius
+          */
+        template <typename PointTDiff> inline int
+        radiusSearchT (const PointTDiff &point, double radius, Indices &k_indices,
+                       std::vector<float> &k_sqr_distances, unsigned int max_nn = 0) const
+        {
+          PointT p;
+          copyPoint (point, p);
+          return (radiusSearch (p, radius, k_indices, k_sqr_distances, max_nn));
+        }
+
+        /** \brief Search for all the nearest neighbors of the query point in a given radius.
+          *
+          * \attention This method does not do any bounds checking for the input index
+          * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+          *
+          * \param[in] cloud the point cloud data
+          * \param[in] index a \a valid index in \a cloud representing a \a valid (i.e., finite) query point
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \return number of neighbors found in radius
+          *
+          * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
+          */
+        virtual int
+        radiusSearch (const PointCloud &cloud, index_t index, double radius,
+                      Indices &k_indices, std::vector<float> &k_sqr_distances,
+                      unsigned int max_nn = 0) const;
+
+        /** \brief Search for all the nearest neighbors of the query point in a given radius (zero-copy).
+          *
+          * \attention This method does not do any bounds checking for the input index
+          * (i.e., index >= cloud.size () || index < 0), and assumes valid (i.e., finite) data.
+          *
+          * \param[in] index a \a valid index representing a \a valid query point in the dataset given
+          * by \a setInputCloud. If indices were given in setInputCloud, index will be the position in
+          * the indices vector.
+          *
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \return number of neighbors found in radius
+          *
+          * \exception asserts in debug mode if the index is not between 0 and the maximum number of points
+          */
+        virtual int
+        radiusSearch (index_t index, double radius, Indices &k_indices,
+                      std::vector<float> &k_sqr_distances, unsigned int max_nn = 0) const;
+
+        /** \brief Search for all the nearest neighbors of the query point in a given radius.
+          * \param[in] cloud the point cloud data
+          * \param[in] indices the indices in \a cloud. If indices is empty, neighbors will be searched for all points.
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          */
+        virtual void
+        radiusSearch (const PointCloud& cloud,
+                      const Indices& indices,
+                      double radius,
+                      std::vector<Indices>& k_indices,
+                      std::vector< std::vector<float> > &k_sqr_distances,
+                      unsigned int max_nn = 0) const;
+
+        /** \brief Search for all the nearest neighbors of the query points in a given radius.
+          * \param[in] cloud the point cloud data
+          * \param[in] indices a vector of point cloud indices to query for nearest neighbors
+          * \param[in] radius the radius of the sphere bounding all of p_q's neighbors
+          * \param[out] k_indices the resultant indices of the neighboring points, k_indices[i] corresponds to the neighbors of the query point i
+          * \param[out] k_sqr_distances the resultant squared distances to the neighboring points, k_sqr_distances[i] corresponds to the neighbors of the query point i
+          * \param[in] max_nn if given, bounds the maximum returned neighbors to this value. If \a max_nn is set to
+          * 0 or to a number higher than the number of points in the input cloud, all neighbors in \a radius will be
+          * returned.
+          * \note This method copies the input point cloud of type PointTDiff to a temporary cloud of type PointT and performs the batch search on the new cloud. You should prefer the single-point search if you don't use a search algorithm that accelerates batch NN search.
+          */
+        /*
+        template <typename PointTDiff> void
+        radiusSearchT (const pcl::PointCloud<PointTDiff> &cloud,
+                       const Indices& indices,
+                       double radius,
+                       std::vector<Indices> &k_indices,
+                       std::vector< std::vector<float> > &k_sqr_distances,
+                       unsigned int max_nn = 0) const
+        {
+          // Copy all the data fields from the input cloud to the output one
+          using FieldListInT = typename pcl::traits::fieldList<PointT>::type;
+          using FieldListOutT = typename pcl::traits::fieldList<PointTDiff>::type;
+          using FieldList = typename pcl::intersect<FieldListInT, FieldListOutT>::type;
+
+          pcl::PointCloud<PointT> pc;
+          if (indices.empty ())
+          {
+            pc.resize (cloud.size ());
+            for (std::size_t i = 0; i < cloud.size (); ++i)
+              pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (cloud[i], pc[i]));
+            radiusSearch (pc, Indices (), radius, k_indices, k_sqr_distances, max_nn);
+          }
+          else
+          {
+            pc.resize (indices.size ());
+            for (std::size_t i = 0; i < indices.size (); ++i)
+              pcl::for_each_type <FieldList> (pcl::NdConcatenateFunctor <PointTDiff, PointT> (cloud[indices[i]], pc[i]));
+            radiusSearch (pc, Indices(), radius, k_indices, k_sqr_distances, max_nn);
+          }
+        }
+        */
+
+      protected:
+        void
+        sortResults (Indices& indices, std::vector<float>& distances) const;
+
+        PointCloudConstPtr input_;
+        IndicesConstPtr indices_;
+        bool sorted_results_;
+        std::string name_;
+
+      private:
+        struct Compare
+        {
+          Compare (const std::vector<float>& distances)
+          : distances_ (distances)
+          {
+          }
+
+          bool
+          operator () (index_t first, index_t second) const
+          {
+            return (distances_ [first] < distances_[second]);
+          }
+
+          const std::vector<float>& distances_;
+        };
+    }; // class Search    
+  } // namespace search
+} // namespace oneapi
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/search/impl/search.hpp>
+#endif
diff --git a/oneapi/search/src/kdtree.cpp b/oneapi/search/src/kdtree.cpp
new file mode 100644
index 000000000..64774c570
--- /dev/null
+++ b/oneapi/search/src/kdtree.cpp
@@ -0,0 +1,46 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#include <pcl/oneapi/search/impl/kdtree.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+// Instantiations of specific point types
+PCL_INSTANTIATE(OneAPI_KdTree, PCL_XYZ_POINT_TYPES)
+#endif    // PCL_NO_PRECOMPILE
+
diff --git a/oneapi/segmentation/CMakeLists.txt b/oneapi/segmentation/CMakeLists.txt
new file mode 100644
index 000000000..0c6a7198a
--- /dev/null
+++ b/oneapi/segmentation/CMakeLists.txt
@@ -0,0 +1,33 @@
+set(SUBSYS_NAME oneapi_segmentation)
+set(SUBSYS_PATH oneapi/segmentation)
+set(SUBSYS_DESC "Point cloud oneAPI sac_segmentation library")
+set(SUBSYS_DEPS common oneapi_sample_consensus oneapi_common)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/oneapi/segmentation/sac_segmentation.h"
+)
+
+set(srcs
+  src/sac_segmentation.cpp
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} )
+target_link_libraries("${LIB_NAME}" pcl_oneapi_sample_consensus pcl_common pcl_oneapi_common)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
+
diff --git a/oneapi/segmentation/include/pcl/oneapi/segmentation/impl/sac_segmentation.hpp b/oneapi/segmentation/include/pcl/oneapi/segmentation/impl/sac_segmentation.hpp
new file mode 100644
index 000000000..e78e6eb2b
--- /dev/null
+++ b/oneapi/segmentation/include/pcl/oneapi/segmentation/impl/sac_segmentation.hpp
@@ -0,0 +1,206 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  Copyright (c) 2012-, Open Perception, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_ONEAPI_SEGMENTATION_IMPL_SAC_SEGMENTATION_H_
+#define PCL_ONEAPI_SEGMENTATION_IMPL_SAC_SEGMENTATION_H_
+
+#include <pcl/oneapi/segmentation/sac_segmentation.h>
+
+// Sample Consensus methods
+#include <pcl/oneapi/sample_consensus/sac.h>
+#include <pcl/oneapi/sample_consensus/ransac.h>
+
+// Sample Consensus models
+#include <pcl/oneapi/sample_consensus/sac_model.h>
+#include <pcl/oneapi/sample_consensus/sac_model_plane.h>
+
+
+#include <pcl/memory.h>  // for static_pointer_cast
+
+
+#include <chrono>
+inline double getTimeStamp()
+{
+  namespace sc = std::chrono;
+  sc::system_clock::duration d = sc::system_clock::now().time_since_epoch();
+  sc::seconds s = sc::duration_cast<sc::seconds>(d);
+  return s.count() + (sc::duration_cast<sc::microseconds>(d - s).count()) / 1e6;
+}
+
+
+namespace pcl
+{
+namespace oneapi
+{
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SACSegmentation<PointT>::segment (PointIndicesDev &inliers, ModelCoefficients &model_coefficients)
+{
+  // Copy the header information
+  inliers.header = model_coefficients.header = input_->header;
+
+  if (!initCompute ())
+  {
+    inliers.indices.clear (); model_coefficients.values.clear ();
+    return;
+  }
+
+  // Initialize the Sample Consensus model and set its parameters
+  if (!initSACModel (model_type_))
+  {
+    PCL_ERROR ("[pcl::%s::segment] Error initializing the SAC model!\n", getClassName ().c_str ());
+    deinitCompute ();
+    inliers.indices.clear (); model_coefficients.values.clear ();
+    return;
+  }
+  // Initialize the Sample Consensus method and set its parameters
+  initSAC (method_type_);
+
+  if (!sac_->computeModel (0))
+  {
+    PCL_ERROR ("[pcl::%s::segment] Error segmenting the model! No solution found.\n", getClassName ().c_str ());
+    deinitCompute ();
+    inliers.indices.clear (); model_coefficients.values.clear ();
+    return;
+  }
+
+  // Get the model inliers
+  sac_->getInliers (inliers.indices);
+
+  // Get the model coefficients
+  Eigen::VectorXf coeff (model_->getModelSize ());
+  sac_->getModelCoefficients (coeff);
+
+  // If the user needs optimized coefficients
+  if (optimize_coefficients_)
+  {
+    Eigen::VectorXf coeff_refined (model_->getModelSize ());
+    // Without sort, the output is not similar to CPU
+    std::sort(inliers.indices.begin(), inliers.indices.end());
+    model_->optimizeModelCoefficients (inliers.indices, coeff, coeff_refined);
+    model_coefficients.values.resize (coeff_refined.size ());
+    memcpy (&model_coefficients.values[0], &coeff_refined[0], coeff_refined.size () * sizeof (float));
+    // Refine inliers
+    model_->selectWithinDistance (coeff_refined, threshold_, inliers.indices);
+  }
+  else
+  {
+    model_coefficients.values.resize (coeff.size ());
+    memcpy (&model_coefficients.values[0], &coeff[0], coeff.size () * sizeof (float));
+  }
+
+  deinitCompute ();
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> bool
+SACSegmentation<PointT>::initSACModel (const int model_type)
+{
+  if (model_)
+    model_.reset ();
+
+  // Build the model
+  switch (model_type)
+  {
+    case SACMODEL_PLANE:
+    {
+      PCL_DEBUG ("[pcl::%s::initSACModel] Using a model of type: SACMODEL_PLANE\n", getClassName ().c_str ());
+      model_.reset (new SampleConsensusModelPlane<PointT> (input_, *indices_, random_));
+      break;
+    }
+    default:
+    {
+      PCL_ERROR ("[pcl::%s::initSACModel] No valid model given!\n", getClassName ().c_str ());
+      return (false);
+    }
+  }
+  return (true);
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointT> void
+SACSegmentation<PointT>::initSAC (const int method_type)
+{
+  if (sac_)
+    sac_.reset ();
+  // Build the sample consensus method
+  switch (method_type)
+  {
+    case pcl::oneapi::SAC_RANSAC:
+    default:
+    {
+      PCL_DEBUG ("[pcl::%s::initSAC] Using a method of type: SAC_RANSAC with a model threshold of %f\n", getClassName ().c_str (), threshold_);
+      sac_.reset (new RandomSampleConsensus<PointT> (model_, threshold_));
+      break;
+    }
+  }
+  // Set the Sample Consensus parameters if they are given/changed
+  if (sac_->getProbability () != probability_)
+  {
+    PCL_DEBUG ("[pcl::%s::initSAC] Setting the desired probability to %f\n", getClassName ().c_str (), probability_);
+    sac_->setProbability (probability_);
+  }
+  if (max_iterations_ != -1 && sac_->getMaxIterations () != max_iterations_)
+  {
+    PCL_DEBUG ("[pcl::%s::initSAC] Setting the maximum number of iterations to %d\n", getClassName ().c_str (), max_iterations_);
+    sac_->setMaxIterations (max_iterations_);
+  }
+  if (samples_radius_ > 0.)
+  {
+    PCL_DEBUG ("[pcl::%s::initSAC] Setting the maximum sample radius to %f\n", getClassName ().c_str (), samples_radius_);
+    // Set maximum distance for radius search during random sampling
+    model_->setSamplesMaxDist (samples_radius_);
+  }
+  if (sac_->getNumberOfThreads () != threads_)
+  {
+    PCL_DEBUG ("[pcl::%s::initSAC] Setting the number of threads to %i\n", getClassName ().c_str (), threads_);
+    sac_->setNumberOfThreads (threads_);
+  }
+}
+
+} // namespace oneapi
+} // namespace pcl
+
+
+
+#define PCL_INSTANTIATE_SACSegmentation(T) template class PCL_EXPORTS pcl::oneapi::SACSegmentation<T>;
+
+#endif        // PCL_ONEAPI_SEGMENTATION_IMPL_SAC_SEGMENTATION_H_
+
diff --git a/oneapi/segmentation/include/pcl/oneapi/segmentation/sac_segmentation.h b/oneapi/segmentation/include/pcl/oneapi/segmentation/sac_segmentation.h
new file mode 100644
index 000000000..2d66e3ab0
--- /dev/null
+++ b/oneapi/segmentation/include/pcl/oneapi/segmentation/sac_segmentation.h
@@ -0,0 +1,302 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2009, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+#include <pcl/ModelCoefficients.h>
+#include <pcl/oneapi/PointIndices.h>
+#include <pcl/pcl_exports.h>
+
+// Sample Consensus methods
+#include <pcl/oneapi/sample_consensus/method_types.h>
+#include <pcl/oneapi/sample_consensus/sac.h>
+
+// Sample Consensus models
+#include <pcl/oneapi/sample_consensus/model_types.h>
+#include <pcl/oneapi/sample_consensus/sac_model.h>
+
+//using namespace pcl;
+//using namespace pcl::oneapi;
+
+namespace pcl
+{
+namespace oneapi
+{
+  /** \brief @b SACSegmentation represents the Nodelet segmentation class for
+    * Sample Consensus methods and models, in the sense that it just creates a
+    * Nodelet wrapper for generic-purpose SAC-based segmentation.
+    * \author Radu Bogdan Rusu
+    * \ingroup segmentation
+    */
+  template <typename PointT>
+  class SACSegmentation : public PCLBase<PointT>
+  {
+    using PCLBase<PointT>::initCompute;
+    using PCLBase<PointT>::deinitCompute;
+
+     public:
+      using PCLBase<PointT>::input_;
+      using PCLBase<PointT>::indices_;
+
+      using PointCloud = pcl::PointCloud<PointT>;
+      using PointCloudPtr = typename PointCloud::Ptr;
+      using PointCloudConstPtr = typename PointCloud::ConstPtr;
+
+      using SampleConsensusPtr = typename SampleConsensus<PointT>::Ptr;
+      using SampleConsensusModelPtr = typename SampleConsensusModel<PointT>::Ptr;
+
+      /** \brief Empty constructor. 
+        * \param[in] random if true set the random seed to the current time, else set to 12345 (default: false)
+        */
+      SACSegmentation (bool random = false)
+        : model_ ()
+        , sac_ ()
+        , model_type_ (-1)
+        , method_type_ (0)
+        , threshold_ (0)
+        , optimize_coefficients_ (true)
+        , radius_min_ (-std::numeric_limits<double>::max ())
+        , radius_max_ (std::numeric_limits<double>::max ())
+        , samples_radius_ (0.0)
+        , eps_angle_ (0.0)
+        , axis_ (Eigen::Vector3f::Zero ())
+        , max_iterations_ (50)
+        , threads_ (-1)
+        , probability_ (0.99)
+        , random_ (random)
+      {
+      }
+
+      /** \brief Empty destructor. */
+      ~SACSegmentation () { /*srv_.reset ();*/ };
+
+      /** \brief The type of model to use (user given parameter).
+        * \param[in] model the model type (check \a model_types.h)
+        */
+      inline void
+      setModelType (int model) { model_type_ = model; }
+
+      /** \brief Get the type of SAC model used. */
+      inline int
+      getModelType () const { return (model_type_); }
+
+      /** \brief Get a pointer to the SAC method used. */
+      inline SampleConsensusPtr
+      getMethod () const { return (sac_); }
+
+      /** \brief Get a pointer to the SAC model used. */
+      inline SampleConsensusModelPtr
+      getModel () const { return (model_); }
+
+      /** \brief The type of sample consensus method to use (user given parameter).
+        * \param[in] method the method type (check \a method_types.h)
+        */
+      inline void
+      setMethodType (int method) { method_type_ = method; }
+
+      /** \brief Get the type of sample consensus method used. */
+      inline int
+      getMethodType () const { return (method_type_); }
+
+      /** \brief Distance to the model threshold (user given parameter).
+        * \param[in] threshold the distance threshold to use
+        */
+      inline void
+      setDistanceThreshold (double threshold) { threshold_ = threshold; }
+
+      /** \brief Get the distance to the model threshold. */
+      inline double
+      getDistanceThreshold () const { return (threshold_); }
+
+      /** \brief Set the maximum number of iterations before giving up.
+        * \param[in] max_iterations the maximum number of iterations the sample consensus method will run
+        */
+      inline void
+      setMaxIterations (int max_iterations) { max_iterations_ = max_iterations; }
+
+      /** \brief Get maximum number of iterations before giving up. */
+      inline int
+      getMaxIterations () const { return (max_iterations_); }
+
+      /** \brief Set the probability of choosing at least one sample free from outliers.
+        * \param[in] probability the model fitting probability
+        */
+      inline void
+      setProbability (double probability) { probability_ = probability; }
+
+      /** \brief Get the probability of choosing at least one sample free from outliers. */
+      inline double
+      getProbability () const { return (probability_); }
+
+      /** \brief Set the number of threads to use or turn off parallelization.
+        * \param[in] nr_threads the number of hardware threads to use (0 sets the value automatically, a negative number turns parallelization off)
+        * \note Not all SAC methods have a parallel implementation. Some will ignore this setting.
+        */
+      inline void
+      setNumberOfThreads (const int nr_threads = -1) { threads_ = nr_threads; }
+
+      /** \brief Set to true if a coefficient refinement is required.
+        * \param[in] optimize true for enabling model coefficient refinement, false otherwise
+        */
+      inline void
+      setOptimizeCoefficients (bool optimize) { optimize_coefficients_ = optimize; }
+
+      /** \brief Get the coefficient refinement internal flag. */
+      inline bool
+      getOptimizeCoefficients () const { return (optimize_coefficients_); }
+
+      /** \brief Set the minimum and maximum allowable radius limits for the model (applicable to models that estimate
+        * a radius)
+        * \param[in] min_radius the minimum radius model
+        * \param[in] max_radius the maximum radius model
+        */
+      inline void
+      setRadiusLimits (const double &min_radius, const double &max_radius)
+      {
+        radius_min_ = min_radius;
+        radius_max_ = max_radius;
+      }
+
+      /** \brief Get the minimum and maximum allowable radius limits for the model as set by the user.
+        * \param[out] min_radius the resultant minimum radius model
+        * \param[out] max_radius the resultant maximum radius model
+        */
+      inline void
+      getRadiusLimits (double &min_radius, double &max_radius)
+      {
+        min_radius = radius_min_;
+        max_radius = radius_max_;
+      }
+
+      /** \brief Get maximum distance allowed when drawing random samples
+        *
+        * \param[out] radius the maximum distance (L2 norm)
+        */
+      inline void
+      getSamplesMaxDist (double &radius)
+      {
+        radius = samples_radius_;
+      }
+
+      /** \brief Set the axis along which we need to search for a model perpendicular to.
+        * \param[in] ax the axis along which we need to search for a model perpendicular to
+        */
+      inline void
+      setAxis (const Eigen::Vector3f &ax) { axis_ = ax; }
+
+      /** \brief Get the axis along which we need to search for a model perpendicular to. */
+      inline Eigen::Vector3f
+      getAxis () const { return (axis_); }
+
+      /** \brief Set the angle epsilon (delta) threshold.
+        * \param[in] ea the maximum allowed difference between the model normal and the given axis in radians.
+        */
+      inline void
+      setEpsAngle (double ea) { eps_angle_ = ea; }
+
+      /** \brief Get the epsilon (delta) model angle threshold in radians. */
+      inline double
+      getEpsAngle () const { return (eps_angle_); }
+
+      /** \brief Base method for segmentation of a model in a PointCloud given by <setInputCloud (), setIndices ()>
+        * \param[out] inliers the resultant point indices that support the model found (inliers)
+        * \param[out] model_coefficients the resultant model coefficients
+        */
+      virtual void
+      segment (PointIndicesDev &inliers, ModelCoefficients &model_coefficients);
+
+    protected:
+      /** \brief Initialize the Sample Consensus model and set its parameters.
+        * \param[in] model_type the type of SAC model that is to be used
+        */
+      virtual bool
+      initSACModel (const int model_type);
+
+      /** \brief Initialize the Sample Consensus method and set its parameters.
+        * \param[in] method_type the type of SAC method to be used
+        */
+      virtual void
+      initSAC (const int method_type);
+
+      /** \brief The model that needs to be segmented. */
+      SampleConsensusModelPtr model_;
+
+      /** \brief The sample consensus segmentation method. */
+      SampleConsensusPtr sac_;
+
+      /** \brief The type of model to use (user given parameter). */
+      int model_type_;
+
+      /** \brief The type of sample consensus method to use (user given parameter). */
+      int method_type_;
+
+      /** \brief Distance to the model threshold (user given parameter). */
+      double threshold_;
+
+      /** \brief Set to true if a coefficient refinement is required. */
+      bool optimize_coefficients_;
+
+      /** \brief The minimum and maximum radius limits for the model. Applicable to all models that estimate a radius. */
+      double radius_min_, radius_max_;
+
+      /** \brief The maximum distance of subsequent samples from the first (radius search) */
+      double samples_radius_;
+
+      /** \brief The maximum allowed difference between the model normal and the given axis. */
+      double eps_angle_;
+
+      /** \brief The axis along which we need to search for a model perpendicular to. */
+      Eigen::Vector3f axis_;
+
+      /** \brief Maximum number of iterations before giving up (user given parameter). */
+      int max_iterations_;
+
+      /** \brief The number of threads the scheduler should use, or a negative number if no parallelization is wanted. */
+      int threads_;
+
+      /** \brief Desired probability of choosing at least one sample free from outliers (user given parameter). */
+      double probability_;
+
+      /** \brief Set to true if we need a random seed. */
+      bool random_;
+
+      /** \brief Class get name method. */
+      virtual std::string
+      getClassName () const { return ("SACSegmentation"); }
+  };
+} // namespace oneapi
+} // namespace pcl
+
+
+
diff --git a/oneapi/segmentation/src/sac_segmentation.cpp b/oneapi/segmentation/src/sac_segmentation.cpp
new file mode 100644
index 000000000..e56d9cfd0
--- /dev/null
+++ b/oneapi/segmentation/src/sac_segmentation.cpp
@@ -0,0 +1,50 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2012, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of the copyright holder(s) nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+//#include <pcl/oneapi/segmentation/sac_segmentation.h>
+#include <pcl/oneapi/segmentation/impl/sac_segmentation.hpp>
+
+// Instantiations of specific point types
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+  PCL_INSTANTIATE(SACSegmentation, (pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGBA)(pcl::PointXYZRGB)(pcl::PointXYZRGBNormal))
+#else
+  PCL_INSTANTIATE(SACSegmentation, PCL_XYZ_POINT_TYPES)
+#endif
diff --git a/oneapi/surface/CMakeLists.txt b/oneapi/surface/CMakeLists.txt
new file mode 100644
index 000000000..fe09ffce4
--- /dev/null
+++ b/oneapi/surface/CMakeLists.txt
@@ -0,0 +1,44 @@
+set(SUBSYS_NAME oneapi_surface)
+set(SUBSYS_PATH oneapi/surface)
+set(SUBSYS_DESC "Point cloud oneAPI surface library")
+set(SUBSYS_DEPS common oneapi_common oneapi_kdtree kdtree surface)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(incs
+  "include/pcl/oneapi/surface/mls.h"
+  "include/pcl/oneapi/surface/processing.h"
+)
+
+set(impl_incs
+  "include/pcl/oneapi/surface/impl/processing.hpp"
+)
+
+set(srcs
+  src/mls.cpp
+)
+
+if(WIN32)
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qiopenmp -Qopenmp-targets=spir64")
+else()
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fiopenmp -fopenmp-targets=spir64")
+endif()
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+include_directories("${CMAKE_CURRENT_SOURCE_DIR}/include" "${CMAKE_CURRENT_SOURCE_DIR}/src" "${CMAKE_CURRENT_SOURCE_DIR}/src/dpcpp" "${CMAKE_CURRENT_SOURCE_DIR}/../containers/include" "${CMAKE_CURRENT_SOURCE_DIR}/../utils/include"  "${CMAKE_CURRENT_SOURCE_DIR}/../common/include")
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs})
+target_link_libraries("${LIB_NAME}" pcl_oneapi_common pcl_oneapi_kdtree pcl_kdtree pcl_oneapi_search pcl_search pcl_surface)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}" ${incs})
+PCL_ADD_INCLUDES("${SUBSYS_NAME}" "${SUBSYS_PATH}/impl" ${impl_incs})
diff --git a/oneapi/surface/include/pcl/oneapi/surface/convex_hull.h b/oneapi/surface/include/pcl/oneapi/surface/convex_hull.h
new file mode 100644
index 000000000..8211591e2
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/convex_hull.h
@@ -0,0 +1,76 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/pcl_macros.h>
+#include <pcl/point_types.h>
+
+#include <memory>
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    class PCL_EXPORTS PseudoConvexHull3D
+    {
+    public:
+
+      using PointType = pcl::PointXYZ;
+      using Cloud = pcl::oneapi::DeviceArray<PointType>;
+      
+
+      PseudoConvexHull3D(std::size_t buffer_size);
+      ~PseudoConvexHull3D();
+	        
+      void
+      reconstruct (const Cloud &points, Cloud &output);
+
+      void 
+      reduce(const Cloud &points, Cloud &output);
+
+    private:
+      
+      struct Impl;
+      std::shared_ptr<Impl> impl_;
+
+      void
+      reconstruct (const Cloud &points, DeviceArray2D<int>& vertexes);  
+    };
+  }
+}
diff --git a/oneapi/surface/include/pcl/oneapi/surface/device/mls.hpp b/oneapi/surface/include/pcl/oneapi/surface/device/mls.hpp
new file mode 100644
index 000000000..fb7cd9a66
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/device/mls.hpp
@@ -0,0 +1,280 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef PCL_ONEAPI_DEVICE_MLS_HPP_
+#define PCL_ONEAPI_DEVICE_MLS_HPP_
+
+#include <pcl/oneapi/common/device/eigen.h>
+
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+namespace pcl
+{
+namespace oneapi
+{
+namespace device
+{
+  /** \brief Data structure used to store the MLS polynomial partial derivatives */
+  struct PolynomialPartialDerivative
+  {
+    float z;    /**< \brief The z component of the polynomial evaluated at z(u, v). */
+    float z_u;  /**< \brief The partial derivative dz/du. */
+    float z_v;  /**< \brief The partial derivative dz/dv. */
+    float z_uu; /**< \brief The partial derivative d^2z/du^2. */
+    float z_vv; /**< \brief The partial derivative d^2z/dv^2. */
+    float z_uv; /**< \brief The partial derivative d^2z/dudv. */
+  };
+
+  __device_inline__ void getMLSCoordinates (const float3& pt, const float3& mean, const float3& u_axis,
+     const float3& v_axis, const float3& plane_normal,  float& u, float& v, float& w)
+  {
+    vec3f delta = pt - mean;
+    u = delta.dot (u_axis);
+    v = delta.dot (v_axis);
+    w = delta.dot (plane_normal);
+  }
+
+
+ /** \brief Calculate the polynomial's first and second partial derivatives.
+  * \param[in] u The u-coordinate of the point in local MLS frame.
+  * \param[in] v The v-coordinate of the point in local MLS frame.
+  * \return The polynomial partial derivatives at the provided uv coordinates.
+  */
+  __device_inline__
+  PolynomialPartialDerivative getPolynomialPartialDerivative(const float u, const float v,
+     const int order, const int map_idx, const nd_item<1> it, global_ptr<float> &cvec,
+      local_ptr<float> &buf)
+  {
+    const int local_id = it.get_local_id(0);
+    PolynomialPartialDerivative d = {0.0f,0.0f,0.0f,0.0f,0.0f,0.0f};
+    const int u_pow = local_id*(order+2)*2;
+    const int v_pow = local_id*(order+2)*2 + order+2;
+    const int local_c_idx = v_pow + order + 2;
+    const int nr_coeff = (order + 1) *  (order + 2) / 2;
+    const int c_idx = map_idx * nr_coeff;
+
+    int j = 0;
+    buf[u_pow] = 1;   //u_pow
+    buf[v_pow] = 1; //v_pow
+
+    for (int i = 0; i < nr_coeff; i++)
+    {
+      buf[local_c_idx + i] = cvec[c_idx + i];
+    }
+
+    for (int ui = 0; ui <= order; ++ui)
+    {
+      for (int vi = 0; vi <= order - ui; ++vi)
+      {
+        // Compute displacement along normal
+        d.z += buf[u_pow + ui] * buf[v_pow + vi] * buf[local_c_idx + j];
+
+        // Compute partial derivatives
+        if (ui >=1)
+          d.z_u += buf[local_c_idx + j] * ui * buf[u_pow + ui - 1] * buf[v_pow + vi];
+
+        if (vi >= 1)
+          d.z_v += buf[local_c_idx + j] * vi * buf[u_pow + ui] * buf[v_pow + vi - 1];
+
+        if (ui >= 1 && vi >= 1)
+          d.z_uv += buf[local_c_idx + j] * ui * buf[u_pow + ui - 1] * vi * buf[v_pow + vi - 1];
+
+        if (ui >= 2)
+          d.z_uu += buf[local_c_idx + j] * ui * (ui - 1) * buf[u_pow + ui - 2] * buf[v_pow + vi];
+
+        if (vi >= 2)
+          d.z_vv += buf[local_c_idx + j] * vi * (vi - 1) * buf[u_pow + ui] * buf[v_pow + vi - 2];
+
+        if (ui == 0)
+          buf[v_pow + vi + 1] = buf[v_pow + vi] * v;
+
+         ++j;
+      }
+      buf[u_pow + ui + 1] = buf[u_pow + ui]* u;
+    }
+    return d;
+  }
+
+  /** \brief Project a point onto the MLS plane.
+    * \param[in] u The u-coordinate of the point in local MLS frame.
+    * \param[in] v The v-coordinate of the point in local MLS frame.
+    * \return The ProjectionResults for the input data.
+    */
+  __device_inline__
+  void projectPointToMLSPlane(const float3& mean, const float3& u_axis, const float3 &v_axis,
+      const float3& plane_normal, const float u, const float v, MLSResult::ProjectionResults &result)
+  {
+    result.u = u;
+    result.v = v;
+    result.normal = plane_normal;
+    result.point = mean + u * u_axis + v * v_axis;
+  }
+
+  /** \brief Project a point along the MLS plane normal to the polynomial surface.
+    * \param[in] u The u-coordinate of the point in local MLS frame.
+    * \param[in] v The v-coordinate of the point in local MLS frame.
+    * \return The ProjectionResults for the input data.
+    * \note If the MLSResults does not contain polynomial data it projects the point onto the mls plane.
+    */
+  __device_inline__
+  void projectPointSimpleToPolynomialSurface(const float3& mean, const float3& u_axis, const float3 &v_axis,
+      const float3& plane_normal, global_ptr<float> &cvec, local_ptr<float> &derivativeBuf, const nd_item<1> it,
+      const int order, const int map_idx, const float u, const float v, MLSResult::ProjectionResults &result)
+  {
+    const int nr_coeff = (order + 1) *  (order + 2) / 2;
+    float w = 0.0f;
+
+    result.u = u;
+    result.v = v;
+    result.normal = plane_normal;
+
+    if ((map_idx != -1) && (sycl::isfinite(cvec[map_idx * nr_coeff])))
+    {
+      const PolynomialPartialDerivative d = getPolynomialPartialDerivative(u, v, order,
+                                            map_idx, it, cvec, derivativeBuf);
+
+      w = d.z;
+
+      vec3f normal (result.normal);
+      normal -= (d.z_u * u_axis + d.z_v * v_axis);
+      normal.normalize();
+
+      result.normal = normal;
+    }
+    // need to move this out or only check 
+    result.point = mean + u * u_axis + v * v_axis + w * plane_normal;
+  }
+
+  /** \brief Project a point orthogonal to the polynomial surface.
+   * \param[in] u The u-coordinate of the point in local MLS frame.
+   * \param[in] v The v-coordinate of the point in local MLS frame.
+   * \param[in] w The w-coordinate of the point in local MLS frame.
+   * \return The ProjectionResults for the input data.
+   * \note If the MLSResults does not contain polynomial data it projects the point onto the mls plane.
+   * \note If the optimization diverges it performs a simple projection on to the polynomial surface.
+   * \note This was implemented based on this https://math.stackexchange.com/questions/1497093/shortest-distance-between-point-and-surface
+   */
+  __device_inline__
+  void projectPointOrthogonalToPolynomialSurface(const float3& mean, const float3& u_axis, const float3 &v_axis,
+      const float3& plane_normal, global_ptr<float> &cvec, local_ptr<float> &derivativeBuf, const nd_item<1> it,
+      const int order, const float u, const float v, const float w, MLSResult::ProjectionResults &result, const int& map_idx)
+  {
+    float gu = u;
+    float gv = v;
+    float gw = 0.0f;
+    const int nr_coeff = (order + 1) *  (order + 2) / 2;
+    const int MAX_ITERATIONS = 10;
+
+    result.normal = plane_normal;
+    if ((map_idx != -1) && (sycl::isfinite(cvec[map_idx * nr_coeff])))
+    {
+      vec3f normal = plane_normal;
+
+      PolynomialPartialDerivative d = getPolynomialPartialDerivative(gu, gv, order,
+                                      map_idx, it, cvec, derivativeBuf);
+
+      gw = d.z;
+
+      float err_total = 0.0f;
+      const float dist1 = sycl::fabs(gw - w);
+      float dist2;
+
+      int iteration = 0;
+
+      do
+      {
+        const float e1 = (gu - u) + d.z_u * gw - d.z_u * w;
+        const float e2 = (gv - v) + d.z_v * gw - d.z_v * w;
+
+        const float F1u = 1 + d.z_uu * gw + d.z_u * d.z_u - d.z_uu * w;
+        const float F1v = d.z_uv * gw + d.z_u * d.z_v - d.z_uv * w;
+
+        const float F2u = d.z_uv * gw + d.z_v * d.z_u - d.z_uv * w;
+        const float F2v = 1 + d.z_vv * gw + d.z_v * d.z_v - d.z_vv * w;
+
+        matrix2x2f J;
+        J[0].x() = F1u;
+        J[1].x() = F1v;
+        J[0].y() = F2u;
+        J[1].y() = F2v;
+
+        const vec2f err (e1, e2);
+        vec2f update = J.inverse2x2() * err;
+
+        gu -= update.x();
+        gv -= update.y();
+
+        d = getPolynomialPartialDerivative(gu, gv, order, map_idx, it, cvec, derivativeBuf);
+        gw = d.z;
+        dist2 = sycl::sqrt ((gu - u) * (gu - u) + (gv - v) * (gv - v) + (gw - w) * (gw - w));
+
+        err_total = sycl::sqrt (e1 * e1 + e2 * e2);
+
+        if ((iteration > MAX_ITERATIONS) ||
+            (sycl::fabs(e1*e1) < std::numeric_limits<float>::min()) ||
+            (sycl::fabs(e2*e2) < std::numeric_limits<float>::min()))
+             break;
+
+        iteration++;
+
+      } while ((err_total > 1e-8f) && (dist2 < dist1));
+
+      if (dist2 > dist1) // the optimization was diverging reset the coordinates for simple projection
+      {
+        gu = u;
+        gv = v;
+        d = getPolynomialPartialDerivative(u, v, order, map_idx, it, cvec, derivativeBuf);
+        gw = d.z;
+      }
+
+      normal.data -= (d.z_u * u_axis + d.z_v * v_axis);
+      normal.normalize();
+
+      result.u = gu;
+      result.v = gv;
+      result.normal = normal;
+    }
+    result.point = mean + gu * u_axis + gv * v_axis + gw * plane_normal;
+  }
+
+}; // namespace device
+}; // namespace oneapi
+}; // namespace pcl
+
+
+#endif // PCL_ONEAPI_DEVICE_MLS_HPP_
diff --git a/oneapi/surface/include/pcl/oneapi/surface/impl/mls.hpp b/oneapi/surface/include/pcl/oneapi/surface/impl/mls.hpp
new file mode 100644
index 000000000..b14089d43
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/impl/mls.hpp
@@ -0,0 +1,1379 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifndef PCL_ONEAPI_SURFACE_IMPL_MLS_HPP_
+#define PCL_ONEAPI_SURFACE_IMPL_MLS_HPP_
+
+#include <pcl/oneapi/surface/mls.h>
+#include <pcl/oneapi/surface/device/mls.hpp>
+#include <pcl/oneapi/common/device/centroid.h>
+#include <pcl/oneapi/utils/common.h>
+#include <pcl/oneapi/common/common.h> // for getMinMax3D
+
+#include <Eigen/LU>
+
+#define GET_BLOCK_SIZE(t, blk) (t + blk - 1)/blk*blk
+#define ROUND_UP(x, m) ((x) + (m - 1)) / m
+
+using namespace sycl;
+
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::process(PointCloudOut &output)
+{
+  // Reset or initialize the collection of indices
+  corresponding_input_indices_ = std::make_shared<PointIndices>();
+
+  // Check if normals have to be computed/saved
+  if (compute_normals_)
+  {
+    normals_ = std::make_shared<NormalCloud>();
+    // Copy the header
+    normals_->header = input_->header;
+    // Clear the fields in case the method exits before computation
+    normals_->width = normals_->height = 0;
+    normals_->points.clear ();
+  }
+
+  output.header = input_->header;
+  output.width = output.height = 0;
+  output.clear();
+
+
+  if (search_radius_ <= 0 || sqr_gauss_param_ <= 0)
+  {
+   // PCL_ERROR ("[pcl::%s::process] Upsample method was set to DISTINCT_CLOUD, but no distinct cloud was specified.\n", getClassName.c_str());
+    return;
+  }
+
+  if (!initCompute())
+    return;
+
+  // Initialize the spatial locator
+  if (!tree_)
+  {
+    setSearchMethod(std::make_shared<pcl::oneapi::KdTreeFLANN<PointInT>>(false));
+    setSearchRadius(search_radius_);
+  }
+
+
+  switch (upsample_method_)
+  {
+    // Initialize random number generator if necessary
+    case (RANDOM_UNIFORM_DENSITY):
+    {
+      std::random_device rd;
+      rng_.seed (rd());
+      const double tmp = search_radius_ / 2.0;
+      rng_uniform_distribution_.reset (new std::uniform_real_distribution<> (-tmp, tmp));
+
+      break;
+    }
+    case (VOXEL_GRID_DILATION):
+    case (DISTINCT_CLOUD):
+    default:
+      break;
+  }
+
+  // Perform the actual surface reconstruction
+  performProcessing (output);
+
+  if (compute_normals_)
+  {
+    normals_->height = 1;
+    normals_->width = normals_->size ();
+
+    for (std::size_t i = 0; i < output.size (); ++i)
+    {
+      using FieldList = typename pcl::traits::fieldList<PointOutT>::type;
+      pcl::for_each_type<FieldList> (SetIfFieldExists<PointOutT, float> (output[i], "normal_x", (*normals_)[i].normal_x));
+      pcl::for_each_type<FieldList> (SetIfFieldExists<PointOutT, float> (output[i], "normal_y", (*normals_)[i].normal_y));
+      pcl::for_each_type<FieldList> (SetIfFieldExists<PointOutT, float> (output[i], "normal_z", (*normals_)[i].normal_z));
+      pcl::for_each_type<FieldList> (SetIfFieldExists<PointOutT, float> (output[i], "curvature", (*normals_)[i].curvature));
+    }
+  }
+
+  // Set proper widths and heights for the clouds
+  output.height = 1;
+  output.width = output.size();
+
+  deinitCompute();
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::computeMLSPointNormal (const PointCloudDevInConstPtr &cloud,
+                                                                     const std::vector<int> &nn_indices,
+                                                                     const std::vector<int> &nn_splits,
+                                                                     const std::vector<int> &nn_query_indices,
+                                                                     PointCloudOut &projected_points,
+                                                                     NormalCloud &projected_points_normals,
+                                                                     PointIndices &corresponding_input_indices,
+                                                                     MLSResult &mls_result)
+{
+
+  mls_result.setDevice(dpct::get_default_queue());
+  mls_result.convertQueryBuffer(*cloud, nn_query_indices);
+  mls_result.computeMLSSurface(*cloud, nn_indices, nn_splits, search_radius_, order_);
+
+  switch(upsample_method_)
+  {
+    case (NONE):
+    {
+      DeviceArray<MLSResult::ProjectionResults> proj;
+      mls_result.projectQueryPoint(projection_method_, proj);
+      addProjectedPointNormal(proj, DeviceArray<int>(),  mls_result.curvature_, projected_points,
+          projected_points_normals, corresponding_input_indices);
+      break;
+    }
+    case (SAMPLE_LOCAL_PLANE):
+    {
+      std::vector<MLSResult::Displacement> disp_vec;
+
+      // Uniformly sample a circle around the query point using the radius and step parameters
+      for (float u_disp = -static_cast<float> (upsampling_radius_); u_disp <= upsampling_radius_; u_disp += static_cast<float> (upsampling_step_))
+        for (float v_disp = -static_cast<float> (upsampling_radius_); v_disp <= upsampling_radius_; v_disp += static_cast<float> (upsampling_step_))
+          if (u_disp * u_disp + v_disp * v_disp < upsampling_radius_ * upsampling_radius_)
+          {
+              disp_vec.push_back({u_disp, v_disp});
+          }
+
+      DeviceArray<MLSResult::Displacement> disp_array (disp_vec.size());
+
+      disp_array.upload(disp_vec);
+
+      DeviceArray<MLSResult::ProjectionResults> proj;
+      mls_result.projectPointSimpleToPolynomialSurface(proj, disp_array);
+
+      query_map_.create(proj.size());
+
+      for (int i = 0; i < nn_splits.size(); i++)
+      {
+        for (int j = 0; j < disp_vec.size(); j++)
+        {
+          query_map_[i*disp_vec.size() + j] = i;
+        }
+      }
+
+      addProjectedPointNormal(proj, query_map_, mls_result.curvature_, projected_points,
+          projected_points_normals, corresponding_input_indices);
+
+      break;
+    }
+    case (RANDOM_UNIFORM_DENSITY):
+    {
+      // Compute the local point density and add more samples if necessary
+      DeviceArray<int> num_points_to_add(nn_splits.size(), pcl::oneapi::SHARED_MEMORY);
+      int total_points = 0;
+
+      for (int i = 0; i < nn_splits.size(); i++)
+      {
+        num_points_to_add[i] = static_cast<int> (std::floor (desired_num_points_in_radius_ / 2.0
+              / static_cast<double> ( mls_result.num_neighbors_[i])));
+        if (num_points_to_add[i] <= 0)
+          total_points++;
+        else
+          total_points += num_points_to_add[i];
+      }
+
+      // Expand all the projection selection to ease projectedpoint buffer calculation
+      density_map_.create(total_points);
+      query_map_.create(total_points);
+      random_u_.create(total_points);
+      random_v_.create(total_points);
+
+      for (int i = 0, j=0; i < nn_splits.size(); i++)
+      {
+        if (num_points_to_add[i] <= 0)
+        {
+          density_map_[j] = -1;
+          query_map_[j] = i;
+          j++;
+        }
+        else
+        {
+          for (int num_added = 0; num_added < num_points_to_add[i];)
+          {
+            const double u = (*rng_uniform_distribution_) (rng_);
+            const double v = (*rng_uniform_distribution_) (rng_);
+
+            // Check if inside circle; if not, try another coin flip
+            if (u * u + v * v > search_radius_ * search_radius_ / 4)
+              continue;
+
+            random_u_[j] = u;
+            random_v_[j] = v;
+
+            density_map_[j] = mls_result.num_neighbors_[i];
+            query_map_[j] = i;
+
+            num_added++;
+            j++;
+          }
+        }
+      }
+
+      DeviceArray<MLSResult::ProjectionResults> proj;
+      mls_result.projectRandomUniformDensity(projection_method_, density_map_, query_map_, random_u_, random_v_, proj);
+      // need to pass the query_map into below
+      addProjectedPointNormal(proj, query_map_, mls_result.curvature_, projected_points, projected_points_normals, corresponding_input_indices);
+      break;
+    }
+
+    default:
+      break;
+  }
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::performProcessing (PointCloudOut &output)
+{
+  // Compute the number of coefficients
+  nr_coeff_ = (order_ + 1) * (order_ + 2) / 2;
+
+
+  DeviceArray<int> raw_indices;
+  DeviceArray<float> raw_dists;
+  DeviceArray<int> raw_splits;
+
+  tree_->setSortedResults(false);
+
+  unsigned int remain_query_size = (*input_).size();
+  unsigned int start = 0;
+  unsigned int end  = 0;
+
+  while (remain_query_size > 0)
+  {
+    const int process_size = (remain_query_size / block_size_ > 0) ? block_size_ : remain_query_size % block_size_ ;
+    end += process_size;
+
+    remain_query_size -= process_size;
+
+    tree_->fixedRadiusSearch(input_, raw_indices, raw_dists, raw_splits, start, end);
+
+    std::vector<int> nn_indices;
+    std::vector<int> nn_splits;
+    std::vector<int> nn_valid_indices;
+
+    nn_indices.reserve(raw_indices.size());
+    nn_splits.reserve(raw_splits.size());
+    nn_valid_indices.reserve(raw_splits.size());
+    valid_.resize(raw_splits.size());
+    nn_indices_remap_.resize(raw_splits.size());
+
+    // Only need indices size >= 3
+    int cur_index = 0;
+    int split_index = 0;
+    for (int i = 0; i < raw_splits.size(); ++i)
+    {
+      int num_neighbors;
+      num_neighbors =  (i < raw_splits.size() - 1) ? raw_splits[i+1] - raw_splits[i] : raw_splits.size() - raw_splits[i];
+      nn_indices_remap_.at(i) = split_index;
+      if (num_neighbors >= 3)
+      {
+        cur_index += num_neighbors;
+        nn_splits.emplace_back(cur_index);
+        nn_valid_indices.emplace_back(i + start);
+        valid_.at(i) = true;
+        nn_indices.insert(nn_indices.end(), raw_indices + raw_splits[i], 
+          raw_indices + raw_splits[i+1]);
+        split_index++;
+      }
+      else
+      {
+        valid_.at(i) = false;
+      }
+    }
+
+    PointCloudOut projected_points;
+    NormalCloud projected_points_normals;
+
+    if (!nn_indices.empty() && !nn_splits.empty())
+    {
+      computeMLSPointNormal(input_, nn_indices, nn_splits, nn_valid_indices, projected_points,
+        projected_points_normals, *corresponding_input_indices_, mls_results_);
+
+
+      output.insert(output.end(), projected_points.begin(), projected_points.end());
+
+      if (compute_normals_)
+        normals_->insert (normals_->end (), projected_points_normals.begin(), projected_points_normals.end ());
+
+      // Perform the distinct-cloud or voxel-grid upsampling
+      performUpsampling (output);
+    }
+
+    nn_indices_remap_.clear();
+    start = end;
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::performUpsampling (PointCloudOut &output)
+{
+
+  if (upsample_method_ == DISTINCT_CLOUD)
+  {
+    typename pcl::PointCloud<PointInT>::Ptr finite_distinct_cloud =  std::make_shared<pcl::PointCloud<PointInT>>();
+
+    for (std::size_t dp_i = 0; dp_i < distinct_cloud_->size(); ++dp_i)
+    {
+       // Distinct cloud may have nan points, skip them
+       if (!std::isfinite ((*distinct_cloud_)[dp_i].x))
+         continue;
+       finite_distinct_cloud->points.push_back((*distinct_cloud_)[dp_i]);
+    }
+
+    finite_distinct_cloud->width = finite_distinct_cloud->points.size();
+    finite_distinct_cloud->height = 1;
+    finite_distinct_cloud->is_dense = true;
+
+    std::vector<std::vector<int>> nn_indices;
+    std::vector<std::vector<float>> nn_dists;
+    // This is using flann kdtree, instead of fixed radius tree
+    tree_->setInputCloud(input_);
+    tree_->nearestKSearch(finite_distinct_cloud, 1, nn_indices, nn_dists);
+
+    DeviceArray<sycl::float3> finite_distinct_cloud_d ( finite_distinct_cloud->width );
+    std::vector<int> input_index;
+    input_index.reserve(finite_distinct_cloud->width);
+
+    int pt_idx = 0;
+    for (auto it = nn_indices.begin(); it != nn_indices.end(); ++it)
+    {
+      if (valid_[it->front()] == false)
+        continue;
+
+      finite_distinct_cloud_d[pt_idx++] = sycl::float3(
+          finite_distinct_cloud->points[it - nn_indices.begin()].x,
+          finite_distinct_cloud->points[it - nn_indices.begin()].y,
+          finite_distinct_cloud->points[it - nn_indices.begin()].z);
+
+      input_index.push_back(nn_indices_remap_.at(it->front()));
+    }
+
+    DeviceArray<int> d_input_index (input_index.size());
+    d_input_index.upload(input_index);
+
+    DeviceArray<MLSResult::ProjectionResults> proj;
+    mls_results_.projectPoint(finite_distinct_cloud_d, d_input_index, projection_method_,
+        5 * nr_coeff_, proj);
+
+    addProjectedPointNormal(proj, d_input_index, mls_results_.curvature_, output, *normals_,
+        *corresponding_input_indices_);
+
+  }
+
+  // For the voxel grid upsampling method, generate the voxel grid and dilate it
+  // Then, project the newly obtained points to the MLS surface
+  if (upsample_method_ == VOXEL_GRID_DILATION)
+  {
+    corresponding_input_indices_ = std::make_shared<PointIndices>();
+
+    // Migrate later as std::map is not efficient in GPU
+    MLSVoxelGrid voxel_grid (input_, indices_, voxel_size_);
+    for (int iteration = 0; iteration < dilation_iteration_num_; ++iteration)
+      voxel_grid.dilate ();
+
+    typename pcl::PointCloud<PointInT>::Ptr voxel_cloud = std::make_shared<pcl::PointCloud<PointInT>>();
+    voxel_cloud->width = voxel_grid.voxel_grid_.size();
+    voxel_cloud->height = 1;
+    voxel_cloud->is_dense = true;
+    voxel_cloud->points.resize(voxel_cloud->width * voxel_cloud->height);
+
+    DeviceArray<sycl::float3> voxel_cloud_d ( voxel_cloud->width );
+
+    size_t cidx = 0;
+    for (typename MLSVoxelGrid::HashMap::iterator m_it = voxel_grid.voxel_grid_.begin (); m_it != voxel_grid.voxel_grid_.end (); ++m_it)
+    {
+      // Get 3D position of point
+      Eigen::Vector3f pos;
+      voxel_grid.getPosition (m_it->first, pos);
+
+      PointInT p;
+      p.x = pos[0];
+      p.y = pos[1];
+      p.z = pos[2];
+
+      voxel_cloud->points[cidx++] = p;
+    }
+
+    std::vector<std::vector<int>> nn_indices;
+    std::vector<std::vector<float>> nn_dists;
+    // This is using flann kdtree, instead of fixed radius tree
+    tree_->setInputCloud(input_);
+    tree_->nearestKSearch(voxel_cloud, 1, nn_indices, nn_dists);
+
+    std::vector<int> input_index;
+    input_index.reserve(voxel_cloud->width);
+
+    int pt_idx = 0;
+    for (auto it = nn_indices.begin(); it != nn_indices.end(); ++it)
+    {
+      if (valid_[it->front()] == false)
+        continue;
+
+      voxel_cloud_d[pt_idx++] = sycl::float3(
+          voxel_cloud->points[it - nn_indices.begin()].x,
+          voxel_cloud->points[it - nn_indices.begin()].y,
+          voxel_cloud->points[it - nn_indices.begin()].z);
+
+      input_index.push_back(nn_indices_remap_.at(it->front()));
+    }
+
+    DeviceArray<int> d_input_index (input_index.size());
+    d_input_index.upload(input_index);
+
+    DeviceArray<MLSResult::ProjectionResults> proj;
+    mls_results_.projectPoint(voxel_cloud_d, d_input_index, projection_method_,
+        5 * nr_coeff_, proj);
+
+    addProjectedPointNormal(proj, d_input_index, mls_results_.curvature_, output, *normals_,
+        *corresponding_input_indices_);
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::copyMissingFields (const PointInT &point_in,
+                                                                 PointOutT &point_out) const
+{
+  PointOutT temp = point_out;
+  copyPoint (point_in, point_out);
+  point_out.x = temp.x;
+  point_out.y = temp.y;
+  point_out.z = temp.z;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::addProjectedPointNormal (const pcl::oneapi::DeviceArray<MLSResult::ProjectionResults> proj,
+                                                                               const pcl::oneapi::DeviceArray<int> &query_map,
+                                                                               const pcl::oneapi::DeviceArray<float> &curvature,
+                                                                               PointCloudOut &projected_points,
+                                                                               NormalCloud &projected_points_normals,
+                                                                               PointIndices &corresponding_input_indices) const
+{
+  for (int i = 0; i < proj.size(); i++)
+  {
+    PointOutT aux;
+    int query_idx = (query_map.empty()) ? i : query_map[i];
+    aux.x = static_cast<float> (proj[i].point.x());
+    aux.y = static_cast<float> (proj[i].point.y());
+    aux.z = static_cast<float> (proj[i].point.z());
+
+    // Copy additional point information if available
+    copyMissingFields ((*input_)[query_idx], aux);
+
+    projected_points.emplace_back(aux);
+    corresponding_input_indices.indices.emplace_back (query_idx);
+
+    if (compute_normals_)
+    {
+      pcl::Normal aux_normal;
+      aux_normal.normal_x = static_cast<float> (proj[i].normal.x());
+      aux_normal.normal_y = static_cast<float> (proj[i].normal.y());
+      aux_normal.normal_z = static_cast<float> (proj[i].normal.z());
+      aux_normal.curvature = curvature[query_idx];
+      projected_points_normals.emplace_back (aux_normal);
+    }
+  }
+}
+
+Eigen::MatrixXd vector_to_eigen_matrix(float* data, int offset, int m, int n)
+{
+  auto begin = data + offset*m*m;
+  auto end = data + offset*m*m + n*m;
+
+  std::vector<float> new_data(begin, end);
+
+  return Eigen::MatrixXf::Map(new_data.data(), m, n).cast<double>();
+}
+
+Eigen::VectorXd vector_to_eigen_vector(float* data, int offset, int m, int n)
+{
+  auto begin = data + offset*m;
+  auto end = data + offset*m + n;
+
+  std::vector<float> new_data(begin, end);
+
+  return Eigen::VectorXf::Map(new_data.data(), n).cast<double>();
+}
+
+//void
+template<typename PointT> void
+pcl::oneapi::MLSResult::convertQueryBuffer( const pcl::oneapi::PointCloudDev<PointT> &cloud,
+                                            const std::vector<int> &query_indices)
+{
+  query_point_.create(query_indices.size());
+  for (int i = 0; i < query_indices.size(); ++i)
+  {
+    query_point_[i].x() = cloud[query_indices.at(i)].x;
+    query_point_[i].y() = cloud[query_indices.at(i)].y;
+    query_point_[i].z() = cloud[query_indices.at(i)].z;
+  }
+}
+
+void
+pcl::oneapi::MLSResult::projectRandomUniformDensity (ProjectionMethod method,
+                                                     const DeviceArray<int>& density_map,
+                                                     const DeviceArray<int>& query_map,
+                                                     const DeviceArray<float>& random_u,
+                                                     const DeviceArray<float>& random_v,
+                                                     DeviceArray<MLSResult::ProjectionResults>& proj)
+{
+  proj.create(density_map.size());
+
+  auto order = order_;
+  const int nr_coeff = (order + 1) * (order + 2) / 2;
+  const int slmSize =  (order + 2) * 2 + nr_coeff;
+  const int workitems = proj.size();
+  const size_t workitems_aligned = align(workitems, 32);
+
+  // Submit multiple kernels to run simulatenously to handle each case
+  // If using single kernel, many branching.  Unknown if single kernel have better performance or
+  // multiple
+
+  // handle projectQueryPoint ORTHOGONAL
+  if (method == ORTHOGONAL) {
+    q_.submit([&](handler &h) {
+      auto query_point_p = query_point_.ptr();
+      auto c_vec_p = c_vec_.ptr();
+      auto c_vec_map_p = c_vec_map_.ptr();
+      auto mean_p = mean_.ptr();
+      auto u_axis_p = u_axis_.ptr();
+      auto v_axis_p = v_axis_.ptr();
+      auto plane_normal_p = plane_normal_.ptr();
+      auto query_map_p = query_map.ptr();
+      auto density_map_p = density_map.ptr();
+      auto proj_p = proj.ptr();
+      local_accessor <float>  lDerivativeBuf(range(slmSize), h);
+      range global {workitems_aligned};
+      range local {1};
+      h.parallel_for(nd_range(global, local), [=](sycl::nd_item<1> it) {
+        int idx = it.get_global_linear_id();
+        if (idx < workitems)
+        {
+          if ((density_map_p[idx] == -1) && (method == ORTHOGONAL))
+          {
+            const int query_idx = query_map_p[idx];
+            const int map_idx = c_vec_map_p[query_idx];
+            if (map_idx != -1)
+            {
+              float u, v, w;
+
+              oneapi::device::getMLSCoordinates(query_point_p[query_idx], mean_p[query_idx],
+                u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx],
+                u, v, w);
+
+              local_ptr<float> powBuffer { local_ptr<float>(lDerivativeBuf) };
+              global_ptr<float> cvecBuffer { global_ptr<float>(c_vec_p) };
+
+              oneapi::device::projectPointOrthogonalToPolynomialSurface(mean_p[query_idx],
+                u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx], cvecBuffer,
+                powBuffer, it, order, u, v, w, proj_p[idx], map_idx);
+            }
+            else
+            {
+              proj_p[idx].normal = plane_normal_p[query_idx];
+              proj_p[idx].point = mean_p[query_idx];
+            }
+          }
+        }
+      });
+    });
+  } 
+  else
+  {
+    // handle projectQuery SIMPLE and NONE
+    q_.submit([&](handler &h) {
+      auto mean_p = mean_.ptr();
+      auto c_vec_p = c_vec_.ptr();
+      auto c_vec_map_p = c_vec_map_.ptr();
+      auto plane_normal_p = plane_normal_.ptr();
+      auto u_axis_p = u_axis_.ptr();
+      auto v_axis_p = v_axis_.ptr();
+      auto query_map_p = query_map.ptr();
+      auto density_map_p = density_map.ptr();
+      auto proj_p = proj.ptr();
+      h.parallel_for(workitems, [=](auto &idx) {
+        if ((density_map_p[idx] == -1) && (method == SIMPLE))
+        {
+          const int query_idx = query_map_p[idx];
+          const int map_idx = c_vec_map_p[query_idx];
+          const int nr_coeff = (order + 1) *  (order + 2) / 2;
+          const int cvec_index = map_idx * nr_coeff;
+          if (map_idx != -1)
+          {
+            vec3f normal;
+
+            proj_p[idx].point = mean_p[query_idx] + (c_vec_p[cvec_index] * plane_normal_p[query_idx]);
+
+            normal = plane_normal_p[query_idx] - c_vec_p[cvec_index + order + 1]  * u_axis_p[query_idx]
+                  - c_vec_p[cvec_index + 1] * v_axis_p[query_idx];
+
+            normal.normalize();
+            proj_p[idx].normal = normal;
+          }
+          else
+          {
+            proj_p[idx].normal = plane_normal_p[query_idx];
+            proj_p[idx].point = mean_p[query_idx];
+          }
+        }
+        else if ((density_map_p[idx] == -1) && (method == NONE))
+        {
+          const int query_idx = query_map_p[idx];
+          proj_p[idx].normal = plane_normal_p[query_idx];
+          proj_p[idx].point = mean_p[query_idx];
+        }
+      });
+    });
+  }
+
+  // handle random u and v
+  q_.submit([&](handler &h) {
+    auto mean_p = mean_.ptr();
+    auto c_vec_p = c_vec_.ptr();
+    auto c_vec_map_p = c_vec_map_.ptr();
+    auto plane_normal_p = plane_normal_.ptr();
+    auto u_axis_p = u_axis_.ptr();
+    auto v_axis_p = v_axis_.ptr();
+    auto query_map_p = query_map.ptr();
+    auto density_map_p = density_map.ptr();
+    auto random_u_p = random_u.ptr();
+    auto random_v_p = random_v.ptr();
+    auto proj_p = proj.ptr();
+    local_accessor <float> lDerivativeBuf(range(slmSize), h);
+    range global {workitems_aligned};
+    range local {1};
+    h.parallel_for(nd_range(global, local), [=](sycl::nd_item<1> it) {
+      const int idx = it.get_global_linear_id();
+      if ((idx < workitems) && (density_map_p[idx] != -1))
+        {
+          const int query_idx = query_map_p[idx];
+          if (order > 1 && density_map_p[idx] >= 5 * nr_coeff)
+          {
+            local_ptr<float> powBuffer { local_ptr<float>(lDerivativeBuf) };
+            global_ptr<float> cvecBuffer { global_ptr<float>(c_vec_p) };
+            const int map_idx = c_vec_map_p[query_idx];
+
+            oneapi::device::projectPointSimpleToPolynomialSurface(mean_p[query_idx],
+              u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx], cvecBuffer,
+              powBuffer, it, order, map_idx, random_u_p[idx], random_v_p[idx], proj_p[idx]);
+          }
+          else
+          {
+            oneapi::device::projectPointToMLSPlane(mean_p[query_idx], u_axis_p[query_idx],
+                v_axis_p[query_idx], plane_normal_p[query_idx], random_u_p[idx],
+                random_v_p[idx], proj_p[idx]);
+          }
+      }
+    });
+  });
+
+  q_.wait();
+}
+
+void
+pcl::oneapi::MLSResult::projectPointSimpleToPolynomialSurface (DeviceArray<MLSResult::ProjectionResults>& proj, 
+    const DeviceArray<MLSResult::Displacement> &disp)
+{
+  const int order = order_;
+  const int nr_coeff = (order + 1) * (order + 2) / 2;
+  const int slmSize =  (order + 2) * 2 + nr_coeff;
+  const int disp_size = disp.size();
+  const int workitems = query_count_;
+  const size_t workitems_aligned = align(workitems, 32);
+
+  proj.create(workitems * disp_size, &q_);
+
+  q_.submit([&](handler &h) {
+    auto c_vec_p = c_vec_.ptr();
+    auto c_vec_map_p = c_vec_map_.ptr();
+    auto mean_p = mean_.ptr();
+    auto u_axis_p = u_axis_.ptr();
+    auto v_axis_p = v_axis_.ptr();
+    auto disp_p = disp.ptr();
+    auto plane_normal_p = plane_normal_.ptr();
+    auto proj_p = proj.ptr();
+    local_accessor <float> lDerivativeBuf(range(slmSize), h);
+    range global {workitems_aligned};
+    range local {1};
+    h.parallel_for(nd_range(global, local), [=](sycl::nd_item<1> it) {
+      const int idx = it.get_global_linear_id();
+      if (idx < workitems)
+      {
+        const int map_idx = c_vec_map_p[idx];
+
+        local_ptr<float> powBuffer { local_ptr<float>(lDerivativeBuf) };
+        global_ptr<float> cvecBuffer { global_ptr<float>(c_vec_p) };
+
+        for (int i = 0; i < disp_size; i++)
+        {
+          oneapi::device::projectPointSimpleToPolynomialSurface(mean_p[idx],
+            u_axis_p[idx], v_axis_p[idx], plane_normal_p[idx], cvecBuffer,
+            powBuffer, it, order, map_idx, disp_p[i].u, disp_p[i].v,
+            proj_p[idx*disp_size + i]);
+        }
+      }
+    });
+  }).wait();
+
+}
+
+template<typename PointT> inline void
+pcl::oneapi::MLSResult::projectPoint (const DeviceArray<PointT> &point, const DeviceArray<int>& query_map,
+    const ProjectionMethod method, int required_neighbors, DeviceArray<ProjectionResults>& proj)
+{
+  auto order = order_;
+  const int nr_coeff = (order + 1) * (order + 2) / 2;
+  const int slmSize =  (order + 2) * 2 + nr_coeff;
+  const size_t work_items = query_map.size();
+  const size_t work_items_aligned = align(work_items, 32);
+
+  proj.create(work_items);
+  q_.submit([&](handler &h) {
+    auto point_p = point.ptr();
+    auto c_vec_p = c_vec_.ptr();
+    auto c_vec_map_p = c_vec_map_.ptr();
+    auto mean_p = mean_.ptr();
+    auto u_axis_p = u_axis_.ptr();
+    auto v_axis_p = v_axis_.ptr();
+    auto plane_normal_p = plane_normal_.ptr();
+    auto query_map_p = query_map.ptr();
+    auto num_neighbors_p = num_neighbors_.ptr();
+    auto proj_p = proj.ptr();
+    local_accessor <float> lDerivativeBuf(range(slmSize), h);
+    range global {work_items_aligned};
+    range local {1};
+    h.parallel_for(nd_range(global, local), [=](sycl::nd_item<1> it) {
+      int idx = it.get_global_linear_id();
+      if (idx < work_items)
+      {
+        const int query_idx = query_map_p[idx];
+        const int cvec_map_idx = c_vec_map_p[query_idx];
+        const int cvec_idx = cvec_map_idx * nr_coeff;
+
+        float u, v, w;
+
+        oneapi::device::getMLSCoordinates(point_p[idx], mean_p[query_idx],
+             u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx],
+             u, v, w);
+
+        if (order > 1 && num_neighbors_p[query_idx] >= required_neighbors &&
+            std::isfinite(c_vec_p[cvec_idx]) && (method != NONE))
+        {
+          local_ptr<float> powBuffer { local_ptr<float>(lDerivativeBuf) };
+          global_ptr<float> cvecBuffer { global_ptr<float>(c_vec_p) };
+          if (method == ORTHOGONAL)
+            oneapi::device::projectPointOrthogonalToPolynomialSurface(mean_p[query_idx],
+              u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx], cvecBuffer,
+              powBuffer, it, order, u, v, w, proj_p[idx], cvec_map_idx);
+           else
+            oneapi::device::projectPointSimpleToPolynomialSurface(mean_p[query_idx],
+              u_axis_p[query_idx], v_axis_p[query_idx], plane_normal_p[query_idx], cvecBuffer,
+              powBuffer, it, order, cvec_map_idx, u, v, proj_p[idx]);
+        }
+        else
+        {
+          oneapi::device::projectPointToMLSPlane(mean_p[query_idx], u_axis_p[query_idx],
+            v_axis_p[query_idx], plane_normal_p[query_idx], u, v, proj_p[idx]);
+
+        }
+      }
+    });
+  }).wait();
+}
+
+void
+pcl::oneapi::MLSResult::projectQueryPoint (ProjectionMethod method, DeviceArray<MLSResult::ProjectionResults>& proj)
+{
+  int order = order_;
+  proj.create(query_count_);
+
+  const int nr_coeff = (order + 1) * (order + 2) / 2;
+
+  if ( method != NONE)
+  {
+    if (method == ORTHOGONAL)
+    {
+      const int slmSize =  (order + 2) * 2 + nr_coeff;
+      const int workitems = mean_.size();
+      const size_t workitems_aligned = align(workitems, 32);
+
+      q_.submit([&](handler &h) {
+        auto query_pt_p = query_point_.ptr();
+        auto c_vec_p = c_vec_.ptr();
+        auto c_vec_map_p = c_vec_map_.ptr();
+        auto mean_p = mean_.ptr();
+        auto u_axis_p = u_axis_.ptr();
+        auto v_axis_p = v_axis_.ptr();
+        auto plane_normal_p = plane_normal_.ptr();
+        auto proj_p = proj.ptr();
+        local_accessor <float> lDerivativeBuf(range(slmSize), h);
+        range global {workitems_aligned};
+        range local {1};
+        h.parallel_for(nd_range(global, local), [=](sycl::nd_item<1> it) {
+          int idx = it.get_global_linear_id();
+          if (idx < workitems)
+          {
+            const int map_idx = c_vec_map_p[idx];
+            const int cvec_index = map_idx * nr_coeff;
+
+            if ((map_idx != -1) && (sycl::isfinite(c_vec_p[cvec_index])))
+            {
+              float u, v, w;
+              oneapi::device::getMLSCoordinates(query_pt_p[idx], mean_p[idx],
+                u_axis_p[idx], v_axis_p[idx], plane_normal_p[idx],
+                u, v, w);
+
+              local_ptr<float> powBuffer { local_ptr<float>(lDerivativeBuf) };
+              global_ptr<float> cvecBuffer { global_ptr<float>(c_vec_p) };
+
+              oneapi::device::projectPointOrthogonalToPolynomialSurface(mean_p[idx],
+                u_axis_p[idx], v_axis_p[idx], plane_normal_p[idx], cvecBuffer,
+                powBuffer, it, order, u, v, w, proj_p[idx], map_idx);
+            }
+            else
+            {
+              proj_p[idx].normal = plane_normal_p[idx];
+              proj_p[idx].point = mean_p[idx];
+            }
+          }
+        });
+      });
+    }
+    else // SIMPLE
+    {
+      q_.submit([&](handler &h) {
+        auto mean_p = mean_.ptr();
+        auto c_vec_p = c_vec_.ptr();
+        auto c_vec_map_p = c_vec_map_.ptr();
+        auto plane_normal_p = plane_normal_.ptr();
+        auto u_axis_p = u_axis_.ptr();
+        auto v_axis_p = v_axis_.ptr();
+        auto proj_p = proj.ptr();
+        h.parallel_for(mean_.size(), [=](auto &idx) {
+          const int map_idx = c_vec_map_p[idx];
+          const int nr_coeff = (order + 1) *  (order + 2) / 2;
+          const int cvec_index = map_idx * nr_coeff;
+          if ((map_idx != -1) && (sycl::isfinite(c_vec_p[cvec_index])))
+          {
+            vec3f normal;
+            proj_p[idx].point = mean_p[idx] + (c_vec_p[cvec_index] * plane_normal_p[idx]);
+
+            normal = plane_normal_p[idx] - c_vec_p[cvec_index + order + 1]  * u_axis_p[idx]
+                          - c_vec_p[cvec_index + 1] * v_axis_p[idx];
+
+            normal.normalize();
+            proj_p[idx].normal = normal;
+          }
+          else
+          {
+            proj_p[idx].normal = plane_normal_p[idx];
+            proj_p[idx].point = mean_p[idx];
+          }
+        });
+      });
+    }
+
+    q_.wait();
+  }
+  else // NONE
+  {
+    proj.create(query_count_);
+    for (int i = 0; i < mean_.size(); i++)
+    {
+      proj[i].normal = plane_normal_[i];
+      proj[i].point = mean_[i];
+      proj[i].u = 0;
+      proj[i].v = 0;
+    }
+  }
+}
+
+template <typename PointT> void
+pcl::oneapi::MLSResult::computeMLSSurface(const pcl::oneapi::PointCloudDev<PointT> &cloud,
+                                        const std::vector<int> &nn_indices,
+                                        const std::vector<int> &nn_splits,
+                                        double search_radius,
+                                        const int polynomial_order)
+{
+  nn_indices_.upload(nn_indices.data(), nn_indices.size());
+  nn_splits_.upload(nn_splits.data(), nn_splits.size());
+
+  query_count_ = nn_splits_.size();
+
+  // Compute Model Coefficients
+  /////////////////////////////
+  mean_.create(query_count_);
+  u_axis_.create(query_count_, pcl::oneapi::DEVICE_MEMORY);
+  v_axis_.create(query_count_, pcl::oneapi::DEVICE_MEMORY);
+  plane_normal_.create(query_count_);
+  curvature_.create(query_count_);
+
+  q_.submit([&](handler &h) {
+    auto cloud_p = cloud.points.ptr();
+    auto indices_p = nn_indices_.ptr();
+    auto query_p = query_point_.ptr();
+    auto segments_p = nn_splits_.ptr();
+    auto plane_normal_p = plane_normal_.ptr();
+    auto curvature_p = curvature_.ptr();
+    auto mean_p = mean_.ptr();
+    auto u_axis_p = u_axis_.ptr();
+    auto v_axis_p = v_axis_.ptr();
+    h.parallel_for(nn_splits.size(), [=](auto &idx) {
+
+      const int start = (idx == 0) ? 0 : segments_p[idx-1];
+      const int end = segments_p[idx];
+
+      sycl::float3 centroid;
+      oneapi::device::compute3DCentroid(cloud_p, indices_p,  start, end, centroid);
+
+      matrix3x3f covariance;
+      oneapi::device::computeCovarianceMatrix(cloud_p, indices_p, start, end, centroid,
+          covariance);
+
+      float3 eigen_vector;
+      float eigen_value;
+
+      oneapi::device::eigen33(covariance, eigen_value, eigen_vector);
+
+      vec4f coefficients (eigen_vector, 0.0f);
+      vec4f centroid4 (centroid, 0.0f);
+
+      coefficients.data.w() = -1 * coefficients.dot(centroid4);
+
+      vec3f query_point (query_p[idx]);
+
+      if (!sycl::isfinite(eigen_vector.x()) || !sycl::isfinite(eigen_vector.y()) ||
+            !sycl::isfinite(eigen_vector.z()))
+      {
+        // Invalid plane coefficients, this may happen if the input cloud is non-dense (it contains invalid points).
+        // Keep the input point and stop here.
+        mean_p[idx] = query_point;
+        return;
+      }
+
+      // Projected query point
+      vec3f coefficients3 (coefficients.x(), coefficients.y(), coefficients.z());
+
+      const float distance = query_point.dot(coefficients3) + coefficients.w();
+
+      float3 meanvalue = query_point.data - distance * coefficients3.data;
+
+      //Sum the diagonal
+      float curvature = covariance.trace3x3();
+
+      // Compute the curvature surface change
+      if (curvature != 0)
+        curvature = sycl::fabs(eigen_value / curvature);
+
+      // Local coordinate system (Darboux frame)
+      vec3f v = coefficients3.unitOrthogonal();
+      vec3f u = coefficients3.cross(v);
+
+      plane_normal_p[idx] = coefficients3;
+      v_axis_p[idx] = v;
+      u_axis_p[idx] = u;
+      mean_p[idx] = meanvalue;
+      curvature_p[idx] = curvature;
+    });
+  });
+
+  num_neighbors_.create(nn_splits.size(), &q_);
+
+  for (int i = 0; i < nn_splits.size(); i++)
+  {
+      int start = (i == 0) ? 0 : nn_splits.at(i-1);
+      int end = nn_splits.at(i);
+
+      num_neighbors_[i] = end - start;
+  }
+
+  // Perform polynomial fit to update point and normal
+  ////////////////////////////////////////////////////
+
+  order_ = polynomial_order;
+  const int order = order_;
+  const int nr_coeff = (order_ + 1) *  (order_ + 2) / 2;
+  const float radius_sqr = (float) (search_radius * search_radius);
+
+  const size_t local_size = nr_coeff;
+  const size_t localitems_aligned = align(local_size, 4);
+  const size_t workitems_aligned = nn_splits.size() * localitems_aligned;
+
+  struct p_order_map
+  {
+    int ui;
+    int vi;
+  };
+
+  std::vector<struct p_order_map> order_map (nr_coeff);
+  int p = 0;
+
+  for (int ui = 0; ui <= order; ++ui)
+  {
+    for (int vi = 0; vi <= order - ui; ++vi)
+    {
+      order_map[p++] = {ui, vi};
+    }
+  }
+
+  sycl::buffer order_map_d(order_map);
+
+  P_weight_Pt_.create(nn_splits.size() * nr_coeff* nr_coeff, &q_);
+  DeviceArray<float> d_c_vec(nn_splits.size() * nr_coeff);
+
+  q_.wait();
+
+  if (q_.get_device().is_gpu())
+  {
+    // Compare to CPU version, the neighbors are sorted.  The nn_indices_ are not sorted
+    // The output doesn't need the nn_indices_to be sorted
+    q_.submit([&](handler &h) {
+      auto cloud_p = cloud.points.ptr();
+      auto indices_p = nn_indices_.ptr();
+      auto segments_p = nn_splits_.ptr();
+      auto plane_normal_p = plane_normal_.ptr();
+      auto mean_p = mean_.ptr();
+      auto u_axis_p = u_axis_.ptr();
+      auto v_axis_p = v_axis_.ptr();
+      auto p_weight_pt_p = P_weight_Pt_.ptr();
+      auto c_vec_p = d_c_vec.ptr();
+      range global {workitems_aligned, local_size };
+      range local {localitems_aligned, local_size };
+      // Store the P and P weight
+      local_accessor <float, 2>  shareBuf(range<2>{localitems_aligned * 3, local_size}, h);
+      accessor <struct p_order_map, 1, access::mode::read, access::target::device>
+             order_map_p(order_map_d, h);
+      h.parallel_for(nd_range<2>(global, local), [=](sycl::nd_item<2> it) {
+        const int l_x = it.get_local_id(0);
+        const int l_y = it.get_local_id(1);
+        const int g_x = it.get_global_id(0);
+
+        int idx = g_x / localitems_aligned;
+
+        const size_t start = (idx == 0) ? 0 : segments_p[idx-1];
+        const size_t end = segments_p[idx];
+        const size_t neighbors = end - start;
+
+        size_t block = 0;
+        if (neighbors >= local_size)
+          block = divUp(neighbors, local_size);
+
+        float weight_pt = 0.0f;
+        float cvec = 0.0f;
+
+        float3 mean = mean_p[idx];
+        float3 u = u_axis_p[idx];
+        float3 v = v_axis_p[idx];
+        float3 plane_normal = plane_normal_p[idx];
+
+        for (int i = 0; i < block; i++)
+        {
+          if (l_x < local_size)
+          {
+            if (i * local_size + l_x < neighbors)
+            {
+              float3 cloud = float3(cloud_p[indices_p[start + i*local_size + l_x ]].x,
+                                  cloud_p[indices_p[start + i*local_size + l_x ]].y,
+                                  cloud_p[indices_p[start + i*local_size + l_x ]].z);
+              float3 de_meaned = cloud - mean;
+              float weight_vec = sycl::exp(-1 * sycl::dot(de_meaned, de_meaned)/radius_sqr);
+
+              // Go through neighbors, transform them in the local coordinate system,
+              // save height and the evaluation of the polynomial's terms
+              float u_coord = sycl::dot(de_meaned, u);
+              float v_coord = sycl::dot(de_meaned, v);
+
+              float f_vec = sycl::dot(de_meaned, plane_normal);
+
+              float u_pow = 1.0f;
+              float v_pow = 1.0f;
+
+              for (int m = 0; m < order_map_p[l_y].ui; ++m)
+              {
+                u_pow *= u_coord;
+              }
+
+              for (int m = 0; m < order_map_p[l_y].vi; ++m)
+              {
+                v_pow *= v_coord;
+              }
+
+              float p = u_pow * v_pow;
+
+              // Copy the P to local memory
+
+              // P_weight =  P * weight_vec.diagonal
+              shareBuf[l_y][l_x] = p;
+              shareBuf[l_y + local_size][l_x] = p * weight_vec;
+              shareBuf[l_y + local_size*2][l_x] = p * weight_vec * f_vec;
+            }
+            else
+            {
+              shareBuf[l_y + local_size*2][l_x] = 0.0f;
+              shareBuf[l_y + local_size][l_x] = 0.0f;
+            }
+          }
+
+          it.barrier(access::fence_space::local_space);
+
+          if (l_x < local_size)
+          {
+            for (int ni = 0; ni < local_size; ni++)
+            {
+              weight_pt += shareBuf[l_y + local_size][ni] * shareBuf[l_x][ni];
+            }
+
+            for (int ni = 0; ni < local_size; ni++)
+            {
+              cvec += shareBuf[l_y + local_size*2][ni];
+            }
+          }
+          it.barrier(access::fence_space::local_space);
+        }
+
+        if (l_x < local_size)
+        {
+          p_weight_pt_p[idx * local_size * local_size + l_x * local_size + l_y] = weight_pt;
+          if (l_x == 0)
+            c_vec_p[idx * local_size + l_y ] = cvec;
+        }
+      });
+    });
+
+    c_vec_.create(nn_splits.size() * nr_coeff, &q_);
+    c_vec_map_.create(nn_splits.size(), &q_);
+
+    q_.wait();
+
+#pragma omp parallel for
+    for (int s = 0; s < nn_splits.size(); ++ s) {
+
+      auto neighbors = num_neighbors_[s];
+
+      if (neighbors >= nr_coeff) {
+
+        Eigen::MatrixXd P_weight_Pt = vector_to_eigen_matrix(P_weight_Pt_.ptr(), s, nr_coeff, nr_coeff);
+        Eigen::VectorXd c_vec = vector_to_eigen_vector(d_c_vec.ptr(), s, nr_coeff, nr_coeff);
+
+        P_weight_Pt.llt().solveInPlace(c_vec);
+
+        std::vector<float> c_vec_out(c_vec.data(), c_vec.data() + c_vec.rows() * c_vec.cols());
+
+        if (std::isfinite(c_vec_out[0]))
+        {
+          for (int ii = 0; ii < nr_coeff; ii++)
+          {
+            c_vec_[s*nr_coeff+ii] = c_vec_out.at(ii);
+          }
+          c_vec_map_[s] = s;
+        }
+        else
+        {
+          c_vec_map_[s] = -1;
+        }
+      }
+      else
+      {
+        c_vec_map_[s] = -1;
+      }
+    }
+  }
+  else
+  {
+    c_vec_.create(nn_splits.size() * nr_coeff, &q_);
+    c_vec_map_.create(nn_splits.size(), &q_);
+
+#pragma omp parallel for
+    for (int idx = 0; idx < nn_splits.size(); ++idx)
+    {
+      Eigen::VectorXd c_vec;
+      const size_t start = (idx == 0) ? 0 : nn_splits_.ptr()[idx-1];
+      const size_t end = nn_splits_.ptr()[idx];
+      const size_t num_neighbors = end - start;
+
+      if (num_neighbors >= nr_coeff)
+      {
+        Eigen::VectorXd weight_vec (num_neighbors);
+        Eigen::VectorXd f_vec (num_neighbors);
+        Eigen::MatrixXd P (nr_coeff, num_neighbors);
+        Eigen::MatrixXd P_weight_Pt (nr_coeff, nr_coeff);
+
+        std::vector<Eigen::Vector3d, Eigen::aligned_allocator<Eigen::Vector3d>> de_meaned(num_neighbors);
+
+        for (std::size_t ni = 0; ni < static_cast<std::size_t>(num_neighbors); ++ni)
+        {
+          de_meaned[ni][0] = cloud.points.ptr()[nn_indices_.ptr()[start + ni]].x - mean_.ptr()[idx].x();
+          de_meaned[ni][1] = cloud.points.ptr()[nn_indices_.ptr()[start + ni]].y - mean_.ptr()[idx].y();
+          de_meaned[ni][2] = cloud.points.ptr()[nn_indices_.ptr()[start + ni]].z - mean_.ptr()[idx].z();
+
+          weight_vec(ni) = std::exp(-(de_meaned[ni].dot(de_meaned[ni])) / radius_sqr);
+        }
+
+        Eigen::Vector3d u_axis (u_axis_.ptr()[idx].x(), u_axis_.ptr()[idx].y(), u_axis_.ptr()[idx].z());
+        Eigen::Vector3d v_axis (v_axis_.ptr()[idx].x(), v_axis_.ptr()[idx].y(), v_axis_.ptr()[idx].z());
+        Eigen::Vector3d plane_normal (plane_normal_.ptr()[idx].x(),
+                                      plane_normal_.ptr()[idx].y(),
+                                      plane_normal_.ptr()[idx].z());
+
+
+        for (std::size_t ni = 0; ni < static_cast<std::size_t>(num_neighbors); ++ni)
+        {
+          // Transforming coordinates
+          const double u_coord = de_meaned[ni].dot(u_axis);
+          const double v_coord = de_meaned[ni].dot(v_axis);
+          f_vec (ni) = de_meaned[ni].dot (plane_normal);
+
+          // Compute the polynomial's terms at the current point
+          int j = 0;
+          double u_pow = 1;
+          for (int ui = 0; ui <= order; ++ui)
+          {
+            double v_pow = 1;
+            for (int vi = 0; vi <= order - ui; ++vi)
+            {
+              P (j++, ni) = u_pow * v_pow;
+              v_pow *= v_coord;
+            }
+            u_pow *= u_coord;
+          }
+        }
+
+        // Computing coefficients
+        const Eigen::MatrixXd P_weight = P * weight_vec.asDiagonal();
+        P_weight_Pt = P_weight * P.transpose();
+        c_vec = P_weight * f_vec;
+        P_weight_Pt.llt().solveInPlace (c_vec);
+
+        std::vector<float> c_vec_out(c_vec.data(), c_vec.data() + c_vec.rows() * c_vec.cols());
+
+        if (std::isfinite(c_vec_out[0]))
+        {
+          for (int ii = 0; ii < nr_coeff; ii++)
+          {
+            c_vec_[idx*nr_coeff+ii] = c_vec_out.at(ii);
+          }
+          c_vec_map_[idx] = idx;
+        }
+        else
+        {
+          c_vec_map_[idx] = -1;
+        }
+      }
+      else
+      {
+          c_vec_map_[idx] = -1;
+      }
+    } // for idx
+  }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT>
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::MLSVoxelGrid::MLSVoxelGrid (PointCloudDevInConstPtr& cloud,
+                                                                          IndicesDevPtr &indices,
+                                                                          float voxel_size) :
+  voxel_grid_ (), data_size_ (), voxel_size_ (voxel_size)
+{
+  getMinMax3D (*cloud, *indices, bounding_min_, bounding_max_);
+
+  Eigen::Vector4f bounding_box_size = bounding_max_ - bounding_min_;
+  const double max_size = (std::max) ((std::max)(bounding_box_size.x (), bounding_box_size.y ()), bounding_box_size.z ());
+  // Put initial cloud in voxel grid
+  data_size_ = static_cast<std::uint64_t> (1.5 * max_size / voxel_size_);
+  for (std::size_t i = 0; i < indices->size (); ++i)
+    if (std::isfinite ((*cloud)[(*indices)[i]].x))
+    {
+      Eigen::Vector3i pos;
+      getCellIndex ((*cloud)[(*indices)[i]].getVector3fMap (), pos);
+
+      uint64_t index_1d;
+      getIndexIn1D (pos, index_1d);
+      Leaf leaf;
+      voxel_grid_[index_1d] = leaf;
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::MLSVoxelGrid::dilate ()
+{
+  HashMap new_voxel_grid = voxel_grid_;
+  for (typename MLSVoxelGrid::HashMap::iterator m_it = voxel_grid_.begin (); m_it != voxel_grid_.end (); ++m_it)
+  {
+    Eigen::Vector3i index;
+    getIndexIn3D (m_it->first, index);
+
+    // Now dilate all of its voxels
+    for (int x = -1; x <= 1; ++x)
+      for (int y = -1; y <= 1; ++y)
+        for (int z = -1; z <= 1; ++z)
+          if (x != 0 || y != 0 || z != 0)
+          {
+            Eigen::Vector3i new_index;
+            new_index = index + Eigen::Vector3i (x, y, z);
+
+            std::uint64_t index_1d;
+            getIndexIn1D (new_index, index_1d);
+            Leaf leaf;
+            new_voxel_grid[index_1d] = leaf;
+          }
+  }
+  voxel_grid_ = new_voxel_grid;
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT, typename PointOutT> void
+pcl::oneapi::MovingLeastSquares<PointInT, PointOutT>::setSearchRadius (double radius)
+{
+  search_radius_ = radius; sqr_gauss_param_ = search_radius_ * search_radius_;
+
+  if (tree_)
+  {
+    tree_->setInputCloud(input_, search_radius_);
+  }
+
+}
+
+#define PCL_INSTANTIATE_MovingLeastSquares(T,OutT) template class PCL_EXPORTS pcl::oneapi::MovingLeastSquares<T,OutT>;
+
+#endif // PCL_ONEAPI_SURFACE_IMPL_MLS_HPP_
diff --git a/oneapi/surface/include/pcl/oneapi/surface/impl/processing.hpp b/oneapi/surface/include/pcl/oneapi/surface/impl/processing.hpp
new file mode 100644
index 000000000..d52115a69
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/impl/processing.hpp
@@ -0,0 +1,69 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ * Point Cloud Library (PCL) - www.pointclouds.org
+ * Copyright (c) 2009-2012, Willow Garage, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * * Redistributions of source code must retain the above copyright
+ *   notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above
+ *   copyright notice, this list of conditions and the following
+ *   disclaimer in the documentation and/or other materials provided
+ *   with the distribution.
+ * * Neither the name of Willow Garage, Inc. nor the names of its
+ *   contributors may be used to endorse or promote products derived
+ *   from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+
+namespace pcl
+{
+namespace oneapi
+{
+
+template <typename PointInT, typename PointOutT> void
+CloudSurfaceProcessing<PointInT, PointOutT>::process (pcl::PointCloud<PointOutT> &output)
+{
+  // Copy the header
+  output.header = input_->header;
+
+  if (!initCompute ())
+  {
+    output.width = output.height = 0;
+    output.clear ();
+    return;
+  }
+
+  // Perform the actual surface reconstruction
+  performProcessing (output);
+
+  deinitCompute ();
+}
+
+} // namespace oneapi
+} // namespace pcl
+
diff --git a/oneapi/surface/include/pcl/oneapi/surface/mls.h b/oneapi/surface/include/pcl/oneapi/surface/mls.h
new file mode 100644
index 000000000..28dcb9bc2
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/mls.h
@@ -0,0 +1,625 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <random>
+#include <CL/sycl.hpp>
+//#include <pcl/pcl_macros.h>
+#include <pcl/point_types.h>
+#include <pcl/oneapi/kdtree/kdtree_flann.h> // for Search
+#include <pcl/oneapi/surface/processing.h>
+
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/point_cloud.h>
+
+#include <memory>
+
+namespace pcl
+{
+namespace oneapi
+{
+  struct MLSResult
+  {
+    enum ProjectionMethod
+    {
+      NONE,
+      SIMPLE,
+      ORTHOGONAL
+    };
+
+    struct ProjectionResults
+    {
+      ProjectionResults () : u (0.0f), v (0.0f) {}
+      float u;             /**< \brief The u-coordinate of the projected point in local MLS frame. */
+      float v;             /**< \brief The v-coordinate of the projected point in local MLS frame. */
+      sycl::float3 point;  /**< \brief The projected point. */
+      sycl::float3 normal; /**< \brief The projected point's normal. */
+    };
+
+    struct Displacement
+    {
+      float u;
+      float v;
+    };
+
+    inline
+    MLSResult () : query_point_ (DeviceArray<sycl::float3>{}),
+                   nn_indices_ (DeviceArray<int>{}),
+                   nn_splits_ (DeviceArray<int>{}),
+                   P_weight_Pt_ (DeviceArray<float>{}),
+                   mean_ (DeviceArray<sycl::float3>{}),
+                   plane_normal_ (DeviceArray<sycl::float3>{}),
+                   u_axis_ (DeviceArray<sycl::float3>{}),
+                   v_axis_ (DeviceArray<sycl::float3>{}),
+                   c_vec_ (DeviceArray<float>{}),
+                   c_vec_map_ (DeviceArray<int>{}),
+                   curvature_ (DeviceArray<float>{}),
+                   num_neighbors_ (DeviceArray<int>{}),
+                   u_v_coord_ (DeviceArray<Displacement>{}),
+                   query_count_ (0),
+                   order_ (0) {}
+
+
+    /**
+     * \brief Project a point along the MLS plane normal to the polynomial surface.
+     * \param[in] u The u-coordinate of the point in local MLS frame.
+     * \param[in] v The v-coordinate of the point in local MLS frame.
+     * \return The ProjectionResults for the input data.
+     * \note If the MLSResults does not contain polynomial data it projects the point onto the mls plane.
+     */
+    inline void
+    projectPointSimpleToPolynomialSurface (DeviceArray<ProjectionResults>& proj,
+        const DeviceArray<Displacement>& disp);
+
+    /**
+     * \brief Project a point using the specified method.
+     * \param[in] pt The point to be project.
+     * \param[in] method The projection method to be used.
+     * \param[in] required_neighbors The minimum number of neighbors required.
+     * \note If required_neighbors is 0 then any number of neighbors is allowed.
+     * \note If required_neighbors is not satisfied it projects to the mls plane.
+     * \return The MLSProjectionResults for the input data.
+     */
+    template<typename PointT> inline void
+    projectPoint (const DeviceArray<PointT> &pt, const DeviceArray<int>& index,
+        const ProjectionMethod method, int required_neighbors,
+        DeviceArray<ProjectionResults>& proj);
+
+    /**
+     * \brief Project the query point used to generate the mls surface about using the specified method.
+     * \param[in] method The projection method to be used.
+     * \param[in] required_neighbors The minimum number of neighbors required.
+     * \return The ProjectionResults for the input data.
+     */
+     void
+     projectQueryPoint (ProjectionMethod method, DeviceArray<ProjectionResults>& proj);
+
+     /**
+      * \brief Project a point with random uniform density
+      */
+     inline void
+     projectRandomUniformDensity (const ProjectionMethod method,
+         const DeviceArray<int>& density_map, const DeviceArray<int>& point_map,
+         const DeviceArray<float>& random_u, const DeviceArray<float>& random_v,
+         DeviceArray<ProjectionResults>& proj);
+
+    /** \brief Smooth a given point and its neighborhood using Moving Least Squares.
+     * \param[in] cloud the input cloud, used together with index and nn_indices
+     * \param[in] index the index of the query point in the input cloud
+     * \param[in] nn_indices the set of nearest neighbors indices for pt
+     * \param[in] search_radius the search radius used to find nearest neighbors for pt
+     * \param[in] polynomial_order the order of the polynomial to fit to the nearest neighbors
+     * \param[in] weight_func defines the weight function for the polynomial fit
+     */
+    template <typename PointT> void
+    computeMLSSurface (const pcl::oneapi::PointCloudDev<PointT> &cloud,
+                      const std::vector<int> &nn_indices,
+                      const std::vector<int> &nn_splits,
+                      double search_radius,
+                      const int polynomial_order = 2);
+
+    void
+    setDevice(sycl::queue q) { q_ = q; };
+
+    template<typename PointT> void
+    convertQueryBuffer(const pcl::oneapi::PointCloudDev<PointT> &cloud, const std::vector<int>& query_indices);
+
+    DeviceArray<sycl::float3> query_point_;
+    DeviceArray<int> nn_indices_;
+    DeviceArray<int> nn_splits_;
+    DeviceArray<float> P_weight_Pt_;
+    DeviceArray<sycl::float3> mean_;         /**< \brief The mean point of all the neighbors. */
+    DeviceArray<sycl::float3> plane_normal_; /**< \brief The normal of the local plane of the query point. */
+    DeviceArray<sycl::float3> u_axis_;       /**< \brief The axis corresponding to the u-coordinates of the local plane of the query point. */
+    DeviceArray<sycl::float3> v_axis_;       /**< \brief The axis corresponding to the v-coordinates of the local plane of the query point. */
+    DeviceArray<float> c_vec_;              /**< \brief The polynomial coefficients Example: z = c_vec[0] + c_vec[1]*v + c_vec[2]*v^2 + c_vec[3]*u + c_vec[4]*u*v + c_vec[5]*u^2 */
+    DeviceArray<int> c_vec_map_;
+    DeviceArray<float> curvature_;
+    DeviceArray<int>  num_neighbors_;        /**< \brief Number of neighbors for each query point */
+    DeviceArray<Displacement> u_v_coord_;
+
+    int query_count_;
+
+    int order_;
+    sycl::queue q_;                         /** \brief sycl queue for HW job submision */
+  };
+
+  template <typename PointInT, typename PointOutT>
+  class PCL_EXPORTS MovingLeastSquares  : public CloudSurfaceProcessing<PointInT, PointOutT> {
+  public:
+
+    using pcl::oneapi::PCLBase<PointInT>::input_;
+    using pcl::oneapi::PCLBase<PointInT>::indices_;
+    using pcl::oneapi::PCLBase<PointInT>::initCompute;
+    using pcl::oneapi::PCLBase<PointInT>::deinitCompute;
+
+    using KdTree = pcl::oneapi::KdTreeFLANN<PointInT>;
+    using KdTreePtr = shared_ptr<pcl::oneapi::KdTreeFLANN<PointInT>>;
+    using NormalCloud = pcl::PointCloud<pcl::Normal>;
+    using NormalCloudPtr = NormalCloud::Ptr;
+
+    using PointCloudOut = pcl::PointCloud<PointOutT>;
+    using PointCloudOutPtr = typename PointCloudOut::Ptr;
+    using PointCloudOutConstPtr = typename PointCloudOut::ConstPtr;
+
+    using PointCloudIn = pcl::PointCloud<PointInT>;
+    using PointCloudInPtr = typename PointCloudIn::Ptr;
+    using PointCloudInConstPtr = typename PointCloudIn::ConstPtr;
+
+    using PointCloudDevIn = pcl::oneapi::PointCloudDev<PointInT>;
+    using PointCloudDevInPtr = typename PointCloudDevIn::Ptr;
+    using PointCloudDevInConstPtr = typename PointCloudDevIn::ConstPtr;
+
+    enum UpsamplingMethod
+    {
+      NONE,                   /**< \brief No upsampling will be done, only the input points will be projected
+                                          to their own MLS surfaces. */
+      DISTINCT_CLOUD,         /**< \brief Project the points of the distinct cloud to the MLS surface. */
+      SAMPLE_LOCAL_PLANE,     /**< \brief The local plane of each input point will be sampled in a circular fashion
+                                          using the \ref upsampling_radius_ and the \ref upsampling_step_ parameters. */
+      RANDOM_UNIFORM_DENSITY, /**< \brief The local plane of each input point will be sampled using an uniform random
+                                          distribution such that the density of points is constant throughout the
+                                          cloud - given by the \ref desired_num_points_in_radius_ parameter. */
+      VOXEL_GRID_DILATION     /**< \brief The input cloud will be inserted into a voxel grid with voxels of
+                                          size \ref voxel_size_; this voxel grid will be dilated \ref dilation_iteration_num_
+                                          times and the resulting points will be projected to the MLS surface
+                                          of the closest point in the input cloud; the result is a point cloud
+                                          with filled holes and a constant point density. */
+    };
+
+    MovingLeastSquares() : CloudSurfaceProcessing<PointInT, PointOutT> (),
+                           distinct_cloud_ (),
+                           tree_ (),
+                           order_ (2),
+                           search_radius_ (0.0),
+                           sqr_gauss_param_ (0.0),
+                           compute_normals_ (false),
+                           upsample_method_ (NONE),
+                           upsampling_radius_ (0.0),
+                           upsampling_step_ (0.0),
+                           desired_num_points_in_radius_ (0),
+                           projection_method_ (MLSResult::SIMPLE),
+                           voxel_size_ (1.0),
+                           dilation_iteration_num_ (0),
+                           nr_coeff_ (),
+                           block_size_ (5000),
+                           valid_ (),
+                           nn_indices_remap_ (),
+                           rng_uniform_distribution_()
+                           {};
+
+
+
+    ~MovingLeastSquares() {}
+
+    void
+    process(PointCloudOut &output) override;
+
+    void
+    setInputCloud (const PointCloudDevInConstPtr &cloud) override
+    {
+      input_ = cloud;
+    }
+
+    void
+    setInputCloud (const PointCloudInConstPtr &cloud) override
+    {
+      PointCloudDev<PointInT> cloud_dev (cloud);
+
+      input_ = cloud_dev.makeShared();
+    }
+
+    /** \brief Set whether the algorithm should also store the normals computed
+      * \note This is optional, but need a proper output cloud type
+      */
+    inline void
+    setComputeNormals (bool compute_normals) { compute_normals_ = compute_normals; }
+
+    /** \brief Provide a pointer to the search object.
+      * \param[in] tree a pointer to the spatial search object.
+      */
+    inline void
+    setSearchMethod (const KdTreePtr &tree)
+    {
+      tree_ = tree;
+    }
+
+    /** \brief Get a pointer to the search method used. */
+    inline KdTreePtr
+    getSearchMethod () const { return (tree_); }
+
+    /** \brief Set the order of the polynomial to be fit.
+      * \param[in] order the order of the polynomial
+      * \note Setting order > 1 indicates using a polynomial fit.
+      */
+    inline void
+    setPolynomialOrder (int order) { order_ = order; }
+
+    /** \brief Get the order of the polynomial to be fit. */
+    inline int
+    getPolynomialOrder () const { return (order_); }
+
+    /** \brief Set the sphere radius that is to be used for determining the k-nearest neighbors used for fitting.
+      * \param[in] radius the sphere radius that is to contain all k-nearest neighbors
+      * \note Calling this method resets the squared Gaussian parameter to radius * radius !
+      */
+    void setSearchRadius (double radius);
+
+
+    /** \brief Get the sphere radius used for determining the k-nearest neighbors. */
+    inline double
+    getSearchRadius () const { return (search_radius_); }
+
+    /** \brief Set the parameter used for distance based weighting of neighbors (the square of the search radius works
+      * best in general).
+      * \param[in] sqr_gauss_param the squared Gaussian parameter
+      */
+    inline void
+    setSqrGaussParam (double sqr_gauss_param) { sqr_gauss_param_ = sqr_gauss_param; }
+
+    /** \brief Get the parameter for distance based weighting of neighbors. */
+    inline double
+    getSqrGaussParam () const { return (sqr_gauss_param_); }
+
+    /** \brief Set the upsampling method to be used
+      * \param method
+      */
+    inline void
+    setUpsamplingMethod (UpsamplingMethod method) { upsample_method_ = method; }
+
+    /** \brief Set the distinct cloud used for the DISTINCT_CLOUD upsampling method. */
+    inline void
+    setDistinctCloud (PointCloudInConstPtr distinct_cloud) { distinct_cloud_ = distinct_cloud; }
+
+    /** \brief Get the distinct cloud used for the DISTINCT_CLOUD upsampling method. */
+    inline PointCloudInConstPtr
+    getDistinctCloud () const { return (distinct_cloud_); }
+
+    /** \brief Set the radius of the circle in the local point plane that will be sampled
+     *  \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+     *  \param[in] radius the radius of the circle
+     */
+    inline void
+    setUpsamplingRadius (double radius) { upsampling_radius_ = radius; }
+
+    /** \brief Get the radius of the circle in the local point plane that will be sampled
+      * \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+      */
+    inline double
+    getUpsamplingRadius () const { return (upsampling_radius_); }
+
+    /** \brief Set the step size for the local plane sampling
+      * \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+      * \param[in] step_size the step size
+      */
+    inline void
+    setUpsamplingStepSize (double step_size) { upsampling_step_ = step_size; }
+
+    /** \brief Get the step size for the local plane sampling
+      * \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+      */
+    inline double
+    getUpsamplingStepSize () const { return (upsampling_step_); }
+
+    /** \brief Set the parameter that specifies the desired number of points within the search radius
+      * \note Used only in the case of RANDOM_UNIFORM_DENSITY upsampling
+      * \param[in] desired_num_points_in_radius the desired number of points in the output cloud in a sphere of
+      * radius \ref search_radius_ around each point
+      */
+    inline void
+    setPointDensity (int desired_num_points_in_radius) { desired_num_points_in_radius_ = desired_num_points_in_radius; }
+
+    /** \brief Get the parameter that specifies the desired number of points within the search radius
+      * \note Used only in the case of RANDOM_UNIFORM_DENSITY upsampling
+      */
+    inline int
+    getPointDensity () const { return (desired_num_points_in_radius_); }
+
+    /** \brief Set the voxel size for the voxel grid
+      * \note Used only in the VOXEL_GRID_DILATION upsampling method
+      * \param[in] voxel_size the edge length of a cubic voxel in the voxel grid
+      */
+    inline void
+    setDilationVoxelSize (float voxel_size) { voxel_size_ = voxel_size; }
+
+    /** \brief Get the voxel size for the voxel grid
+      * \note Used only in the VOXEL_GRID_DILATION upsampling method
+      */
+    inline float
+    getDilationVoxelSize () const { return (voxel_size_); }
+
+    /** \brief Set the number of dilation steps of the voxel grid
+      * \note Used only in the VOXEL_GRID_DILATION upsampling method
+      * \param[in] iterations the number of dilation iterations
+      */
+    inline void
+    setDilationIterations (int iterations) { dilation_iteration_num_ = iterations; }
+
+    /** \brief Get the number of dilation steps of the voxel grid
+      * \note Used only in the VOXEL_GRID_DILATION upsampling method
+      */
+    inline int
+    getDilationIterations () const { return (dilation_iteration_num_); }
+
+    /** \brief Set the method to be used when projection the point on to the MLS surface.
+     * \param method
+     * \note This is only used when polynomial fit is enabled.
+     */
+    inline void
+    setProjectionMethod (MLSResult::ProjectionMethod method) { projection_method_ = method; }
+
+    /** \brief Get the current projection method being used. */
+    inline MLSResult::ProjectionMethod
+    getProjectionMethod () const { return (projection_method_); }
+
+    inline void
+    setSearchBlockSize(int block_size) { block_size_ = block_size; }
+
+
+  protected:
+
+    /** \brief sycl queue for HW job submision */
+    sycl::queue q_;
+
+    /** \brief The point cloud that will hold the estimated normals, if set. */
+    NormalCloudPtr normals_;
+
+    /** \brief The distinct point cloud that will be projected to the MLS surface. */
+    PointCloudInConstPtr distinct_cloud_;
+
+    /** \brief A pointer to the spatial search object. */
+    KdTreePtr tree_;
+
+    /** \brief The order of the polynomial to be fit. */
+    int order_;
+
+    /** \brief The nearest neighbors search radius for each point. */
+    double search_radius_;
+
+    /** \brief Parameter for distance based weighting of neighbors (search_radius_ * search_radius_ works fine) */
+    double sqr_gauss_param_;
+
+    /** \brief Parameter that specifies whether the normals should be computed for the input cloud or not */
+    bool compute_normals_;
+
+    /** \brief Parameter that specifies the upsampling method to be used */
+    UpsamplingMethod upsample_method_;
+
+    /** \brief Radius of the circle in the local point plane that will be sampled
+     *  \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+     */
+    double upsampling_radius_;
+
+    /** \brief Step size for the local plane sampling
+     *  \note Used only in the case of SAMPLE_LOCAL_PLANE upsampling
+     */
+    double upsampling_step_;
+
+    /** \brief Parameter that specifies the desired number of points within the search radius
+     *  \note Used only in the case of RANDOM_UNIFORM_DENSITY upsampling
+     */
+    int desired_num_points_in_radius_;
+
+    /** \brief Stores the MLS result for each point in the input cloud
+     *  \note Used only in the case of VOXEL_GRID_DILATION or DISTINCT_CLOUD upsampling
+     */
+    MLSResult mls_results_;
+
+    /** \brief Parameter that specifies the projection method to be used. */
+    MLSResult::ProjectionMethod projection_method_;
+
+    /** \brief A minimalistic implementation of a voxel grid, necessary for the point cloud upsampling
+      * \note Used only in the case of VOXEL_GRID_DILATION upsampling
+      */
+    class MLSVoxelGrid
+    {
+      public:
+        struct Leaf { Leaf () : valid (true) {} bool valid; };
+
+        MLSVoxelGrid (PointCloudDevInConstPtr& cloud,
+                      IndicesDevPtr &indices,
+                      float voxel_size);
+
+        void
+        dilate ();
+
+        inline void
+        getIndexIn1D (const Eigen::Vector3i &index, std::uint64_t &index_1d) const
+        {
+          index_1d = index[0] * data_size_ * data_size_ +
+                     index[1] * data_size_ + index[2];
+        }
+
+        inline void
+        getIndexIn3D (std::uint64_t index_1d, Eigen::Vector3i& index_3d) const
+        {
+          index_3d[0] = static_cast<Eigen::Vector3i::Scalar> (index_1d / (data_size_ * data_size_));
+          index_1d -= index_3d[0] * data_size_ * data_size_;
+          index_3d[1] = static_cast<Eigen::Vector3i::Scalar> (index_1d / data_size_);
+          index_1d -= index_3d[1] * data_size_;
+          index_3d[2] = static_cast<Eigen::Vector3i::Scalar> (index_1d);
+        }
+
+        inline void
+        getCellIndex (const Eigen::Vector3f &p, Eigen::Vector3i& index) const
+        {
+          for (int i = 0; i < 3; ++i)
+            index[i] = static_cast<Eigen::Vector3i::Scalar> ((p[i] - bounding_min_ (i)) / voxel_size_);
+        }
+
+        inline void
+        getPosition (const std::uint64_t &index_1d, Eigen::Vector3f &point) const
+        {
+          Eigen::Vector3i index_3d;
+          getIndexIn3D (index_1d, index_3d);
+          for (int i = 0; i < 3; ++i)
+            point[i] = static_cast<Eigen::Vector3f::Scalar> (index_3d[i]) * voxel_size_ + bounding_min_[i];
+        }
+
+        typedef std::map<std::uint64_t, Leaf> HashMap;
+        HashMap voxel_grid_;
+        Eigen::Vector4f bounding_min_, bounding_max_;
+        std::uint64_t data_size_;
+        float voxel_size_;
+        PCL_MAKE_ALIGNED_OPERATOR_NEW
+    };
+
+    /** \brief Voxel size for the VOXEL_GRID_DILATION upsampling method */
+    float voxel_size_;
+
+    /** \brief Number of dilation steps for the VOXEL_GRID_DILATION upsampling method */
+    int dilation_iteration_num_;
+
+    /** \brief Number of coefficients, to be computed from the requested order.*/
+    int nr_coeff_;
+
+    int block_size_;
+
+    std::vector<bool> valid_;
+
+    // Eventually this will not need after restructure 
+    // Use for Dilation and Distict cloud upsampling only
+    std::vector<int> nn_indices_remap_;
+
+
+    /** \brief Collects for each point in output the corrseponding point in the input. */
+    PointIndicesPtr corresponding_input_indices_;
+
+    /** \brief Smooth a given point and its neighborghood using Moving Least Squares.
+      * \param[in] index the index of the query point in the input cloud
+      * \param[in] nn_indices the set of nearest neighbors indices for pt
+      * \param[out] projected_points the set of projected points around the query point
+      * (in the case of upsampling method NONE, only the query point projected to its own fitted surface will be returned,
+      * in the case of the other upsampling methods, multiple points will be returned)
+      * \param[out] projected_points_normals the normals corresponding to the projected points
+      * \param[out] corresponding_input_indices the set of indices with each point in output having the corresponding point in input
+      * \param[out] mls_result stores the MLS result for each point in the input cloud
+      * (used only in the case of VOXEL_GRID_DILATION or DISTINCT_CLOUD upsampling)
+      */
+    void
+    computeMLSPointNormal (const PointCloudDevInConstPtr &cloud,
+                           const std::vector<int> &nn_indices,
+                           const std::vector<int> &nn_splits,
+                           const std::vector<int> &nn_query_indices,
+                           PointCloudOut &projected_points,
+                           NormalCloud &projected_points_normals,
+                           PointIndices &corresponding_input_indices,
+                           MLSResult &mls_result);
+
+    /** \brief This is a helper function for adding projected points
+      * \param[in] index the index of the query point in the input cloud
+      * \param[in] point the projected point to be added
+      * \param[in] normal the projected point's normal to be added
+      * \param[in] curvature the projected point's curvature
+      * \param[out] projected_points the set of projected points around the query point
+      * \param[out] projected_points_normals the normals corresponding to the projected points
+      * \param[out] corresponding_input_indices the set of indices with each point in output having the corresponding point in input
+      */
+    void
+    addProjectedPointNormal (const DeviceArray<MLSResult::ProjectionResults> proj,
+                             const DeviceArray<int> &query_map,
+                             const DeviceArray<float>  &curvature,
+                             PointCloudOut &projected_points,
+                             NormalCloud &projected_points_normals,
+                             PointIndices &corresponding_input_indices) const;
+
+    void
+    copyMissingFields (const PointInT &point_in,
+                       PointOutT &point_out) const;
+
+
+    /** \brief Abstract surface reconstruction method.
+      * \param[out] output the result of the reconstruction
+      */
+    void
+    performProcessing (PointCloudOut &output) override;
+
+    /** \brief Perform upsampling for the distinct-cloud and voxel-grid methods
+      * \param[out] output the result of the reconstruction
+     */
+    void
+    performUpsampling (PointCloudOut &output);
+
+  private:
+    /*
+     * Use for Random Uniform Density only
+     */
+    PointCloudDevInConstPtr cloud_;
+    DeviceArray<int> density_map_;
+    DeviceArray<int> query_map_;
+    DeviceArray<float> random_u_;
+    DeviceArray<float> random_v_;
+
+    /** \brief Random number generator algorithm. */
+    mutable std::mt19937 rng_;
+
+    /** \brief Random number generator using an uniform distribution of floats
+     *  \note Used only in the case of RANDOM_UNIFORM_DENSITY upsampling
+     */
+    std::unique_ptr<std::uniform_real_distribution<>> rng_uniform_distribution_;
+
+    /** \brief Abstract class get name method. */
+    std::string
+    getClassName () const { return ("MovingLeastSquares"); }
+  };
+}
+}
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/surface/impl/mls.hpp>
+#endif
diff --git a/oneapi/surface/include/pcl/oneapi/surface/processing.h b/oneapi/surface/include/pcl/oneapi/surface/processing.h
new file mode 100644
index 000000000..96261df03
--- /dev/null
+++ b/oneapi/surface/include/pcl/oneapi/surface/processing.h
@@ -0,0 +1,92 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <pcl/oneapi/pcl_base.h>
+
+namespace pcl
+{
+namespace oneapi
+{
+  template <typename PointT> class PointCloud;
+
+  /** \brief @b CloudSurfaceProcessing represents the base class for algorithms that takes a point cloud as input and
+    * produces a new output cloud that has been modified towards a better surface representation. These types of
+    * algorithms include surface smoothing, hole filling, cloud upsampling etc.
+    *
+    * \author Alexandru E. Ichim
+    * \ingroup surface
+    */
+  template <typename PointInT, typename PointOutT>
+  class CloudSurfaceProcessing : public PCLBase<PointInT>
+  {
+    public:
+      typedef shared_ptr<CloudSurfaceProcessing<PointInT, PointOutT> > Ptr;
+      typedef shared_ptr<const CloudSurfaceProcessing<PointInT, PointOutT> > ConstPtr;
+
+      using PCLBase<PointInT>::input_;
+      using PCLBase<PointInT>::indices_;
+      using PCLBase<PointInT>::initCompute;
+      using PCLBase<PointInT>::deinitCompute;
+
+    public:
+      /** \brief Constructor. */
+      CloudSurfaceProcessing () : PCLBase<PointInT> ()
+      {};
+
+      /** \brief Empty destructor */
+      ~CloudSurfaceProcessing () {}
+
+      /** \brief Process the input cloud and store the results
+        * \param[out] output the cloud where the results will be stored
+        */
+      virtual void
+      process (pcl::PointCloud<PointOutT> &output);
+
+    protected:
+      /** \brief Abstract cloud processing method */
+      virtual void
+      performProcessing (pcl::PointCloud<PointOutT> &output) = 0;
+
+  };
+}
+}
+
+#include "pcl/oneapi/surface/impl/processing.hpp"
diff --git a/oneapi/surface/src/convex_hull.cpp b/oneapi/surface/src/convex_hull.cpp
new file mode 100644
index 000000000..09eb090f7
--- /dev/null
+++ b/oneapi/surface/src/convex_hull.cpp
@@ -0,0 +1,141 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTR
+ IBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <pcl/oneapi/surface/convex_hull.h>
+#include <pcl/oneapi/utils/device/static_check.hpp>
+#include "internal.h"
+#include <pcl/exceptions.h>
+
+pcl::oneapi::device::FacetStream::FacetStream(std::size_t buffer_size)
+{
+  verts_inds.create(3, buffer_size);  
+  head_points.create(buffer_size);
+  
+  scan_buffer.create(buffer_size);
+  facet_count = 0;
+
+  verts_inds2.create(3,buffer_size);  
+  head_points2.create(buffer_size);
+
+  empty_facets.create(3, buffer_size);
+
+  int zero = 0;  
+  empty_count.upload(&zero, 1);
+}
+
+bool 
+pcl::oneapi::device::FacetStream::canSplit() const
+{
+  return (bool)(static_cast<Eigen::Index>(facet_count * 3) < verts_inds.cols());
+}
+
+struct pcl::oneapi::PseudoConvexHull3D::Impl
+{
+    Impl(std::size_t buffer_size) : fs(buffer_size) {}
+    ~Impl() {};
+    
+    device::FacetStream fs;
+};
+
+pcl::oneapi::PseudoConvexHull3D::PseudoConvexHull3D(std::size_t bsize)
+{
+  impl_.reset( new Impl(bsize) );
+}
+pcl::oneapi::PseudoConvexHull3D::~PseudoConvexHull3D() {}
+
+
+void 
+pcl::oneapi::PseudoConvexHull3D::reconstruct (const Cloud &cloud, DeviceArray2D<int>& vertexes)
+{     
+  const device::Cloud& c = (const device::Cloud&)cloud;
+    
+  device::FacetStream& fs = impl_->fs;
+  device::PointStream ps(c);
+
+  ps.computeInitalSimplex();
+
+  fs.setInitialFacets(ps.simplex);
+  ps.initalClassify();
+
+  for(;;)
+  {
+    //new external points number
+    ps.cloud_size = ps.searchFacetHeads(fs.facet_count, fs.head_points);  
+    if (ps.cloud_size == 0)
+      break;
+      
+    fs.compactFacets();
+    ps.classify(fs);
+    	
+    if (!fs.canSplit())
+      throw PCLException("Can't split facets, please enlarge default buffer", __FILE__, "", __LINE__);
+		
+    fs.splitFacets();
+  }
+
+  int ecount;
+  int fcount = fs.facet_count;
+  fs.empty_count.download(&ecount);
+  
+  vertexes.create(3, fcount + ecount);
+  DeviceArray2D<int> subf(3, fcount, vertexes.ptr(),        vertexes.step());
+  DeviceArray2D<int> sube(3, ecount, vertexes.ptr()+fcount, vertexes.step());
+  
+  DeviceArray2D<int>(3, fcount, fs.verts_inds.ptr(), fs.verts_inds.step()).copyTo(subf);
+  DeviceArray2D<int>(3, ecount, fs.empty_facets.ptr(), fs.empty_facets.step()).copyTo(sube);
+}
+
+void
+pcl::oneapi::PseudoConvexHull3D::reconstruct (const Cloud &points, Cloud &output)
+{
+  DeviceArray2D<int> vertexes;
+  reconstruct(points, vertexes);
+
+  DeviceArray<int> cont(vertexes.cols() * vertexes.rows());
+  DeviceArray2D<int> buf(3, vertexes.cols(), cont.ptr(), vertexes.cols() * sizeof(int));
+  vertexes.copyTo(buf);
+
+  std::size_t new_size = device::remove_duplicates(cont);
+  DeviceArray<int> new_cont(cont.ptr(), new_size);
+  output.create(new_size);
+
+  const device::Cloud& c = (const device::Cloud&)points;
+  device::Cloud& o = (device::Cloud&)output;
+
+  device::pack_hull(c, new_cont, o);
+}
diff --git a/oneapi/surface/src/dpcpp/convex_hull.dp.cpp b/oneapi/surface/src/dpcpp/convex_hull.dp.cpp
new file mode 100644
index 000000000..2352fef79
--- /dev/null
+++ b/oneapi/surface/src/dpcpp/convex_hull.dp.cpp
@@ -0,0 +1,1075 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#include <oneapi/dpl/execution>
+#include <oneapi/dpl/algorithm>
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "internal.h"
+#include "device.h"
+#include <limits>
+
+#include <pcl/oneapi/utils/device/algorithm.hpp>
+#include <pcl/oneapi/utils/device/warp.hpp>
+#include <pcl/oneapi/utils/device/static_check.hpp>
+#include <pcl/oneapi/utils/common.h>
+#include <pcl/oneapi/utils/safe_call.hpp>
+
+#include <dpct/dpl_utils.hpp>
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    { 	  
+      template<bool use_max>
+      struct IndOp
+      {
+        __dpct_inline__ std::tuple<float, int>
+        operator()(const std::tuple<float, int>& e1,
+                   const std::tuple<float, int>& e2) const
+        {
+          std::tuple<float, int> res;
+
+          if (use_max)
+            std::get<0>(res) = sycl::fmax((float)(std::get<0>(e1)), (float)(std::get<0>(e2)));
+          else
+            std::get<0>(res) = sycl::fmin((float)(std::get<0>(e1)), (float)(std::get<0>(e2)));
+
+          std::get<1>(res)  = (std::get<0>(res) == std::get<0>(e1)) ? std::get<1>(e1) : std::get<1>(e2);
+          return res;			  
+        }
+      };
+
+      struct X
+      {
+        __dpct_inline__ std::tuple<float, int>
+        operator()(const std::tuple<PointType, int>& in) const
+        {
+          return std::tuple<float, int>(std::get<0>(in).x(), std::get<1>(in));
+        }
+      };
+
+      struct Y
+      {
+        __dpct_inline__ float
+        operator()(const PointType& in) const {
+          return in.y();
+        }
+      };
+
+      struct Z
+      {
+        __dpct_inline__ float
+        operator()(const PointType& in) const {
+          return in.z();
+        }
+      };
+		  
+      struct LineDist
+      {
+        sycl::float3 x1, x2;
+        LineDist(const PointType& p1, const PointType& p2) : x1(tr(p1)), x2(tr(p2)) {}
+
+        __dpct_inline__ std::tuple<float, int>
+        operator()(const std::tuple<PointType, int>& in) const
+        {
+          sycl::float3 x0 = tr(std::get<0>(in));
+
+          float dist = norm(cross(x0 - x1, x0 - x2))/norm(x1 - x2);
+
+          return std::tuple<float, int>(dist, std::get<1>(in));
+        }	      
+      };
+
+      struct PlaneDist
+      {
+        sycl::float3 x1, n;
+        PlaneDist(const PointType& p1, const PointType& p2, const PointType& p3) : x1(tr(p1))
+        {
+          sycl::float3 x2 = tr(p2), x3 = tr(p3);
+          n = normalized(cross(x2 - x1, x3 - x1));
+        }
+
+        __dpct_inline__ std::tuple<float, int>
+        operator()(const std::tuple<PointType, int>& in) const
+        {
+          sycl::float3 x0 = tr(std::get<0>(in));
+          float dist = sycl::fabs(dot(n, x0 - x1));
+          return std::tuple<float, int>(dist, std::get<1>(in));
+        }
+      };	 
+
+      template<typename It, typename Unary, typename Init, typename Binary>
+        int transform_reduce_index(It beg, It end, Unary unop, Init init, Binary binary)
+      {
+        ::oneapi::dpl::counting_iterator<int> cbeg(0);
+        /*
+        DPCT1007:20: Migration of this CUDA API is not supported by the Intel(R) DPC++
+        Compatibility Tool.
+        */
+        //counting_iterator<int> cend = cbeg + thrust::distance(beg, end);
+        ::oneapi::dpl::counting_iterator<int> cend = cbeg + std::distance(beg, end);
+
+        std::tuple<float, int> t = std::transform_reduce(
+            ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+            //oneapi::dpl::make_zip_iterator(std::make_tuple(beg, cbeg)),
+            //oneapi::dpl::make_zip_iterator(std::make_tuple(end, cend)),
+            ::oneapi::dpl::make_zip_iterator(beg, cbeg),
+            ::oneapi::dpl::make_zip_iterator(end, cend),
+            init,
+            binary,
+            unop);
+
+        return std::get<1>(t);
+      }
+
+      template<typename It, typename Unary>
+        int transform_reduce_min_index(It beg, It end, Unary unop)
+      {
+        std::tuple<float, int> min_tuple(std::numeric_limits<float>::max(), 0);
+        return transform_reduce_index(beg, end, unop, min_tuple, IndOp<false>());
+      }
+
+      template<typename It, typename Unary>
+        int transform_reduce_max_index(It beg, It end, Unary unop)
+      {
+        std::tuple<float, int> max_tuple(std::numeric_limits<float>::min(), 0);
+        return transform_reduce_index(beg, end, unop, max_tuple, IndOp<true>());
+      }    
+    }
+  }
+}
+
+pcl::oneapi::device::PointStream::PointStream(const Cloud& cloud_) : cloud(cloud_)
+{				
+  cloud_size = cloud.size();
+  facets_dists.create(cloud_size);
+  perm.create(cloud_size);
+
+  dpct::device_pointer<int> pbeg(perm.ptr());
+  dpct::iota(::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+             pbeg,
+             pbeg + cloud_size);  
+}
+
+void pcl::oneapi::device::PointStream::computeInitalSimplex()
+{
+  dpct::device_pointer<const PointType> beg(cloud.ptr());  
+  dpct::device_pointer<const PointType> end = beg + cloud_size;
+     
+  int minx = transform_reduce_min_index(beg, end, X());
+  int maxx = transform_reduce_max_index(beg, end, X());
+
+  PointType p1 = *(beg + minx);
+  PointType p2 = *(beg + maxx);
+
+  int maxl = transform_reduce_max_index(beg, end, LineDist(p1, p2));
+
+  PointType p3 = *(beg + maxl);
+    
+  int maxp = transform_reduce_max_index(beg, end, PlaneDist(p1, p2, p3));
+
+  PointType p4 = *(beg + maxp);
+
+  simplex.x1 = tr(p1);  simplex.x2 = tr(p2);  simplex.x3 = tr(p3);  simplex.x4 = tr(p4);
+
+  simplex.i1 = minx;    simplex.i2 = maxx;    simplex.i3 = maxl;    simplex.i4 = maxp;
+
+  float maxy = std::transform_reduce(
+      ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+      beg,
+      end,
+      std::numeric_limits<float>::min(),
+      sycl::maximum<float>(),
+      Y());
+  float miny = std::transform_reduce(
+      ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+      beg,
+      end,
+      std::numeric_limits<float>::max(),
+      sycl::minimum<float>(),
+      Y());
+
+  float maxz = std::transform_reduce(
+      ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+      beg,
+      end,
+      std::numeric_limits<float>::min(),
+      sycl::maximum<float>(),
+      Z());
+  float minz = std::transform_reduce(
+      ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+      beg,
+      end,
+      std::numeric_limits<float>::max(),
+      sycl::minimum<float>(),
+      Z());
+
+  float dx = (p2.x() - p1.x());
+  float dy = (maxy - miny);
+  float dz = (maxz - minz);
+
+  cloud_diag = sqrt(dx*dx + dy*dy + dz*dz);
+
+  simplex.p1 = compute_plane(simplex.x4, simplex.x2, simplex.x3, simplex.x1);
+  simplex.p2 = compute_plane(simplex.x3, simplex.x1, simplex.x4, simplex.x2);
+  simplex.p3 = compute_plane(simplex.x2, simplex.x1, simplex.x4, simplex.x3);
+  simplex.p4 = compute_plane(simplex.x1, simplex.x2, simplex.x3, simplex.x4);  
+}
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      void init_fs(int i1, int i2, int i3, int i4, PtrStep<int> verts_inds)
+      {
+        *(sycl::int4*)verts_inds.ptr(0) = sycl::int4(i2, i1, i1, i1);
+        *(sycl::int4*)verts_inds.ptr(1) = sycl::int4(i3, i3, i2, i2);
+        *(sycl::int4*)verts_inds.ptr(2) = sycl::int4(i4, i4, i4, i3);
+      }
+    }
+  }
+}
+
+void pcl::oneapi::device::FacetStream::setInitialFacets(const InitalSimplex& s)
+{
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+    PtrStep<int> verts_inds_ct4 = verts_inds;
+
+    cgh.parallel_for(
+        sycl::nd_range<3>(sycl::range<3>(1, 1, 1), sycl::range<3>(1, 1, 1)),
+        [=](sycl::nd_item<3> item_ct1) {
+          pcl::oneapi::device::init_fs(s.i1, s.i2, s.i3, s.i4, verts_inds_ct4);
+        });
+  }).wait();
+
+  facet_count = 4;
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      struct InitalClassify
+      {
+        float diag;
+        sycl::float4 pl1, pl2, pl3, pl4;
+
+        InitalClassify(const sycl::float4& p1,
+                       const sycl::float4& p2,
+                       const sycl::float4& p3,
+                       const sycl::float4& p4,
+                       float diagonal)
+        : diag(diagonal), pl1(p1), pl2(p2), pl3(p3), pl4(p4)
+        {
+          pl1 *= compue_inv_normal_norm(pl1);
+          pl2 *= compue_inv_normal_norm(pl2);
+          pl3 *= compue_inv_normal_norm(pl3);
+          pl4 *= compue_inv_normal_norm(pl4);
+        }
+
+        __dpct_inline__ std::uint64_t
+        operator()(const PointType& p) const
+        {
+          sycl::float4 x = p;
+          x.w() = 1;
+
+          float d0 = dot(pl1, x);
+          float d1 = dot(pl2, x);
+          float d2 = dot(pl3, x);
+          float d3 = dot(pl4, x);
+
+          float dists[] = { d0, d1, d2, d3 };
+          int negs_inds[4];
+          int neg_count = 0;
+
+          int idx = std::numeric_limits<int>::max();
+          float dist = 0;
+
+          #pragma unroll
+          for(int i = 0; i < 4; ++i)
+            if (dists[i] < 0)
+              negs_inds[neg_count++] = i;
+
+          if (neg_count == 3)
+          {
+            int i1 = negs_inds[1];
+            int i2 = negs_inds[2];
+
+            int ir = sycl::fabs(dists[i1]) < sycl::fabs(dists[i2]) ? i2 : i1;
+            negs_inds[1] = ir;
+            --neg_count;
+          }
+
+          if (neg_count == 2)
+          {
+            int i1 = negs_inds[0];
+            int i2 = negs_inds[1];
+
+            int ir = sycl::fabs(dists[i1]) < sycl::fabs(dists[i2]) ? i2 : i1;
+            negs_inds[0] = ir;
+            --neg_count;              
+          }
+
+          if (neg_count == 1)
+          {
+            idx = negs_inds[0];
+            dist =
+                diag - sycl::fabs(dists[idx]); // to ensure that sorting order is
+                                                 // inverse, i.e. distant points go first
+          }
+
+          //if (neg_count == 0)
+          //  then internal point ==>> idx = std::numeric_limits<int>::max()
+
+          std::uint64_t res = idx;
+          res <<= 32;
+          return res + *reinterpret_cast<unsigned int*>(&dist);
+        }		
+      };		
+
+      void initalClassifyKernel(const InitalClassify ic, const PointType* points, int cloud_size, std::uint64_t* output,
+                                sycl::nd_item<3>& item_ct1)
+      {
+        int index = item_ct1.get_local_id(2) +
+                    item_ct1.get_group(2) * item_ct1.get_local_range().get(2);
+
+        if (index < cloud_size)              
+          output[index] = ic(points[index]); 
+      }
+    }
+  }
+}
+
+void pcl::oneapi::device::PointStream::initalClassify()
+{
+  //thrust::device_ptr<const PointType> beg(cloud.ptr());
+  //thrust::device_ptr<const PointType> end = beg + cloud_size;
+  dpct::device_pointer<std::uint64_t> out(facets_dists.ptr());
+
+  InitalClassify ic(simplex.p1, simplex.p2, simplex.p3, simplex.p4, cloud_diag);
+  //thrust::transform(beg, end, out, ic);
+  
+  //printFuncAttrib(initalClassifyKernel);
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+    const PointType* cloud_ct1 = cloud;
+    int cloud_size_ct2 = cloud_size;
+    std::uint64_t * facets_dists_ct3 = facets_dists;
+
+    cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(1, 1, divUp(cloud_size, 256)) *
+                                           sycl::range<3>(1, 1, 256),
+                                       sycl::range<3>(1, 1, 256)),
+                     [=](sycl::nd_item<3> item_ct1) {
+                       pcl::oneapi::device::initalClassifyKernel(
+                           ic, cloud_ct1, cloud_size_ct2, facets_dists_ct3, item_ct1);
+                     });
+  }).wait();
+
+  dpct::device_pointer<int> pbeg(perm.ptr());
+  dpct::sort(::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+             out,
+             out + cloud_size,
+             pbeg);
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      dpct::global_memory<int, 0> new_cloud_size;
+      struct SearchFacetHeads
+      {		
+        std::uint64_t *facets_dists;
+        int cloud_size;
+        int facet_count;
+        int *perm;
+        const PointType* points;
+
+        mutable int* head_points;
+        //bool logger;
+
+        __dpct_inline__ void
+        operator()(int facet, int* new_cloud_size) const
+        {			
+          const std::uint64_t* b = facets_dists;
+          const std::uint64_t* e = b + cloud_size;
+
+          bool last_thread = facet == facet_count;
+
+          int search_value = !last_thread ? facet : std::numeric_limits<int>::max();		
+          int index = lower_bound(b, e, search_value, LessThanByFacet()) - b;			
+        
+          if (last_thread)
+              *new_cloud_size = index;
+          else
+          {
+            bool not_found = index == cloud_size || (facet != (facets_dists[index] >> 32));
+
+            head_points[facet] = not_found ? -1 : perm[index];		
+          }
+        }
+      };
+
+      void searchFacetHeadsKernel(const SearchFacetHeads sfh, sycl::nd_item<3>& item_ct1,
+                                  int *new_cloud_size)
+      {
+        int facet = item_ct1.get_local_id(2) +
+                    item_ct1.get_local_range().get(2) * item_ct1.get_group(2);
+
+        if (facet <= sfh.facet_count)
+          sfh(facet, new_cloud_size);
+      }
+    }
+  }
+}
+
+int pcl::oneapi::device::PointStream::searchFacetHeads(std::size_t facet_count, DeviceArray<int>& head_points)
+{
+  SearchFacetHeads sfh;
+
+  sfh.facets_dists = facets_dists;
+  sfh.cloud_size = (int)cloud_size;
+  sfh.facet_count = (int)facet_count;
+  sfh.perm = perm;
+  sfh.points = cloud.ptr();
+  sfh.head_points = head_points;  
+	
+  //thrust::counting_iterator<int> b(0);
+  //thrust::counting_iterator<int> e = b + facet_count + 1;  	
+  //thrust::for_each(b, e, sfh);
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+  new_cloud_size.init();
+
+  auto new_cloud_size_ptr_ct1 = new_cloud_size.get_ptr();
+
+  cgh.parallel_for(
+      sycl::nd_range<3>(sycl::range<3>(1, 1, divUp(facet_count + 1, 256)) *
+                            sycl::range<3>(1, 1, 256),
+                        sycl::range<3>(1, 1, 256)),
+      [=](sycl::nd_item<3> item_ct1) {
+        pcl::oneapi::device::searchFacetHeadsKernel(sfh, item_ct1, new_cloud_size_ptr_ct1);
+      });
+  }).wait();
+
+  int new_size;
+  /*
+  DPCT1003:27: Migrated API does not return error code. (*, 0) is inserted. You may need
+  to rewrite this code.
+  */
+  cudaSafeCall(
+      (dpct::get_default_queue()
+           .memcpy((void*)&new_size, new_cloud_size.get_ptr(), sizeof(new_size))
+           .wait(),
+       0));
+
+  return new_size;
+}
+
+///////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      struct NotMinus1
+      {
+        __dpct_inline__ int
+        operator()(const int& v) const {
+          return (v == -1) ? 0 : 1;
+        }
+      };
+
+      struct Compaction
+      {
+        enum 
+        {
+          CTA_SIZE = 256,
+
+          WARPS = CTA_SIZE/ Warp::WARP_SIZE
+        };
+
+        int* head_points_in;
+        PtrStep<int>  verts_inds_in;
+		
+        int *scan_buffer;
+        int facet_count;
+
+        mutable int* head_points_out;
+        mutable PtrStep<int>  verts_inds_out;
+		
+        mutable PtrStep<int> empty_facets;
+        mutable int *empty_count;
+
+        __dpct_inline__ void
+        operator()(sycl::nd_item<3>& item_ct1, volatile int* wapr_buffer) const
+        {
+          int idx = item_ct1.get_local_id(2) +
+                    item_ct1.get_group(2) * item_ct1.get_local_range().get(2);
+
+#if 0x7FFFFFFF >= 9000
+          /*
+          DPCT1086:28: Migration of __activemask is not supported. You may need to use
+          0xffffffff instead or adjust the code.
+          */
+          if (sycl::all_of_group(
+                item_ct1.get_sub_group(),
+                //(~__activemask() &
+                (~0xffffffff &
+                 (0x1 << item_ct1.get_sub_group().get_local_linear_id())) ||
+                    idx >= facet_count))
+            return;
+#else
+          if (sycl::all_of_group(item_ct1.get_sub_group(), idx >= facet_count))
+            return;
+#endif
+
+          int empty = 0;
+
+          if(idx < facet_count)
+          {
+            int head_idx = head_points_in[idx];
+            if (head_idx != -1)
+            {
+              int offset = scan_buffer[idx];
+
+              head_points_out[offset] = head_idx;
+					
+              verts_inds_out.ptr(0)[offset] = verts_inds_in.ptr(0)[idx];
+              verts_inds_out.ptr(1)[offset] = verts_inds_in.ptr(1)[idx];
+              verts_inds_out.ptr(2)[offset] = verts_inds_in.ptr(2)[idx];          
+            }
+            else                
+              empty = 1;                
+          }
+
+#if 0x7FFFFFFF >= 9000
+          /*
+          DPCT1086:29: Migration of __activemask is not supported. You may need to use
+          0xffffffff instead or adjust the code.
+          */
+          int total = sycl::popcount(sycl::reduce_over_group(
+              item_ct1.get_sub_group(),
+              //(__activemask() & (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+              (0xffffffff & (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                      empty
+                  ? (0x1 << item_ct1.get_sub_group().get_local_linear_id())
+                  : 0,
+              sycl::ext::oneapi::plus<>()));
+#else
+          int total = sycl::popcount(sycl::reduce_over_group(
+              item_ct1.get_sub_group(),
+              empty ? (0x1 << item_ct1.get_sub_group().get_local_linear_id()) : 0,
+              sycl::ext::oneapi::plus<>()));
+#endif
+          if (total > 0)
+          {
+#if 0x7FFFFFFF >= 9000
+            /*
+            DPCT1086:30: Migration of __activemask is not supported. You may need to use
+            0xffffffff instead or adjust the code.
+            */
+            int offset = Warp::binaryExclScan(sycl::reduce_over_group(
+                item_ct1.get_sub_group(),
+                //(__activemask() &
+                (0xffffffff &
+                 (0x1 << item_ct1.get_sub_group().get_local_linear_id())) &&
+                        empty
+                    ? (0x1 << item_ct1.get_sub_group().get_local_linear_id())
+                    : 0,
+                sycl::ext::oneapi::plus<>()),
+                item_ct1);
+#else
+            int offset = Warp::binaryExclScan(sycl::reduce_over_group(
+                item_ct1.get_sub_group(),
+                empty ? (0x1 << item_ct1.get_sub_group().get_local_linear_id()) : 0,
+                sycl::ext::oneapi::plus<>()),
+                item_ct1);
+#endif
+
+            int laneid = Warp::laneId(item_ct1);
+            int warpid = Warp::id(item_ct1);
+            if (laneid == 0)
+            {
+              int old = sycl::atomic<int>(sycl::global_ptr<int>(empty_count)).fetch_add(total);
+              wapr_buffer[warpid] = old;                    
+            }
+            int old = wapr_buffer[warpid];
+
+            if (empty)
+            {
+              empty_facets.ptr(0)[old + offset] = verts_inds_in.ptr(0)[idx];
+              empty_facets.ptr(1)[old + offset] = verts_inds_in.ptr(1)[idx];
+              empty_facets.ptr(2)[old + offset] = verts_inds_in.ptr(2)[idx];		                  
+            }
+          }							
+        }
+      };
+
+      void
+      compactionKernel(const Compaction c,
+                       sycl::nd_item<3>& item_ct1,
+                       volatile int* wapr_buffer) {
+        c(item_ct1, wapr_buffer);
+      }
+    }
+  }
+}
+
+
+void pcl::oneapi::device::FacetStream::compactFacets()
+{
+  int old_empty_count;  
+  empty_count.download(&old_empty_count);
+
+  dpct::device_pointer<int> b(head_points.ptr());
+  dpct::device_pointer<int> e = b + facet_count;
+  dpct::device_pointer<int> o(scan_buffer.ptr());
+
+  /*
+  DPCT1007:31: Migration of this CUDA API is not supported by the Intel(R) DPC++
+  Compatibility Tool.
+  */
+  //thrust::transform_exclusive_scan(b, e, o, NotMinus1(), 0, std::plus<int>());
+  std::transform_exclusive_scan(b, e, o, 0, std::plus<int>{}, NotMinus1());
+
+  Compaction c;
+
+  c.verts_inds_in   = verts_inds;
+  c.head_points_in  = head_points;    
+
+  c.scan_buffer = scan_buffer;
+  c.facet_count = facet_count;
+
+  c.head_points_out = head_points2;
+  c.verts_inds_out = verts_inds2;
+
+  c.empty_facets = empty_facets;
+  c.empty_count = empty_count;
+ 
+  int block = Compaction::CTA_SIZE;
+  int grid = divUp(facet_count, block);
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+    sycl::local_accessor<volatile int> wapr_buffer_acc_ct1(sycl::range<1>(8 /*WARPS*/), cgh);
+
+    cgh.parallel_for(
+        sycl::nd_range<3>(sycl::range<3>(1, 1, grid) * sycl::range<3>(1, 1, block),
+                          sycl::range<3>(1, 1, block)),
+        [=](sycl::nd_item<3> item_ct1) [[intel::reqd_sub_group_size(32)]] {
+          pcl::oneapi::device::compactionKernel(c, item_ct1, wapr_buffer_acc_ct1.get_pointer());
+        });
+  }).wait();
+
+  verts_inds.swap(verts_inds2);
+  head_points.swap(head_points2);
+
+  int new_empty_count;  
+  empty_count.download(&new_empty_count); 
+  
+  facet_count -= new_empty_count - old_empty_count;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////////
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      struct Classify
+      {
+        std::uint64_t* facets_dists;
+        int* scan_buffer;
+
+        int* head_points;
+        int* perm;
+        PtrStep<int>  verts_inds;
+
+        const PointType *points;
+
+        float diag;
+
+        int facet_count;
+
+        __dpct_inline__ void
+        operator()(int point_idx) const
+        {
+          int perm_index = perm[point_idx];
+          
+          int facet = facets_dists[point_idx] >> 32;
+          facet = scan_buffer[facet];
+
+          int hi = head_points[facet];
+
+          if (hi == perm_index)
+          {
+            std::uint64_t res = std::numeric_limits<int>::max();
+            res <<= 32;
+            facets_dists[point_idx] = res;
+          }
+          else
+          {
+            int i1 = verts_inds.ptr(0)[facet];
+            int i2 = verts_inds.ptr(1)[facet];
+            int i3 = verts_inds.ptr(2)[facet];
+
+            sycl::float3 hp = tr(points[hi]);
+            sycl::float3 v1 = tr(points[i1]);
+            sycl::float3 v2 = tr(points[i2]);
+            sycl::float3 v3 = tr(points[i3]);
+
+            sycl::float4 p0 = compute_plane(hp, v1, v2, /*opposite*/ v3); // j
+            sycl::float4 p1 = compute_plane(hp, v2, v3, /*opposite*/ v1); // facet_count + j
+            sycl::float4 p2 = compute_plane(hp, v3, v1, /*opposite*/ v2); // facet_count + j*2
+
+            /*
+            DPCT1084:35: The function call has multiple migration results in different
+            template instantiations that could not be unified. You may need to adjust
+            the code.
+            */
+            p0 *= compue_inv_normal_norm(p0);
+            /*
+            DPCT1084:36: The function call has multiple migration results in different
+            template instantiations that could not be unified. You may need to adjust
+            the code.
+            */
+            p1 *= compue_inv_normal_norm(p1);
+            /*
+            DPCT1084:37: The function call has multiple migration results in different
+            template instantiations that could not be unified. You may need to adjust
+            the code.
+            */
+            p2 *= compue_inv_normal_norm(p2);
+
+            sycl::float4 p = points[perm_index];
+            p.w() = 1;
+
+            float d0 = dot(p, p0);
+            float d1 = dot(p, p1);
+            float d2 = dot(p, p2);
+
+            float dists[] = { d0, d1, d2 };
+            int negs_inds[3];
+            int neg_count = 0;
+
+            int new_idx = std::numeric_limits<int>::max();
+            float dist = 0;
+
+            int indeces[] = { facet, facet + facet_count, facet + facet_count * 2 };
+
+            #pragma unroll
+            for(int i = 0; i < 3; ++i)
+              if (dists[i] < 0)
+                negs_inds[neg_count++] = i;
+
+            if (neg_count == 3)
+            {
+              int i1 = negs_inds[1];
+              int i2 = negs_inds[2];
+
+              int ir = sycl::fabs(dists[i1]) < sycl::fabs(dists[i2]) ? i2 : i1;
+              negs_inds[1] = ir;
+              --neg_count;
+            }
+
+            if (neg_count == 2)
+            {
+              int i1 = negs_inds[0];
+              int i2 = negs_inds[1];
+
+              int ir = sycl::fabs(dists[i1]) < sycl::fabs(dists[i2]) ? i2 : i1;
+              negs_inds[0] = ir;
+              --neg_count;
+            }
+
+            if (neg_count == 1)
+            {
+              new_idx = negs_inds[0];
+              dist =
+                diag -
+                sycl::fabs(dists[new_idx]); // to ensure that sorting order is
+                                              // inverse, i.e. distant points go first
+              new_idx = indeces[new_idx];
+            }
+
+            // if (neg_count == 0)
+            // new_idx = std::numeric_limits<int>::max() ==>> internal point
+                      	       	 	   
+            std::uint64_t res = new_idx;
+            res <<= 32;
+            res += *reinterpret_cast<unsigned int*>(&dist);
+
+            facets_dists[point_idx] = res;
+          } /* if (hi == perm_index) */
+        }
+      };
+
+      void classifyKernel(const Classify c, int cloud_size, sycl::nd_item<3>& item_ct1)
+      {
+        int point_idx = item_ct1.get_local_id(2) +
+                          item_ct1.get_group(2) * item_ct1.get_local_range().get(2);
+
+        if ( point_idx < cloud_size )
+          c(point_idx);
+      }
+    }
+  }
+}
+
+void pcl::oneapi::device::PointStream::classify(FacetStream& fs)
+{
+  Classify c;
+
+  c.facets_dists = facets_dists;
+  c.scan_buffer = fs.scan_buffer;
+  c.head_points = fs.head_points;
+  c.perm = perm;
+
+  c.verts_inds = fs.verts_inds;
+  c.points = cloud;
+
+  c.diag = cloud_diag;
+  c.facet_count = fs.facet_count;
+
+  //thrust::counting_iterator<int> b(0);    
+  //thrust::for_each(b, b + cloud_size, c);
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+  auto cloud_size_ct1 = cloud_size;
+
+  cgh.parallel_for(sycl::nd_range<3>(sycl::range<3>(1, 1, divUp(cloud_size, 256)) *
+                                         sycl::range<3>(1, 1, 256),
+                                     sycl::range<3>(1, 1, 256)),
+                   [=](sycl::nd_item<3> item_ct1) {
+                     pcl::oneapi::device::classifyKernel(c, cloud_size_ct1, item_ct1);
+                   });
+  });
+  /*
+  DPCT1010:38: SYCL uses exceptions to report errors and does not use the error codes.
+  The call was replaced with 0. You need to rewrite this code.
+  */
+  cudaSafeCall(0);
+  /*
+  DPCT1003:39: Migrated API does not return error code. (*, 0) is inserted. You may need
+  to rewrite this code.
+  */
+  cudaSafeCall((dpct::get_current_device().queues_wait_and_throw(), 0));
+
+  dpct::device_pointer<std::uint64_t> beg(facets_dists.ptr());
+  dpct::device_pointer<std::uint64_t> end = beg + cloud_size;
+
+  dpct::device_pointer<int> pbeg(perm.ptr());
+  dpct::sort(::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()),
+             beg,
+             end,
+             pbeg);
+}
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      struct SplitFacets
+      {
+        int* head_points;
+        int facet_count;
+
+        mutable PtrStep<int>  verts_inds;
+
+        __dpct_inline__ void
+        operator()(int facet) const
+        {
+          int hi = head_points[facet];
+          int i1 = verts_inds.ptr(0)[facet];
+          int i2 = verts_inds.ptr(1)[facet];
+          int i3 = verts_inds.ptr(2)[facet];
+        
+          make_facet(hi, i1, i2, facet);
+          make_facet(hi, i2, i3, facet + facet_count);
+          make_facet(hi, i3, i1, facet + facet_count * 2);
+        }
+
+        __dpct_inline__ void
+        make_facet(int i1, int i2, int i3, int out_idx) const
+        {
+          verts_inds.ptr(0)[out_idx] = i1;
+          verts_inds.ptr(1)[out_idx] = i2;
+          verts_inds.ptr(2)[out_idx] = i3;
+        }
+      };
+
+      void splitFacetsKernel(const SplitFacets sf, sycl::nd_item<3>& item_ct1)
+      {
+        int facet = item_ct1.get_local_id(2) +
+                    item_ct1.get_group(2) * item_ct1.get_local_range().get(2);
+
+        if (facet < sf.facet_count)        
+          sf(facet);        
+      }
+    }
+  }
+}
+
+void pcl::oneapi::device::FacetStream::splitFacets()
+{
+  SplitFacets sf;
+  sf.head_points = head_points;
+  sf.verts_inds = verts_inds;
+  sf.facet_count = facet_count;
+    
+
+  //thrust::counting_iterator<int> b(0);    
+  //thrust::for_each(b, b + facet_count, sf);
+
+  dpct::get_default_queue().parallel_for(
+      sycl::nd_range<3>(sycl::range<3>(1, 1, divUp(facet_count, 256)) *
+                            sycl::range<3>(1, 1, 256),
+                        sycl::range<3>(1, 1, 256)),
+      [=](sycl::nd_item<3> item_ct1) {
+        pcl::oneapi::device::splitFacetsKernel(sf, item_ct1);
+      });
+  /*
+  DPCT1010:40: SYCL uses exceptions to report errors and does not use the error codes.
+  The call was replaced with 0. You need to rewrite this code.
+  */
+  cudaSafeCall(0);
+  /*
+  DPCT1003:41: Migrated API does not return error code. (*, 0) is inserted. You may need
+  to rewrite this code.
+  */
+  cudaSafeCall((dpct::get_current_device().queues_wait_and_throw(), 0));
+
+  facet_count *= 3;
+}
+
+size_t pcl::oneapi::device::remove_duplicates(DeviceArray<int>& indeces)
+{
+  dpct::device_pointer<int> beg(indeces.ptr());
+  dpct::device_pointer<int> end = beg + indeces.size();
+
+  ::oneapi::dpl::sort(
+      ::oneapi::dpl::execution::make_device_policy(dpct::get_default_queue()), beg, end);
+  return (std::size_t)(std::unique(beg, end) - beg);
+}
+
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      void gatherKernel(const PtrSz<int> indeces, const PointType* src, PointType* dst,
+                        sycl::nd_item<3>& item_ct1)
+      {
+          int idx = item_ct1.get_group(2) * item_ct1.get_local_range().get(2) +
+                    item_ct1.get_local_id(2);
+
+          if (idx < indeces.size)
+            dst[idx] = src[indeces.data[idx]];
+      }
+    }
+  }
+}
+
+void pcl::oneapi::device::pack_hull(const DeviceArray<PointType>& points, const DeviceArray<int>& indeces, DeviceArray<PointType>& output)
+{
+  output.create(indeces.size());
+
+  //device_ptr<const PointType> in(points.ptr());  
+  
+  //thrust::device_ptr<const int> mb(indeces.ptr());
+  //thrust::device_ptr<const int> me = mb + indeces.size();
+
+  //device_ptr<PointType> out(output.ptr());  
+
+  //thrust::gather(mb, me, in, out);
+
+  dpct::get_default_queue().submit([&](sycl::handler& cgh) {
+    //auto indeces_ct0 = indeces;
+    const PtrSz<int> indeces_ct0 = indeces;
+    //auto points_ct1 = points;
+    const PointType* points_ct1 = points;
+    //auto output_ct2 = output;
+    pcl::oneapi::device::PointType * output_ct2 = output;
+
+    cgh.parallel_for(
+        sycl::nd_range<3>(sycl::range<3>(1, 1, divUp(indeces.size(), 256)) *
+                              sycl::range<3>(1, 1, 256),
+                          sycl::range<3>(1, 1, 256)),
+        [=](sycl::nd_item<3> item_ct1) {
+          pcl::oneapi::device::gatherKernel(indeces_ct0, points_ct1, output_ct2, item_ct1);
+        });
+  });
+  /*
+  DPCT1010:42: SYCL uses exceptions to report errors and does not use the error codes.
+  The call was replaced with 0. You need to rewrite this code.
+  */
+  cudaSafeCall(0);
+  /*
+  DPCT1003:43: Migrated API does not return error code. (*, 0) is inserted. You may need
+  to rewrite this code.
+  */
+  cudaSafeCall((dpct::get_current_device().queues_wait_and_throw(), 0));
+}
diff --git a/oneapi/surface/src/dpcpp/device.h b/oneapi/surface/src/dpcpp/device.h
new file mode 100644
index 000000000..a4b753c01
--- /dev/null
+++ b/oneapi/surface/src/dpcpp/device.h
@@ -0,0 +1,115 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include "internal.h"
+#include <pcl/oneapi/utils/device/vector_math.hpp>
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      /** \brief Computers plane from 3 points (v, v1, v2), ensures that point P lies positive subspace.
+        * \param[in] v 3D point volume tsdf volume container
+        * \param[in] v1 3D point volume tsdf volume container
+        * \param[in] v2 3D point volume tsdf volume container
+        * \param[in] p point for sign check of plane coefs (should lie in positive subspace)
+        * \return a,b,c,d coefs vector
+        */
+      __dpct_inline__ sycl::float4
+      compute_plane(const sycl::float3& v,
+                    const sycl::float3& v1,
+                    const sycl::float3& v2,
+                    const sycl::float3& p)
+      {
+        sycl::float3 n = cross(v1 - v,
+                               v2 - v);
+
+        float d = -dot(n, v);
+
+        if (dot(n, p) + d < 0)
+        {
+          //dpct_operator_overloading::operator*=(n, -1.f);
+          //dpct_operator_overloading::operator*=(n, -1.f);
+          n*=-1.f;
+          d*=-1.f;
+        }
+        return sycl::float4(n.x(), n.y(), n.z(), d);
+      }
+
+      __dpct_inline__ sycl::float3
+      tr(const PointType& p) {
+        return sycl::float3(p.x(), p.y(), p.z());
+      }
+
+      struct LessThanByFacet
+      {
+        __dpct_inline__ bool
+        operator()(const std::uint64_t& e1, const int& e2) const
+        {
+          int i1 = (int)(e1 >> 32);
+          return i1 < e2;
+        }
+      };
+
+      __dpct_inline__ float
+      compue_inv_normal_norm(const sycl::float4& p) {
+        return 1.f / sycl::sqrt(p.x() * p.x() + p.y() * p.y() + p.z() * p.z());
+      }
+
+/*
+DPCT1011:11: The tool detected overloaded operators for built-in vector types, which may
+conflict with the SYCL 1.2.1 standard operators (see 4.10.2.1 Vec interface). The tool
+inserted a namespace to avoid the conflict. Use SYCL 1.2.1 standard operators instead.
+*/
+// Remove overloaded operators for vector multiply a value
+//    namespace dpct_operator_overloading {
+/*
+__dpct_inline__ sycl::float4&
+operator*=(sycl::float4& p, float v) {
+  p.x() *= v; p.y() *= v; p.z() *= v; p.w() *= v; return p;
+}*/
+
+//} // namespace dpct_operator_overloading
+    }
+  }
+};
diff --git a/oneapi/surface/src/internal.h b/oneapi/surface/src/internal.h
new file mode 100644
index 000000000..a1dad3159
--- /dev/null
+++ b/oneapi/surface/src/internal.h
@@ -0,0 +1,123 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#pragma once
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cstdint>
+
+#include <pcl/oneapi/containers/device_array.h>
+
+namespace pcl
+{
+  namespace oneapi
+  {
+    namespace device
+    {
+      using PointType = sycl::float4;
+      using Cloud = pcl::oneapi::DeviceArray<PointType>;
+
+      using FacetsDists = DeviceArray<std::uint64_t>;
+      using Perm = DeviceArray<int>;
+
+      struct InitalSimplex
+      {
+        sycl::float3 x1, x2, x3, x4;
+        int i1, i2, i3, i4;
+
+        sycl::float4 p1, p2, p3, p4;
+      };
+
+      struct FacetStream
+      {	
+      public:
+        FacetStream(std::size_t buffer_size);
+
+        // indeces: in each col indeces of vertexes for single facet
+        DeviceArray2D<int>  verts_inds;		  
+
+        DeviceArray<int> head_points;		  
+        std::size_t facet_count;
+
+        DeviceArray2D<int>  empty_facets;
+        DeviceArray<int> empty_count;
+		  
+        DeviceArray<int>  scan_buffer;
+
+        void setInitialFacets(const InitalSimplex& simplex);
+
+        void compactFacets();
+
+        bool canSplit() const;
+        void splitFacets();
+      private:
+		  
+        //for compation (double buffering)
+        DeviceArray2D<int>  verts_inds2;
+        DeviceArray<sycl::float4> facet_planes2;
+        DeviceArray<int> head_points2;		  
+      };	
+	 
+      struct PointStream
+      {
+      public:
+        PointStream(const Cloud& cloud);
+		  
+        const Cloud cloud;
+        FacetsDists facets_dists;
+        Perm perm;
+
+        std::size_t cloud_size;
+
+        InitalSimplex simplex;
+        float cloud_diag;
+
+        void computeInitalSimplex();
+
+        void initalClassify();
+		  
+        int searchFacetHeads(std::size_t facet_count, DeviceArray<int>& head_points);
+
+        void classify(FacetStream& fs);	  		  
+      };	 	  	
+
+      std::size_t remove_duplicates(DeviceArray<int>& indeces);
+      void pack_hull(const DeviceArray<PointType>& points, const DeviceArray<int>& indeces, DeviceArray<PointType>& output);
+    }
+  }
+}
diff --git a/oneapi/surface/src/mls.cpp b/oneapi/surface/src/mls.cpp
new file mode 100644
index 000000000..94aba5cf5
--- /dev/null
+++ b/oneapi/surface/src/mls.cpp
@@ -0,0 +1,55 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+//#include <pcl/oneapi/surface/mls.h>
+#include <pcl/oneapi/surface/impl/mls.hpp>
+
+#ifndef PCL_NO_PRECOMPILE
+#include <pcl/point_types.h>
+#include <pcl/impl/instantiate.hpp>
+//PCL_INSTANTIATE(OneAPI_MLS, PCL_POINT_TYPES)
+#ifdef PCL_ONLY_CORE_POINT_TYPES
+// Instantiations of specific point types
+PCL_INSTANTIATE_PRODUCT(MovingLeastSquares,
+    ((pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGB)(pcl::PointXYZRGBA)(pcl::PointXYZRGBNormal)(pcl::PointNormal))
+    ((pcl::PointXYZ)(pcl::PointXYZI)(pcl::PointXYZRGB)(pcl::PointXYZRGBA)(pcl::PointXYZRGBNormal)(pcl::PointNormal)))
+#else
+PCL_INSTANTIATE_PRODUCT(MovingLeastSquares, (PCL_XYZ_POINT_TYPES)(PCL_XYZ_POINT_TYPES))
+#endif
+#endif    // PCL_NO_PRECOMPILE
diff --git a/oneapi/surface_omp/CMakeLists.txt b/oneapi/surface_omp/CMakeLists.txt
new file mode 100644
index 000000000..986d20525
--- /dev/null
+++ b/oneapi/surface_omp/CMakeLists.txt
@@ -0,0 +1,58 @@
+set(SUBSYS_NAME oneapi_surface_omp)
+set(SUBSYS_PATH oneapi/surface_omp)
+set(SUBSYS_DESC "Point cloud surface library with OpenMP offloading")
+set(SUBSYS_DEPS common search kdtree octree surface)
+set(CMAKE_C_COMPILER "icx")
+set(CMAKE_CXX_COMPILER "icpx")
+set(CMAKE_CXX_STANDARD 17)
+set(PCL_CXX_COMPILE_FEATURES cxx_std_17)
+
+set(build TRUE)
+PCL_SUBSYS_OPTION(build "${SUBSYS_NAME}" "${SUBSYS_DESC}" ON)
+PCL_SUBSYS_DEPEND(build "${SUBSYS_NAME}" DEPS ${SUBSYS_DEPS})# OPT_DEPS qhull vtk)
+PCL_SET_SUBSYS_INCLUDE_DIR("${SUBSYS_NAME}" "${SUBSYS_PATH}")
+PCL_ADD_DOC("${SUBSYS_NAME}")
+
+if(NOT build)
+  return()
+endif()
+
+set(srcs
+  "src/gp3.cpp"
+)
+
+set(incs
+  "include/pcl/${SUBSYS_PATH}/gp3.h"
+)
+
+set(impl_incs
+  "include/pcl/${SUBSYS_PATH}/impl/gp3.hpp"
+)
+
+set(LIB_NAME "pcl_${SUBSYS_NAME}")
+
+include_directories(
+  "${CMAKE_CURRENT_SOURCE_DIR}/include"
+  "${CMAKE_CURRENT_SOURCE_DIR}"
+)
+
+find_package(TBB REQUIRED)
+
+# Enabling Intel OpenMP offloading
+if(WIN32)
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Qiopenmp ")
+else()
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fiopenmp ")
+endif()
+PCL_ADD_LIBRARY(${LIB_NAME} COMPONENT ${SUBSYS_NAME} SOURCES ${srcs} ${incs} ${impl_incs})
+set_target_properties(${LIB_NAME} PROPERTIES LINKER_LANGUAGE CXX)
+if(WIN32)
+target_link_libraries("${LIB_NAME}" msvcrt.lib)
+endif()
+target_link_libraries("${LIB_NAME}" TBB::tbb pcl_common pcl_search pcl_kdtree pcl_octree pcl_surface)
+#target_link_libraries("${LIB_NAME}" pcl_common pcl_search pcl_kdtree pcl_octree pcl_surface)
+target_include_directories(${LIB_NAME} PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+PCL_MAKE_PKGCONFIG(${LIB_NAME} COMPONENT ${SUBSYS_NAME} DESC ${SUBSYS_DESC} PCL_DEPS ${SUBSYS_DEPS})
+
+# Install include files
+PCL_ADD_INCLUDES("${SUBSYS_PATH}" "${SUBSYS_PATH}" ${incs})
diff --git a/oneapi/surface_omp/include/pcl/oneapi/surface_omp/gp3.h b/oneapi/surface_omp/include/pcl/oneapi/surface_omp/gp3.h
new file mode 100644
index 000000000..51ad90ed3
--- /dev/null
+++ b/oneapi/surface_omp/include/pcl/oneapi/surface_omp/gp3.h
@@ -0,0 +1,338 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Point Cloud Library (PCL) - www.pointclouds.org
+ *  Copyright (c) 2010-2011, Willow Garage, Inc.
+ *
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#pragma once
+
+#include <CL/sycl.hpp>
+
+// PCL includes
+#include <pcl/surface/reconstruction.h>
+
+#include <pcl/kdtree/kdtree.h>
+
+#include <fstream>
+
+#include <Eigen/Geometry> // for cross
+
+namespace pcl
+{
+  struct PolygonMesh;
+
+  template<typename...>
+  struct PointNormalExt;
+
+  template <typename PointInT>
+  struct PointNormalExt<PointInT> {
+    PointInT pt;
+    inline bool operator<(const PointNormalExt &rhs) const { return std::tie(pt.x, pt.y, pt.z) < std::tie(rhs.pt.x, rhs.pt.y, rhs.pt.z);}
+  };
+  /** \brief GreedyProjectionTriangulation is an implementation of a greedy triangulation algorithm for 3D points
+    * based on local 2D projections. It assumes locally smooth surfaces and relatively smooth transitions between
+    * areas with different point densities.
+    * \author Zoltan Csaba Marton
+    * \ingroup surface
+    */
+  template <typename PointInT>
+  class GreedyProjectionTriangulationOMP : public MeshConstruction<PointInT>
+  {
+    public:
+      using Ptr = shared_ptr<GreedyProjectionTriangulationOMP<PointInT> >;
+      using ConstPtr = shared_ptr<const GreedyProjectionTriangulationOMP<PointInT> >;
+
+      using MeshConstruction<PointInT>::tree_;
+      using MeshConstruction<PointInT>::input_;
+      using MeshConstruction<PointInT>::indices_;
+
+      using KdTree = pcl::KdTree<PointInT>;
+      using KdTreePtr = typename KdTree::Ptr;
+
+      using PointCloudIn = pcl::PointCloud<PointInT>;
+      using PointCloudInPtr = typename PointCloudIn::Ptr;
+      using PointCloudInConstPtr = typename PointCloudIn::ConstPtr;
+
+      enum GP3Type
+      {
+        NONE = -1,    // not-defined
+        FREE = 0,
+        FRINGE = 1,
+        BOUNDARY = 2,
+        COMPLETED = 3
+      };
+
+      struct Link
+      {
+        Link(int a, int b) {left = a; right = b;}
+        int left;
+        int right;
+      };
+
+      struct PointXYZExt : pcl::PointXYZ
+      {
+        inline bool operator==(const PointXYZExt &rhs) const { return ((x == rhs.x) && (y == rhs.y) && (z == rhs.z));}
+        inline bool operator<(const PointXYZExt &rhs) const { return std::tie(x, y, z) < std::tie(rhs.x, rhs.y, rhs.z);}
+      };
+
+      struct Vertices
+      {
+        int x;
+        int y;
+        int z;
+
+        inline bool operator==(const Vertices &rhs) const { return ((x == rhs.x) && (y == rhs.y) && (z == rhs.z));}
+        inline bool operator<(const Vertices &rhs) const { return std::tie(x, y, z) < std::tie(rhs.x, rhs.y, rhs.z);}
+      };
+
+
+      /** \brief Empty constructor. */
+      GreedyProjectionTriangulationOMP () :
+        mu_ (0),
+        search_radius_ (0), // must be set by user
+        nnn_ (100),
+        minimum_angle_ (M_PI/18), // 10 degrees
+        maximum_angle_ (2*M_PI/3), // 120 degrees
+        eps_angle_(M_PI/4), //45 degrees,
+        consistent_(false),
+        consistent_ordering_ (false),
+        threads_ (1),
+        overlapPercentage_ (0.02),
+        cleanDuplicate_ (false)
+      {};
+
+      /** \brief Set the multiplier of the nearest neighbor distance to obtain the final search radius for each point
+       *  (this will make the algorithm adapt to different point densities in the cloud).
+        * \param[in] mu the multiplier
+        */
+      inline void
+      setMu (double mu) { mu_ = mu; }
+
+      /** \brief Get the nearest neighbor distance multiplier. */
+      inline double
+      getMu () const { return (mu_); }
+
+      /** \brief Set the maximum number of nearest neighbors to be searched for.
+        * \param[in] nnn the maximum number of nearest neighbors
+        */
+      inline void
+      setMaximumNearestNeighbors (int nnn) { nnn_ = nnn; }
+
+      /** \brief Get the maximum number of nearest neighbors to be searched for. */
+      inline int
+      getMaximumNearestNeighbors () const { return (nnn_); }
+
+      /** \brief Set the sphere radius that is to be used for determining the k-nearest neighbors used for triangulating.
+        * \param[in] radius the sphere radius that is to contain all k-nearest neighbors
+        * \note This distance limits the maximum edge length!
+        */
+      inline void
+      setSearchRadius (double radius) { search_radius_ = radius; }
+
+      /** \brief Get the sphere radius used for determining the k-nearest neighbors. */
+      inline double
+      getSearchRadius () const { return (search_radius_); }
+
+      /** \brief Set the minimum angle each triangle should have.
+        * \param[in] minimum_angle the minimum angle each triangle should have
+        * \note As this is a greedy approach, this will have to be violated from time to time
+        */
+      inline void
+      setMinimumAngle (double minimum_angle) { minimum_angle_ = minimum_angle; }
+
+      /** \brief Get the parameter for distance based weighting of neighbors. */
+      inline double
+      getMinimumAngle () const { return (minimum_angle_); }
+
+      /** \brief Set the maximum angle each triangle can have.
+        * \param[in] maximum_angle the maximum angle each triangle can have
+        * \note For best results, its value should be around 120 degrees
+        */
+      inline void
+      setMaximumAngle (double maximum_angle) { maximum_angle_ = maximum_angle; }
+
+      /** \brief Get the parameter for distance based weighting of neighbors. */
+      inline double
+      getMaximumAngle () const { return (maximum_angle_); }
+
+      /** \brief Don't consider points for triangulation if their normal deviates more than this value from the query point's normal.
+        * \param[in] eps_angle maximum surface angle
+        * \note As normal estimation methods usually give smooth transitions at sharp edges, this ensures correct triangulation
+        *       by avoiding connecting points from one side to points from the other through forcing the use of the edge points.
+        */
+      inline void
+      setMaximumSurfaceAngle (double eps_angle) { eps_angle_ = eps_angle; }
+
+      /** \brief Get the maximum surface angle. */
+      inline double
+      getMaximumSurfaceAngle () const { return (eps_angle_); }
+
+      /** \brief Set the flag if the input normals are oriented consistently.
+        * \param[in] consistent set it to true if the normals are consistently oriented
+        */
+      inline void
+      setNormalConsistency (bool consistent) { consistent_ = consistent; }
+
+      /** \brief Get the flag for consistently oriented normals. */
+      inline bool
+      getNormalConsistency () const { return (consistent_); }
+
+      /** \brief Set the flag to order the resulting triangle vertices consistently (positive direction around normal).
+        * @note Assumes consistently oriented normals (towards the viewpoint) -- see setNormalConsistency ()
+        * \param[in] consistent_ordering set it to true if triangle vertices should be ordered consistently
+        */
+      inline void
+      setConsistentVertexOrdering (bool consistent_ordering) { consistent_ordering_ = consistent_ordering; }
+
+      /** \brief Get the flag signaling consistently ordered triangle vertices. */
+      inline bool
+      getConsistentVertexOrdering () const { return (consistent_ordering_); }
+
+      /** \brief Set the maximum number of threads to use
+      * \param threads the maximum number of hardware threads to use (0 sets the value to 1)
+      */
+      inline void
+      setNumberOfThreads (unsigned int threads = 1)
+      {
+        if (threads > 0)
+          threads_ = threads;
+        else
+          PCL_ERROR("[pcl::%s::setNumberofThreads must be greater than 0!\n", getClassName().c_str());
+      }
+
+      inline void
+      setBlockOverlapPercentage(double percentage = 0.01)
+      {
+        if (percentage > 0.0)
+          overlapPercentage_ = percentage;
+        else
+          PCL_ERROR("[pcl::%s::setBlockOverlapPercentage must be greater than 0!\n", getClassName().c_str());
+      }
+
+      inline void
+      setRemoveDuplicateMesh(bool clear)
+      {
+        cleanDuplicate_ = clear;
+      }
+
+    protected:
+      /** \brief The nearest neighbor distance multiplier to obtain the final search radius. */
+      double mu_;
+
+      /** \brief The nearest neighbors search radius for each point and the maximum edge length. */
+      double search_radius_;
+
+      /** \brief The maximum number of nearest neighbors accepted by searching. */
+      int nnn_;
+
+      /** \brief The preferred minimum angle for the triangles. */
+      double minimum_angle_;
+
+      /** \brief The maximum angle for the triangles. */
+      double maximum_angle_;
+
+      /** \brief Maximum surface angle. */
+      double eps_angle_;
+
+      /** \brief Set this to true if the normals of the input are consistently oriented. */
+      bool consistent_;
+
+      /** \brief Set this to true if the output triangle vertices should be consistently oriented. */
+      bool consistent_ordering_;
+
+     private:
+      // Variables made global to decrease the number of parameters to helper functions
+
+      /** \brief Temporary variable to store a triangle (as a set of point indices) **/
+      pcl::Vertices triangle_;
+
+      /** \brief Flag to set if the next neighbor was already connected in the previous step.
+        * To avoid inconsistency it should not be connected again.
+        */
+      bool already_connected_;
+
+      /** \brief The maximum number of threads the scheduler should use. */
+      unsigned int threads_;
+
+      /** \brief The percentage of overlap between two blocks */
+      double overlapPercentage_;
+
+      /** \brief Remove duplicate points and triangles */
+      bool cleanDuplicate_;
+
+
+      /** \brief The actual surface reconstruction method.
+        * \param[out] output the resultant polygonal mesh
+        */
+      void
+      performReconstruction (pcl::PolygonMesh &output) override;
+
+      void performReconstruction (std::vector<pcl::Vertices> &polygons) override
+      {
+        PCL_ERROR ("[pcl::%s::peformReconstruction] not implemented.\n", getClassName().c_str());
+        polygons.clear();
+      }
+
+      /** \brief Compute surface reconstruction based on block to allow multiple threads perform concurrently. */
+      void
+      computeBlockGreedyProjection(const std::pair<double, double>& segment, pcl::PolygonMesh &triangles);
+
+
+      /** \brief Compute surface reconstruction based on block boundary to allow multiple threads perform concurrently. */
+      void
+      computeBoundaryBlockGreedyProjection(const std::pair<double, double>& segment, pcl::PolygonMesh &triangles);
+
+
+      /** \brief Remove duplication of point cloud and polygons in the mesh   */
+      void
+      meshCleanup(pcl::PolygonMesh& output);
+
+
+      /** \brief Remove duplication of polygons for the main mesh and boundary mesh  */
+      void
+      removeBoundaryPolygons(pcl::PolygonMesh &output, pcl::PolygonMesh& boundary);
+
+
+      /** \brief Class get name method. */
+      std::string
+      getClassName () const override { return ("GreedyProjectionTriangulationOMP"); }
+  };
+
+} // namespace pcl
+
+#ifdef PCL_NO_PRECOMPILE
+#include <pcl/oneapi/surface_omp/impl/gp3.hpp>
+#endif
diff --git a/oneapi/surface_omp/include/pcl/oneapi/surface_omp/impl/gp3.hpp b/oneapi/surface_omp/include/pcl/oneapi/surface_omp/impl/gp3.hpp
new file mode 100644
index 000000000..944eed4d1
--- /dev/null
+++ b/oneapi/surface_omp/include/pcl/oneapi/surface_omp/impl/gp3.hpp
@@ -0,0 +1,501 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#ifndef PCL_SURFACE_OMP_IMPL_GP3_H_
+#define PCL_SURFACE_OMP_IMPL_GP3_H_
+
+#include <unordered_set>
+#include <map>
+#include <pcl/surface/gp3.h>
+#include <pcl/oneapi/surface_omp/gp3.h>
+#include <pcl/common/common.h>
+#include <pcl/conversions.h>
+
+#include <tbb/tbb.h>
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT> void
+pcl::GreedyProjectionTriangulationOMP<PointInT>::performReconstruction (pcl::PolygonMesh &output)
+{
+  output.polygons.clear ();
+  output.polygons.reserve (2 * indices_->size ()); /// NOTE: usually the number of triangles is around twice the number of vertices
+
+  PointInT minPt, maxPt;
+
+  pcl::getMinMax3D(*input_, minPt, maxPt);
+
+  double blockRange =  (maxPt.x - minPt.x)/(double)(threads_);
+
+  double overlapRange = blockRange * overlapPercentage_;
+
+  std::vector<double> rangesVec;
+  std::vector<std::pair<double, double>> blocksVec;
+
+  for (int i = 0; i < threads_ + 1; i++)
+  {
+    rangesVec.push_back(minPt.x + blockRange*i);
+  }
+
+  // For each thread, it handles only one blocks based on blocksVec x coordinate
+  for (int i = 0; i < threads_; i++)
+  {
+    blocksVec.push_back(std::make_pair(rangesVec.at(i), rangesVec.at(i+1)));
+  }
+
+  std::vector<std::pair<double, double>> boundaryVec;
+
+  // For each thread, it handles only one boundary blocks based on blocksVec x coordinate
+  for (int i = 1; i < threads_; i++)
+  {
+    boundaryVec.push_back(std::make_pair(rangesVec.at(i) - overlapRange, rangesVec.at(i) + overlapRange));
+  }
+
+  std::vector<int> boundary_triangle_order;
+
+  // create a pattern to access boundary block triangle for each block
+  // example pattern like 0 0 0 1 1 2 2
+  for (int i = 0; i < threads_ - 1; i++)
+  {
+    if ((i == 0) || (i == threads_ - 1))
+      boundary_triangle_order.push_back(i);
+    boundary_triangle_order.push_back(i);
+    boundary_triangle_order.push_back(i);
+  }
+
+  std::vector<pcl::PolygonMesh> triangles (threads_);
+  std::vector<pcl::PolygonMesh> boundary_triangles (threads_ - 1);
+
+  tbb::parallel_for(tbb::blocked_range<size_t>(0, triangles.size()),
+    [&](const tbb::blocked_range<size_t> &range) {
+
+    for (size_t blk = range.begin(); blk < range.end(); ++blk)
+    {
+      computeBlockGreedyProjection(blocksVec.at(blk), triangles.at(blk));
+      if (blk < boundary_triangles.size())
+        computeBoundaryBlockGreedyProjection(boundaryVec.at(blk), boundary_triangles.at(blk));
+
+      pcl::PolygonMesh triangle_blk;
+
+      triangle_blk = boundary_triangles.at(boundary_triangle_order.at(blk*2));
+
+      if ((blk != 0) && (blk != (threads_ - 1)))
+      {
+        // combine both triangles_gap
+        triangle_blk += boundary_triangles.at(boundary_triangle_order.at(blk*2+1));
+      }
+      removeBoundaryPolygons(triangles.at(blk), triangle_blk);
+
+      if (blk < boundary_triangles.size())
+        triangles.at(blk) += boundary_triangles.at(blk);
+    }
+  });
+
+  for (int blk = 0; blk < threads_; blk++)
+  {
+    output += triangles.at(blk);
+  }
+
+  if (cleanDuplicate_)
+    meshCleanup(output);
+
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT> void
+pcl::GreedyProjectionTriangulationOMP<PointInT>::computeBlockGreedyProjection (const std::pair<double, double>& segment,
+    pcl::PolygonMesh &triangles)
+{
+  typename pcl::PointCloud<PointInT>::Ptr partial_cloud(new pcl::PointCloud<PointInT>());
+
+  partial_cloud->points.reserve((*input_).size()/threads_);
+
+  for (int pt = 0; pt < (*input_).size(); pt++)
+  {
+    if ((input_->points[pt].x >= segment.first) &&
+        (input_->points[pt].x < segment.second))
+    {
+      partial_cloud->push_back(input_->points[pt]);
+    }
+  }
+
+  typename pcl::search::KdTree<PointInT>::Ptr tree (new pcl::search::KdTree<PointInT>);
+
+  pcl::GreedyProjectionTriangulation<PointInT> gp3;
+
+  gp3.setInputCloud(partial_cloud);
+  gp3.setSearchMethod(tree);
+  gp3.setSearchRadius(search_radius_);
+  gp3.setMu(mu_);
+  gp3.setMaximumNearestNeighbors (nnn_);
+  gp3.setMaximumSurfaceAngle(eps_angle_);
+  gp3.setMinimumAngle(minimum_angle_);
+  gp3.setMaximumAngle(maximum_angle_);
+  gp3.setNormalConsistency(consistent_);
+  gp3.setConsistentVertexOrdering(consistent_ordering_);
+
+  gp3.reconstruct(triangles);
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT> void
+pcl::GreedyProjectionTriangulationOMP<PointInT>::computeBoundaryBlockGreedyProjection (const std::pair<double, double>& segment,
+    pcl::PolygonMesh &triangles)
+{
+  typename pcl::PointCloud<PointInT>::Ptr partial_cloud(new pcl::PointCloud<PointInT>());
+
+  pcl::Indices partial_indices;
+
+  partial_cloud->points.reserve((*input_).size()/threads_* overlapPercentage_);
+  partial_indices.reserve((*input_).size()/threads_ * overlapPercentage_);
+
+  for (int pt = 0; pt < (*input_).size(); pt++)
+  {
+    if ((input_->points[pt].x >= segment.first) &&
+        (input_->points[pt].x <= segment.second))
+    {
+      partial_cloud->push_back(input_->points[pt]);
+      partial_indices.push_back(pt);
+    }
+  }
+
+  if (partial_indices.size() == 0)
+  {
+    PCL_ERROR ("[pcl::%s::performReconstruction] Reconstruction failed.  Overlap percentage is too low: %f\n", getClassName ().c_str (), overlapPercentage_);
+    return;
+  }
+
+  /* We may have sufficient overlap for this, so no need to search for nnn_; */
+  const int K = nnn_/2;
+
+  std::vector<int> pointIdxKNNSearch(K);
+  std::vector<float> pointKNNSquaredDistance(K);
+
+  pcl::Indices knnSearchIndex;
+
+  for (int pt = 0; pt < (*partial_cloud).size(); pt++)
+  {
+    tree_->nearestKSearch(partial_cloud->points[pt], K, pointIdxKNNSearch, pointKNNSquaredDistance);
+    knnSearchIndex.insert(knnSearchIndex.end(), pointIdxKNNSearch.begin(), pointIdxKNNSearch.end());
+  }
+
+  partial_indices.insert(partial_indices.end(), knnSearchIndex.begin(), knnSearchIndex.end());
+
+  //std::sort(partial_indices.begin(), partial_indices.end());
+  tbb::parallel_sort(partial_indices.begin(), partial_indices.end());
+
+  partial_indices.erase(std::unique(partial_indices.begin(), partial_indices.end()),
+      partial_indices.end());
+
+  typename pcl::PointCloud<PointInT>::Ptr new_cloud(new pcl::PointCloud<PointInT>());
+
+  new_cloud->points.reserve(partial_indices.size());
+
+  for (int pt = 0; pt < partial_indices.size(); pt++)
+  {
+    new_cloud->emplace_back(input_->points[partial_indices.at(pt)]);
+  }
+
+  typename pcl::search::KdTree<PointInT>::Ptr gp3_tree (new pcl::search::KdTree<PointInT>);
+
+  pcl::GreedyProjectionTriangulation<PointInT> gp3;
+
+  gp3.setInputCloud(new_cloud);
+  gp3.setSearchMethod(gp3_tree);
+  gp3.setSearchRadius(search_radius_);
+  gp3.setMu(mu_);
+  gp3.setMaximumNearestNeighbors (nnn_);
+  gp3.setMaximumSurfaceAngle(eps_angle_);
+  gp3.setMinimumAngle(minimum_angle_);
+  gp3.setMaximumAngle(maximum_angle_);
+  gp3.setNormalConsistency(consistent_);
+  gp3.setConsistentVertexOrdering(consistent_ordering_);
+
+  gp3.reconstruct(triangles);
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT> void
+pcl::GreedyProjectionTriangulationOMP<PointInT>::removeBoundaryPolygons (pcl::PolygonMesh &input,
+    pcl::PolygonMesh &boundary)
+{
+  std::vector<PointXYZExt> src_cloud;
+  src_cloud.reserve(input.cloud.width);
+
+  int point_step = input.cloud.point_step;
+
+  auto input_elem = input.cloud.data;
+  for (int pt = 0; pt < input.cloud.width; pt++)
+  {
+    PointXYZExt vtx;
+
+    int pt_step = point_step*pt;
+
+    vtx.x = *reinterpret_cast<const float *>(&input_elem[pt_step]);
+    vtx.y = *reinterpret_cast<const float *>(&input_elem[pt_step + 4]);
+    vtx.z = *reinterpret_cast<const float *>(&input_elem[pt_step + 8]);
+
+    src_cloud.emplace_back(vtx);
+  }
+
+  auto extra_elem = boundary.cloud.data;
+  std::unordered_set<int> duplicate_index;
+
+  for (int pt = 0; pt < boundary.cloud.width; pt++)
+  {
+    PointXYZExt vtx;
+
+    int pt_step = point_step*pt;
+    vtx.x = *reinterpret_cast<const float *>(&extra_elem[pt_step]);
+    vtx.y = *reinterpret_cast<const float *>(&extra_elem[pt_step + 4]);
+    vtx.z = *reinterpret_cast<const float *>(&extra_elem[pt_step + 8]);
+
+    auto pp = std::find(src_cloud.begin(), src_cloud.end(), vtx);
+
+    if (pp != src_cloud.end())
+    {
+      int index = std::distance(src_cloud.begin(), pp);
+      duplicate_index.insert(index);
+    }
+  }
+
+  std::vector<Vertices> remain_vertices;
+  for (int pt = 0; pt < input.polygons.size(); pt++)
+  {
+    bool found = false;
+    if ((duplicate_index.find(input.polygons[pt].vertices[0]) != duplicate_index.end()) &&
+        (duplicate_index.find(input.polygons[pt].vertices[1]) != duplicate_index.end()) &&
+        (duplicate_index.find(input.polygons[pt].vertices[2]) != duplicate_index.end()))
+        found = true;
+
+
+    if (!found)
+      remain_vertices.push_back({input.polygons[pt].vertices[0], input.polygons[pt].vertices[1],
+          input.polygons[pt].vertices[2]});
+  }
+
+  input.polygons.clear();
+  input.polygons.reserve(remain_vertices.size());
+
+  for (auto vtx : remain_vertices)
+  {
+    pcl::Vertices v;
+    v.vertices.resize(3);
+    v.vertices[0] = vtx.x;
+    v.vertices[1] = vtx.y;
+    v.vertices[2] = vtx.z;
+    input.polygons.emplace_back(v);
+  }
+}
+
+/////////////////////////////////////////////////////////////////////////////////////////////
+template <typename PointInT> void
+pcl::GreedyProjectionTriangulationOMP<PointInT>::meshCleanup (pcl::PolygonMesh &output)
+{
+  typename pcl::PointCloud<PointInT>::Ptr new_cloud(new pcl::PointCloud<PointInT>());
+  std::map<PointNormalExt<PointInT>, int> main_cloud_map;
+  std::multimap<PointNormalExt<PointInT>, int> duplicate_cloud_map;
+  std::vector<Link> duplicate_indices;
+
+  int unique_count = 0;
+  int point_step = output.cloud.point_step;
+  auto cloud_elem = output.cloud.data;
+  for (int i = 0; i < output.cloud.width; i++)
+  {
+    PointNormalExt<PointInT> pt;
+    int pt_step = point_step*i;
+
+    std::memcpy(&pt.pt, &cloud_elem[pt_step], point_step);
+
+    auto pp = main_cloud_map.find(pt);
+    if (pp == main_cloud_map.end())
+    {
+      main_cloud_map.insert({pt, unique_count});
+      new_cloud->push_back(pt.pt);
+
+      if (i != unique_count)
+      {
+        Link l (i, unique_count);
+        duplicate_indices.push_back(l);
+      }
+      unique_count++;
+    }
+    else
+    {
+      duplicate_cloud_map.insert({pt, i});
+    }
+  }
+
+  for (auto elm : duplicate_cloud_map)
+  {
+    auto pp = main_cloud_map.find(elm.first);
+
+    if (pp->second != elm.second)
+    {
+      Link l (elm.second, pp->second);
+      duplicate_indices.push_back(l);
+    }
+  }
+
+  tbb::parallel_sort(duplicate_indices.begin(), duplicate_indices.end(),
+            [](const Link& pt1, const Link& pt2) { return pt1.left < pt2.left; });
+
+  pcl::toPCLPointCloud2(*new_cloud, output.cloud);
+
+  std::unordered_multimap<int, int> triangle_map_x, triangle_map_y, triangle_map_z;
+
+  for (int i = 0; i < output.polygons.size(); i++)
+  {
+    triangle_map_x.insert(std::pair<int, int>(output.polygons[i].vertices[0], i));
+    triangle_map_y.insert(std::pair<int, int>(output.polygons[i].vertices[1], i));
+    triangle_map_z.insert(std::pair<int, int>(output.polygons[i].vertices[2], i));
+  }
+
+  std::vector<std::pair<int, int>> tmp_ins;
+  for (auto elm : duplicate_indices)
+  {
+    auto its = triangle_map_x.equal_range(elm.left);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      tmp_ins.push_back(std::pair<int, int>(elm.right, it->second));
+    }
+    for (auto i=0; i < tmp_ins.size(); i++) {
+      triangle_map_x.insert(tmp_ins[i]);
+    }
+    tmp_ins.clear();
+    triangle_map_x.erase(elm.left);
+    its = triangle_map_y.equal_range(elm.left);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      tmp_ins.push_back(std::pair<int, int>(elm.right, it->second));
+    }
+    for (auto i=0; i < tmp_ins.size(); i++) {
+      triangle_map_y.insert(tmp_ins[i]);
+    }
+    tmp_ins.clear();
+    triangle_map_y.erase(elm.left);
+    its = triangle_map_z.equal_range(elm.left);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      tmp_ins.push_back(std::pair<int, int>(elm.right, it->second));
+    }
+    for (auto i=0; i < tmp_ins.size(); i++) {
+      triangle_map_z.insert(tmp_ins[i]);
+    }
+    tmp_ins.clear();
+    triangle_map_z.erase(elm.left);
+  }
+
+  tbb::task_group tasks;
+
+  tasks.run([&]() {
+  for (auto et = triangle_map_x.begin(); et != triangle_map_x.end(); ++et)
+  {
+    auto its = triangle_map_x.equal_range(et->first);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      output.polygons[it->second].vertices[0] = it->first;
+    }
+  }
+  });
+
+  tasks.run([&]() {
+  for (auto et = triangle_map_y.begin(); et != triangle_map_y.end(); ++et)
+  {
+    auto its = triangle_map_y.equal_range(et->first);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      output.polygons[it->second].vertices[1] = it->first;
+    }
+  }
+  });
+
+  tasks.run([&]() {
+  for (auto et = triangle_map_z.begin(); et != triangle_map_z.end(); ++et)
+  {
+    auto its = triangle_map_z.equal_range(et->first);
+    for (auto it = its.first; it != its.second; ++it)
+    {
+      output.polygons[it->second].vertices[2] = it->first;
+    }
+  }
+  });
+
+  tasks.wait();
+
+  std::vector<Vertices> temp_vertices;
+  temp_vertices.reserve(output.polygons.size());
+
+  tbb::parallel_for(tbb::blocked_range<size_t>(0, output.polygons.size()),
+    [&](const tbb::blocked_range<size_t> &range) {
+
+    for (size_t pt = range.begin(); pt < range.end(); ++pt)
+    {
+      std::sort(output.polygons[pt].vertices.begin(), output.polygons[pt].vertices.end());
+    }
+  });
+
+  for (int pt = 0; pt < output.polygons.size(); pt++)
+  {
+    Vertices t = {output.polygons[pt].vertices[0], output.polygons[pt].vertices[1],
+                output.polygons[pt].vertices[2]};
+    temp_vertices.emplace_back(t);
+  }
+
+  tbb::parallel_sort(temp_vertices.begin(), temp_vertices.end());
+  temp_vertices.erase(std::unique(temp_vertices.begin(), temp_vertices.end()),
+      temp_vertices.end());
+
+  output.polygons.clear();
+  output.polygons.reserve(temp_vertices.size());
+
+  for (auto elm : temp_vertices)
+  {
+    pcl::Vertices vtx;
+    vtx.vertices.resize(3);
+    vtx.vertices[0] = elm.x;
+    vtx.vertices[1] = elm.y;
+    vtx.vertices[2] = elm.z;
+    output.polygons.emplace_back(vtx);
+  }
+}
+
+#define PCL_INSTANTIATE_GreedyProjectionTriangulationOMP(T)                \
+  template class PCL_EXPORTS pcl::GreedyProjectionTriangulationOMP<T>;
+
+#endif    // PCL_SURFACE_OMP_IMPL_GP3_H_
+
+
diff --git a/oneapi/surface_omp/src/gp3.cpp b/oneapi/surface_omp/src/gp3.cpp
new file mode 100644
index 000000000..fc5d20ab9
--- /dev/null
+++ b/oneapi/surface_omp/src/gp3.cpp
@@ -0,0 +1,45 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2010, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ *
+ */
+
+#include <pcl/oneapi/surface_omp/gp3.h>
+#include <pcl/oneapi/surface_omp/impl/gp3.hpp>
+#include <pcl/impl/instantiate.hpp>
+#include <pcl/point_types.h>
+
+// Instantiations of specific point types
+PCL_INSTANTIATE(GreedyProjectionTriangulationOMP, (pcl::PointNormal)(pcl::PointXYZRGBNormal)(pcl::PointXYZINormal))
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/common.h b/oneapi/utils/include/pcl/oneapi/utils/common.h
new file mode 100644
index 000000000..21265e521
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/common.h
@@ -0,0 +1,120 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#ifndef __PCL_ONEAPI_COMMON_H__
+#define __PCL_ONEAPI_COMMON_H__
+
+#include <CL/sycl.hpp>
+#include <chrono>
+
+#define __device_inline__ __inline__ __attribute__ ((always_inline))
+
+#define BUSY_WAIT_ITERATIONS 16
+#define HIGH_LOAD_MAGNITUDE 10
+
+/* Time in term of microseconds */
+static double minimal_sleep_precision = 0.0;
+static unsigned int high_load = 0;
+static bool busy_wait = true;
+static char passive_policy[] = "PASSIVE";
+
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        template<typename T1, typename T2>
+        static inline T1 divUp(const T1 total, const T2 grain) { return (total + grain - 1) / grain; }
+
+        template<typename T1, typename T2>
+        static inline T1 align(const T1 total, const T2 grain) { return divUp(total, grain) * grain; }
+
+        static void wait_for(sycl::event& event, size_t sleep_time = 1) {
+          using namespace std;
+          using namespace std::chrono;
+
+          if (!minimal_sleep_precision) {
+            auto start = high_resolution_clock::now();
+            this_thread::sleep_for(microseconds(1));
+            auto end = high_resolution_clock::now();
+
+            /* Measure minimal granularity of sleep time for the system */
+            minimal_sleep_precision = (end - start).count() / 1e3;
+
+            const char* wait_policy = std::getenv("PCL_ONEAPI_WAIT_POLICY");
+
+            const int passive_name_len = sizeof(passive_policy);
+
+            if (wait_policy &&  (sizeof(wait_policy) == passive_name_len)
+                && (strncmp(wait_policy, passive_policy, passive_name_len) == 0))
+              busy_wait = false;
+          }
+
+          while (event.get_info<sycl::info::event::command_execution_status>() ==
+            sycl::info::event_command_status::running) {
+
+            if (busy_wait || high_load > 0) {
+              continue;
+            } else {
+              auto start = high_resolution_clock::now();
+              this_thread::sleep_for(microseconds(sleep_time));
+              auto end = high_resolution_clock::now();
+
+              double observed_sleep = (end - start).count() / 1e3;
+              if (observed_sleep/(sleep_time + minimal_sleep_precision) > HIGH_LOAD_MAGNITUDE) {
+                high_load = BUSY_WAIT_ITERATIONS;
+              }
+            }
+          }
+          if (high_load > 0)
+            high_load--;
+        }
+
+        static void wait_for(std::vector<sycl::event>& event_list, size_t sleep_time = 1) {
+          for (auto &event : event_list) {
+            wait_for(event, sleep_time);
+          }
+        }
+    }
+
+    namespace device
+    {
+        using pcl::oneapi::divUp;
+    }
+}
+
+
+#endif /* __PCL_ONEAPI_COMMON_H__ */
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/algorithm.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/algorithm.hpp
new file mode 100644
index 000000000..45be7e433
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/algorithm.hpp
@@ -0,0 +1,82 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_DEVICE_ALGORITHM_HPP_
+#define PCL_ONEAPI_DEVICE_ALGORITHM_HPP_
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            template <class T> __dpct_inline__ void swap(T &a, T &b)
+            {
+              T c(a); a=b; b=c;
+            }
+
+            template<typename Iterator, typename T, typename BinaryPredicate>
+            Iterator lower_bound(Iterator first, Iterator last, const T &val, BinaryPredicate comp)
+            {
+                int len = last - first;
+
+                while(len > 0)
+                {
+                    int half = len >> 1;
+                    Iterator middle = first;
+
+                    middle += half;
+
+                    if(comp(*middle, val))
+                    {
+                        first = middle;
+
+                        ++first;
+                        len -= half + 1;
+                    }
+                    else
+                    {
+                        len = half;
+                    }
+                }
+                return first;
+            }
+        }
+    }
+}
+#endif /* PCL_ONEAPI_DEVICE_ALGORITHM_HPP_ */
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/funcattrib.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/funcattrib.hpp
new file mode 100755
index 000000000..12ab9a5fa
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/funcattrib.hpp
@@ -0,0 +1,73 @@
+/*
+* Software License Agreement (BSD License)
+*
+*  Copyright (c) 2011, Willow Garage, Inc.
+*  All rights reserved.
+*
+*  Redistribution and use in source and binary forms, with or without
+*  modification, are permitted provided that the following conditions
+*  are met:
+*
+*   * Redistributions of source code must retain the above copyright
+*     notice, this list of conditions and the following disclaimer.
+*   * Redistributions in binary form must reproduce the above
+*     copyright notice, this list of conditions and the following
+*     disclaimer in the documentation and/or other materials provided
+*     with the distribution.
+*   * Neither the name of Willow Garage, Inc. nor the names of its
+*     contributors may be used to endorse or promote products derived
+*     from this software without specific prior written permission.
+*
+*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+*  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+*  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+*  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+*  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+*  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+*  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+*  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+*  POSSIBILITY OF SUCH DAMAGE.
+*
+*  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+*/
+
+#ifndef PCL_DEVICE_FUNCATTRIB_HPP_
+#define PCL_DEVICE_FUNCATTRIB_HPP_
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <cstdio>
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            template<class Func> 
+            void printFuncAttrib(Func& func)
+            {
+
+                dpct::kernel_function_info attrs;
+                cudaFuncGetAttributes(&attrs, func);  
+
+                printf("=== Function stats ===\n");
+                printf("Name: \n");
+                // printf("sharedSizeBytes    = %d\n", (int)attrs.sharedSizeBytes);
+                // printf("constSizeBytes     = %d\n", (int)attrs.constSizeBytes);
+                // printf("localSizeBytes     = %d\n", (int)attrs.localSizeBytes);
+                // printf("maxThreadsPerBlock = %d\n", attrs.max_work_group_size);
+                // printf("numRegs            = %d\n", attrs.numRegs);
+                // printf("ptxVersion         = %d\n", attrs.ptxVersion);
+                // printf("binaryVersion      = %d\n", attrs.binaryVersion);
+                // printf("\n");
+                fflush(stdout); 
+            }
+        }
+    }
+}
+
+#endif  /* PCL_DEVICE_FUNCATTRIB_HPP_ */
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_downsweep.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_downsweep.hpp
new file mode 100644
index 000000000..93b26eaab
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_downsweep.hpp
@@ -0,0 +1,661 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * AgentRadixSortDownsweep implements a stateful abstraction of thread
+ * blocks for participating in device-wide radix sort downsweep .
+ */
+
+#pragma once
+
+#include "block_load.hpp"
+#include "block_store.hpp"
+#include "block_radix_rank.hpp"
+#include "block_exchange.hpp"
+#include "radix_rank_sort_operations.hpp"
+#include "util_type.hpp"
+
+
+/******************************************************************************
+ * Tuning policy types
+ ******************************************************************************/
+
+/**
+ * Parameterizable tuning policy type for AgentRadixSortDownsweep
+ */
+template <
+    int                 NOMINAL_BLOCK_THREADS_4B,       ///< Threads per thread block
+    int                 NOMINAL_ITEMS_PER_THREAD_4B,    ///< Items per thread (per tile of input)
+    int                 SUBGROUP,
+    typename            ComputeT,                       ///< Dominant compute type
+    BlockLoadAlgorithm  _LOAD_ALGORITHM,                ///< The BlockLoad algorithm to use
+    RadixRankAlgorithm  _RANK_ALGORITHM,                ///< The radix ranking algorithm to use
+    BlockScanAlgorithm  _SCAN_ALGORITHM,                ///< The block scan algorithm to use
+    int                 _RADIX_BITS,                    ///< The number of radix bits, i.e., log2(bins)
+    typename            ScalingType = RegBoundScaling<NOMINAL_BLOCK_THREADS_4B, NOMINAL_ITEMS_PER_THREAD_4B, SUBGROUP, ComputeT> >
+struct AgentRadixSortDownsweepPolicy : ScalingType
+{
+    enum
+    {
+        RADIX_BITS              = _RADIX_BITS,              ///< The number of radix bits, i.e., log2(bins)
+    };
+
+    static const BlockLoadAlgorithm  LOAD_ALGORITHM     = _LOAD_ALGORITHM;    ///< The BlockLoad algorithm to use
+    static const RadixRankAlgorithm  RANK_ALGORITHM     = _RANK_ALGORITHM;    ///< The radix ranking algorithm to use
+    static const BlockScanAlgorithm  SCAN_ALGORITHM     = _SCAN_ALGORITHM;    ///< The BlockScan algorithm to use
+};
+
+
+/******************************************************************************
+ * Thread block abstractions
+ ******************************************************************************/
+
+
+/**
+ * \brief AgentRadixSortDownsweep implements a stateful abstraction of thread blocks for participating in device-wide radix sort downsweep .
+ */
+template <
+    typename AgentRadixSortDownsweepPolicy,     ///< Parameterized AgentRadixSortDownsweepPolicy tuning policy type
+    bool     IS_DESCENDING,                     ///< Whether or not the sorted-order is high-to-low
+    typename KeyT,                              ///< KeyT type
+    typename ValueT,                            ///< ValueT type
+    typename OffsetT>                           ///< Signed integer type for global offsets
+struct AgentRadixSortDownsweep
+{
+    //---------------------------------------------------------------------
+    // Type definitions and constants
+    //---------------------------------------------------------------------
+
+    // Appropriate unsigned-bits representation of KeyT
+    typedef typename Traits<KeyT>::UnsignedBits UnsignedBits;
+
+    static const UnsignedBits           LOWEST_KEY  = Traits<KeyT>::LOWEST_KEY;
+    static const UnsignedBits           MAX_KEY     = Traits<KeyT>::MAX_KEY;
+
+    static const BlockLoadAlgorithm     LOAD_ALGORITHM  = AgentRadixSortDownsweepPolicy::LOAD_ALGORITHM;
+    static const RadixRankAlgorithm     RANK_ALGORITHM  = AgentRadixSortDownsweepPolicy::RANK_ALGORITHM;
+    static const BlockScanAlgorithm     SCAN_ALGORITHM  = AgentRadixSortDownsweepPolicy::SCAN_ALGORITHM;
+
+    enum
+    {
+        BLOCK_THREADS           = AgentRadixSortDownsweepPolicy::BLOCK_THREADS,
+        ITEMS_PER_THREAD        = AgentRadixSortDownsweepPolicy::ITEMS_PER_THREAD,
+        RADIX_BITS              = AgentRadixSortDownsweepPolicy::RADIX_BITS,
+        TILE_ITEMS              = BLOCK_THREADS * ITEMS_PER_THREAD,
+
+        RADIX_DIGITS            = 1 << RADIX_BITS,
+        KEYS_ONLY               = std::is_same<ValueT, NullType>::value,
+        LOAD_SUBGROUP_STRIPED   = 1,
+        LOG_SUBGROUP            = AgentRadixSortDownsweepPolicy::LOG_SUBGROUP,
+    };
+
+    // Radix ranking type to use
+    using BlockRadixRankT = BlockRadixRankMatch<BLOCK_THREADS, RADIX_BITS, IS_DESCENDING, LOG_SUBGROUP, SCAN_ALGORITHM>;
+
+    // Digit extractor type
+    using DigitExtractorT = BFEDigitExtractor<KeyT>;
+
+    enum
+    {
+        /// Number of bin-starting offsets tracked per thread
+        BINS_TRACKED_PER_THREAD = BlockRadixRankT::BINS_TRACKED_PER_THREAD
+    };
+
+    // BlockLoad type (keys)
+    using BlockLoadKeysT =
+      BlockLoad<UnsignedBits, BLOCK_THREADS, ITEMS_PER_THREAD, LOAD_ALGORITHM>;
+
+    // BlockLoad type (values)
+    using BlockLoadValuesT =
+      BlockLoad<ValueT, BLOCK_THREADS, ITEMS_PER_THREAD, LOAD_ALGORITHM>;
+
+    // Value exchange array type
+    typedef ValueT ValueExchangeT[TILE_ITEMS];
+
+    /**
+     * Shared memory storage layout
+     */
+    union __dpct_align__(16) _TempStorage
+    {
+        typename BlockLoadKeysT::TempStorage    load_keys;
+        typename BlockLoadValuesT::TempStorage  load_values;
+        typename BlockRadixRankT::TempStorage   radix_rank;
+
+        struct KeysAndOffsets
+        {
+            UnsignedBits                        exchange_keys[TILE_ITEMS];
+            OffsetT                             relative_bin_offsets[RADIX_DIGITS];
+        } keys_and_offsets;
+
+        Uninitialized<ValueExchangeT>           exchange_values;
+
+        OffsetT                                 exclusive_digit_prefix[RADIX_DIGITS];
+    };
+
+
+    /// Alias wrapper allowing storage to be unioned
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    //---------------------------------------------------------------------
+    // Thread fields
+    //---------------------------------------------------------------------
+
+    // Shared storage for this CTA
+    _TempStorage    &temp_storage;
+
+    // Input and output device pointers
+    const UnsignedBits  *d_keys_in;
+    const ValueT        *d_values_in;
+    UnsignedBits        *d_keys_out;
+    ValueT              *d_values_out;
+
+    // The global scatter base offset for each digit (valid in the first RADIX_DIGITS threads)
+    OffsetT         bin_offset[BINS_TRACKED_PER_THREAD];
+
+    // Digit extractor
+    DigitExtractorT digit_extractor;
+
+    // Whether to short-cirucit
+    int             short_circuit;
+
+    sycl::nd_item<2> item_ct1;
+
+    //---------------------------------------------------------------------
+    // Utility methods
+    //---------------------------------------------------------------------
+
+
+    /**
+     * Scatter ranked keys through shared memory, then to device-accessible memory
+     */
+    template <bool FULL_TILE>
+    __dpct_inline__ void
+    ScatterKeys(UnsignedBits (&twiddled_keys)[ITEMS_PER_THREAD],
+                OffsetT (&relative_bin_offsets)[ITEMS_PER_THREAD],
+                int (&ranks)[ITEMS_PER_THREAD], OffsetT valid_items)
+    {
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
+        {
+            temp_storage.keys_and_offsets.exchange_keys[ranks[ITEM]] = twiddled_keys[ITEM];
+        }
+
+        CTA_SYNC(item_ct1);
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
+        {
+            UnsignedBits key = temp_storage.keys_and_offsets
+                                   .exchange_keys[item_ct1.get_local_id(1) +
+                                                  (ITEM * BLOCK_THREADS)];
+            UnsignedBits digit          = digit_extractor.Digit(key);
+            relative_bin_offsets[ITEM]  = temp_storage.keys_and_offsets.relative_bin_offsets[digit];
+
+            // Un-twiddle
+            key = Traits<KeyT>::TwiddleOut(key);
+
+            if (FULL_TILE ||
+                (static_cast<OffsetT>(item_ct1.get_local_id(1) +
+                                      (ITEM * BLOCK_THREADS)) < valid_items))
+            {
+                d_keys_out[relative_bin_offsets[ITEM] +
+                           item_ct1.get_local_id(1) + (ITEM * BLOCK_THREADS)] =
+                    key;
+            }
+        }
+    }
+
+
+    /**
+     * Scatter ranked values through shared memory, then to device-accessible memory
+     */
+    template <bool FULL_TILE>
+    __dpct_inline__ void
+    ScatterValues(ValueT (&values)[ITEMS_PER_THREAD],
+                  OffsetT (&relative_bin_offsets)[ITEMS_PER_THREAD],
+                  int (&ranks)[ITEMS_PER_THREAD], OffsetT valid_items)
+    {
+        CTA_SYNC(item_ct1);
+
+        ValueExchangeT &exchange_values = temp_storage.exchange_values.Alias();
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
+        {
+            exchange_values[ranks[ITEM]] = values[ITEM];
+        }
+
+        CTA_SYNC(item_ct1);
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ++ITEM)
+        {
+            ValueT value = exchange_values[item_ct1.get_local_id(1) +
+                                           (ITEM * BLOCK_THREADS)];
+
+            if (FULL_TILE ||
+                (static_cast<OffsetT>(item_ct1.get_local_id(1) +
+                                      (ITEM * BLOCK_THREADS)) < valid_items))
+            {
+                d_values_out[relative_bin_offsets[ITEM] +
+                             item_ct1.get_local_id(1) +
+                             (ITEM * BLOCK_THREADS)] = value;
+            }
+        }
+    }
+
+
+    /**
+     *  Load a tile of keys (specialized for full tile, warp-striped load)
+     */
+    __dpct_inline__ void LoadKeys(UnsignedBits (&keys)[ITEMS_PER_THREAD],
+                                  OffsetT block_offset, OffsetT valid_items,
+                                  UnsignedBits oob_item,
+                                  Int2Type<true> is_full_tile,
+                                  Int2Type<true> warp_striped)
+    {
+      (void) valid_items;
+      (void) oob_item;
+      (void) is_full_tile;
+      (void) warp_striped;
+
+      LoadDirectWarpStriped(item_ct1.get_local_id(1), d_keys_in + block_offset, keys,
+          LOG_SUBGROUP);
+    }
+
+    /**
+     * Load a tile of keys (specialized for partial tile, warp-striped load)
+     */
+    __dpct_inline__ void LoadKeys(UnsignedBits (&keys)[ITEMS_PER_THREAD],
+                                  OffsetT block_offset, OffsetT valid_items,
+                                  UnsignedBits oob_item,
+                                  Int2Type<false> is_full_tile,
+                                  Int2Type<true> warp_striped)
+    {
+      (void) is_full_tile;
+      (void) warp_striped;
+
+      LoadDirectWarpStriped(item_ct1.get_local_id(1),
+                              d_keys_in + block_offset, keys, valid_items,
+                              oob_item, LOG_SUBGROUP);
+    }
+
+    /**
+     * Load a tile of items (specialized for full tile, warp-striped load)
+     */
+    __dpct_inline__ void LoadValues(ValueT (&values)[ITEMS_PER_THREAD],
+                                    OffsetT block_offset, OffsetT valid_items,
+                                    Int2Type<true> is_full_tile,
+                                    Int2Type<true> warp_striped)
+    {
+        (void) valid_items;
+        (void) is_full_tile;
+        (void) warp_striped;
+
+        LoadDirectWarpStriped(item_ct1.get_local_id(1),
+                              d_values_in + block_offset, values, LOG_SUBGROUP);
+    }
+
+    /**
+     * Load a tile of items (specialized for partial tile, warp-striped load)
+     */
+    __dpct_inline__ void LoadValues(ValueT (&values)[ITEMS_PER_THREAD],
+                                    OffsetT block_offset, OffsetT valid_items,
+                                    Int2Type<false> is_full_tile,
+                                    Int2Type<true> warp_striped)
+    {
+        (void) is_full_tile;
+        (void) warp_striped;
+        // Register pressure work-around: moving valid_items through shfl prevents compiler
+        // from reusing guards/addressing from prior guarded loads
+
+        LoadDirectWarpStriped(item_ct1.get_local_id(1),
+                              d_values_in + block_offset, values, valid_items, LOG_SUBGROUP);
+    }
+
+    /**
+     * Truck along associated values
+     */
+    template <bool FULL_TILE>
+    __dpct_inline__ void
+    GatherScatterValues(OffsetT (&relative_bin_offsets)[ITEMS_PER_THREAD],
+                        int (&ranks)[ITEMS_PER_THREAD], OffsetT block_offset,
+                        OffsetT valid_items, Int2Type<false> /*is_keys_only*/)
+    {
+        ValueT values[ITEMS_PER_THREAD];
+
+        CTA_SYNC(item_ct1);
+
+        LoadValues(
+            values,
+            block_offset,
+            valid_items,
+            Int2Type<FULL_TILE>(),
+            Int2Type<LOAD_SUBGROUP_STRIPED>());
+
+        ScatterValues<FULL_TILE>(
+            values,
+            relative_bin_offsets,
+            ranks,
+            valid_items);
+    }
+
+
+    /**
+     * Truck along associated values (specialized for key-only sorting)
+     */
+    template <bool FULL_TILE>
+    __dpct_inline__ void
+    GatherScatterValues(OffsetT (&/*relative_bin_offsets*/)[ITEMS_PER_THREAD],
+                        int (&/*ranks*/)[ITEMS_PER_THREAD],
+                        OffsetT /*block_offset*/, OffsetT /*valid_items*/,
+                        Int2Type<true> /*is_keys_only*/)
+    {}
+
+
+    /**
+     * Process tile
+     */
+    template <bool FULL_TILE>
+    __dpct_inline__ void ProcessTile(OffsetT block_offset,
+                                     const OffsetT &valid_items = TILE_ITEMS)
+    {
+        UnsignedBits    keys[ITEMS_PER_THREAD];
+        int             ranks[ITEMS_PER_THREAD];
+        OffsetT         relative_bin_offsets[ITEMS_PER_THREAD];
+
+        // Assign default (min/max) value to all keys
+        UnsignedBits default_key = (IS_DESCENDING) ? LOWEST_KEY : MAX_KEY;
+
+        // Load tile of keys
+        LoadKeys(
+            keys,
+            block_offset,
+            valid_items,
+            default_key,
+            Int2Type<FULL_TILE>(),
+            Int2Type<LOAD_SUBGROUP_STRIPED>());
+
+        // Twiddle key bits if necessary
+        #pragma unroll
+        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
+        {
+            keys[KEY] = Traits<KeyT>::TwiddleIn(keys[KEY]);
+        }
+
+        // Rank the twiddled keys
+        int exclusive_digit_prefix[BINS_TRACKED_PER_THREAD];
+        BlockRadixRankT(temp_storage.radix_rank, item_ct1).RankKeys(
+            keys,
+            ranks,
+            digit_extractor,
+            exclusive_digit_prefix);
+
+        CTA_SYNC(item_ct1);
+
+        // Share exclusive digit prefix
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                // Store exclusive prefix
+                temp_storage.exclusive_digit_prefix[bin_idx] =
+                    exclusive_digit_prefix[track];
+            }
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Get inclusive digit prefix
+        int inclusive_digit_prefix[BINS_TRACKED_PER_THREAD];
+
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                if (IS_DESCENDING)
+                {
+                    // Get inclusive digit prefix from exclusive prefix (higher bins come first)
+                    inclusive_digit_prefix[track] = (bin_idx == 0) ?
+                        (BLOCK_THREADS * ITEMS_PER_THREAD) :
+                        temp_storage.exclusive_digit_prefix[bin_idx - 1];
+                }
+                else
+                {
+                    // Get inclusive digit prefix from exclusive prefix (lower bins come first)
+                    inclusive_digit_prefix[track] = (bin_idx == RADIX_DIGITS - 1) ?
+                        (BLOCK_THREADS * ITEMS_PER_THREAD) :
+                        temp_storage.exclusive_digit_prefix[bin_idx + 1];
+                }
+            }
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Update global scatter base offsets for each digit
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                bin_offset[track] -= exclusive_digit_prefix[track];
+                temp_storage.keys_and_offsets.relative_bin_offsets[bin_idx] = bin_offset[track];
+                bin_offset[track] += inclusive_digit_prefix[track];
+            }
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Scatter keys
+        ScatterKeys<FULL_TILE>(keys, relative_bin_offsets, ranks, valid_items);
+
+        // Gather/scatter values
+        GatherScatterValues<FULL_TILE>(relative_bin_offsets , ranks, block_offset, valid_items, Int2Type<KEYS_ONLY>());
+    }
+
+    //---------------------------------------------------------------------
+    // Copy shortcut
+    //---------------------------------------------------------------------
+
+    /**
+     * Copy tiles within the range of input
+     */
+    template <typename InputIteratorT, typename T>
+    __dpct_inline__ void Copy(InputIteratorT d_in, T *d_out,
+                              OffsetT block_offset, OffsetT block_end)
+    {
+        // Simply copy the input
+        while (block_end - block_offset >= TILE_ITEMS)
+        {
+            T items[ITEMS_PER_THREAD];
+
+            LoadDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1),
+                                             d_in + block_offset, items);
+            CTA_SYNC(item_ct1);
+            StoreDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1),
+                                              d_out + block_offset, items);
+
+            block_offset += TILE_ITEMS;
+        }
+
+        // Clean up last partial tile with guarded-I/O
+        if (block_offset < block_end)
+        {
+            OffsetT valid_items = block_end - block_offset;
+
+            T items[ITEMS_PER_THREAD];
+
+            LoadDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1),
+                                             d_in + block_offset, items,
+                                             valid_items);
+            CTA_SYNC(item_ct1);
+            StoreDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1),
+                                              d_out + block_offset, items,
+                                              valid_items);
+        }
+    }
+
+
+    /**
+     * Copy tiles within the range of input (specialized for NullType)
+     */
+    template <typename InputIteratorT>
+    __dpct_inline__ void Copy(InputIteratorT /*d_in*/, NullType * /*d_out*/,
+                              OffsetT /*block_offset*/, OffsetT /*block_end*/)
+    {}
+
+
+    //---------------------------------------------------------------------
+    // Interface
+    //---------------------------------------------------------------------
+
+    /**
+     * Constructor
+     */
+    __dpct_inline__
+    AgentRadixSortDownsweep(TempStorage &temp_storage,
+                            OffsetT (&bin_offset)[BINS_TRACKED_PER_THREAD],
+                            OffsetT num_items, const KeyT *d_keys_in,
+                            KeyT *d_keys_out, const ValueT *d_values_in,
+                            ValueT *d_values_out, int current_bit, int num_bits,
+                            sycl::nd_item<2>& item_ct1)
+        : temp_storage(temp_storage.Alias()),
+          d_keys_in(reinterpret_cast<const UnsignedBits *>(d_keys_in)),
+          d_values_in(d_values_in),
+          d_keys_out(reinterpret_cast<UnsignedBits *>(d_keys_out)),
+          d_values_out(d_values_out), digit_extractor(current_bit, num_bits),
+          short_circuit(1),
+          item_ct1(item_ct1)
+    {
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            this->bin_offset[track] = bin_offset[track];
+
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                // Short circuit if the histogram has only bin counts of only zeros or problem-size
+                short_circuit = short_circuit && ((bin_offset[track] == 0) || (bin_offset[track] == num_items));
+            }
+        }
+
+        short_circuit = CTA_SYNC_AND(short_circuit, item_ct1);
+    }
+
+
+    /**
+     * Constructor
+     */
+    __dpct_inline__
+    AgentRadixSortDownsweep(TempStorage &temp_storage, OffsetT num_items,
+                            OffsetT *d_spine, const KeyT *d_keys_in,
+                            KeyT *d_keys_out, const ValueT *d_values_in,
+                            ValueT *d_values_out, int current_bit, int num_bits,
+                            sycl::nd_item<2>& item_ct1)
+        : temp_storage(temp_storage.Alias()),
+          d_keys_in(reinterpret_cast<const UnsignedBits *>(d_keys_in)),
+          d_values_in(d_values_in),
+          d_keys_out(reinterpret_cast<UnsignedBits *>(d_keys_out)),
+          d_values_out(d_values_out), digit_extractor(current_bit, num_bits),
+          short_circuit(1),
+          item_ct1(item_ct1)
+    {
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+            // Load digit bin offsets (each of the first RADIX_DIGITS threads will load an offset for that digit)
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                if (IS_DESCENDING)
+                    bin_idx = RADIX_DIGITS - bin_idx - 1;
+
+                // Short circuit if the first block's histogram has only bin counts of only zeros or problem-size
+                OffsetT first_block_bin_offset =
+                    d_spine[item_ct1.get_group_range(0) * bin_idx];
+                short_circuit = short_circuit && ((first_block_bin_offset == 0) || (first_block_bin_offset == num_items));
+
+                // Load my block's bin offset for my bin
+                bin_offset[track] =
+                    d_spine[(item_ct1.get_group_range(0) * bin_idx) +
+                            item_ct1.get_group(0)];
+            }
+        }
+
+        short_circuit = CTA_SYNC_AND(short_circuit, item_ct1);
+    }
+
+
+    /**
+     * Distribute keys from a segment of input tiles.
+     */
+    __dpct_inline__ void ProcessRegion(OffsetT block_offset, OffsetT block_end)
+    {
+        if (short_circuit)
+        {
+            // Copy keys
+            Copy(d_keys_in, d_keys_out, block_offset, block_end);
+
+            // Copy values
+            Copy(d_values_in, d_values_out, block_offset, block_end);
+        }
+        else
+        {
+            // Process full tiles of tile_items
+            #pragma unroll 1
+            while (block_end - block_offset >= TILE_ITEMS)
+            {
+                ProcessTile<true>(block_offset);
+                block_offset += TILE_ITEMS;
+
+                CTA_SYNC(item_ct1);
+            }
+
+            // Clean up last partial tile with guarded-I/O
+            if (block_offset < block_end)
+            {
+                ProcessTile<false>(block_offset, block_end - block_offset);
+            }
+
+        }
+    }
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_upsweep.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_upsweep.hpp
new file mode 100644
index 000000000..bde6c3199
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_radix_sort_upsweep.hpp
@@ -0,0 +1,508 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * AgentRadixSortUpsweep implements a stateful abstraction of thread blocks for participating in device-wide radix sort upsweep .
+ */
+
+#pragma once
+
+#include "block_load.hpp"
+#include "radix_rank_sort_operations.hpp"
+#include "util_type.hpp"
+
+/******************************************************************************
+ * Tuning policy types
+ ******************************************************************************/
+
+/**
+ * Parameterizable tuning policy type for AgentRadixSortUpsweep
+ */
+template <
+    int                 NOMINAL_BLOCK_THREADS_4B,       ///< Threads per thread block
+    int                 NOMINAL_ITEMS_PER_THREAD_4B,    ///< Items per thread (per tile of input)
+    int                 SUBGROUP,
+    typename            ComputeT,                       ///< Dominant compute type
+    int                 _RADIX_BITS,                   ///< The number of radix bits, i.e., log2(bins)
+    typename            ScalingType = RegBoundScaling<NOMINAL_BLOCK_THREADS_4B, NOMINAL_ITEMS_PER_THREAD_4B, SUBGROUP, ComputeT> >
+struct AgentRadixSortUpsweepPolicy : ScalingType
+{
+    enum
+    {
+        RADIX_BITS          = _RADIX_BITS,          ///< The number of radix bits, i.e., log2(bins)
+    };
+};
+
+
+/******************************************************************************
+ * Thread block abstractions
+ ******************************************************************************/
+
+/**
+ * \brief AgentRadixSortUpsweep implements a stateful abstraction of thread blocks for participating in device-wide radix sort upsweep .
+ */
+template <
+    typename AgentRadixSortUpsweepPolicy,   ///< Parameterized AgentRadixSortUpsweepPolicy tuning policy type
+    typename KeyT,                          ///< KeyT type
+    typename OffsetT>                       ///< Signed integer type for global offsets
+struct AgentRadixSortUpsweep
+{
+
+    //---------------------------------------------------------------------
+    // Type definitions and constants
+    //---------------------------------------------------------------------
+
+    typedef typename Traits<KeyT>::UnsignedBits UnsignedBits;
+
+    // Integer type for digit counters (to be packed into words of PackedCounters)
+    typedef unsigned char DigitCounter;
+
+    // Integer type for packing DigitCounters into columns of shared memory banks
+    typedef unsigned int PackedCounter;
+
+    enum
+    {
+        RADIX_BITS              = AgentRadixSortUpsweepPolicy::RADIX_BITS,
+        BLOCK_THREADS           = AgentRadixSortUpsweepPolicy::BLOCK_THREADS,
+        KEYS_PER_THREAD         = AgentRadixSortUpsweepPolicy::ITEMS_PER_THREAD,
+
+        RADIX_DIGITS            = 1 << RADIX_BITS,
+
+        LOG_SUBGROUP_THREADS    = AgentRadixSortUpsweepPolicy::LOG_SUBGROUP,
+        SUBGROUP_THREADS        = 1 << LOG_SUBGROUP_THREADS,
+        SUBGROUPS               = (BLOCK_THREADS + SUBGROUP_THREADS - 1) / SUBGROUP_THREADS,
+
+        TILE_ITEMS              = BLOCK_THREADS * KEYS_PER_THREAD,
+
+        BYTES_PER_COUNTER       = sizeof(DigitCounter),
+        LOG_BYTES_PER_COUNTER   = Log2<BYTES_PER_COUNTER>::VALUE,
+
+        PACKING_RATIO           = sizeof(PackedCounter) / sizeof(DigitCounter),
+        LOG_PACKING_RATIO       = Log2<PACKING_RATIO>::VALUE,
+
+        LOG_COUNTER_LANES       = ONEAPI_MAX(0, int(RADIX_BITS) - int(LOG_PACKING_RATIO)),
+        COUNTER_LANES           = 1 << LOG_COUNTER_LANES,
+
+        // To prevent counter overflow, we must periodically unpack and aggregate the
+        // digit counters back into registers.  Each counter lane is assigned to a
+        // subgroup for aggregation.
+
+        LANES_PER_SUBGROUP      = ONEAPI_MAX(1, (COUNTER_LANES + SUBGROUPS - 1) / SUBGROUPS),
+
+        // Unroll tiles in batches without risk of counter overflow
+        UNROLL_COUNT            = ONEAPI_MIN(64, 255 / KEYS_PER_THREAD),
+        UNROLLED_ELEMENTS       = UNROLL_COUNT * TILE_ITEMS,
+    };
+
+
+    // Digit extractor type
+    typedef BFEDigitExtractor<KeyT> DigitExtractorT;
+
+    /**
+     * Shared memory storage layout
+     */
+    union __dpct_align__(16) _TempStorage
+    {
+        DigitCounter    thread_counters[COUNTER_LANES][BLOCK_THREADS][PACKING_RATIO];
+        PackedCounter   packed_thread_counters[COUNTER_LANES][BLOCK_THREADS];
+        OffsetT         block_counters[SUBGROUP_THREADS][RADIX_DIGITS];
+    };
+
+
+    /// Alias wrapper allowing storage to be unioned
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    //---------------------------------------------------------------------
+    // Thread fields (aggregate state bundle)
+    //---------------------------------------------------------------------
+
+    // Shared storage for this CTA
+    _TempStorage    &temp_storage;
+
+    // Thread-local counters for periodically aggregating composite-counter lanes
+    OffsetT         local_counts[LANES_PER_SUBGROUP][PACKING_RATIO];
+
+    // Input and output device pointers
+    const UnsignedBits  *d_keys_in;
+
+    // Digit extractor
+    DigitExtractorT digit_extractor;
+
+    sycl::nd_item<2> item_ct1;
+
+
+    //---------------------------------------------------------------------
+    // Helper structure for templated iteration
+    //---------------------------------------------------------------------
+
+    // Iterate
+    template <int COUNT, int MAX>
+    struct Iterate
+    {
+        // BucketKeys
+        static __dpct_inline__ void
+        BucketKeys(AgentRadixSortUpsweep &cta,
+                   UnsignedBits keys[KEYS_PER_THREAD])
+        {
+            cta.Bucket(keys[COUNT]);
+
+            // Next
+            Iterate<COUNT + 1, MAX>::BucketKeys(cta, keys);
+        }
+    };
+
+    // Terminate
+    template <int MAX>
+    struct Iterate<MAX, MAX>
+    {
+        // BucketKeys
+        static __dpct_inline__ void
+        BucketKeys(AgentRadixSortUpsweep & /*cta*/,
+                   UnsignedBits /*keys*/[KEYS_PER_THREAD]) {}
+    };
+
+
+    //---------------------------------------------------------------------
+    // Utility methods
+    //---------------------------------------------------------------------
+
+    /**
+     * Decode a key and increment corresponding smem digit counter
+     */
+    __dpct_inline__ void Bucket(UnsignedBits key)
+    {
+        // Perform transform op
+        UnsignedBits converted_key = Traits<KeyT>::TwiddleIn(key);
+
+        // Extract current digit bits
+        UnsignedBits digit = digit_extractor.Digit(converted_key);
+
+        // Get sub-counter offset
+        UnsignedBits sub_counter = digit & (PACKING_RATIO - 1);
+
+        // Get row offset
+        UnsignedBits row_offset = digit >> LOG_PACKING_RATIO;
+
+        // Increment counter
+        temp_storage.thread_counters[row_offset][item_ct1.get_local_id(1)]
+                                    [sub_counter]++;
+    }
+
+
+    /**
+     * Reset composite counters
+     */
+    __dpct_inline__ void ResetDigitCounters()
+    {
+        #pragma unroll
+        for (int LANE = 0; LANE < COUNTER_LANES; LANE++)
+        {
+            temp_storage.packed_thread_counters[LANE][item_ct1.get_local_id(1)] = 0;
+        }
+    }
+
+
+    /**
+     * Reset the unpacked counters in each thread
+     */
+    __dpct_inline__ void ResetUnpackedCounters()
+    {
+        #pragma unroll
+        for (int LANE = 0; LANE < LANES_PER_SUBGROUP; LANE++)
+        {
+            #pragma unroll
+            for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
+            {
+                local_counts[LANE][UNPACKED_COUNTER] = 0;
+            }
+        }
+    }
+
+
+    /**
+     * Extracts and aggregates the digit counters for each counter lane
+     * owned by this subgroup
+     */
+    __dpct_inline__ void UnpackDigitCounts()
+    {
+
+        unsigned int subgroup_tid = LaneId(item_ct1);
+        unsigned int subgroup_id = item_ct1.get_local_id(1) >> LOG_SUBGROUP_THREADS;
+
+#pragma unroll
+        for (int LANE = 0; LANE < LANES_PER_SUBGROUP; LANE++)
+        {
+            const int counter_lane = (LANE * SUBGROUPS) + subgroup_id;
+            if (counter_lane < COUNTER_LANES)
+            {
+                #pragma unroll
+                for (int PACKED_COUNTER = 0; PACKED_COUNTER < BLOCK_THREADS; PACKED_COUNTER += SUBGROUP_THREADS)
+                {
+                    #pragma unroll
+                    for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
+                    {
+                        OffsetT counter = temp_storage.thread_counters[counter_lane][subgroup_tid + PACKED_COUNTER][UNPACKED_COUNTER];
+                        local_counts[LANE][UNPACKED_COUNTER] += counter;
+                    }
+                }
+            }
+        }
+    }
+
+
+    /**
+     * Processes a single, full tile
+     */
+    __dpct_inline__ void ProcessFullTile(OffsetT block_offset)
+    {
+        // Tile of keys
+        UnsignedBits keys[KEYS_PER_THREAD];
+
+        LoadDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1),
+                                         d_keys_in + block_offset, keys);
+
+        // Prevent hoisting
+        CTA_SYNC(item_ct1);
+
+        // Bucket tile of keys
+        Iterate<0, KEYS_PER_THREAD>::BucketKeys(*this, keys);
+    }
+
+
+    /**
+     * Processes a single load (may have some threads masked off)
+     */
+    __dpct_inline__ void ProcessPartialTile(OffsetT block_offset,
+                                            const OffsetT &block_end)
+    {
+        // Process partial tile if necessary using single loads
+        for (OffsetT offset = item_ct1.get_local_id(1);
+             offset < block_end - block_offset; offset += BLOCK_THREADS)
+        {
+            // Load and bucket key
+            UnsignedBits key = d_keys_in[block_offset + offset];
+
+            Bucket(key);
+        }
+    }
+
+
+    //---------------------------------------------------------------------
+    // Interface
+    //---------------------------------------------------------------------
+
+    /**
+     * Constructor
+     */
+    __dpct_inline__ AgentRadixSortUpsweep(TempStorage &temp_storage,
+                                          const KeyT *d_keys_in,
+                                          int current_bit, int num_bits,
+                                          sycl::nd_item<2> &item_ct1)
+        : temp_storage(temp_storage.Alias()),
+          d_keys_in(reinterpret_cast<const UnsignedBits *>(d_keys_in)),
+          digit_extractor(current_bit, num_bits),
+          item_ct1 (item_ct1)
+    {}
+
+
+    /**
+     * Compute radix digit histograms from a segment of input tiles.
+     */
+    __dpct_inline__ void ProcessRegion(OffsetT block_offset,
+                                       const OffsetT &block_end)
+    {
+        // Reset digit counters in smem and unpacked counters in registers
+        ResetDigitCounters();
+        ResetUnpackedCounters();
+
+        // Unroll batches of full tiles
+        while (block_end - block_offset >= UNROLLED_ELEMENTS)
+        {
+
+            for (int i = 0; i < UNROLL_COUNT; ++i)
+            {
+                ProcessFullTile(block_offset);
+                block_offset += TILE_ITEMS;
+            }
+
+            CTA_SYNC(item_ct1);
+
+            // Aggregate back into local_count registers to prevent overflow
+            UnpackDigitCounts();
+
+            CTA_SYNC(item_ct1);
+
+            // Reset composite counters in lanes
+            ResetDigitCounters();
+        }
+
+        // Unroll single full tiles
+        while (block_end - block_offset >= TILE_ITEMS)
+        {
+            ProcessFullTile(block_offset);
+            block_offset += TILE_ITEMS;
+        }
+
+        // Process partial tile if necessary
+        ProcessPartialTile(block_offset, block_end);
+
+        CTA_SYNC(item_ct1);
+
+        // Aggregate back into local_count registers
+        UnpackDigitCounts();
+    }
+
+
+    /**
+     * Extract counts (saving them to the external array)
+     */
+    template <bool IS_DESCENDING>
+    __dpct_inline__ void ExtractCounts(OffsetT *counters,
+                                       int bin_stride = 1, int bin_offset = 0)
+    {
+        unsigned int subgroup_id = item_ct1.get_local_id(1) >> LOG_SUBGROUP_THREADS;
+        unsigned int subgroup_tid = LaneId(item_ct1);
+
+        // Place unpacked digit counters in shared memory
+        #pragma unroll
+        for (int LANE = 0; LANE < LANES_PER_SUBGROUP; LANE++)
+        {
+            int counter_lane = (LANE * SUBGROUPS) + subgroup_id;
+            if (counter_lane < COUNTER_LANES)
+            {
+                int digit_row = counter_lane << LOG_PACKING_RATIO;
+
+                #pragma unroll
+                for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
+                {
+                    int bin_idx = digit_row + UNPACKED_COUNTER;
+
+                    temp_storage.block_counters[subgroup_tid][bin_idx] =
+                        local_counts[LANE][UNPACKED_COUNTER];
+                }
+            }
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Rake-reduce bin_count reductions
+
+        // Whole blocks
+        #pragma unroll
+        for (int BIN_BASE   = RADIX_DIGITS % BLOCK_THREADS;
+            (BIN_BASE + BLOCK_THREADS) <= RADIX_DIGITS;
+            BIN_BASE += BLOCK_THREADS)
+        {
+            int bin_idx = BIN_BASE + item_ct1.get_local_id(1);
+
+            OffsetT bin_count = 0;
+            #pragma unroll
+            for (int i = 0; i < SUBGROUP_THREADS; ++i)
+                bin_count += temp_storage.block_counters[i][bin_idx];
+
+            if (IS_DESCENDING)
+                bin_idx = RADIX_DIGITS - bin_idx - 1;
+
+            counters[(bin_stride * bin_idx) + bin_offset] = bin_count;
+        }
+
+        // Remainder
+        if ((RADIX_DIGITS % BLOCK_THREADS != 0) &&
+            (item_ct1.get_local_id(1) < RADIX_DIGITS))
+        {
+            int bin_idx = item_ct1.get_local_id(1);
+
+            OffsetT bin_count = 0;
+            #pragma unroll
+            for (int i = 0; i < SUBGROUP_THREADS; ++i)
+                bin_count += temp_storage.block_counters[i][bin_idx];
+
+            if (IS_DESCENDING)
+                bin_idx = RADIX_DIGITS - bin_idx - 1;
+
+            counters[(bin_stride * bin_idx) + bin_offset] = bin_count;
+        }
+    }
+
+
+    /**
+     * Extract counts
+     */
+    template <int BINS_TRACKED_PER_THREAD>
+    __dpct_inline__ void ExtractCounts(
+        OffsetT (&bin_count)[BINS_TRACKED_PER_THREAD]) ///< [out] The exclusive prefix sum for the digits
+                      ///< [(threadIdx.x * BINS_TRACKED_PER_THREAD) ...
+                      ///< (threadIdx.x * BINS_TRACKED_PER_THREAD) +
+                      ///< BINS_TRACKED_PER_THREAD - 1]
+    {
+        unsigned int subgroup_id = item_ct1.get_local_id(1) >> LOG_SUBGROUP_THREADS;
+        unsigned int subgroup_tid = LaneId(item_ct1);
+
+        // Place unpacked digit counters in shared memory
+        #pragma unroll
+        for (int LANE = 0; LANE < LANES_PER_SUBGROUP; LANE++)
+        {
+            int counter_lane = (LANE * SUBGROUPS) + subgroup_id;
+            if (counter_lane < COUNTER_LANES)
+            {
+                int digit_row = counter_lane << LOG_PACKING_RATIO;
+
+                #pragma unroll
+                for (int UNPACKED_COUNTER = 0; UNPACKED_COUNTER < PACKING_RATIO; UNPACKED_COUNTER++)
+                {
+                    int bin_idx = digit_row + UNPACKED_COUNTER;
+
+                    temp_storage.block_counters[subgroup_tid][bin_idx] =
+                        local_counts[LANE][UNPACKED_COUNTER];
+                }
+            }
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Rake-reduce bin_count reductions
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx =
+                (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                bin_count[track] = 0;
+
+                #pragma unroll
+                for (int i = 0; i < SUBGROUP_THREADS; ++i)
+                    bin_count[track] += temp_storage.block_counters[i][bin_idx];
+            }
+        }
+    }
+};
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_segmented_radix_sort.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_segmented_radix_sort.hpp
new file mode 100644
index 000000000..f5a12ab06
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/agent_segmented_radix_sort.hpp
@@ -0,0 +1,271 @@
+/******************************************************************************
+ * Copyright (c) 2011-2021, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#pragma once
+
+#include "agent_radix_sort_downsweep.hpp"
+#include "agent_radix_sort_upsweep.hpp"
+#include "block_radix_sort.hpp"
+#include "util_type.hpp"
+#include "device_double_buffer.hpp"
+
+/**
+ * This agent will be implementing the `DeviceSegmentedRadixSort'
+ *
+ * @tparam IS_DESCENDING
+ *   Whetherer or not the sorted-order is high-to-low
+ *
+ * @tparam SegmentedPolicyT
+ *   Chained tuning policy
+ *
+ * @tparam KeyT
+ *   Key type
+ *
+ * @tparam ValueT
+ *   Value type
+ *
+ * @tparam OffsetT
+ *   Signed integer type for global offsets
+ */
+template <bool IS_DESCENDING,
+          typename SegmentedPolicyT,
+          typename KeyT,
+          typename ValueT,
+          typename OffsetT>
+struct AgentSegmentedRadixSort
+{
+  OffsetT num_items;
+
+  static constexpr int ITEMS_PER_THREAD = SegmentedPolicyT::ITEMS_PER_THREAD;
+  static constexpr int BLOCK_THREADS    = SegmentedPolicyT::BLOCK_THREADS;
+  static constexpr int RADIX_BITS       = SegmentedPolicyT::RADIX_BITS;
+  static constexpr int LOG_SUBGROUP     = SegmentedPolicyT::LOG_SUBGROUP;
+  static constexpr int RADIX_DIGITS     = 1 << RADIX_BITS;
+  static constexpr int KEYS_ONLY        = std::is_same<ValueT, NullType>::value;
+
+  // Huge segment handlers
+  using BlockUpsweepT = AgentRadixSortUpsweep<SegmentedPolicyT, KeyT, OffsetT>;
+  using DigitScanT    = BlockScan<OffsetT, BLOCK_THREADS>;
+  using BlockDownsweepT =
+    AgentRadixSortDownsweep<SegmentedPolicyT, IS_DESCENDING, KeyT, ValueT, OffsetT>;
+
+  /// Number of bin-starting offsets tracked per thread
+  static constexpr int BINS_TRACKED_PER_THREAD = BlockDownsweepT::BINS_TRACKED_PER_THREAD;
+
+  // Small segment handlers
+  using BlockRadixSortT =
+    BlockRadixSort<KeyT,
+                   BLOCK_THREADS,
+                   ITEMS_PER_THREAD,
+                   ValueT,
+                   RADIX_BITS,
+                   LOG_SUBGROUP,
+                   (SegmentedPolicyT::RANK_ALGORITHM == RADIX_RANK_MEMOIZE),
+                   SegmentedPolicyT::SCAN_ALGORITHM>;
+
+  using BlockKeyLoadT = BlockLoad<KeyT,
+                                  BLOCK_THREADS,
+                                  ITEMS_PER_THREAD,
+                                  SegmentedPolicyT::LOAD_ALGORITHM>;
+
+  using BlockValueLoadT = BlockLoad<ValueT,
+                                    BLOCK_THREADS,
+                                    ITEMS_PER_THREAD,
+                                    SegmentedPolicyT::LOAD_ALGORITHM>;
+
+  union _TempStorage
+  {
+    // Huge segment handlers
+    typename BlockUpsweepT::TempStorage upsweep;
+    typename BlockDownsweepT::TempStorage downsweep;
+
+    struct UnboundBlockSort
+    {
+      OffsetT reverse_counts_in[RADIX_DIGITS];
+      OffsetT reverse_counts_out[RADIX_DIGITS];
+      typename DigitScanT::TempStorage scan;
+    } unbound_sort;
+
+    // Small segment handlers
+    typename BlockKeyLoadT::TempStorage keys_load;
+    typename BlockValueLoadT::TempStorage values_load;
+    typename BlockRadixSortT::TempStorage sort;
+  };
+
+  using TempStorage = Uninitialized<_TempStorage>;
+  _TempStorage &temp_storage;
+
+  sycl::nd_item<2> item_ct1;
+
+  __dpct_inline__ AgentSegmentedRadixSort(OffsetT num_items,
+                                          TempStorage &temp_storage,
+                                          sycl::nd_item<2> &item_ct1)
+      : num_items(num_items), temp_storage(temp_storage.Alias()),  item_ct1(item_ct1)
+  {}
+
+  __dpct_inline__ void ProcessSinglePass(int begin_bit, int end_bit,
+                                         const KeyT *d_keys_in,
+                                         const ValueT *d_values_in,
+                                         KeyT *d_keys_out, ValueT *d_values_out)
+  {
+    KeyT thread_keys[ITEMS_PER_THREAD];
+    ValueT thread_values[ITEMS_PER_THREAD];
+
+    // For FP64 the difference is:
+    // Lowest() -> -1.79769e+308 = 00...00b -> TwiddleIn -> -0 = 10...00b
+    // LOWEST   -> -nan          = 11...11b -> TwiddleIn ->  0 = 00...00b
+
+    using UnsignedBitsT = typename Traits<KeyT>::UnsignedBits;
+    UnsignedBitsT default_key_bits = IS_DESCENDING ? Traits<KeyT>::LOWEST_KEY
+                                                   : Traits<KeyT>::MAX_KEY;
+    KeyT oob_default = reinterpret_cast<KeyT &>(default_key_bits);
+
+    BlockValueLoadT(temp_storage.values_load, item_ct1)
+        .Load(d_values_in, thread_values, num_items);
+    BlockKeyLoadT(temp_storage.keys_load, item_ct1)
+        .Load(d_keys_in, thread_keys, num_items, oob_default);
+
+    CTA_SYNC(item_ct1);
+
+    BlockRadixSortT(temp_storage.sort, item_ct1).SortBlockedToStriped(
+      thread_keys,
+      thread_values,
+      begin_bit,
+      end_bit);
+
+    StoreDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1), d_keys_out,
+                                            thread_keys, num_items);
+
+    StoreDirectStriped<BLOCK_THREADS>(item_ct1.get_local_id(1), d_values_out,
+                                            thread_values, num_items);
+  }
+
+  __dpct_inline__ void ProcessIterative(int current_bit, int pass_bits,
+                                        const KeyT *d_keys_in,
+                                        const ValueT *d_values_in,
+                                        KeyT *d_keys_out, ValueT *d_values_out)
+  {
+    // Upsweep
+    BlockUpsweepT upsweep(temp_storage.upsweep,
+                          d_keys_in,
+                          current_bit,
+                          pass_bits,
+                          item_ct1);
+    upsweep.ProcessRegion(OffsetT{}, num_items);
+
+    CTA_SYNC(item_ct1);
+
+    // The count of each digit value in this pass (valid in the first RADIX_DIGITS threads)
+    OffsetT bin_count[BINS_TRACKED_PER_THREAD];
+    upsweep.ExtractCounts(bin_count);
+
+    CTA_SYNC(item_ct1);
+
+    if (IS_DESCENDING)
+    {
+      // Reverse bin counts
+      #pragma unroll
+      for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+      {
+        int bin_idx =
+            (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+        if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+        {
+          temp_storage.unbound_sort.reverse_counts_in[bin_idx] = bin_count[track];
+        }
+      }
+
+      CTA_SYNC(item_ct1);
+
+      #pragma unroll
+      for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+      {
+        int bin_idx =
+            (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+        if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+        {
+          bin_count[track] = temp_storage.unbound_sort.reverse_counts_in[RADIX_DIGITS - bin_idx - 1];
+        }
+      }
+    }
+
+    // Scan
+    // The global scatter base offset for each digit value in this pass
+    // (valid in the first RADIX_DIGITS threads)
+    OffsetT bin_offset[BINS_TRACKED_PER_THREAD];
+    DigitScanT(temp_storage.unbound_sort.scan, item_ct1).ExclusiveSum(bin_count, bin_offset);
+
+    if (IS_DESCENDING)
+    {
+      // Reverse bin offsets
+      #pragma unroll
+      for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+      {
+        int bin_idx =
+            (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+        if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+        {
+          temp_storage.unbound_sort
+              .reverse_counts_out[item_ct1.get_local_id(1)] = bin_offset[track];
+        }
+      }
+
+      CTA_SYNC(item_ct1);
+
+#pragma unroll
+      for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+      {
+        int bin_idx =
+            (item_ct1.get_local_id(1) * BINS_TRACKED_PER_THREAD) + track;
+
+        if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+        {
+          bin_offset[track] = temp_storage.unbound_sort.reverse_counts_out[RADIX_DIGITS - bin_idx - 1];
+        }
+      }
+    }
+
+    CTA_SYNC(item_ct1);
+
+    // Downsweep
+    BlockDownsweepT downsweep(temp_storage.downsweep,
+                              bin_offset,
+                              num_items,
+                              d_keys_in,
+                              d_keys_out,
+                              d_values_in,
+                              d_values_out,
+                              current_bit,
+                              pass_bits,
+                              item_ct1);
+    downsweep.ProcessRegion(OffsetT{}, num_items);
+  }
+};
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_exchange.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_exchange.hpp
new file mode 100644
index 000000000..47cc0cf69
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_exchange.hpp
@@ -0,0 +1,445 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * The BlockExchange class provides [<em>collective</em>](index.html#sec0) methods for rearranging data partitioned across a thread block.
+ */
+
+#pragma once
+
+#include "util_type.hpp"
+
+/**
+ * \brief The BlockExchange class provides [<em>collective</em>](index.html#sec0) methods for rearranging data partitioned across a thread block. ![](transpose_logo.png)
+ * \ingroup BlockModule
+ *
+ * \tparam T                    The data type to be exchanged.
+ * \tparam BLOCK_DIM_X          The thread block length in threads along the X dimension
+ * \tparam ITEMS_PER_THREAD     The number of items partitioned onto each thread.
+ * \tparam SUBGROUP_TIME_SLICING    <b>[optional]</b> When \p true, only use enough shared memory for a single subgroup's worth of tile data, time-slicing the block-wide exchange over multiple synchronized rounds.  Yields a smaller memory footprint at the expense of decreased parallelism.  (Default: false)
+ * \tparam BLOCK_DIM_Y          <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ *
+ * \par Overview
+ * - It is commonplace for blocks of threads to rearrange data items between
+ *   threads.  For example, the device-accessible memory subsystem prefers access patterns
+ *   where data items are "striped" across threads (where consecutive threads access consecutive items),
+ *   yet most block-wide operations prefer a "blocked" partitioning of items across threads
+ *   (where consecutive items belong to a single thread).
+ * - BlockExchange supports the following types of data exchanges:
+ *   - Transposing between [<em>blocked</em>](index.html#sec5sec3) and [<em>striped</em>](index.html#sec5sec3) arrangements
+ *   - Transposing between [<em>blocked</em>](index.html#sec5sec3) and [<em>subgroup-striped</em>](index.html#sec5sec3) arrangements
+ *   - Scattering ranked items to a [<em>blocked arrangement</em>](index.html#sec5sec3)
+ *   - Scattering ranked items to a [<em>striped arrangement</em>](index.html#sec5sec3)
+ * - \rowmajor
+ */
+template <
+    typename    InputT,
+    int         BLOCK_DIM_X,
+    int         ITEMS_PER_THREAD,
+    int         LOG_SUBGROUP,
+    bool        SUBGROUP_TIME_SLICING  = false,
+    int         BLOCK_DIM_Y         = 1>
+class BlockExchange
+{
+private:
+
+    /******************************************************************************
+     * Constants
+     ******************************************************************************/
+
+    /// Constants
+    enum
+    {
+        /// The thread block size in threads
+        BLOCK_THREADS               = BLOCK_DIM_X * BLOCK_DIM_Y,
+
+        LOG_SUBGROUP_THREADS        = LOG_SUBGROUP,
+        SUBGROUP_THREADS            = 1 << LOG_SUBGROUP_THREADS,
+        SUBGROUPS                   = (BLOCK_THREADS + SUBGROUP_THREADS - 1) / SUBGROUP_THREADS,
+
+        TILE_ITEMS                  = BLOCK_THREADS * ITEMS_PER_THREAD,
+
+        TIME_SLICES                 = (SUBGROUP_TIME_SLICING) ? SUBGROUPS : 1,
+
+        TIME_SLICED_THREADS         = (SUBGROUP_TIME_SLICING) ? ONEAPI_MIN(BLOCK_THREADS, SUBGROUP_THREADS) : BLOCK_THREADS,
+        TIME_SLICED_ITEMS           = TIME_SLICED_THREADS * ITEMS_PER_THREAD,
+
+        SUBGROUP_TIME_SLICED_THREADS    = ONEAPI_MIN(BLOCK_THREADS, SUBGROUP_THREADS),
+        SUBGROUP_TIME_SLICED_ITEMS      = SUBGROUP_TIME_SLICED_THREADS * ITEMS_PER_THREAD,
+    };
+
+    /******************************************************************************
+     * Type definitions
+     ******************************************************************************/
+
+    /// Shared memory storage layout type
+    struct __dpct_align__(16) _TempStorage
+    {
+        InputT buff[TIME_SLICED_ITEMS];
+    };
+
+public:
+
+    /// \smemstorage{BlockExchange}
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+private:
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Shared storage reference
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    unsigned int linear_tid;
+    unsigned int lane_id;
+    unsigned int subgroup_id;
+    unsigned int subgroup_offset;
+
+    sycl::nd_item<2> item_ct1;
+
+
+    /******************************************************************************
+     * Utility methods
+     ******************************************************************************/
+
+    /// Internal storage allocator
+    __dpct_inline__ _TempStorage &PrivateStorage(_TempStorage *private_storage)
+    {
+
+        return (*private_storage);
+    }
+
+    /**
+     * Exchanges data items annotated by rank into <em>blocked</em> arrangement.  Specialized for no timeslicing.
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToBlocked(
+        InputT (
+            &input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>blocked</em> and
+                                             ///< <em>striped</em> arrangements.
+        OutputT (&output_items) [ITEMS_PER_THREAD], ///< [out] Items to exchange, converting between
+                                ///< <em>blocked</em> and <em>striped</em>
+                                ///< arrangements.
+        OffsetT (&ranks)[ITEMS_PER_THREAD], ///< [in] Corresponding scatter ranks
+        Int2Type<false> /*time_slicing*/)
+    {
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            int item_offset = ranks[ITEM];
+            temp_storage.buff[item_offset] = input_items[ITEM];
+        }
+
+        CTA_SYNC(item_ct1);
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            int item_offset = (linear_tid * ITEMS_PER_THREAD) + ITEM;
+            output_items[ITEM] = temp_storage.buff[item_offset];
+        }
+    }
+
+    /**
+     * Exchanges data items annotated by rank into <em>blocked</em> arrangement.  Specialized for subgroup-timeslicing.
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToBlocked(
+        InputT (&input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>blocked</em> and
+                                             ///< <em>striped</em> arrangements.
+        OutputT (&output_items)[ITEMS_PER_THREAD], ///< [out] Items to exchange, converting between
+                                ///< <em>blocked</em> and <em>striped</em>
+                                ///< arrangements.
+        OffsetT ranks[ITEMS_PER_THREAD], ///< [in] Corresponding scatter ranks
+        Int2Type<true>  /*time_slicing*/)
+    {
+        InputT temp_items[ITEMS_PER_THREAD];
+
+        #pragma unroll
+        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
+        {
+            CTA_SYNC(item_ct1);
+
+            const int SLICE_OFFSET = TIME_SLICED_ITEMS * SLICE;
+
+            #pragma unroll
+            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+            {
+                int item_offset = ranks[ITEM] - SLICE_OFFSET;
+                if ((item_offset >= 0) && (item_offset < SUBGROUP_TIME_SLICED_ITEMS))
+                {
+                    temp_storage.buff[item_offset] = input_items[ITEM];
+                }
+            }
+
+            CTA_SYNC(item_ct1);
+
+            if (subgroup_id == SLICE)
+            {
+                #pragma unroll
+                for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+                {
+                    int item_offset = (lane_id * ITEMS_PER_THREAD) + ITEM;
+                    temp_items[ITEM] = temp_storage.buff[item_offset];
+                }
+            }
+        }
+
+        // Copy
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            output_items[ITEM] = temp_items[ITEM];
+        }
+    }
+
+    /**
+     * Exchanges data items annotated by rank into <em>striped</em> arrangement.  Specialized for no timeslicing.
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToStriped(
+        InputT (&input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>blocked</em> and
+                                             ///< <em>striped</em> arrangements.
+        OutputT (&output_items) [ITEMS_PER_THREAD], ///< [out] Items to exchange, converting between
+                                ///< <em>blocked</em> and <em>striped</em>
+                                ///< arrangements.
+        OffsetT (&ranks)[ITEMS_PER_THREAD], ///< [in] Corresponding scatter ranks
+        Int2Type<false> /*time_slicing*/)
+    {
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            int item_offset = ranks[ITEM];
+            temp_storage.buff[item_offset] = input_items[ITEM];
+        }
+
+        CTA_SYNC(item_ct1);
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            int item_offset = int(ITEM * BLOCK_THREADS) + linear_tid;
+            output_items[ITEM] = temp_storage.buff[item_offset];
+        }
+    }
+    /**
+     * Exchanges data items annotated by rank into <em>striped</em> arrangement.  Specialized for subgroup-timeslicing.
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToStriped(
+        InputT (&input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>blocked</em> and
+                                             ///< <em>striped</em> arrangements.
+        OutputT (&output_items)[ITEMS_PER_THREAD], ///< [out] Items to exchange, converting between
+                                ///< <em>blocked</em> and <em>striped</em>
+                                ///< arrangements.
+        OffsetT (&ranks)[ITEMS_PER_THREAD], ///< [in] Corresponding scatter ranks
+        Int2Type<true> /*time_slicing*/)
+    {
+        InputT temp_items[ITEMS_PER_THREAD];
+
+        #pragma unroll
+        for (int SLICE = 0; SLICE < TIME_SLICES; SLICE++)
+        {
+            const int SLICE_OFFSET  = SLICE * TIME_SLICED_ITEMS;
+            const int SLICE_OOB     = SLICE_OFFSET + TIME_SLICED_ITEMS;
+
+            CTA_SYNC(item_ct1);
+
+            #pragma unroll
+            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+            {
+                int item_offset = ranks[ITEM] - SLICE_OFFSET;
+                if ((item_offset >= 0) && (item_offset < SUBGROUP_TIME_SLICED_ITEMS))
+                {
+                    temp_storage.buff[item_offset] = input_items[ITEM];
+                }
+            }
+
+            CTA_SYNC(item_ct1);
+
+            #pragma unroll
+            for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+            {
+                // Read a strip of items
+                const int STRIP_OFFSET  = ITEM * BLOCK_THREADS;
+                const int STRIP_OOB     = STRIP_OFFSET + BLOCK_THREADS;
+
+                if ((SLICE_OFFSET < STRIP_OOB) && (SLICE_OOB > STRIP_OFFSET))
+                {
+                    int item_offset = STRIP_OFFSET + linear_tid - SLICE_OFFSET;
+                    if ((item_offset >= 0) && (item_offset < TIME_SLICED_ITEMS))
+                    {
+                        temp_items[ITEM] = temp_storage.buff[item_offset];
+                    }
+                }
+            }
+        }
+
+        // Copy
+        #pragma unroll
+        for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        {
+            output_items[ITEM] = temp_items[ITEM];
+        }
+    }
+
+public:
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Collective constructor using a private static allocation of shared memory as temporary storage.
+     */
+    __dpct_inline__ BlockExchange(sycl::nd_item<2> item_ct1,
+                                  _TempStorage *private_storage)
+        : temp_storage(PrivateStorage(private_storage)),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          subgroup_id((SUBGROUPS == 1) ? 0 : linear_tid / SUBGROUP_THREADS),
+          lane_id(LaneId(item_ct1)), subgroup_offset(subgroup_id * SUBGROUP_TIME_SLICED_ITEMS)
+    {}
+
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockExchange(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          lane_id(LaneId(item_ct1)),
+          subgroup_id((SUBGROUPS == 1) ? 0 : linear_tid / SUBGROUP_THREADS),
+          subgroup_offset(subgroup_id * SUBGROUP_TIME_SLICED_ITEMS),
+          item_ct1 (item_ct1)
+    {}
+
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Scatter exchanges
+     *********************************************************************/
+    //@{
+
+
+    /**
+     * \brief Exchanges data items annotated by rank into <em>blocked</em> arrangement.
+     *
+     * \par
+     * - \smemreuse
+     *
+     * \tparam OffsetT                              <b>[inferred]</b> Signed integer type for local offsets
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToBlocked(
+        InputT (
+            &input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>striped</em> and
+                                             ///< <em>blocked</em> arrangements.
+        OutputT (&output_items)
+            [ITEMS_PER_THREAD], ///< [out] Items from exchange, converting
+                                ///< between <em>striped</em> and
+                                ///< <em>blocked</em> arrangements.
+        OffsetT (
+            &ranks)[ITEMS_PER_THREAD]) ///< [in] Corresponding scatter ranks
+    {
+        ScatterToBlocked(input_items, output_items, ranks, Int2Type<SUBGROUP_TIME_SLICING>());
+    }
+
+
+
+
+    //@}  end member group
+
+
+    template <typename OffsetT>
+    __dpct_inline__ void ScatterToBlocked(
+        InputT (
+            &items)[ITEMS_PER_THREAD], ///< [in-out] Items to exchange,
+                                       ///< converting between <em>striped</em>
+                                       ///< and <em>blocked</em> arrangements.
+        OffsetT (
+            &ranks)[ITEMS_PER_THREAD]) ///< [in] Corresponding scatter ranks
+    {
+        ScatterToBlocked(items, items, ranks);
+    }
+
+
+    /**
+     * \brief Exchanges data items annotated by rank into <em>striped</em> arrangement.
+     *
+     * \par
+     * - \smemreuse
+     *
+     * \tparam OffsetT                              <b>[inferred]</b> Signed integer type for local offsets
+     */
+    template <typename OutputT, typename OffsetT>
+    __dpct_inline__ void ScatterToStriped(
+        InputT (&input_items)[ITEMS_PER_THREAD], ///< [in] Items to exchange,
+                                             ///< converting between
+                                             ///< <em>striped</em> and
+                                             ///< <em>blocked</em> arrangements.
+        OutputT (&output_items)[ITEMS_PER_THREAD], ///< [out] Items from exchange, converting
+                                ///< between <em>striped</em> and
+                                ///< <em>blocked</em> arrangements.
+        OffsetT (&ranks)[ITEMS_PER_THREAD]) ///< [in] Corresponding scatter ranks
+    {
+        ScatterToStriped(input_items, output_items, ranks, Int2Type<SUBGROUP_TIME_SLICING>());
+    }
+
+    template <typename OffsetT>
+    __dpct_inline__ void ScatterToStriped(
+        InputT (&items)[ITEMS_PER_THREAD], ///< [in-out] Items to exchange,
+                                       ///< converting between <em>striped</em>
+                                       ///< and <em>blocked</em> arrangements.
+        OffsetT (&ranks)[ITEMS_PER_THREAD]) ///< [in] Corresponding scatter ranks
+    {
+        ScatterToStriped(items, items, ranks);
+    }
+
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_load.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_load.hpp
new file mode 100644
index 000000000..815efd747
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_load.hpp
@@ -0,0 +1,635 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2016, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * Operations for reading linear tiles of data into the thread block.
+ */
+
+#pragma once
+
+#include "util_type.hpp"
+
+/******************************************************************//**
+ * \name Blocked arrangement I/O (direct)
+ *********************************************************************/
+//@{
+
+
+/**
+ * \brief Load a linear segment of items into a blocked arrangement across the thread block.
+ *
+ * \blocked
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectBlocked(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD]) ///< [out] Data to load
+{
+    // Load directly in thread-blocked order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        items[ITEM] = block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM];
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a blocked arrangement across the thread block, guarded by range.
+ *
+ * \blocked
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectBlocked(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items)                   ///< [in] Number of valid items to load
+{
+
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        if ((linear_tid * ITEMS_PER_THREAD) + ITEM < valid_items)
+        {
+            items[ITEM] = block_itr[(linear_tid * ITEMS_PER_THREAD) + ITEM];
+        }
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a blocked arrangement across the thread block, guarded by range, with a fall-back assignment of out-of-bound elements..
+ *
+ * \blocked
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, typename DefaultT, int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectBlocked(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items,                   ///< [in] Number of valid items to load
+    DefaultT oob_default) ///< [in] Default value to assign out-of-bound items
+{
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        items[ITEM] = oob_default;
+
+    LoadDirectBlocked(linear_tid, block_itr, items, valid_items);
+}
+
+/**
+ * \brief Load a linear segment of items into a striped arrangement across the thread block.
+ *
+ * \striped
+ *
+ * \tparam BLOCK_THREADS        The thread block size in threads
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <int BLOCK_THREADS, typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD]) ///< [out] Data to load
+{
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        items[ITEM] = block_itr[linear_tid + ITEM * BLOCK_THREADS];
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a striped arrangement across the thread block, guarded by range
+ *
+ * \striped
+ *
+ * \tparam BLOCK_THREADS        The thread block size in threads
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <int BLOCK_THREADS, typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items)                   ///< [in] Number of valid items to load
+{
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        if (linear_tid + (ITEM * BLOCK_THREADS) < valid_items)
+        {
+            items[ITEM] = block_itr[linear_tid + ITEM * BLOCK_THREADS];
+        }
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a striped arrangement across the thread block, guarded by range, with a fall-back assignment of out-of-bound elements.
+ *
+ * \striped
+ *
+ * \tparam BLOCK_THREADS        The thread block size in threads
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <int BLOCK_THREADS, typename InputT, typename DefaultT,
+          int ITEMS_PER_THREAD,
+          typename InputIteratorT>
+__dpct_inline__ void LoadDirectStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items,                   ///< [in] Number of valid items to load
+    DefaultT oob_default) ///< [in] Default value to assign out-of-bound items
+{
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        items[ITEM] = oob_default;
+
+    LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
+}
+
+/**
+ * \brief Load a linear segment of items into a warp-striped arrangement across the thread block.
+ *
+ * \warpstriped
+ *
+ * \par Usage Considerations
+ * The number of threads in the thread block must be a multiple of the architecture's warp size.
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT, int LOG_SUBGROUP = 4>
+SYCL_EXTERNAL __dpct_inline__ void LoadDirectWarpStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int log_subgroup)
+{
+    int subgroup_threads   = 1 << log_subgroup;
+    int tid                = linear_tid & (subgroup_threads - 1);
+    int wid                = linear_tid >> log_subgroup;
+    int warp_offset        = wid * subgroup_threads * ITEMS_PER_THREAD;
+
+    // Load directly in warp-striped order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        new(&items[ITEM]) InputT(block_itr[warp_offset + tid + (ITEM * subgroup_threads)]);
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a warp-striped arrangement across the thread block, guarded by range
+ *
+ * \warpstriped
+ *
+ * \par Usage Considerations
+ * The number of threads in the thread block must be a multiple of the architecture's warp size.
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, int ITEMS_PER_THREAD,
+          typename InputIteratorT, int LOG_SUBGROUP=4>
+SYCL_EXTERNAL __dpct_inline__ void LoadDirectWarpStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items,                   ///< [in] Number of valid items to load
+    int log_subgroup)
+{
+    int subgroup_threads   = 1 << log_subgroup;
+    int tid                = linear_tid & (subgroup_threads - 1);
+    int wid                = linear_tid >> log_subgroup;
+    int warp_offset        = wid * subgroup_threads * ITEMS_PER_THREAD;
+
+    // Load directly in warp-striped order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        if (warp_offset + tid + (ITEM * subgroup_threads) < valid_items)
+        {
+            new(&items[ITEM]) InputT(block_itr[warp_offset + tid + (ITEM * subgroup_threads)]);
+        }
+    }
+}
+
+
+/**
+ * \brief Load a linear segment of items into a warp-striped arrangement across the thread block, guarded by range, with a fall-back assignment of out-of-bound elements.
+ *
+ * \warpstriped
+ *
+ * \par Usage Considerations
+ * The number of threads in the thread block must be a multiple of the architecture's warp size.
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to load.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam InputIteratorT       <b>[inferred]</b> The random-access iterator type for input \iterator.
+ */
+template <typename InputT, typename DefaultT, int ITEMS_PER_THREAD,
+          typename InputIteratorT, int LOG_SUBGROUP=4>
+SYCL_EXTERNAL __dpct_inline__ void LoadDirectWarpStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    InputIteratorT block_itr, ///< [in] The thread block's base input iterator
+                              ///< for loading from
+    InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+    int valid_items,                   ///< [in] Number of valid items to load
+    DefaultT oob_default, ///< [in] Default value to assign out-of-bound items
+    int log_subgroup)
+{
+    // Load directly in warp-striped order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+        items[ITEM] = oob_default;
+
+    LoadDirectWarpStriped(linear_tid, block_itr, items, valid_items, log_subgroup);
+}
+
+//-----------------------------------------------------------------------------
+// Generic BlockLoad abstraction
+//-----------------------------------------------------------------------------
+
+/**
+ * \brief BlockLoadAlgorithm enumerates alternative algorithms for BlockLoad to read a linear segment of data from memory into a blocked arrangement across a thread block.
+ */
+enum BlockLoadAlgorithm
+{
+    /**
+     * \par Overview
+     *
+     * A [<em>blocked arrangement</em>](index.html#sec5sec3) of data is read
+     * directly from memory.
+     *
+     * \par Performance Considerations
+     * The utilization of memory transactions (coalescing) decreases as the
+     * access stride between threads increases (i.e., the number items per thread).
+     */
+    BLOCK_LOAD_DIRECT,
+
+    /**
+     * \par Overview
+     *
+     * A [<em>striped arrangement</em>](index.html#sec5sec3) of data is read
+     * directly from memory.
+     *
+     * \par Performance Considerations
+     * The utilization of memory transactions (coalescing) doesn't depend on
+     * the number of items per thread.
+     */
+    BLOCK_LOAD_STRIPED,
+};
+
+/**
+ * \brief The BlockLoad class provides [<em>collective</em>](index.html#sec0) data movement methods for loading a linear segment of items from memory into a [<em>blocked arrangement</em>](index.html#sec5sec3) across a thread block.  ![](block_load_logo.png)
+ * \ingroup BlockModule
+ * \ingroup UtilIo
+ *
+ * \tparam InputT               The data type to read into (which must be convertible from the input iterator's value type).
+ * \tparam BLOCK_DIM_X          The thread block length in threads along the X dimension
+ * \tparam ITEMS_PER_THREAD     The number of consecutive items partitioned onto each thread.
+ * \tparam ALGORITHM            <b>[optional]</b> BlockLoadAlgorithm tuning policy.  default: BLOCK_LOAD_DIRECT.
+ * \tparam SUBGROUP_TIME_SLICING    <b>[optional]</b> Whether or not only one warp's worth of shared memory should be allocated and time-sliced among block-warps during any load-related data transpositions (versus each warp having its own storage). (default: false)
+ * \tparam BLOCK_DIM_Y          <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ *
+ * \par Overview
+ * - The BlockLoad class provides a single data movement abstraction that can be specialized
+ *   to implement different BlockLoadAlgorithm strategies.  This facilitates different
+ *   performance policies for different architectures, data types, granularity sizes, etc.
+ * - BlockLoad can be optionally specialized by different data movement strategies:
+ *   -# <b>BLOCK_LOAD_DIRECT</b>.  A [<em>blocked arrangement</em>](index.html#sec5sec3)
+ *      of data is read directly from memory.  [More...](\ref BlockLoadAlgorithm)
+*    -# <b>BLOCK_LOAD_STRIPED,</b>.  A [<em>striped arrangement</em>](index.html#sec5sec3)
+ *      of data is read directly from memory.  [More...](\ref BlockLoadAlgorithm)
+ * - \rowmajor
+ */
+template <
+    typename            InputT,
+    int                 BLOCK_DIM_X,
+    int                 ITEMS_PER_THREAD,
+    BlockLoadAlgorithm  ALGORITHM           = BLOCK_LOAD_DIRECT,
+    int                 BLOCK_DIM_Y         = 1,
+    int                 BLOCK_DIM_Z         = 1>
+class BlockLoad
+{
+private:
+
+    /******************************************************************************
+     * Constants and typed definitions
+     ******************************************************************************/
+
+    /// Constants
+    enum
+    {
+        /// The thread block size in threads
+        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
+    };
+
+
+    /******************************************************************************
+     * Algorithmic variants
+     ******************************************************************************/
+
+    /// Load helper
+    template <BlockLoadAlgorithm _POLICY, int DUMMY>
+    struct LoadInternal;
+
+
+    /**
+     * BLOCK_LOAD_DIRECT specialization of load helper
+     */
+    template <int DUMMY>
+    struct LoadInternal<BLOCK_LOAD_DIRECT, DUMMY>
+    {
+        /// Shared memory storage layout type
+        typedef NullType TempStorage;
+
+        /// Linear thread-id
+        int linear_tid;
+
+        /// Constructor
+        __dpct_inline__ LoadInternal(TempStorage & /*temp_storage*/,
+                                     int linear_tid)
+            : linear_tid(linear_tid)
+        {}
+
+        /// Load a linear segment of items from memory
+        template <typename InputIteratorT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD]) ///< [out] Data to load
+        {
+            LoadDirectBlocked(linear_tid, block_itr, items);
+        }
+
+        /// Load a linear segment of items from memory, guarded by range
+        template <typename InputIteratorT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+             int valid_items) ///< [in] Number of valid items to load
+        {
+            LoadDirectBlocked(linear_tid, block_itr, items, valid_items);
+        }
+
+        /// Load a linear segment of items from memory, guarded by range, with a fall-back assignment of out-of-bound elements
+        template <typename InputIteratorT, typename DefaultT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+             int valid_items,      ///< [in] Number of valid items to load
+             DefaultT oob_default) ///< [in] Default value to assign
+                                   ///< out-of-bound items
+        {
+            LoadDirectBlocked(linear_tid, block_itr, items, valid_items, oob_default);
+        }
+
+    };
+
+
+    /**
+    * BLOCK_LOAD_STRIPED specialization of load helper
+    */
+    template <int DUMMY>
+    struct LoadInternal<BLOCK_LOAD_STRIPED, DUMMY>
+    {
+        /// Shared memory storage layout type
+        typedef NullType TempStorage;
+
+        /// Linear thread-id
+        int linear_tid;
+
+        /// Constructor
+        __dpct_inline__ LoadInternal(TempStorage & /*temp_storage*/,
+                                     int linear_tid)
+            : linear_tid(linear_tid)
+        {}
+
+        /// Load a linear segment of items from memory
+        template <typename InputIteratorT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD]) ///< [out] Data to load
+        {
+            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items);
+        }
+
+        /// Load a linear segment of items from memory, guarded by range
+        template <typename InputIteratorT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+             int valid_items) ///< [in] Number of valid items to load
+        {
+            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
+        }
+
+        /// Load a linear segment of items from memory, guarded by range, with a fall-back assignment of out-of-bound elements
+        template <typename InputIteratorT, typename DefaultT>
+        __dpct_inline__ void
+        Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                       ///< iterator for loading from
+             InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+             int valid_items,      ///< [in] Number of valid items to load
+             DefaultT oob_default) ///< [in] Default value to assign
+                                   ///< out-of-bound items
+        {
+            LoadDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items, oob_default);
+        }
+
+    };
+
+
+    /******************************************************************************
+     * Type definitions
+     ******************************************************************************/
+
+    /// Internal load implementation to use
+    typedef LoadInternal<ALGORITHM, 0> InternalLoad;
+
+
+    /// Shared memory storage layout type
+    typedef typename InternalLoad::TempStorage _TempStorage;
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Thread reference to shared storage
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    int linear_tid;
+
+public:
+
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockLoad(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1))
+    {}
+
+
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Data movement
+     *********************************************************************/
+    //@{
+
+
+    /**
+     * \brief Load a linear segment of items from memory.
+     *
+     */
+    template <typename InputIteratorT>
+    __dpct_inline__ void
+    Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                   ///< iterator for loading from
+         InputT (&items)[ITEMS_PER_THREAD]) ///< [out] Data to load
+    {
+        InternalLoad(temp_storage, linear_tid).Load(block_itr, items);
+    }
+
+
+    /**
+     * \brief Load a linear segment of items from memory, guarded by range.
+     *
+     */
+    template <typename InputIteratorT>
+    __dpct_inline__ void
+    Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                   ///< iterator for loading from
+         InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+         int valid_items) ///< [in] Number of valid items to load
+    {
+        InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items);
+    }
+
+
+    /**
+     * \brief Load a linear segment of items from memory, guarded by range, with a fall-back assignment of out-of-bound elements
+     *
+     */
+    template <typename InputIteratorT, typename DefaultT>
+    __dpct_inline__ void
+    Load(InputIteratorT block_itr, ///< [in] The thread block's base input
+                                   ///< iterator for loading from
+         InputT (&items)[ITEMS_PER_THREAD], ///< [out] Data to load
+         int valid_items, ///< [in] Number of valid items to load
+         DefaultT
+             oob_default) ///< [in] Default value to assign out-of-bound items
+    {
+        InternalLoad(temp_storage, linear_tid).Load(block_itr, items, valid_items, oob_default);
+    }
+
+
+    //@}  end member group
+
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_rank.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_rank.hpp
new file mode 100644
index 000000000..2587e66f1
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_rank.hpp
@@ -0,0 +1,778 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * BlockRadixRank provides operations for ranking unsigned integer types within a thread block
+ */
+
+#pragma once
+
+#include "block_scan.hpp"
+#include "thread_reduce.hpp"
+#include "util_type.hpp"
+
+
+/**
+ * \brief Radix ranking algorithm, the algorithm used to implement stable ranking of the
+ * keys from a single tile. Note that different ranking algorithms require different
+ * initial arrangements of keys to function properly.
+ */
+enum RadixRankAlgorithm
+{
+    /** Ranking using the BlockRadixRank algorithm with MEMOIZE_OUTER_SCAN == false. It
+     * uses thread-private histograms, and thus uses more shared memory. Requires blocked
+     * arrangement of keys. Does not support count callbacks. */
+    RADIX_RANK_BASIC,
+    /** Ranking using the BlockRadixRank algorithm with MEMOIZE_OUTER_SCAN ==
+     * true. Similar to RADIX_RANK BASIC, it requires blocked arrangement of
+     * keys and does not support count callbacks.*/
+    RADIX_RANK_MEMOIZE,
+    /** Ranking using the BlockRadixRankMatch algorithm. It uses subgroup-private
+     * histograms and matching for ranking the keys in a single item in subgroup. Therefore,
+     * it uses less shared memory compared to RADIX_RANK_BASIC. It requires
+     * subgroup-striped key arrangement and supports count callbacks. */
+    RADIX_RANK_MATCH,
+};
+
+
+/** Empty callback implementation */
+template <int BINS_PER_THREAD>
+struct BlockRadixRankEmptyCallback
+{
+    __dpct_inline__ void operator()(int (&bins)[BINS_PER_THREAD]) { (void) bins;}
+};
+
+
+/**
+ * \brief BlockRadixRank provides operations for ranking unsigned integer types within a thread block.
+ * \ingroup BlockModule
+ *
+ * \tparam BLOCK_DIM_X          The thread block length in threads along the X dimension
+ * \tparam RADIX_BITS           The number of radix bits per digit place
+ * \tparam IS_DESCENDING           Whether or not the sorted-order is high-to-low
+ * \tparam MEMOIZE_OUTER_SCAN   <b>[optional]</b> Whether or not to buffer outer raking scan partials to incur fewer shared memory reads at the expense of higher register pressure (default: true for architectures SM35 and newer, false otherwise).  See BlockScanAlgorithm::BLOCK_SCAN_RAKING_MEMOIZE for more details.
+ * \tparam INNER_SCAN_ALGORITHM <b>[optional]</b> The BlockScanAlgorithm algorithm to use (default: BLOCK_SCAN_SUBGROUP_SCANS)
+ * \tparam BLOCK_DIM_Y          <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ *
+ * \par Overview
+ * Blah...
+ * - Keys must be in a form suitable for radix ranking (i.e., unsigned bits).
+ * - \blocked
+ *
+ */
+template <int BLOCK_DIM_X, int RADIX_BITS, bool IS_DESCENDING,
+          int LOG_SUBGROUP, bool MEMOIZE_OUTER_SCAN = true,
+          BlockScanAlgorithm INNER_SCAN_ALGORITHM = BLOCK_SCAN_SUBGROUP_SCANS,
+          int BLOCK_DIM_Y = 1>
+class BlockRadixRank
+{
+private:
+
+    /******************************************************************************
+     * Type definitions and constants
+     ******************************************************************************/
+
+    // Integer type for digit counters (to be packed into words of type PackedCounters)
+    typedef unsigned short DigitCounter;
+
+    // Integer type for packing DigitCounters into columns of shared memory banks
+    using PackedCounter = unsigned int;
+
+    enum
+    {
+        // The thread block size in threads
+        BLOCK_THREADS               = BLOCK_DIM_X * BLOCK_DIM_Y,
+
+        RADIX_DIGITS                = 1 << RADIX_BITS,
+
+        LOG_SUBGROUP_THREADS        = LOG_SUBGROUP,
+        SUBGROUP_THREADS            = 1 << LOG_SUBGROUP_THREADS,
+        SUBGROUPS                   = (BLOCK_THREADS + SUBGROUP_THREADS - 1) / SUBGROUP_THREADS,
+
+        BYTES_PER_COUNTER           = sizeof(DigitCounter),
+        LOG_BYTES_PER_COUNTER       = Log2<BYTES_PER_COUNTER>::VALUE,
+
+        PACKING_RATIO               = static_cast<int>(sizeof(PackedCounter) / sizeof(DigitCounter)),
+        LOG_PACKING_RATIO           = Log2<PACKING_RATIO>::VALUE,
+
+        LOG_COUNTER_LANES           = ONEAPI_MAX((int(RADIX_BITS) - int(LOG_PACKING_RATIO)), 0),                // Always at least one lane
+        COUNTER_LANES               = 1 << LOG_COUNTER_LANES,
+
+        // The number of packed counters per thread (plus one for padding)
+        PADDED_COUNTER_LANES        = COUNTER_LANES + 1,
+        RAKING_SEGMENT              = PADDED_COUNTER_LANES,
+    };
+
+public:
+
+    enum
+    {
+        /// Number of bin-starting offsets tracked per thread
+        BINS_TRACKED_PER_THREAD = ONEAPI_MAX(1, (RADIX_DIGITS + BLOCK_THREADS - 1) / BLOCK_THREADS),
+    };
+
+private:
+
+
+    /// BlockScan type
+    typedef BlockScan<
+            PackedCounter,
+            BLOCK_DIM_X,
+            INNER_SCAN_ALGORITHM,
+            BLOCK_DIM_Y>
+        BlockScan;
+
+
+    /// Shared memory storage layout type for BlockRadixRank
+    struct __dpct_align__(16) _TempStorage
+    {
+        union Aliasable
+        {
+            DigitCounter            digit_counters[PADDED_COUNTER_LANES][BLOCK_THREADS][PACKING_RATIO];
+            PackedCounter           raking_grid[BLOCK_THREADS][RAKING_SEGMENT];
+
+        } aliasable;
+
+        // Storage for scanning local ranks
+        typename BlockScan::TempStorage block_scan;
+    };
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Shared storage reference
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    unsigned int linear_tid;
+
+    /// Copy of raking segment, promoted to registers
+    PackedCounter cached_segment[RAKING_SEGMENT];
+
+    sycl::nd_item<2> item_ct1;
+
+    /******************************************************************************
+     * Utility methods
+     ******************************************************************************/
+
+    /**
+     * Internal storage allocator
+     */
+    __dpct_inline__ _TempStorage &PrivateStorage(_TempStorage *private_storage)
+    {
+
+        return (*private_storage);
+    }
+
+
+    /**
+     * Performs upsweep raking reduction, returning the aggregate
+     */
+    __dpct_inline__ PackedCounter Upsweep()
+    {
+        PackedCounter *smem_raking_ptr = temp_storage.aliasable.raking_grid[linear_tid];
+        PackedCounter *raking_ptr;
+
+        if (MEMOIZE_OUTER_SCAN)
+        {
+            // Copy data into registers
+            #pragma unroll
+            for (int i = 0; i < RAKING_SEGMENT; i++)
+            {
+                cached_segment[i] = smem_raking_ptr[i];
+            }
+            raking_ptr = cached_segment;
+        }
+        else
+        {
+            raking_ptr = smem_raking_ptr;
+        }
+
+        return internal::ThreadReduce<RAKING_SEGMENT>(raking_ptr, sycl::plus<>());
+    }
+
+
+    /// Performs exclusive downsweep raking scan
+    __dpct_inline__ void ExclusiveDownsweep(PackedCounter raking_partial)
+    {
+        PackedCounter *smem_raking_ptr = temp_storage.aliasable.raking_grid[linear_tid];
+
+        PackedCounter *raking_ptr = (MEMOIZE_OUTER_SCAN) ?
+            cached_segment :
+            smem_raking_ptr;
+
+        // Exclusive raking downsweep scan
+        internal::ThreadScanExclusive<RAKING_SEGMENT>(raking_ptr, raking_ptr, sycl::plus<>(), raking_partial);
+
+        if (MEMOIZE_OUTER_SCAN)
+        {
+            // Copy data back to smem
+            #pragma unroll
+            for (int i = 0; i < RAKING_SEGMENT; i++)
+            {
+                smem_raking_ptr[i] = cached_segment[i];
+            }
+        }
+    }
+
+
+    /**
+     * Reset shared memory digit counters
+     */
+    __dpct_inline__ void ResetCounters()
+    {
+        // Reset shared memory digit counters
+        #pragma unroll
+        for (int LANE = 0; LANE < PADDED_COUNTER_LANES; LANE++)
+        {
+            *((PackedCounter*) temp_storage.aliasable.digit_counters[LANE][linear_tid]) = 0;
+        }
+    }
+
+
+    /**
+     * Block-scan prefix callback
+     */
+    struct PrefixCallBack
+    {
+        __dpct_inline__ PackedCounter operator()(PackedCounter block_aggregate)
+        {
+            PackedCounter block_prefix = 0;
+
+            // Propagate totals in packed fields
+            #pragma unroll
+            for (int PACKED = 1; PACKED < PACKING_RATIO; PACKED++)
+            {
+                block_prefix += block_aggregate << (sizeof(DigitCounter) * 8 * PACKED);
+            }
+
+            return block_prefix;
+        }
+    };
+
+
+    /**
+     * Scan shared memory digit counters.
+     */
+    __dpct_inline__ void ScanCounters()
+    {
+        // Upsweep scan
+        PackedCounter raking_partial = Upsweep();
+
+        // Compute exclusive sum
+        PackedCounter exclusive_partial;
+        PrefixCallBack prefix_call_back;
+        BlockScan(temp_storage.block_scan, item_ct1).ExclusiveSum(raking_partial, exclusive_partial, prefix_call_back);
+
+        // Downsweep scan with exclusive partial
+        ExclusiveDownsweep(exclusive_partial);
+    }
+
+public:
+
+    /// \smemstorage{BlockScan}
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Collective constructor using a private static allocation of shared memory as temporary storage.
+     */
+    __dpct_inline__ BlockRadixRank(sycl::nd_item<2> item_ct1,
+                                   _TempStorage *private_storage)
+        : temp_storage(PrivateStorage(private_storage)),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1))
+    {}
+
+
+    /**
+     * \abrief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockRadixRank(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          item_ct1 (item_ct1)
+    {}
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Raking
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Rank keys.
+     */
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT>
+    __dpct_inline__ void
+    RankKeys(UnsignedBits (&keys)[KEYS_PER_THREAD], ///< [in] Keys for this tile
+             int (&ranks)[KEYS_PER_THREAD], ///< [out] For each key, the local
+                                            ///< rank within the tile
+             DigitExtractorT digit_extractor)  ///< [in] The digit extractor
+    {
+        DigitCounter    thread_prefixes[KEYS_PER_THREAD];   // For each key, the count of previous keys in this tile having the same digit
+        DigitCounter*   digit_counters[KEYS_PER_THREAD];    // For each key, the byte-offset of its corresponding digit counter in smem
+
+        // Reset shared memory digit counters
+        ResetCounters();
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < KEYS_PER_THREAD; ++ITEM)
+        {
+            // Get digit
+            unsigned int digit = digit_extractor.Digit(keys[ITEM]);
+
+            // Get sub-counter
+            unsigned int sub_counter = digit >> LOG_COUNTER_LANES;
+
+            // Get counter lane
+            unsigned int counter_lane = digit & (COUNTER_LANES - 1);
+
+            if (IS_DESCENDING)
+            {
+                sub_counter = PACKING_RATIO - 1 - sub_counter;
+                counter_lane = COUNTER_LANES - 1 - counter_lane;
+            }
+
+            // Pointer to smem digit counter
+            digit_counters[ITEM] = &temp_storage.aliasable.digit_counters[counter_lane][linear_tid][sub_counter];
+
+            // Load thread-exclusive prefix
+            thread_prefixes[ITEM] = *digit_counters[ITEM];
+
+            // Store inclusive prefix
+            *digit_counters[ITEM] = thread_prefixes[ITEM] + 1;
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Scan shared memory counters
+        ScanCounters();
+
+        CTA_SYNC(item_ct1);
+
+        // Extract the local ranks of each key
+        #pragma unroll
+        for (int ITEM = 0; ITEM < KEYS_PER_THREAD; ++ITEM)
+        {
+            // Add in thread block exclusive prefix
+            ranks[ITEM] = thread_prefixes[ITEM] + *digit_counters[ITEM];
+        }
+    }
+
+
+    /**
+     * \brief Rank keys.  For the lower \p RADIX_DIGITS threads, digit counts for each digit are provided for the corresponding thread.
+     */
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT>
+    __dpct_inline__ void RankKeys(
+        UnsignedBits (&keys)[KEYS_PER_THREAD], ///< [in] Keys for this tile
+        int (&ranks)[KEYS_PER_THREAD],   ///< [out] For each key, the local rank
+                                         ///< within the tile (out parameter)
+        DigitExtractorT digit_extractor, ///< [in] The digit extractor
+        int (&exclusive_digit_prefix)
+            [BINS_TRACKED_PER_THREAD]) ///< [out] The exclusive prefix sum for
+                                       ///< the digits [(threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) ...
+                                       ///< (threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) +
+                                       ///< BINS_TRACKED_PER_THREAD - 1]
+    {
+        // Rank keys
+        RankKeys(keys, ranks, digit_extractor);
+
+        // Get the inclusive and exclusive digit totals corresponding to the calling thread.
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx = (linear_tid * BINS_TRACKED_PER_THREAD) + track;
+
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                if (IS_DESCENDING)
+                    bin_idx = RADIX_DIGITS - bin_idx - 1;
+
+                // Obtain ex/inclusive digit counts.  (Unfortunately these all reside in the
+                // first counter column, resulting in unavoidable bank conflicts.)
+                unsigned int counter_lane   = (bin_idx & (COUNTER_LANES - 1));
+                unsigned int sub_counter    = bin_idx >> (LOG_COUNTER_LANES);
+
+                exclusive_digit_prefix[track] = temp_storage.aliasable.digit_counters[counter_lane][0][sub_counter];
+            }
+        }
+    }
+};
+
+/**
+ * Radix-rank using match.any
+ */
+template <
+    int                     BLOCK_DIM_X,
+    int                     RADIX_BITS,
+    bool                    IS_DESCENDING,
+    int                     LOG_SUBGROUP,
+    BlockScanAlgorithm      INNER_SCAN_ALGORITHM    = BLOCK_SCAN_SUBGROUP_SCANS,
+    int                     BLOCK_DIM_Y             = 1>
+class BlockRadixRankMatch
+{
+private:
+
+    /******************************************************************************
+     * Type definitions and constants
+     ******************************************************************************/
+
+    typedef int32_t    RankT;
+    typedef int32_t    DigitCounterT;
+
+    enum
+    {
+        // The thread block size in threads
+        BLOCK_THREADS               = BLOCK_DIM_X * BLOCK_DIM_Y,
+
+        RADIX_DIGITS                = 1 << RADIX_BITS,
+
+        LOG_SUBGROUP_THREADS            = LOG_SUBGROUP,
+        SUBGROUP_THREADS                = 1 << LOG_SUBGROUP_THREADS,
+        SUBGROUPS                       = (BLOCK_THREADS + SUBGROUP_THREADS - 1) / SUBGROUP_THREADS,
+
+        PADDED_SUBGROUPS            = ((SUBGROUPS & 0x1) == 0) ?
+                                    SUBGROUPS + 1 :
+                                    SUBGROUPS,
+
+        COUNTERS                = PADDED_SUBGROUPS * RADIX_DIGITS,
+        RAKING_SEGMENT          = (COUNTERS + BLOCK_THREADS - 1) / BLOCK_THREADS,
+        PADDED_RAKING_SEGMENT   = ((RAKING_SEGMENT & 0x1) == 0) ?
+                                    RAKING_SEGMENT + 1 :
+                                    RAKING_SEGMENT,
+    };
+
+public:
+
+    enum
+    {
+        /// Number of bin-starting offsets tracked per thread
+        BINS_TRACKED_PER_THREAD = ONEAPI_MAX(1, (RADIX_DIGITS + BLOCK_THREADS - 1) / BLOCK_THREADS),
+    };
+
+private:
+
+    /// BlockScan type
+    typedef BlockScan<
+            DigitCounterT,
+            BLOCK_THREADS,
+            INNER_SCAN_ALGORITHM,
+            BLOCK_DIM_Y>
+        BlockScanT;
+
+
+    /// Shared memory storage layout type for BlockRadixRank
+    struct __dpct_align__(16) _TempStorage
+    {
+        typename BlockScanT::TempStorage            block_scan;
+
+        union __dpct_align__(16) Aliasable
+        {
+            volatile DigitCounterT                  subgroup_digit_counters[RADIX_DIGITS][PADDED_SUBGROUPS];
+            DigitCounterT                           raking_grid[BLOCK_THREADS][PADDED_RAKING_SEGMENT];
+
+        } aliasable;
+    };
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Shared storage reference
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    unsigned int linear_tid;
+
+    sycl::nd_item<2> item_ct1;
+
+
+public:
+
+    /// \smemstorage{BlockScan}
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockRadixRankMatch(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          item_ct1 (item_ct1)
+    {}
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Raking
+     *********************************************************************/
+    //@{
+
+    /** \brief Computes the count of keys for each digit value, and calls the
+     * callback with the array of key counts.
+
+     * @tparam CountsCallback The callback type. It should implement an instance
+     * overload of operator()(int (&bins)[BINS_TRACKED_PER_THREAD]), where bins
+     * is an array of key counts for each digit value distributed in block
+     * distribution among the threads of the thread block. Key counts can be
+     * used, to update other data structures in global or shared
+     * memory. Depending on the implementation of the ranking algoirhtm
+     * (see BlockRadixRankMatchEarlyCounts), key counts may become available
+     * early, therefore, they are returned through a callback rather than a
+     * separate output parameter of RankKeys().
+     */
+    template <int KEYS_PER_THREAD, typename CountsCallback>
+    __dpct_inline__ void CallBack(CountsCallback callback)
+    {
+        int bins[BINS_TRACKED_PER_THREAD];
+        // Get count for each digit
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx = (linear_tid * BINS_TRACKED_PER_THREAD) + track;
+            const int TILE_ITEMS = KEYS_PER_THREAD * BLOCK_THREADS;
+
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                if (IS_DESCENDING)
+                {
+                    bin_idx = RADIX_DIGITS - bin_idx - 1;
+                    bins[track] = (bin_idx > 0 ?
+                        temp_storage.aliasable.subgroup_digit_counters[bin_idx - 1][0] : TILE_ITEMS) -
+                        temp_storage.aliasable.subgroup_digit_counters[bin_idx][0];
+                }
+                else
+                {
+                    bins[track] = (bin_idx < RADIX_DIGITS - 1 ?
+                        temp_storage.aliasable.subgroup_digit_counters[bin_idx + 1][0] : TILE_ITEMS) -
+                        temp_storage.aliasable.subgroup_digit_counters[bin_idx][0];
+                }
+            }
+        }
+        callback(bins);
+    }
+
+    /**
+     * \brief Rank keys.
+     */
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT,
+              typename CountsCallback>
+    __dpct_inline__ void
+    RankKeys(UnsignedBits (&keys)[KEYS_PER_THREAD], ///< [in] Keys for this tile
+             int (&ranks)[KEYS_PER_THREAD],   ///< [out] For each key, the local
+                                              ///< rank within the tile
+             DigitExtractorT digit_extractor, ///< [in] The digit extractor
+             CountsCallback callback)
+    {
+        // Initialize shared digit counters
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < PADDED_RAKING_SEGMENT; ++ITEM)
+            temp_storage.aliasable.raking_grid[linear_tid][ITEM] = 0;
+
+        CTA_SYNC(item_ct1);
+
+        // Each subgroup will strip-mine its section of input, one strip at a time
+
+        volatile DigitCounterT  *digit_counters[KEYS_PER_THREAD];
+        uint32_t                subgroup_id = linear_tid >> LOG_SUBGROUP_THREADS;
+
+        uint32_t lane_mask_lt = ~(~(1 << LaneId(item_ct1))) - 1;
+
+#pragma unroll
+        for (int ITEM = 0; ITEM < KEYS_PER_THREAD; ++ITEM)
+        {
+            // My digit
+            uint32_t digit = digit_extractor.Digit(keys[ITEM]);
+
+            if (IS_DESCENDING)
+                digit = RADIX_DIGITS - digit - 1;
+
+            uint32_t peer_mask = MatchAny(digit, SUBGROUP_THREADS, item_ct1);
+
+            CTA_SYNC(item_ct1);
+
+            // Pointer to smem digit counter for this key
+            digit_counters[ITEM] = &temp_storage.aliasable.subgroup_digit_counters[digit][subgroup_id];
+
+            // Number of occurrences in previous strips
+            DigitCounterT subgroup_digit_prefix = *digit_counters[ITEM];
+
+            // subgroup-barrier
+            SUBGROUP_SYNC(item_ct1);
+
+            // Number of peers having same digit as me
+            int32_t digit_count = sycl::popcount(peer_mask);
+
+            // Number of lower-ranked peers having same digit seen so far
+            int32_t peer_digit_prefix = sycl::popcount(peer_mask & lane_mask_lt);
+
+            if (peer_digit_prefix == 0)
+            {
+                // First thread for each digit updates the shared subgroup counter
+                *digit_counters[ITEM] = DigitCounterT(subgroup_digit_prefix + digit_count);
+            }
+
+            // subgroup-barrier
+            SUBGROUP_SYNC(item_ct1);
+
+            // Number of prior keys having same digit
+            ranks[ITEM] = subgroup_digit_prefix + DigitCounterT(peer_digit_prefix);
+        }
+
+        CTA_SYNC(item_ct1);
+
+        // Scan subgroup counters
+
+        DigitCounterT scan_counters[PADDED_RAKING_SEGMENT];
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < PADDED_RAKING_SEGMENT; ++ITEM)
+            scan_counters[ITEM] = temp_storage.aliasable.raking_grid[linear_tid][ITEM];
+
+        BlockScanT(temp_storage.block_scan, item_ct1).ExclusiveSum(scan_counters, scan_counters);
+
+        #pragma unroll
+        for (int ITEM = 0; ITEM < PADDED_RAKING_SEGMENT; ++ITEM)
+            temp_storage.aliasable.raking_grid[linear_tid][ITEM] = scan_counters[ITEM];
+
+        CTA_SYNC(item_ct1);
+        if (!std::is_same<
+              CountsCallback,
+              BlockRadixRankEmptyCallback<BINS_TRACKED_PER_THREAD>>::value)
+        {
+            CallBack<KEYS_PER_THREAD>(callback);
+        }
+
+        // Seed ranks with counter values from previous subgroups
+        #pragma unroll
+        for (int ITEM = 0; ITEM < KEYS_PER_THREAD; ++ITEM)
+            ranks[ITEM] += *digit_counters[ITEM];
+    }
+
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT>
+    __dpct_inline__ void RankKeys(UnsignedBits (&keys)[KEYS_PER_THREAD],
+                                  int (&ranks)[KEYS_PER_THREAD],
+                                  DigitExtractorT digit_extractor)
+    {
+        RankKeys(keys, ranks, digit_extractor,
+                 BlockRadixRankEmptyCallback<BINS_TRACKED_PER_THREAD>());
+    }
+
+    /**
+     * \brief Rank keys.  For the lower \p RADIX_DIGITS threads, digit counts for each digit are provided for the corresponding thread.
+     */
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT,
+              typename CountsCallback>
+    __dpct_inline__ void RankKeys(
+        UnsignedBits (&keys)[KEYS_PER_THREAD], ///< [in] Keys for this tile
+        int (&ranks)[KEYS_PER_THREAD],   ///< [out] For each key, the local rank
+                                         ///< within the tile (out parameter)
+        DigitExtractorT digit_extractor, ///< [in] The digit extractor
+        int (&exclusive_digit_prefix)
+            [BINS_TRACKED_PER_THREAD], ///< [out] The exclusive prefix sum for
+                                       ///< the digits [(threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) ...
+                                       ///< (threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) +
+                                       ///< BINS_TRACKED_PER_THREAD - 1]
+        CountsCallback callback)
+    {
+        RankKeys(keys, ranks, digit_extractor, callback);
+
+        // Get exclusive count for each digit
+        #pragma unroll
+        for (int track = 0; track < BINS_TRACKED_PER_THREAD; ++track)
+        {
+            int bin_idx = (linear_tid * BINS_TRACKED_PER_THREAD) + track;
+
+            if ((BLOCK_THREADS == RADIX_DIGITS) || (bin_idx < RADIX_DIGITS))
+            {
+                if (IS_DESCENDING)
+                    bin_idx = RADIX_DIGITS - bin_idx - 1;
+
+                exclusive_digit_prefix[track] = temp_storage.aliasable.subgroup_digit_counters[bin_idx][0];
+            }
+        }
+    }
+
+    template <typename UnsignedBits, int KEYS_PER_THREAD,
+              typename DigitExtractorT>
+    __dpct_inline__ void RankKeys(
+        UnsignedBits (&keys)[KEYS_PER_THREAD], ///< [in] Keys for this tile
+        int (&ranks)[KEYS_PER_THREAD], ///< [out] For each key, the local rank
+                                       ///< within the tile (out parameter)
+        DigitExtractorT digit_extractor,
+        int (&exclusive_digit_prefix)
+            [BINS_TRACKED_PER_THREAD]) ///< [out] The exclusive prefix sum for
+                                       ///< the digits [(threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) ...
+                                       ///< (threadIdx.x *
+                                       ///< BINS_TRACKED_PER_THREAD) +
+                                       ///< BINS_TRACKED_PER_THREAD - 1]
+    {
+        RankKeys(keys, ranks, digit_extractor, exclusive_digit_prefix,
+                 BlockRadixRankEmptyCallback<BINS_TRACKED_PER_THREAD>());
+    }
+};
+
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_sort.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_sort.hpp
new file mode 100644
index 000000000..e01446f36
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_radix_sort.hpp
@@ -0,0 +1,486 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * The BlockRadixSort class provides [<em>collective</em>](index.html#sec0) methods for radix sorting of items partitioned across a thread block.
+ */
+
+
+#pragma once
+
+#include "block_exchange.hpp"
+#include "block_radix_rank.hpp"
+#include "util_type.hpp"
+
+
+/**
+ * \brief The BlockRadixSort class provides [<em>collective</em>](index.html#sec0) methods for sorting items partitioned across a thread block using a radix sorting method.  ![](sorting_logo.png)
+ * \ingroup BlockModule
+ *
+ * \tparam KeyT                 KeyT type
+ * \tparam BLOCK_DIM_X          The thread block length in threads along the X dimension
+ * \tparam ITEMS_PER_THREAD     The number of items per thread
+ * \tparam ValueT               <b>[optional]</b> ValueT type (default: NullType, which indicates a keys-only sort)
+ * \tparam RADIX_BITS           <b>[optional]</b> The number of radix bits per digit place (default: 4 bits)
+ * \tparam MEMOIZE_OUTER_SCAN   <b>[optional]</b> Whether or not to buffer outer raking scan partials to incur fewer shared memory reads at the expense of higher register pressure (default: true for architectures SM35 and newer, false otherwise).
+ * \tparam INNER_SCAN_ALGORITHM <b>[optional]</b> The BlockScanAlgorithm algorithm to use (default: BLOCK_SCAN_SUBGROUP_SCANS)
+ * \tparam BLOCK_DIM_Y          <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ *
+ * \par Overview
+ * The [<em>radix sorting method</em>](http://en.wikipedia.org/wiki/Radix_sort) arranges
+ * items into ascending order.  It relies upon a positional representation for
+ * keys, i.e., each key is comprised of an ordered sequence of symbols (e.g., digits,
+ * characters, etc.) specified from least-significant to most-significant.  For a
+ * given input sequence of keys and a set of rules specifying a total ordering
+ * of the symbolic alphabet, the radix sorting method produces a lexicographic
+ * ordering of those keys.
+ *
+ * \rowmajor
+ *
+ * \par Supported Types
+ * BlockRadixSort can sort all of the built-in C++ numeric primitive types
+ * (<tt>unsigned char</tt>, \p int, \p float, etc.) 
+ *
+ * \par Floating-Point Special Cases
+ *
+ * - Positive and negative zeros are considered equivalent, and will be treated
+ *   as such in the output.
+ * - No special handling is implemented for NaN values; these are sorted
+ *   according to their bit representations after any transformations.
+ *
+ * \par Bitwise Key Transformations
+ * Although the direct radix sorting method can only be applied to unsigned
+ * integral types, BlockRadixSort is able to sort signed and floating-point
+ * types via simple bit-wise transformations that ensure lexicographic key
+ * ordering.
+ *
+ * These transformations must be considered when restricting the
+ * `[begin_bit, end_bit)` range, as the bitwise transformations will occur
+ * before the bit-range truncation.
+ *
+ * Any transformations applied to the keys prior to sorting are reversed
+ * while writing to the final output buffer.
+ *
+ * \par Type Specific Bitwise Transformations
+ * To convert the input values into a radix-sortable bitwise representation,
+ * the following transformations take place prior to sorting:
+ *
+ * - For unsigned integral values, the keys are used directly.
+ * - For signed integral values, the sign bit is inverted.
+ * - For positive floating point values, the sign bit is inverted.
+ * - For negative floating point values, the full key is inverted.
+ *
+ * \par No Descending Sort Transformations
+ * Unlike `DeviceRadixSort`, `BlockRadixSort` does not invert the input key bits
+ * when performing a descending sort. Instead, it has special logic to reverse
+ * the order of the keys while sorting.
+ *
+ * \par Stability
+ * BlockRadixSort is stable. For floating-point types -0.0 and +0.0
+ * are considered equal and appear in the result in the same order as they
+ * appear in the input.
+ *
+ *
+ * \par Performance Considerations
+ * - \granularity
+ *
+ */
+template <typename KeyT, int BLOCK_DIM_X, int ITEMS_PER_THREAD,
+          typename ValueT, int RADIX_BITS = 4,
+          int LOG_SUBGROUP = 4,
+          bool MEMOIZE_OUTER_SCAN = true,
+          BlockScanAlgorithm INNER_SCAN_ALGORITHM = BLOCK_SCAN_SUBGROUP_SCANS,
+          int BLOCK_DIM_Y = 1>
+class BlockRadixSort
+{
+private:
+
+    /******************************************************************************
+     * Constants and type definitions
+     ******************************************************************************/
+
+    enum
+    {
+        // The thread block size in threads
+        BLOCK_THREADS               = BLOCK_DIM_X * BLOCK_DIM_Y,
+    };
+
+    // KeyT traits and unsigned bits type
+    typedef Traits<KeyT>                        KeyTraits;
+    typedef typename KeyTraits::UnsignedBits    UnsignedBits;
+
+    using BlockRadixSortT = BlockRadixSort<KeyT,
+                          BLOCK_DIM_X,
+                          ITEMS_PER_THREAD,
+                          ValueT,
+                          RADIX_BITS,
+                          LOG_SUBGROUP,
+                          MEMOIZE_OUTER_SCAN,
+                          INNER_SCAN_ALGORITHM>;
+
+    /// Ascending BlockRadixRank utility type
+    typedef BlockRadixRank<
+            BLOCK_DIM_X,
+            RADIX_BITS,
+            false,
+            LOG_SUBGROUP,
+            MEMOIZE_OUTER_SCAN,
+            INNER_SCAN_ALGORITHM,
+            BLOCK_DIM_Y>
+        AscendingBlockRadixRank;
+
+    /// Descending BlockRadixRank utility type
+    typedef BlockRadixRank<
+            BLOCK_DIM_X,
+            RADIX_BITS,
+            true,
+            LOG_SUBGROUP,
+            MEMOIZE_OUTER_SCAN,
+            INNER_SCAN_ALGORITHM,
+            BLOCK_DIM_Y>
+        DescendingBlockRadixRank;
+
+    /// Digit extractor type
+    typedef BFEDigitExtractor<KeyT> DigitExtractorT;
+
+    /// BlockExchange utility type for keys
+    typedef BlockExchange<KeyT, BLOCK_DIM_X, ITEMS_PER_THREAD, LOG_SUBGROUP, false, BLOCK_DIM_Y> BlockExchangeKeys;
+
+    /// BlockExchange utility type for values
+    typedef BlockExchange<ValueT, BLOCK_DIM_X, ITEMS_PER_THREAD, LOG_SUBGROUP, false, BLOCK_DIM_Y> BlockExchangeValues;
+
+    /// Shared memory storage layout type
+    union _TempStorage
+    {
+        typename AscendingBlockRadixRank::TempStorage  asending_ranking_storage;
+        typename DescendingBlockRadixRank::TempStorage descending_ranking_storage;
+        typename BlockExchangeKeys::TempStorage        exchange_keys;
+        typename BlockExchangeValues::TempStorage      exchange_values;
+    };
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Shared storage reference
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    unsigned int linear_tid;
+
+    sycl::nd_item<2> item_ct1;
+
+    /******************************************************************************
+     * Utility methods
+     ******************************************************************************/
+
+    /// Internal storage allocator
+    __dpct_inline__ _TempStorage &PrivateStorage(_TempStorage *private_storage)
+    {
+
+        return (*private_storage);
+    }
+
+    /// Rank keys (specialized for ascending sort)
+    __dpct_inline__ void
+    RankKeys(UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD],
+             int (&ranks)[ITEMS_PER_THREAD], DigitExtractorT digit_extractor,
+             Int2Type<false> /*is_descending*/)
+    {
+        AscendingBlockRadixRank(temp_storage.asending_ranking_storage, item_ct1).RankKeys(
+                unsigned_keys,
+                ranks,
+                digit_extractor);
+    }
+
+    /// Rank keys (specialized for descending sort)
+    __dpct_inline__ void
+    RankKeys(UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD],
+             int (&ranks)[ITEMS_PER_THREAD], DigitExtractorT digit_extractor,
+             Int2Type<true> /*is_descending*/)
+    {
+        DescendingBlockRadixRank(temp_storage.descending_ranking_storage, item_ct1).RankKeys(
+                unsigned_keys,
+                ranks,
+                digit_extractor);
+    }
+
+    /// ExchangeValues (specialized for key-value sort, to-blocked arrangement)
+    __dpct_inline__ void
+    ExchangeValues(ValueT (&values)[ITEMS_PER_THREAD],
+                   int (&ranks)[ITEMS_PER_THREAD],
+                   Int2Type<true> /*is_blocked*/)
+    {
+        CTA_SYNC(item_ct1);
+
+        // Exchange values through shared memory in blocked arrangement
+        BlockExchangeValues(temp_storage.exchange_values, item_ct1).ScatterToBlocked(values, ranks);
+    }
+
+    __dpct_inline__ void
+    ExchangeValues(ValueT (&values)[ITEMS_PER_THREAD],
+                   int (&ranks)[ITEMS_PER_THREAD],
+                   Int2Type<false> /*is_blocked*/)
+    {
+        CTA_SYNC(item_ct1);
+
+        // Exchange values through shared memory in blocked arrangement
+        BlockExchangeValues(temp_storage.exchange_values, item_ct1).ScatterToStriped(values, ranks);
+    }
+
+    /// ExchangeValues (specialized for keys-only sort)
+    template <int IS_BLOCKED>
+    __dpct_inline__ void ExchangeValues(ValueT (&/*values*/)[ITEMS_PER_THREAD],
+                                        int (&/*ranks*/)[ITEMS_PER_THREAD],
+                                        Int2Type<IS_BLOCKED> /*is_blocked*/)
+    {}
+
+    /// Sort blocked arrangement
+    template <int DESCENDING>
+    __dpct_inline__ void
+    SortBlocked(KeyT (&keys)[ITEMS_PER_THREAD],     ///< Keys to sort
+                ValueT (&values)[ITEMS_PER_THREAD], ///< Values to sort
+                int begin_bit, ///< The beginning (least-significant) bit index
+                               ///< needed for key comparison
+                int end_bit, ///< The past-the-end (most-significant) bit index
+                             ///< needed for key comparison
+                Int2Type<DESCENDING>  is_descending) ///< Tag whether is a descending-order sort
+                                                    ///< Tag whether is keys-only sort
+    {
+        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD] =
+            reinterpret_cast<UnsignedBits (&)[ITEMS_PER_THREAD]>(keys);
+
+        #pragma unroll
+        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
+        {
+            unsigned_keys[KEY] = KeyTraits::TwiddleIn(unsigned_keys[KEY]);
+        }
+
+        // Radix sorting passes
+        while (true)
+        {
+            int pass_bits = ONEAPI_MIN(RADIX_BITS, end_bit - begin_bit);
+            DigitExtractorT digit_extractor(begin_bit, pass_bits);
+
+            // Rank the blocked keys
+            int ranks[ITEMS_PER_THREAD];
+            RankKeys(unsigned_keys, ranks, digit_extractor, is_descending);
+            begin_bit += RADIX_BITS;
+
+            CTA_SYNC(item_ct1);
+
+            // Exchange keys through shared memory in blocked arrangement
+            BlockExchangeKeys(temp_storage.exchange_keys, item_ct1).ScatterToBlocked(keys, ranks);
+
+            // Exchange values through shared memory in blocked arrangement
+            ExchangeValues(values, ranks, Int2Type<true>(), item_ct1);
+
+            // Quit if done
+            if (begin_bit >= end_bit) break;
+
+            CTA_SYNC(item_ct1);
+        }
+
+        // Untwiddle bits if necessary
+        #pragma unroll
+        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
+        {
+            unsigned_keys[KEY] = KeyTraits::TwiddleOut(unsigned_keys[KEY]);
+        }
+    }
+
+    /// Sort blocked -> striped arrangement
+    template <int DESCENDING>
+    __dpct_inline__ void SortBlockedToStriped(
+        KeyT (&keys)[ITEMS_PER_THREAD],     ///< Keys to sort
+        ValueT (&values)[ITEMS_PER_THREAD], ///< Values to sort
+        int begin_bit, ///< The beginning (least-significant) bit index needed
+                       ///< for key comparison
+        int end_bit,   ///< The past-the-end (most-significant) bit index needed
+                       ///< for key comparison
+        Int2Type<DESCENDING> is_descending) ///< Tag whether is a descending-order sort
+    {
+        UnsignedBits (&unsigned_keys)[ITEMS_PER_THREAD] =
+            reinterpret_cast<UnsignedBits (&)[ITEMS_PER_THREAD]>(keys);
+
+        // Twiddle bits if necessary
+        #pragma unroll
+        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
+        {
+            unsigned_keys[KEY] = KeyTraits::TwiddleIn(unsigned_keys[KEY]);
+        }
+
+        // Radix sorting passes
+        while (true)
+        {
+            int pass_bits = ONEAPI_MIN(RADIX_BITS, end_bit - begin_bit);
+            DigitExtractorT digit_extractor(begin_bit, pass_bits);
+
+            // Rank the blocked keys
+            int ranks[ITEMS_PER_THREAD];
+            RankKeys(unsigned_keys, ranks, digit_extractor, is_descending);
+            begin_bit += RADIX_BITS;
+
+            CTA_SYNC(item_ct1);
+
+            // Check if this is the last pass
+            if (begin_bit >= end_bit)
+            {
+                // Last pass exchanges keys through shared memory in striped arrangement
+                BlockExchangeKeys(temp_storage.exchange_keys, item_ct1).ScatterToStriped(keys, ranks);
+
+                // Last pass exchanges through shared memory in striped arrangement
+                ExchangeValues(values, ranks, Int2Type<false>());
+
+                // Quit
+                break;
+            }
+
+            // Exchange keys through shared memory in blocked arrangement
+            BlockExchangeKeys(temp_storage.exchange_keys, item_ct1).ScatterToBlocked(keys, ranks);
+
+            // Exchange values through shared memory in blocked arrangement
+            ExchangeValues(values, ranks, Int2Type<true>());
+
+            CTA_SYNC(item_ct1);
+        }
+
+        // Untwiddle bits if necessary
+        #pragma unroll
+        for (int KEY = 0; KEY < ITEMS_PER_THREAD; KEY++)
+        {
+            unsigned_keys[KEY] = KeyTraits::TwiddleOut(unsigned_keys[KEY]);
+        }
+    }
+
+public:
+
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockRadixSort(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          item_ct1(item_ct1)
+    {}
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Sorting (blocked arrangements)
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Performs an ascending block-wide radix sort across a [<em>blocked arrangement</em>](index.html#sec5sec3) of keys and values.
+     *
+     * \par
+     * - BlockRadixSort can only accommodate one associated tile of values. To "truck along"
+     *   more than one tile of values, simply perform a key-value sort of the keys paired
+     *   with a temporary value array that enumerates the key indices.  The reordered indices
+     *   can then be used as a gather-vector for exchanging other associated tile data through
+     *   shared memory.
+     *
+     */
+    __dpct_inline__ void
+    Sort(KeyT (&keys)[ITEMS_PER_THREAD],     ///< [in-out] Keys to sort
+         ValueT (&values)[ITEMS_PER_THREAD], ///< [in-out] Values to sort
+         int begin_bit =  0, ///< [in] <b>[optional]</b> The beginning (least-significant)
+                             ///< bit index needed for key comparison
+         int end_bit = sizeof(KeyT) *  8) ///< [in] <b>[optional]</b> The past-the-end (most-significant)
+                                          ///< bit index needed for key comparison
+    {
+        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<false>());
+    }
+
+    /**
+     * \brief Performs a descending block-wide radix sort across a [<em>blocked arrangement</em>](index.html#sec5sec3) of keys and values.
+     *
+     * \par
+     * - BlockRadixSort can only accommodate one associated tile of values. To "truck along"
+     *   more than one tile of values, simply perform a key-value sort of the keys paired
+     *   with a temporary value array that enumerates the key indices.  The reordered indices
+     *   can then be used as a gather-vector for exchanging other associated tile data through
+     *   shared memory.
+     *
+     */
+    __dpct_inline__ void SortDescending(
+        KeyT (&keys)[ITEMS_PER_THREAD],     ///< [in-out] Keys to sort
+        ValueT (&values)[ITEMS_PER_THREAD], ///< [in-out] Values to sort
+        int begin_bit =  0, ///< [in] <b>[optional]</b> The beginning (least-significant)
+                             ///< bit index needed for key comparison
+        int end_bit = sizeof(KeyT) *  8) ///< [in] <b>[optional]</b> The past-the-end (most-significant)
+                                          ///< bit index needed for key comparison
+    {
+        SortBlocked(keys, values, begin_bit, end_bit, Int2Type<true>());
+    }
+
+    /**
+     * \brief Performs an ascending radix sort across a [<em>blocked arrangement</em>](index.html#sec5sec3) of keys and values, leaving them in a [<em>striped arrangement</em>](index.html#sec5sec3).
+     *
+     * \par
+     * - BlockRadixSort can only accommodate one associated tile of values. To "truck along"
+     *   more than one tile of values, simply perform a key-value sort of the keys paired
+     *   with a temporary value array that enumerates the key indices.  The reordered indices
+     *   can then be used as a gather-vector for exchanging other associated tile data through
+     *   shared memory.
+     *
+     */
+    __dpct_inline__ void SortBlockedToStriped(
+        KeyT (&keys)[ITEMS_PER_THREAD],     ///< [in-out] Keys to sort
+        ValueT (&values)[ITEMS_PER_THREAD], ///< [in-out] Values to sort
+        int begin_bit =  0, ///< [in] <b>[optional]</b> The beginning (least-significant) bit
+                            ///< index needed for key comparison
+        int end_bit = sizeof(KeyT) * 8) ///< [in] <b>[optional]</b> The past-the-end (most-significant)
+               ///< bit index needed for key comparison
+    {
+        SortBlockedToStriped(keys, values, begin_bit, end_bit, Int2Type<false>());
+    }
+
+    //@}  end member group
+
+};
+
+/**
+ * \example example_block_radix_sort.cu
+ */
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_raking_layout.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_raking_layout.hpp
new file mode 100644
index 000000000..c4b1baa74
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_raking_layout.hpp
@@ -0,0 +1,138 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * cub::BlockRakingLayout provides a conflict-free shared memory layout abstraction for warp-raking across thread block data.
+ */
+
+
+#pragma once
+
+#include "util_type.hpp"
+
+/**
+ * \brief BlockRakingLayout provides a conflict-free shared memory layout abstraction for 1D raking across thread block data.    ![](raking.png)
+ * \ingroup BlockModule
+ *
+ * \par Overview
+ * This type facilitates a shared memory usage pattern where a block of 
+ * threads places elements into shared memory and then reduces the active
+ * parallelism to one "raking" warp of threads for serially aggregating consecutive
+ * sequences of shared items.  Padding is inserted to eliminate bank conflicts
+ * (for most data types).
+ *
+ * \tparam T                        The data type to be exchanged.
+ * \tparam BLOCK_THREADS            The thread block size in threads.
+ * \tparam LEGACY_PTX_ARCH          <b>[optional]</b> Unused.
+ */
+template <
+    typename    T,
+    int         BLOCK_THREADS,
+    int         LEGACY_PTX_ARCH = 0>
+struct BlockRakingLayout
+{
+    //---------------------------------------------------------------------
+    // Constants and type definitions
+    //---------------------------------------------------------------------
+
+    enum
+    {
+        /// The total number of elements that need to be cooperatively reduced
+        SHARED_ELEMENTS = BLOCK_THREADS,
+
+        /// Maximum number of warp-synchronous raking threads
+        MAX_RAKING_THREADS = ONEAPI_MIN(BLOCK_THREADS, 16),
+
+        /// Number of raking elements per warp-synchronous raking thread (rounded up)
+        SEGMENT_LENGTH = (SHARED_ELEMENTS + MAX_RAKING_THREADS - 1) / MAX_RAKING_THREADS,
+
+        /// Never use a raking thread that will have no valid data (e.g., when BLOCK_THREADS is 62 and SEGMENT_LENGTH is 2, we should only use 31 raking threads)
+        RAKING_THREADS = (SHARED_ELEMENTS + SEGMENT_LENGTH - 1) / SEGMENT_LENGTH,
+
+        /// Whether we will have bank conflicts (technically we should find out if the GCD is > 1)
+        HAS_CONFLICTS = (8 % SEGMENT_LENGTH == 0),
+
+        /// Degree of bank conflicts (e.g., 4-way)
+        CONFLICT_DEGREE = (HAS_CONFLICTS) ?
+            (MAX_RAKING_THREADS * SEGMENT_LENGTH) / 8 :
+            1,
+
+        /// Pad each segment length with one element if segment length is not relatively prime to warp size and can't be optimized as a vector load
+        USE_SEGMENT_PADDING = ((SEGMENT_LENGTH & 1) == 0) && (SEGMENT_LENGTH > 2),
+
+        /// Total number of elements in the raking grid
+        GRID_ELEMENTS = RAKING_THREADS * (SEGMENT_LENGTH + USE_SEGMENT_PADDING),
+
+        /// Whether or not we need bounds checking during raking (the number of reduction elements is not a multiple of the number of raking threads)
+        UNGUARDED = (SHARED_ELEMENTS % RAKING_THREADS == 0),
+    };
+
+
+    /**
+     * \brief Shared memory storage type
+     */
+    struct __dpct_align__(16) _TempStorage
+    {
+        T buff[BlockRakingLayout::GRID_ELEMENTS];
+    };
+
+    /// Alias wrapper allowing storage to be unioned
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /**
+     * \brief Returns the location for the calling thread to place data into the grid
+     */
+    static __dpct_inline__ T *PlacementPtr(TempStorage &temp_storage,
+                                           unsigned int linear_tid)
+    {
+        // Offset for partial
+        unsigned int offset = linear_tid;
+
+        // Add in one padding element for every segment
+        if (USE_SEGMENT_PADDING > 0)
+        {
+            offset += offset / SEGMENT_LENGTH;
+        }
+
+        // Incorporating a block of padding partials every shared memory segment
+        return temp_storage.Alias().buff + offset;
+    }
+
+
+    /**
+     * \brief Returns the location for the calling thread to begin sequential raking
+     */
+    static __dpct_inline__ T *RakingPtr(TempStorage &temp_storage,
+                                        unsigned int linear_tid)
+    {
+        return temp_storage.Alias().buff + (linear_tid * (SEGMENT_LENGTH + USE_SEGMENT_PADDING));
+    }
+};
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan.hpp
new file mode 100644
index 000000000..5adce3f4c
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan.hpp
@@ -0,0 +1,382 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * The BlockScan class provides [<em>collective</em>](index.html#sec0) methods for computing a parallel prefix sum/scan of items partitioned across a thread block.
+ */
+
+#pragma once
+
+#include "block_scan_raking.hpp"
+#include "thread_reduce.hpp"
+#include "util_type.hpp"
+
+
+/******************************************************************************
+ * Algorithmic variants
+ ******************************************************************************/
+
+/**
+ * \brief BlockScanAlgorithm enumerates alternative algorithms for BlockScan to compute a parallel prefix scan across a thread block.
+ */
+enum BlockScanAlgorithm
+{
+
+    /**
+     * \par Overview
+     * An efficient "raking reduce-then-scan" prefix scan algorithm.  Execution is comprised of five phases:
+     * -# Upsweep sequential reduction in registers (if threads contribute more than one input each).  Each thread then places the partial reduction of its item(s) into shared memory.
+     * -# Upsweep sequential reduction in shared memory.  Threads within a single warp rake across segments of shared partial reductions.
+     * -# A warp-synchronous Kogge-Stone style exclusive scan within the raking warp.
+     * -# Downsweep sequential exclusive scan in shared memory.  Threads within a single warp rake across segments of shared partial reductions, seeded with the warp-scan output.
+     * -# Downsweep sequential scan in registers (if threads contribute more than one input), seeded with the raking scan output.
+     *
+     * \par
+     * \image html block_scan_raking.png
+     * <div class="centercaption">\p BLOCK_SCAN_RAKING data flow for a hypothetical 16-thread thread block and 4-thread raking warp.</div>
+     *
+     * \par Performance Considerations
+     * - Although this variant may suffer longer turnaround latencies when the
+     *   GPU is under-occupied, it can often provide higher overall throughput
+     *   across the GPU when suitably occupied.
+     */
+    BLOCK_SCAN_RAKING,
+
+
+    /**
+     * \par Overview
+     * Similar to BLOCK_SCAN_RAKING, but with fewer shared memory reads at
+     * the expense of higher register pressure.  Raking threads preserve their
+     * "upsweep" segment of values in registers while performing warp-synchronous
+     * scan, allowing the "downsweep" not to re-read them from shared memory.
+     */
+    BLOCK_SCAN_RAKING_MEMOIZE,
+
+
+    /**
+     * \par Overview
+     * A quick "tiled warpscans" prefix scan algorithm.  Execution is comprised of four phases:
+     * -# Upsweep sequential reduction in registers (if threads contribute more than one input each).  Each thread then places the partial reduction of its item(s) into shared memory.
+     * -# Compute a shallow, but inefficient warp-synchronous Kogge-Stone style scan within each warp.
+     * -# A propagation phase where the warp scan outputs in each warp are updated with the aggregate from each preceding warp.
+     * -# Downsweep sequential scan in registers (if threads contribute more than one input), seeded with the raking scan output.
+     *
+     * \par
+     * \image html block_scan_warpscans.png
+     * <div class="centercaption">\p BLOCK_SCAN_SUBGROUP_SCANS data flow for a hypothetical 16-thread thread block and 4-thread raking warp.</div>
+     *
+     * \par Performance Considerations
+     * - Although this variant may suffer lower overall throughput across the
+     *   GPU because due to a heavy reliance on inefficient warpscans, it can
+     *   often provide lower turnaround latencies when the GPU is under-occupied.
+     */
+    BLOCK_SCAN_SUBGROUP_SCANS,
+};
+
+
+/******************************************************************************
+ * Block scan
+ ******************************************************************************/
+
+/**
+ * \brief The BlockScan class provides [<em>collective</em>](index.html#sec0) methods for computing a parallel prefix sum/scan of items partitioned across a thread block. ![](block_scan_logo.png)
+ * \ingroup BlockModule
+ *
+ * \tparam T                Data type being scanned
+ * \tparam BLOCK_DIM_X      The thread block length in threads along the X dimension
+ * \tparam ALGORITHM        <b>[optional]</b> BlockScanAlgorithm enumerator specifying the underlying algorithm to use (default: BLOCK_SCAN_RAKING)
+ * \tparam BLOCK_DIM_Y      <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ *
+ * \par Overview
+ * - Given a list of input elements and a binary reduction operator, a [<em>prefix scan</em>](http://en.wikipedia.org/wiki/Prefix_sum)
+ *   produces an output list where each element is computed to be the reduction
+ *   of the elements occurring earlier in the input list.  <em>Prefix sum</em>
+ *   connotes a prefix scan with the addition operator. The term \em inclusive indicates
+ *   that the <em>i</em><sup>th</sup> output reduction incorporates the <em>i</em><sup>th</sup> input.
+ *   The term \em exclusive indicates the <em>i</em><sup>th</sup> input is not incorporated into
+ *   the <em>i</em><sup>th</sup> output reduction.
+ * - \rowmajor
+ * - BlockScan can be optionally specialized by algorithm to accommodate different workload profiles:
+ *   -# <b>BLOCK_SCAN_RAKING</b>.  An efficient (high throughput) "raking reduce-then-scan" prefix scan algorithm. [More...](\ref BlockScanAlgorithm)
+ *   -# <b>BLOCK_SCAN_RAKING_MEMOIZE</b>.  Similar to BLOCK_SCAN_RAKING, but having higher throughput at the expense of additional register pressure for intermediate storage. [More...](\ref BlockScanAlgorithm)
+ *   -# <b>BLOCK_SCAN_SUBGROUP_SCANS</b>.  A quick (low latency) "tiled warpscans" prefix scan algorithm. [More...](\ref BlockScanAlgorithm)
+ *
+ * \par Performance Considerations
+ * - \granularity
+ * - Uses special instructions when applicable (e.g., warp \p SHFL)
+ * - Uses synchronization-free communication between warp lanes when applicable
+ * - Invokes a minimal number of minimal block-wide synchronization barriers (only
+ *   one or two depending on algorithm selection)
+ * - Incurs zero bank conflicts for most types
+ * - Computation is slightly more efficient (i.e., having lower instruction overhead) for:
+ *   - Prefix sum variants (<b><em>vs.</em></b> generic scan)
+ *   - \blocksize
+ * - See BlockScanAlgorithm for performance details regarding algorithmic alternatives
+ */
+template <
+    typename            T,
+    int                 BLOCK_DIM_X,
+    BlockScanAlgorithm  ALGORITHM       = BLOCK_SCAN_RAKING,
+    int                 BLOCK_DIM_Y     = 1>
+class BlockScan
+{
+private:
+
+    /******************************************************************************
+     * Constants and type definitions
+     ******************************************************************************/
+
+    /// Constants
+    enum
+    {
+        /// The thread block size in threads
+        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y,
+    };
+
+    /**
+     * Ensure the template parameterization meets the requirements of the
+     * specified algorithm. Currently, the BLOCK_SCAN_SUBGROUP_SCANS policy
+     * cannot be used with thread block sizes not a multiple of the
+     * architectural warp size.
+     */
+    static const BlockScanAlgorithm SAFE_ALGORITHM =
+        ((ALGORITHM == BLOCK_SCAN_SUBGROUP_SCANS) && (BLOCK_THREADS % 16 != 0)) ?
+            BLOCK_SCAN_RAKING :
+            ALGORITHM;
+
+//    typedef BlockScanWarpScans<T, BLOCK_DIM_X, BLOCK_DIM_Y, BLOCK_DIM_Z> WarpScans;
+    typedef BlockScanRaking<T, BLOCK_DIM_X, BLOCK_DIM_Y, (SAFE_ALGORITHM == BLOCK_SCAN_RAKING_MEMOIZE)> Raking;
+
+    /// Define the delegate type for the desired algorithm
+//    using InternalBlockScan =
+//      cub::detail::conditional_t<
+//        SAFE_ALGORITHM == BLOCK_SCAN_SUBGROUP_SCANS, WarpScans, Raking>;
+    using InternalBlockScan = Raking;
+
+    /// Shared memory storage layout type for BlockScan
+    typedef typename InternalBlockScan::TempStorage _TempStorage;
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Shared storage reference
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    unsigned int linear_tid;
+
+    sycl::nd_item<2> item_ct1;
+
+
+    /******************************************************************************
+     * Utility methods
+     ******************************************************************************/
+
+    /// Internal storage allocator
+    __dpct_inline__ _TempStorage &PrivateStorage(_TempStorage *private_storage)
+    {
+
+        return (*private_storage);
+    }
+
+
+    /******************************************************************************
+     * Public types
+     ******************************************************************************/
+public:
+
+    /// \smemstorage{BlockScan}
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockScan(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          item_ct1 (item_ct1)
+    {}
+
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Exclusive prefix sum operations
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.  Each thread contributes one input element.  The value of 0 is applied as the initial value, and is assigned to \p output in <em>thread</em><sub>0</sub>.
+     *
+     */
+    template <int ITEMS_PER_THREAD>
+    __dpct_inline__ void ExclusiveSum(
+        T (&input)[ITEMS_PER_THREAD],   ///< [in] Calling thread's input item
+        T (&output)[ITEMS_PER_THREAD]) ///< [out] Calling thread's output item (may be
+                            ///< aliased to \p input)
+    {
+        T initial_value{};
+
+        ExclusiveScan(input, output, initial_value, sycl::plus<>());
+    }
+
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.  Each thread contributes one input element.  Instead of using 0 as the block-wide prefix, the call-back functor \p block_prefix_callback_op is invoked by the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the "seed" value that logically prefixes the thread block's scan inputs.  Also provides every thread with the block-wide \p block_aggregate of all inputs.
+     *
+     * \par
+     * - \identityzero
+     * - The \p block_prefix_callback_op functor must implement a member function <tt>T operator()(T block_aggregate)</tt>.
+     *   The functor's input parameter \p block_aggregate is the same value also returned by the scan operation.
+     *   The functor will be invoked by the first warp of threads in the block, however only the return value from
+     *   lane is applied as the block-wide prefix.  Can be stateful.
+     */
+    template <typename BlockPrefixCallbackOp>
+    __dpct_inline__ void
+    ExclusiveSum(T input,   ///< [in] Calling thread's input item
+                 T &output, ///< [out] Calling thread's output item (may be
+                            ///< aliased to \p input)
+                 BlockPrefixCallbackOp &block_prefix_callback_op) ///< [in-out]
+                                                ///< <b>[<em>warp</em><sub>0</sub>
+                                                ///< only]</b> Call-back functor
+                                                ///< for specifying a block-wide
+                                                ///< prefix to be applied to the
+                                                ///< logical input sequence.
+    {
+        ExclusiveScan(input, output, sycl::plus<>(), block_prefix_callback_op);
+    }
+
+
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using addition (+) as the scan operator.  Each thread contributes an array of consecutive input elements.  Instead of using 0 as the block-wide prefix, the call-back functor \p block_prefix_callback_op is invoked by the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the "seed" value that logically prefixes the thread block's scan inputs.  Also provides every thread with the block-wide \p block_aggregate of all inputs.
+     *
+     * \par
+     * - \identityzero
+     * - The \p block_prefix_callback_op functor must implement a member function <tt>T operator()(T block_aggregate)</tt>.
+     *   The functor's input parameter \p block_aggregate is the same value also returned by the scan operation.
+     *   The functor will be invoked by the first warp of threads in the block, however only the return value from
+     *   <em>lane</em><sub>0</sub> is applied as the block-wide prefix.  Can be stateful.
+     * - \blocked
+     * - \granularity
+     */
+    template <int ITEMS_PER_THREAD,
+              typename BlockPrefixCallbackOp>
+    __dpct_inline__ void ExclusiveSum(
+        T (&input)[ITEMS_PER_THREAD],  ///< [in] Calling thread's input items
+        T (&output)[ITEMS_PER_THREAD], ///< [out] Calling thread's output items
+                                       ///< (may be aliased to \p input)
+        BlockPrefixCallbackOp &block_prefix_callback_op) ///< [in-out]
+                                       ///< <b>[<em>warp</em><sub>0</sub>
+                                       ///< only]</b> Call-back functor for
+                                       ///< specifying a block-wide prefix to be
+                                       ///< applied to the logical input
+                                       ///< sequence.
+    {
+        ExclusiveScan(input, output, sycl::plus<>(), block_prefix_callback_op);
+    }
+
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using the specified binary \p scan_op functor.  Each thread contributes one input element.
+     *
+     */
+    template <typename ScanOp>
+    __dpct_inline__ void
+    ExclusiveScan(T input,   ///< [in] Calling thread's input item
+                  T &output, ///< [out] Calling thread's output item (may be
+                             ///< aliased to \p input)
+                  T initial_value, ///< [in] Initial value to seed the exclusive
+                                   ///< scan (and is assigned to \p output[0] in
+                                   ///< <em>thread</em><sub>0</sub>)
+                  ScanOp scan_op)  ///< [in] Binary scan functor
+    {
+        InternalBlockScan(temp_storage, item_ct1).ExclusiveScan(input, output, initial_value, scan_op);
+    }
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using the specified binary \p scan_op functor.  Each thread contributes one input element.
+     *
+     */
+    template <int ITEMS_PER_THREAD, typename ScanOp>
+    __dpct_inline__ void  ExclusiveScan(
+        T (&input)[ITEMS_PER_THREAD],   ///< [in] Calling thread's input item
+        T (&output)[ITEMS_PER_THREAD], ///< [out] Calling thread's output item (may be
+                             ///< aliased to \p input)
+        T initial_value, ///< [in] Initial value to seed the exclusive
+                                   ///< scan (and is assigned to \p output[0] in
+                                   ///< <em>thread</em><sub>0</sub>)
+        ScanOp scan_op)  ///< [in] Binary scan functor
+    {
+
+        // Reduce consecutive thread items in registers
+        T thread_prefix = internal::ThreadReduce(input, scan_op);
+
+        // Exclusive thread block-scan
+        ExclusiveScan(thread_prefix, thread_prefix, initial_value, scan_op);
+
+        // Exclusive scan in registers with prefix as seed
+        internal::ThreadScanExclusive(input, output, scan_op, thread_prefix);
+    }
+
+
+    /**
+     * \brief Computes an exclusive block-wide prefix scan using the specified binary \p scan_op functor.  Each thread contributes one input element.  the call-back functor \p block_prefix_callback_op is invoked by the first warp in the block, and the value returned by <em>lane</em><sub>0</sub> in that warp is used as the "seed" value that logically prefixes the thread block's scan inputs.  Also provides every thread with the block-wide \p block_aggregate of all inputs.
+     *
+     * \par
+     * - The \p block_prefix_callback_op functor must implement a member function <tt>T operator()(T block_aggregate)</tt>.
+     *   The functor's input parameter \p block_aggregate is the same value also returned by the scan operation.
+     *   The functor will be invoked by the first warp of threads in the block, however only the return value from
+     *   <em>lane</em><sub>0</sub> is applied as the block-wide prefix.  Can be stateful.
+     * - Supports non-commutative scan operators.
+     */
+    template <typename ScanOp, typename BlockPrefixCallbackOp>
+    __dpct_inline__ void ExclusiveScan(
+        T input,   ///< [in] Calling thread's input item
+        T &output, ///< [out] Calling thread's output item (may be
+                   ///< aliased to \p input)
+        ScanOp scan_op, ///< [in] Binary scan functor
+        BlockPrefixCallbackOp &block_prefix_callback_op) ///< [in-out]
+                                                ///< <b>[<em>warp</em><sub>0</sub>
+                                                ///< only]</b> Call-back functor
+                                                ///< for specifying a block-wide
+                                                ///< prefix to be applied to the
+                                                ///< logical input sequence.
+    {
+        InternalBlockScan(temp_storage, item_ct1).ExclusiveScan(input, output, scan_op, block_prefix_callback_op);
+    }
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan_raking.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan_raking.hpp
new file mode 100644
index 000000000..014b7e4e1
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_scan_raking.hpp
@@ -0,0 +1,344 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+
+/**
+ * \file
+ * BlockScanRaking provides variants of raking-based parallel prefix scan across a thread block.
+ */
+
+#pragma once
+
+#include "block_raking_layout.hpp"
+#include "thread_scan.hpp"
+
+/**
+ * \brief BlockScanRaking provides variants of raking-based parallel prefix scan across a thread block.
+ */
+template <
+    typename    T,              ///< Data type being scanned
+    int         BLOCK_DIM_X,    ///< The thread block length in threads along the X dimension
+    int         BLOCK_DIM_Y,    ///< The thread block length in threads along the Y dimension
+    bool        MEMOIZE>        ///< Whether or not to buffer outer raking scan partials to incur fewer shared memory reads at the expense of higher register pressure
+struct BlockScanRaking
+{
+    //---------------------------------------------------------------------
+    // Types and constants
+    //---------------------------------------------------------------------
+
+    /// Constants
+    enum
+    {
+        /// The thread block size in threads
+        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y,
+    };
+
+    /// Layout type for padded thread block raking grid
+    typedef BlockRakingLayout<T, BLOCK_THREADS> BlockRakingLayout;
+
+    /// Constants
+    enum
+    {
+        /// Number of raking threads
+        RAKING_THREADS = BlockRakingLayout::RAKING_THREADS,
+
+        /// Number of raking elements per subgroup synchronous raking thread
+        SEGMENT_LENGTH = BlockRakingLayout::SEGMENT_LENGTH,
+
+        /// Cooperative work can be entirely subgroup synchronous
+        SUBGROUP_SYNCHRONOUS = (int(BLOCK_THREADS) == int(RAKING_THREADS)),
+    };
+
+    ///  WarpScan utility type
+    //typedef WarpScan<T, RAKING_THREADS> WarpScan;
+
+    /// Shared memory storage layout type
+    struct _TempStorage
+    {
+        typename BlockRakingLayout::TempStorage     raking_grid;        ///< Padded thread block raking grid
+        T                                           block_aggregate;    ///< Block aggregate
+    };
+
+
+    /// Alias wrapper allowing storage to be unioned
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    //---------------------------------------------------------------------
+    // Per-thread fields
+    //---------------------------------------------------------------------
+
+    // Thread fields
+    _TempStorage    &temp_storage;
+    unsigned int    linear_tid;
+    T               cached_segment[SEGMENT_LENGTH];
+    sycl::nd_item<2> item_ct1;
+
+
+    //---------------------------------------------------------------------
+    // Utility methods
+    //---------------------------------------------------------------------
+
+    /// Templated reduction
+    template <int ITERATION, typename ScanOp>
+    __dpct_inline__ T
+    GuardedReduce(T *raking_ptr,    ///< [in] Input array
+                  ScanOp scan_op,   ///< [in] Binary reduction operator
+                  T raking_partial, ///< [in] Prefix to seed reduction with
+                  Int2Type<ITERATION> /*iteration*/)
+    {
+        if ((BlockRakingLayout::UNGUARDED) || (((linear_tid * SEGMENT_LENGTH) + ITERATION) < BLOCK_THREADS))
+        {
+            T addend = raking_ptr[ITERATION];
+            raking_partial = scan_op(raking_partial, addend);
+        }
+
+        return GuardedReduce(raking_ptr, scan_op, raking_partial, Int2Type<ITERATION + 1>());
+    }
+
+
+    /// Templated reduction (base case)
+    template <typename ScanOp>
+    __dpct_inline__ T
+    GuardedReduce(T * /*raking_ptr*/, ///< [in] Input array
+                  ScanOp /*scan_op*/, ///< [in] Binary reduction operator
+                  T raking_partial,   ///< [in] Prefix to seed reduction with
+                  Int2Type<SEGMENT_LENGTH> /*iteration*/)
+    {
+        return raking_partial;
+    }
+
+
+    /// Templated copy
+    template <int ITERATION>
+    __dpct_inline__ void CopySegment(T *out, ///< [out] Out array
+                                     T *in,  ///< [in] Input array
+                                     Int2Type<ITERATION> /*iteration*/)
+    {
+        out[ITERATION] = in[ITERATION];
+        CopySegment(out, in, Int2Type<ITERATION + 1>());
+    }
+
+ 
+    /// Templated copy (base case)
+    __dpct_inline__ void CopySegment(T * /*out*/, ///< [out] Out array
+                                     T * /*in*/,  ///< [in] Input array
+                                     Int2Type<SEGMENT_LENGTH> /*iteration*/)
+    {}
+
+
+    /// Performs upsweep raking reduction, returning the aggregate
+    template <typename ScanOp> __dpct_inline__ T Upsweep(ScanOp scan_op)
+    {
+        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
+
+        // Read data into registers
+        CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());
+
+        T raking_partial = cached_segment[0];
+
+        return GuardedReduce(cached_segment, scan_op, raking_partial, Int2Type<1>());
+    }
+
+
+    /// Performs exclusive downsweep raking scan
+    template <typename ScanOp>
+    __dpct_inline__ void ExclusiveDownsweep(ScanOp scan_op, T raking_partial,
+                                            bool apply_prefix = true)
+    {
+        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
+
+        // Read data back into registers
+        if (!MEMOIZE)
+        {
+            CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());
+        }
+
+        internal::ThreadScanExclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix);
+
+        // Write data back to smem
+        CopySegment(smem_raking_ptr, cached_segment, Int2Type<0>());
+    }
+
+
+    /// Performs inclusive downsweep raking scan
+    template <typename ScanOp>
+    __dpct_inline__ void InclusiveDownsweep(ScanOp scan_op, T raking_partial,
+                                            bool apply_prefix = true)
+    {
+        T *smem_raking_ptr = BlockRakingLayout::RakingPtr(temp_storage.raking_grid, linear_tid);
+
+        // Read data back into registers
+        if (!MEMOIZE)
+        {
+            CopySegment(cached_segment, smem_raking_ptr, Int2Type<0>());
+        }
+
+        internal::ThreadScanInclusive(cached_segment, cached_segment, scan_op, raking_partial, apply_prefix);
+
+        // Write data back to smem
+        CopySegment(smem_raking_ptr, cached_segment, Int2Type<0>());
+    }
+
+
+    //---------------------------------------------------------------------
+    // Constructors
+    //---------------------------------------------------------------------
+
+    /// Constructor
+    __dpct_inline__ BlockScanRaking(TempStorage &temp_storage,
+                                    sycl::nd_item<2> item_ct1)
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1)),
+          item_ct1 (item_ct1)
+    {}
+
+
+    //---------------------------------------------------------------------
+    // Exclusive scans
+    //---------------------------------------------------------------------
+    /// Computes an exclusive thread block-wide prefix scan using the specified binary \p scan_op functor.  Each thread contributes one input element.
+    template <typename ScanOp>
+    __dpct_inline__ void
+    ExclusiveScan(T input,   ///< [in] Calling thread's input items
+                  T &output, ///< [out] Calling thread's output items (may be
+                             ///< aliased to \p input)
+                  const T &initial_value, ///< [in] Initial value to seed the
+                                          ///< exclusive scan
+                  ScanOp scan_op)  ///< [in] Binary scan operator
+    {
+        if (SUBGROUP_SYNCHRONOUS)
+        {
+            // Short-circuit directly to subgroup-synchronous scan
+          sycl::sub_group sg = item_ct1.get_sub_group();
+
+          output = sycl::exclusive_scan_over_group(sg, input, initial_value, scan_op);
+        }
+        else
+        {
+            // Place thread partial into shared memory raking grid
+            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
+            *placement_ptr = input;
+
+            CTA_SYNC(item_ct1);
+
+            // Reduce parallelism down to just raking threads
+            if (linear_tid < RAKING_THREADS)
+            {
+                // Raking upsweep reduction across shared partials
+                T upsweep_partial = Upsweep(scan_op);
+
+                // Exclusive Warp-synchronous scan
+                T exclusive_partial;
+                sycl::sub_group sg = item_ct1.get_sub_group();
+                exclusive_partial = sycl::exclusive_scan_over_group(sg, upsweep_partial,
+                    initial_value, scan_op);
+
+                // Exclusive raking downsweep scan
+                ExclusiveDownsweep(scan_op, exclusive_partial);
+            }
+
+            CTA_SYNC(item_ct1);
+
+            // Grab exclusive partial from shared memory
+            output = *placement_ptr;
+        }
+    }
+
+    /// Computes an exclusive thread block-wide prefix scan using the specified binary \p scan_op functor.  Each thread contributes one input element.  the call-back functor \p block_prefix_callback_op is invoked by the first subgroup in the block, and the value returned by <em>lane</em><sub>0</sub> in that subgroup is used as the "seed" value that logically prefixes the thread block's scan inputs.  Also provides every thread with the block-wide \p block_aggregate of all inputs.
+    template <typename ScanOp,
+              typename BlockPrefixCallbackOp>
+    __dpct_inline__ void ExclusiveScan(
+        T input,   ///< [in] Calling thread's input item
+        T &output, ///< [out] Calling thread's output item (may be aliased to \p
+                   ///< input)
+        ScanOp scan_op, ///< [in] Binary scan operator
+        BlockPrefixCallbackOp &block_prefix_callback_op)
+                      ///< Call-back functor for specifying a thread block-wide
+                      ///< prefix to be applied to all inputs.
+    {
+        if (SUBGROUP_SYNCHRONOUS)
+        {
+            // Short-circuit directly to subgroup-synchronous scan
+            T block_aggregate;
+            sycl::sub_group sg = item_ct1.get_sub_group();
+            output = sycl::exclusive_scan_over_group(sg, input, scan_op);
+
+            block_aggregate = sycl::reduce_over_group(sg, input, scan_op);
+
+            // Obtain subgroup-wide prefix in lane0, then broadcast to other lanes
+            T block_prefix = block_prefix_callback_op(block_aggregate);
+
+            output = scan_op(block_prefix, output);
+
+            if (linear_tid == 0)
+              output = block_prefix;
+        }
+        else
+        {
+            // Place thread partial into shared memory raking grid
+            T *placement_ptr = BlockRakingLayout::PlacementPtr(temp_storage.raking_grid, linear_tid);
+            *placement_ptr = input;
+
+            CTA_SYNC(item_ct1);
+
+            // Reduce parallelism down to just raking threads
+            if (linear_tid < RAKING_THREADS)
+            {
+                 sycl::sub_group sg = item_ct1.get_sub_group();
+
+                // Raking upsweep reduction across shared partials
+                T upsweep_partial = Upsweep(scan_op);
+
+                // Warp-synchronous scan
+                T exclusive_partial, block_aggregate;
+
+                exclusive_partial = sycl::exclusive_scan_over_group(sg, upsweep_partial, scan_op);
+
+                block_aggregate = sycl::reduce_over_group(sg, upsweep_partial, scan_op);
+
+                // Obtain block-wide prefix in lane0, then broadcast to other lanes
+                T block_prefix = block_prefix_callback_op(block_aggregate);
+
+                // Update prefix with subgroup scan exclusive partial
+                T downsweep_prefix = scan_op(block_prefix, exclusive_partial);
+                if (linear_tid == 0)
+                    downsweep_prefix = block_prefix;
+
+                // Exclusive raking downsweep scan
+                ExclusiveDownsweep(scan_op, downsweep_prefix);
+            }
+
+            CTA_SYNC(item_ct1);
+
+            // Grab thread prefix from shared memory
+            output = *placement_ptr;
+        }
+    }
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_store.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_store.hpp
new file mode 100644
index 000000000..6bfb7e9f1
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/block_store.hpp
@@ -0,0 +1,409 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * Operations for writing linear segments of data from the thread block
+ */
+
+#pragma once
+
+#include "util_type.hpp"
+
+/******************************************************************//**
+ * \name Blocked arrangement I/O (direct)
+ *********************************************************************/
+//@{
+
+/**
+ * \brief Store a blocked arrangement of items across a thread block into a linear segment of items.
+ *
+ * \blocked
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to store.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam OutputIteratorT      <b>[inferred]</b> The random-access iterator type for output \iterator.
+ */
+template <typename T, int ITEMS_PER_THREAD,
+          typename OutputIteratorT>
+__dpct_inline__ void StoreDirectBlocked(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    OutputIteratorT block_itr, ///< [in] The thread block's base output iterator
+                               ///< for storing to
+    T (&items)[ITEMS_PER_THREAD]) ///< [in] Data to store
+{
+    OutputIteratorT thread_itr = block_itr + (linear_tid * ITEMS_PER_THREAD);
+
+    // Store directly in thread-blocked order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        thread_itr[ITEM] = items[ITEM];
+    }
+}
+
+
+/**
+ * \brief Store a blocked arrangement of items across a thread block into a linear segment of items, guarded by range
+ *
+ * \blocked
+ *
+ * \tparam T                    <b>[inferred]</b> The data type to store.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam OutputIteratorT      <b>[inferred]</b> The random-access iterator type for output \iterator.
+ */
+template <typename T, int ITEMS_PER_THREAD,
+          typename OutputIteratorT>
+__dpct_inline__ void StoreDirectBlocked(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    OutputIteratorT block_itr, ///< [in] The thread block's base output iterator
+                               ///< for storing to
+    T (&items)[ITEMS_PER_THREAD], ///< [in] Data to store
+    int valid_items)              ///< [in] Number of valid items to write
+{
+    OutputIteratorT thread_itr = block_itr + (linear_tid * ITEMS_PER_THREAD);
+
+    // Store directly in thread-blocked order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        if (ITEM + (linear_tid * ITEMS_PER_THREAD) < valid_items)
+        {
+            thread_itr[ITEM] = items[ITEM];
+        }
+    }
+}
+
+/**
+ * \brief Store a striped arrangement of data across the thread block into a linear segment of items.
+ *
+ * \striped
+ *
+ * \tparam BLOCK_THREADS        The thread block size in threads
+ * \tparam T                    <b>[inferred]</b> The data type to store.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam OutputIteratorT      <b>[inferred]</b> The random-access iterator type for output \iterator.
+ */
+template <int BLOCK_THREADS, typename T, int ITEMS_PER_THREAD,
+          typename OutputIteratorT>
+__dpct_inline__ void StoreDirectStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    OutputIteratorT block_itr, ///< [in] The thread block's base output iterator
+                               ///< for storing to
+    T (&items)[ITEMS_PER_THREAD]) ///< [in] Data to store
+{
+    OutputIteratorT thread_itr = block_itr + linear_tid;
+
+    // Store directly in striped order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        thread_itr[(ITEM * BLOCK_THREADS)] = items[ITEM];
+    }
+}
+
+
+/**
+ * \brief Store a striped arrangement of data across the thread block into a linear segment of items, guarded by range
+ *
+ * \striped
+ *
+ * \tparam BLOCK_THREADS        The thread block size in threads
+ * \tparam T                    <b>[inferred]</b> The data type to store.
+ * \tparam ITEMS_PER_THREAD     <b>[inferred]</b> The number of consecutive items partitioned onto each thread.
+ * \tparam OutputIteratorT      <b>[inferred]</b> The random-access iterator type for output \iterator.
+ */
+template <int BLOCK_THREADS, typename T, int ITEMS_PER_THREAD,
+          typename OutputIteratorT>
+__dpct_inline__ void StoreDirectStriped(
+    int linear_tid, ///< [in] A suitable 1D thread-identifier for the calling
+                    ///< thread (e.g., <tt>(threadIdx.y * blockDim.x) +
+                    ///< linear_tid</tt> for 2D thread blocks)
+    OutputIteratorT block_itr, ///< [in] The thread block's base output iterator
+                               ///< for storing to
+    T (&items)[ITEMS_PER_THREAD], ///< [in] Data to store
+    int valid_items)              ///< [in] Number of valid items to write
+{
+    OutputIteratorT thread_itr = block_itr + linear_tid;
+
+    // Store directly in striped order
+    #pragma unroll
+    for (int ITEM = 0; ITEM < ITEMS_PER_THREAD; ITEM++)
+    {
+        if ((ITEM * BLOCK_THREADS) + linear_tid < valid_items)
+        {
+            thread_itr[(ITEM * BLOCK_THREADS)] = items[ITEM];
+        }
+    }
+}
+
+//-----------------------------------------------------------------------------
+// Generic BlockStore abstraction
+//-----------------------------------------------------------------------------
+
+/**
+ * \brief BlockStoreAlgorithm enumerates alternative algorithms for BlockStore to write a blocked arrangement of items across a thread block to a linear segment of memory.
+ */
+enum BlockStoreAlgorithm
+{
+    /**
+     * \par Overview
+     *
+     * A [<em>blocked arrangement</em>](index.html#sec5sec3) of data is written
+     * directly to memory.
+     *
+     * \par Performance Considerations
+     * - The utilization of memory transactions (coalescing) decreases as the
+     *   access stride between threads increases (i.e., the number items per thread).
+     */
+    BLOCK_STORE_DIRECT,
+
+    /**
+     * \par Overview
+     * A [<em>striped arrangement</em>](index.html#sec5sec3) of data is written
+     * directly to memory.
+     *
+     * \par Performance Considerations
+     * The utilization of memory transactions (coalescing) remains high regardless
+     * of items written per thread.
+     */
+    BLOCK_STORE_STRIPED,
+};
+
+/**
+ * \brief The BlockStore class provides [<em>collective</em>](index.html#sec0) data movement methods for writing a [<em>blocked arrangement</em>](index.html#sec5sec3) of items partitioned across a thread block to a linear segment of memory.  ![](block_store_logo.png)
+ * \ingroup BlockModule
+ * \ingroup UtilIo
+ *
+ * \tparam T                    The type of data to be written.
+ * \tparam BLOCK_DIM_X          The thread block length in threads along the X dimension
+ * \tparam ITEMS_PER_THREAD     The number of consecutive items partitioned onto each thread.
+ * \tparam ALGORITHM            <b>[optional]</b> BlockStoreAlgorithm tuning policy enumeration.  default: BLOCK_STORE_DIRECT.
+ * \tparam BLOCK_DIM_Y          <b>[optional]</b> The thread block length in threads along the Y dimension (default: 1)
+ * \tparam BLOCK_DIM_Z          <b>[optional]</b> The thread block length in threads along the Z dimension (default: 1)
+ * \tparam LEGACY_PTX_ARCH      <b>[optional]</b> Unused.
+ *
+ * \par Overview
+ * - The BlockStore class provides a single data movement abstraction that can be specialized
+ *   to implement different BlockStoreAlgorithm strategies.  This facilitates different
+ *   performance policies for different architectures, data types, granularity sizes, etc.
+ * - BlockStore can be optionally specialized by different data movement strategies:
+ *   -# <b>BLOCK_STORE_DIRECT</b>.  A [<em>blocked arrangement</em>](index.html#sec5sec3) of data is written
+ *      directly to memory. [More...](\ref BlockStoreAlgorithm)
+ *   -# <b>BLOCK_STORE_STRIPED</b>.  A [<em>striped arrangement</em>](index.html#sec5sec3)
+ *      of data is written directly to memory. [More...](\ref BlockStoreAlgorithm)
+ * - \rowmajor
+ */
+template <
+    typename                T,
+    int                     BLOCK_DIM_X,
+    int                     ITEMS_PER_THREAD,
+    BlockStoreAlgorithm     ALGORITHM           = BLOCK_STORE_DIRECT,
+    int                     BLOCK_DIM_Y         = 1,
+    int                     BLOCK_DIM_Z         = 1>
+class BlockStore
+{
+private:
+    /******************************************************************************
+     * Constants and typed definitions
+     ******************************************************************************/
+
+    /// Constants
+    enum
+    {
+        /// The thread block size in threads
+        BLOCK_THREADS = BLOCK_DIM_X * BLOCK_DIM_Y * BLOCK_DIM_Z,
+    };
+
+
+    /******************************************************************************
+     * Algorithmic variants
+     ******************************************************************************/
+
+    /// Store helper
+    template <BlockStoreAlgorithm _POLICY, int DUMMY>
+    struct StoreInternal;
+
+
+    /**
+     * BLOCK_STORE_DIRECT specialization of store helper
+     */
+    template <int DUMMY>
+    struct StoreInternal<BLOCK_STORE_DIRECT, DUMMY>
+    {
+        /// Shared memory storage layout type
+        typedef NullType TempStorage;
+
+        /// Linear thread-id
+        int linear_tid;
+
+        /// Constructor
+        __dpct_inline__ StoreInternal(TempStorage & /*temp_storage*/,
+                                      int linear_tid)
+            : linear_tid(linear_tid)
+        {}
+
+        /// Store items into a linear segment of memory
+        template <typename OutputIteratorT>
+        __dpct_inline__ void
+        Store(OutputIteratorT block_itr,    ///< [in] The thread block's base
+                                            ///< output iterator for storing to
+              T (&items)[ITEMS_PER_THREAD]) ///< [in] Data to store
+        {
+            StoreDirectBlocked(linear_tid, block_itr, items);
+        }
+
+        /// Store items into a linear segment of memory, guarded by range
+        template <typename OutputIteratorT>
+        __dpct_inline__ void
+        Store(OutputIteratorT block_itr,    ///< [in] The thread block's base
+                                            ///< output iterator for storing to
+              T (&items)[ITEMS_PER_THREAD], ///< [in] Data to store
+              int valid_items) ///< [in] Number of valid items to write
+        {
+            StoreDirectBlocked(linear_tid, block_itr, items, valid_items);
+        }
+    };
+
+
+    /**
+    * BLOCK_STORE_STRIPED specialization of store helper
+    */
+    template <int DUMMY>
+    struct StoreInternal<BLOCK_STORE_STRIPED, DUMMY>
+    {
+        /// Shared memory storage layout type
+        typedef NullType TempStorage;
+
+        /// Linear thread-id
+        int linear_tid;
+
+        /// Constructor
+        __dpct_inline__ StoreInternal(TempStorage & /*temp_storage*/,
+                                      int linear_tid)
+            : linear_tid(linear_tid)
+        {}
+
+        /// Store items into a linear segment of memory
+        template <typename OutputIteratorT>
+        __dpct_inline__ void
+        Store(OutputIteratorT block_itr,    ///< [in] The thread block's base
+                                            ///< output iterator for storing to
+              T (&items)[ITEMS_PER_THREAD]) ///< [in] Data to store
+        {
+            StoreDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items);
+        }
+
+        /// Store items into a linear segment of memory, guarded by range
+        template <typename OutputIteratorT>
+        __dpct_inline__ void
+        Store(OutputIteratorT block_itr,    ///< [in] The thread block's base
+                                            ///< output iterator for storing to
+              T (&items)[ITEMS_PER_THREAD], ///< [in] Data to store
+              int valid_items) ///< [in] Number of valid items to write
+        {
+            StoreDirectStriped<BLOCK_THREADS>(linear_tid, block_itr, items, valid_items);
+        }
+    };
+
+
+    /******************************************************************************
+     * Type definitions
+     ******************************************************************************/
+
+    /// Internal load implementation to use
+    typedef StoreInternal<ALGORITHM, 0> InternalStore;
+
+
+    /// Shared memory storage layout type
+    typedef typename InternalStore::TempStorage _TempStorage;
+
+
+    /******************************************************************************
+     * Thread fields
+     ******************************************************************************/
+
+    /// Thread reference to shared storage
+    _TempStorage &temp_storage;
+
+    /// Linear thread-id
+    int linear_tid;
+
+public:
+
+
+    /// \smemstorage{BlockStore}
+    struct TempStorage : Uninitialized<_TempStorage> {};
+
+
+    /******************************************************************//**
+     * \name Collective constructors
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Collective constructor using the specified memory allocation as temporary storage.
+     */
+    __dpct_inline__ BlockStore(
+        TempStorage &temp_storage,
+        sycl::nd_item<2> item_ct1) ///< [in] Reference to memory allocation
+                                   ///< having layout type TempStorage
+        : temp_storage(temp_storage.Alias()),
+          linear_tid(
+              RowMajorTid(BLOCK_DIM_X, BLOCK_DIM_Y, item_ct1))
+    {}
+
+
+    //@}  end member group
+    /******************************************************************//**
+     * \name Data movement
+     *********************************************************************/
+    //@{
+
+    /**
+     * \brief Store items into a linear segment of memory, guarded by range.
+     *
+     */
+    template <typename OutputIteratorT>
+    __dpct_inline__ void
+    Store(OutputIteratorT block_itr, ///< [out] The thread block's base output
+                                     ///< iterator for storing to
+          T (&items)[ITEMS_PER_THREAD], ///< [in] Data to store
+          int valid_items)              ///< [in] Number of valid items to write
+    {
+        InternalStore(temp_storage, linear_tid).Store(block_itr, items, valid_items);
+    }
+
+    //@}  end member group
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/device_double_buffer.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/device_double_buffer.hpp
new file mode 100644
index 000000000..879de2333
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/device_double_buffer.hpp
@@ -0,0 +1,77 @@
+/*
+ *  Copyright 2021 NVIDIA Corporation
+ *
+ *  Licensed under the Apache License, Version 2.0 (the "License");
+ *  you may not use this file except in compliance with the License.
+ *  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ *  Unless required by applicable law or agreed to in writing, software
+ *  distributed under the License is distributed on an "AS IS" BASIS,
+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *  See the License for the specific language governing permissions and
+ *  limitations under the License.
+ */
+
+#pragma once
+
+#include <dpct/dpct.hpp>
+
+/**
+ * @brief It's a double-buffer storage wrapper for multi-pass stream
+ *        transformations that require more than one storage array for
+ *        streaming intermediate results back and forth.
+ *
+ * Many multi-pass computations require a pair of "ping-pong" storage buffers
+ * (e.g., one for reading from and the other for writing to, and then
+ * vice-versa for the subsequent pass). This structure wraps a set of device
+ * buffers.
+ *
+ * Unlike `cub::DoubleBuffer` this class doesn't provide a "selector" member
+ * to track which buffer is "current". The main reason for this class existence
+ * is the performance difference. Since `cub::DoubleBuffer` relies on the
+ * runtime variable to index pointers arrays, they are placed in the local
+ * memory instead of registers. Local memory accesses significantly affect
+ * performance. On the contrary, this class swaps pointer, so all operations
+ * can be performed in registers.
+ */
+template <typename T>
+class device_double_buffer
+{
+  /// Pair of device buffer pointers
+  T *m_current_buffer {};
+  T *m_alternate_buffer {};
+
+public:
+  /**
+   * @param d_current
+   *   The currently valid buffer
+   *
+   * @param d_alternate
+   *   Alternate storage buffer of the same size as @p d_current
+   */
+  __dpct_inline__ device_double_buffer(T *current, T *alternate)
+      : m_current_buffer(current), m_alternate_buffer(alternate)
+  {}
+
+  /// \brief Return pointer to the currently valid buffer
+  __dpct_inline__ T *current() const
+  {
+    return m_current_buffer;
+  }
+
+  /// \brief Return pointer to the currently invalid buffer
+  __dpct_inline__ T *alternate() const
+  {
+    return m_alternate_buffer;
+  }
+
+  void swap()
+  {
+    T *tmp             = m_current_buffer;
+    m_current_buffer   = m_alternate_buffer;
+    m_alternate_buffer = tmp;
+  }
+};
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/radix_rank_sort_operations.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/radix_rank_sort_operations.hpp
new file mode 100644
index 000000000..9b8a3c62b
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/radix_rank_sort_operations.hpp
@@ -0,0 +1,136 @@
+/******************************************************************************
+ * Copyright (c) 2011-2020, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * radix_rank_sort_operations.dp.hpp contains common abstractions, definitions and
+ * operations used for radix sorting and ranking.
+ */
+
+#pragma once
+
+/** \brief Twiddling keys for radix sort. */
+template <bool IS_DESCENDING, typename KeyT>
+struct RadixSortTwiddle
+{
+    typedef Traits<KeyT> TraitsT;
+    typedef typename TraitsT::UnsignedBits UnsignedBits;
+    static __dpct_inline__ UnsignedBits In(UnsignedBits key)
+    {
+        key = TraitsT::TwiddleIn(key);
+        if (IS_DESCENDING) key = ~key;
+        return key;
+    }
+    static __dpct_inline__ UnsignedBits Out(UnsignedBits key)
+    {
+        if (IS_DESCENDING) key = ~key;
+        key = TraitsT::TwiddleOut(key);
+        return key;
+    }
+    static __dpct_inline__ UnsignedBits DefaultKey()
+    {
+        return Out(~UnsignedBits(0));
+    }
+};
+
+/** \brief Base struct for digit extractor. Contains common code to provide
+    special handling for floating-point -0.0.
+
+    \note This handles correctly both the case when the keys are
+    bitwise-complemented after twiddling for descending sort (in onesweep) as
+    well as when the keys are not bit-negated, but the implementation handles
+    descending sort separately. Twiddling alone maps -0.0f to 0x7fffffff
+    and +0.0f to 0x80000000 for float, which are subsequent bit patterns
+    and bitwise complements of each other. For onesweep, both -0.0f and +0.0f
+    are mapped to the bit pattern of +0.0f (0x80000000) for ascending sort,
+    and to the pattern of -0.0f (0x7fffffff) for descending sort. For all other 
+    sorting implementations, both are always mapped to +0.0f. Since bit patterns
+    for both -0.0f and +0.0f are next to each other and only one of them is used,
+    the sorting works correctly. For double, the same applies, but with 64-bit patterns.
+*/
+template <typename KeyT>
+struct BaseDigitExtractor
+{
+    typedef Traits<KeyT> TraitsT;
+    typedef typename TraitsT::UnsignedBits UnsignedBits;
+
+    enum
+    {
+        FLOAT_KEY = TraitsT::CATEGORY == FLOATING_POINT,
+    };
+
+    static __dpct_inline__ UnsignedBits ProcessFloatMinusZero(UnsignedBits key)
+    {
+        if (!FLOAT_KEY) {
+            return key;
+        } else {
+            UnsignedBits TWIDDLED_MINUS_ZERO_BITS =
+                TraitsT::TwiddleIn(UnsignedBits(1) << UnsignedBits(8 * sizeof(UnsignedBits) - 1));
+            UnsignedBits TWIDDLED_ZERO_BITS = TraitsT::TwiddleIn(0);
+            return key == TWIDDLED_MINUS_ZERO_BITS ? TWIDDLED_ZERO_BITS : key;
+        }
+    }
+};
+
+/** \brief A wrapper type to extract digits. Uses the BFE intrinsic to extract a
+ * key from a digit. */
+template <typename KeyT>
+struct BFEDigitExtractor : BaseDigitExtractor<KeyT>
+{
+    using typename BaseDigitExtractor<KeyT>::UnsignedBits;
+
+    uint32_t bit_start, num_bits;
+    explicit __dpct_inline__ BFEDigitExtractor(uint32_t bit_start = 0,
+                                               uint32_t num_bits = 0)
+        : bit_start(bit_start), num_bits(num_bits)
+    { }
+
+    __dpct_inline__ uint32_t Digit(UnsignedBits key)
+    {
+        return BFE(this->ProcessFloatMinusZero(key), bit_start, num_bits);
+    }
+};
+
+/** \brief A wrapper type to extract digits. Uses a combination of shift and
+ * bitwise and to extract digits. */
+template <typename KeyT>
+struct ShiftDigitExtractor : BaseDigitExtractor<KeyT>
+{
+    using typename BaseDigitExtractor<KeyT>::UnsignedBits;
+
+    uint32_t bit_start, mask;
+    explicit __dpct_inline__ ShiftDigitExtractor(uint32_t bit_start = 0,
+                                                 uint32_t num_bits = 0)
+        : bit_start(bit_start), mask((1 << num_bits) - 1)
+    { }
+
+    __dpct_inline__ uint32_t Digit(UnsignedBits key)
+    {
+        return uint32_t(this->ProcessFloatMinusZero(key) >> UnsignedBits(bit_start)) & mask;
+    }
+};
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_reduce.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_reduce.hpp
new file mode 100644
index 000000000..f9004729e
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_reduce.hpp
@@ -0,0 +1,131 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * Thread utilities for sequential reduction over statically-sized array types
+ */
+
+#pragma once
+
+
+namespace internal {
+
+/**
+ * Sequential reduction over statically-sized array types
+ */
+template <int LENGTH, typename T,
+          typename ReductionOp>
+__dpct_inline__ T
+ThreadReduce(T *input,                 ///< [in] Input array
+             ReductionOp reduction_op, ///< [in] Binary reduction operator
+             T prefix,                 ///< [in] Prefix to seed reduction with
+             Int2Type<LENGTH> /*length*/)
+{
+    T retval = prefix;
+
+    #pragma unroll
+    for (int i = 0; i < LENGTH; ++i)
+        retval = reduction_op(retval, input[i]);
+
+    return retval;
+}
+
+
+/**
+ * \brief Perform a sequential reduction over \p LENGTH elements of the \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     LengthT of input array
+ * \tparam T          <b>[inferred]</b> The data type to be reduced.
+ * \tparam ScanOp     <b>[inferred]</b> Binary reduction operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ReductionOp>
+__dpct_inline__ T
+ThreadReduce(T *input,                 ///< [in] Input array
+             ReductionOp reduction_op, ///< [in] Binary reduction operator
+             T prefix)                 ///< [in] Prefix to seed reduction with
+{
+    return ThreadReduce(input, reduction_op, prefix, Int2Type<LENGTH>());
+}
+
+
+/**
+ * \brief Perform a sequential reduction over \p LENGTH elements of the \p input array.  The aggregate is returned.
+ *
+ * \tparam LENGTH     LengthT of input array
+ * \tparam T          <b>[inferred]</b> The data type to be reduced.
+ * \tparam ScanOp     <b>[inferred]</b> Binary reduction operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ReductionOp>
+__dpct_inline__ T
+ThreadReduce(T *input,                 ///< [in] Input array
+             ReductionOp reduction_op) ///< [in] Binary reduction operator
+{
+    T prefix = input[0];
+    return ThreadReduce<LENGTH - 1>(input + 1, reduction_op, prefix);
+}
+
+
+/**
+ * \brief Perform a sequential reduction over the statically-sized \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     <b>[inferred]</b> LengthT of \p input array
+ * \tparam T          <b>[inferred]</b> The data type to be reduced.
+ * \tparam ScanOp     <b>[inferred]</b> Binary reduction operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ReductionOp>
+__dpct_inline__ T
+ThreadReduce(T (&input)[LENGTH],       ///< [in] Input array
+             ReductionOp reduction_op, ///< [in] Binary reduction operator
+             T prefix)                 ///< [in] Prefix to seed reduction with
+{
+    return ThreadReduce(input, reduction_op, prefix, Int2Type<LENGTH>());
+}
+
+
+/**
+ * \brief Serial reduction with the specified operator
+ *
+ * \tparam LENGTH     <b>[inferred]</b> LengthT of \p input array
+ * \tparam T          <b>[inferred]</b> The data type to be reduced.
+ * \tparam ScanOp     <b>[inferred]</b> Binary reduction operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ReductionOp>
+__dpct_inline__ T
+ThreadReduce(T (&input)[LENGTH],       ///< [in] Input array
+             ReductionOp reduction_op) ///< [in] Binary reduction operator
+{
+    return ThreadReduce<LENGTH>((T*) input, reduction_op);
+}
+
+
+}               // internal namespace
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_scan.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_scan.hpp
new file mode 100644
index 000000000..f473f4a8a
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/thread_scan.hpp
@@ -0,0 +1,200 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+/**
+ * \file
+ * Thread utilities for sequential prefix scan over statically-sized array types
+ */
+
+#pragma once
+
+namespace internal {
+
+
+/**
+ * \addtogroup UtilModule
+ * @{
+ */
+
+/**
+ * \name Sequential prefix scan over statically-sized array types
+ * @{
+ */
+
+template <int LENGTH, typename T, typename ScanOp>
+__dpct_inline__ T ThreadScanExclusive(
+    T inclusive, T exclusive,
+    T *input,       ///< [in] Input array
+    T *output,      ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op, ///< [in] Binary scan operator
+    Int2Type<LENGTH> /*length*/)
+{
+    #pragma unroll
+    for (int i = 0; i < LENGTH; ++i)
+    {
+        inclusive = scan_op(exclusive, input[i]);
+        output[i] = exclusive;
+        exclusive = inclusive;
+    }
+
+    return inclusive;
+}
+
+
+
+/**
+ * \brief Perform a sequential exclusive prefix scan over \p LENGTH elements of the \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     LengthT of \p input and \p output arrays
+ * \tparam T          <b>[inferred]</b> The data type to be scanned.
+ * \tparam ScanOp     <b>[inferred]</b> Binary scan operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ScanOp>
+__dpct_inline__ T ThreadScanExclusive(
+    T *input,       ///< [in] Input array
+    T *output,      ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op, ///< [in] Binary scan operator
+    T prefix,       ///< [in] Prefix to seed scan with
+    bool apply_prefix =
+        true) ///< [in] Whether or not the calling thread should apply its
+              ///< prefix.  If not, the first output element is undefined.
+              ///< (Handy for preventing thread-0 from applying a prefix.)
+{
+    T inclusive = input[0];
+    if (apply_prefix)
+    {
+        inclusive = scan_op(prefix, inclusive);
+    }
+    output[0] = prefix;
+    T exclusive = inclusive;
+
+    return ThreadScanExclusive(inclusive, exclusive, input + 1, output + 1,
+                               scan_op, Int2Type<LENGTH - 1>());
+}
+
+
+/**
+ * \brief Perform a sequential exclusive prefix scan over the statically-sized \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     <b>[inferred]</b> LengthT of \p input and \p output arrays
+ * \tparam T          <b>[inferred]</b> The data type to be scanned.
+ * \tparam ScanOp     <b>[inferred]</b> Binary scan operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ScanOp>
+__dpct_inline__ T ThreadScanExclusive(
+    T (&input)[LENGTH],  ///< [in] Input array
+    T (&output)[LENGTH], ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op,      ///< [in] Binary scan operator
+    T prefix,            ///< [in] Prefix to seed scan with
+    bool apply_prefix = true) ///< [in] Whether or not the calling thread should
+                              ///< apply its prefix.  (Handy for preventing
+                              ///< thread-0 from applying a prefix.)
+{
+    return ThreadScanExclusive<LENGTH>((T*) input, (T*) output, scan_op, prefix, apply_prefix);
+}
+
+template <int LENGTH, typename T, typename ScanOp>
+__dpct_inline__ T ThreadScanInclusive(
+    T inclusive,
+    T *input,       ///< [in] Input array
+    T *output,      ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op, ///< [in] Binary scan operator
+    Int2Type<LENGTH> /*length*/)
+{
+    #pragma unroll
+    for (int i = 0; i < LENGTH; ++i)
+    {
+        inclusive = scan_op(inclusive, input[i]);
+        output[i] = inclusive;
+    }
+
+    return inclusive;
+}
+
+
+/**
+ * \brief Perform a sequential inclusive prefix scan over \p LENGTH elements of the \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     LengthT of \p input and \p output arrays
+ * \tparam T          <b>[inferred]</b> The data type to be scanned.
+ * \tparam ScanOp     <b>[inferred]</b> Binary scan operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ScanOp>
+__dpct_inline__ T ThreadScanInclusive(
+    T *input,       ///< [in] Input array
+    T *output,      ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op, ///< [in] Binary scan operator
+    T prefix,       ///< [in] Prefix to seed scan with
+    bool apply_prefix = true) ///< [in] Whether or not the calling thread should
+                              ///< apply its prefix.  (Handy for preventing
+                              ///< thread-0 from applying a prefix.)
+{
+    T inclusive = input[0];
+    if (apply_prefix)
+    {
+        inclusive = scan_op(prefix, inclusive);
+    }
+    output[0] = inclusive;
+
+    // Continue scan
+    return ThreadScanInclusive(inclusive, input + 1, output + 1, scan_op,
+                               Int2Type<LENGTH - 1>());
+}
+
+
+/**
+ * \brief Perform a sequential inclusive prefix scan over the statically-sized \p input array, seeded with the specified \p prefix.  The aggregate is returned.
+ *
+ * \tparam LENGTH     <b>[inferred]</b> LengthT of \p input and \p output arrays
+ * \tparam T          <b>[inferred]</b> The data type to be scanned.
+ * \tparam ScanOp     <b>[inferred]</b> Binary scan operator type having member <tt>T operator()(const T &a, const T &b)</tt>
+ */
+template <int LENGTH, typename T,
+          typename ScanOp>
+__dpct_inline__ T ThreadScanInclusive(
+    T (&input)[LENGTH],  ///< [in] Input array
+    T (&output)[LENGTH], ///< [out] Output array (may be aliased to \p input)
+    ScanOp scan_op,      ///< [in] Binary scan operator
+    T prefix,            ///< [in] Prefix to seed scan with
+    bool apply_prefix = true) ///< [in] Whether or not the calling thread should
+                              ///< apply its prefix.  (Handy for preventing
+                              ///< thread-0 from applying a prefix.)
+{
+    return ThreadScanInclusive<LENGTH>((T*) input, (T*) output, scan_op, prefix, apply_prefix);
+}
+
+
+//@}  end member group
+
+/** @} */       // end group UtilModule
+
+
+}               // internal namespace
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/sort/util_type.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/sort/util_type.hpp
new file mode 100644
index 000000000..bb72121a6
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/sort/util_type.hpp
@@ -0,0 +1,539 @@
+#pragma once
+
+#include <limits>
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+
+template <bool Test, class T1, class T2>
+using conditional_t = typename std::conditional<Test, T1, T2>::type;
+
+
+/**
+ * \brief A simple "NULL" marker type
+ */
+struct NullType
+{
+    using value_type = NullType;
+
+    template <typename T>
+    __dpct_inline__ NullType &operator=(const T &) {
+      return *this;
+    }
+
+    __dpct_inline__ bool operator==(const NullType &) { return true; }
+
+    __dpct_inline__ bool operator!=(const NullType &) { return false; }
+};
+
+/**
+ *  * \brief Allows for the treatment of an integral constant as a type at compile-time (e.g., to
+ *  achieve static call dispatch based on constant integral values)
+ *   */
+template <int A>
+struct Int2Type
+{
+      enum {VALUE = A};
+};
+
+
+/******************************************************************************
+ * Size and alignment
+ ******************************************************************************/
+
+/// Structure alignment
+template <typename T>
+struct AlignBytes
+{
+    struct Pad
+    {
+        T       val;
+        char    byte;
+    };
+
+    enum
+    {
+        /// The true  alignment of T in bytes
+        ALIGN_BYTES = sizeof(Pad) - sizeof(T)
+    };
+
+    /// The "truly aligned" type
+    typedef T Type;
+};
+
+
+// Specializations where host C++ compilers (e.g., 32-bit Windows) may disagree
+// with device C++ compilers (EDG) on types passed as template parameters through
+// kernel functions
+
+#define __CUB_ALIGN_BYTES(t, b)                                                \
+  template <> struct AlignBytes<t>                                             \
+  { enum { ALIGN_BYTES = b }; typedef __dpct_align__(b) t Type; };
+
+__CUB_ALIGN_BYTES(sycl::short4, 8)
+__CUB_ALIGN_BYTES(sycl::ushort4, 8)
+__CUB_ALIGN_BYTES(sycl::int2, 8)
+__CUB_ALIGN_BYTES(sycl::uint2, 8)
+__CUB_ALIGN_BYTES(long long, 8)
+__CUB_ALIGN_BYTES(unsigned long long, 8)
+__CUB_ALIGN_BYTES(sycl::float2, 8)
+__CUB_ALIGN_BYTES(double, 8)
+#ifdef _WIN32
+    __CUB_ALIGN_BYTES(sycl::long2, 8)
+    __CUB_ALIGN_BYTES(sycl::ulong2, 8)
+#else
+    __CUB_ALIGN_BYTES(sycl::long2, 16)
+    __CUB_ALIGN_BYTES(sycl::ulong2, 16)
+#endif
+__CUB_ALIGN_BYTES(sycl::int4, 16)
+__CUB_ALIGN_BYTES(sycl::uint4, 16)
+__CUB_ALIGN_BYTES(sycl::float4, 16)
+__CUB_ALIGN_BYTES(sycl::long4, 16)
+__CUB_ALIGN_BYTES(sycl::ulong4, 16)
+__CUB_ALIGN_BYTES(sycl::double2, 16)
+__CUB_ALIGN_BYTES(sycl::double4, 16)
+
+// clang-format off
+template <typename T> struct AlignBytes<volatile T> : AlignBytes<T> {};
+template <typename T> struct AlignBytes<const T> : AlignBytes<T> {};
+template <typename T> struct AlignBytes<const volatile T> : AlignBytes<T> {};
+// clang-format on
+
+
+
+/// Unit-words of data movement
+template <typename T>
+struct UnitWord
+{
+    enum {
+        ALIGN_BYTES = AlignBytes<T>::ALIGN_BYTES
+    };
+
+    template <typename Unit>
+    struct IsMultiple
+    {
+        enum {
+            UNIT_ALIGN_BYTES    = AlignBytes<Unit>::ALIGN_BYTES,
+            IS_MULTIPLE         = (sizeof(T) % sizeof(Unit) == 0) && (int(ALIGN_BYTES) % int(UNIT_ALIGN_BYTES) == 0)
+        };
+    };
+
+    /// Biggest shuffle word that T is a whole multiple of and is not larger than
+    /// the alignment of T
+    using ShuffleWord = conditional_t<IsMultiple<int>::IS_MULTIPLE, unsigned int,
+                          conditional_t<IsMultiple<short>::IS_MULTIPLE, unsigned short,
+                                 unsigned char>>;
+
+    /// Biggest volatile word that T is a whole multiple of and is not larger than
+    /// the alignment of T
+    using VolatileWord = conditional_t<IsMultiple<long long>::IS_MULTIPLE,
+                                 unsigned long long,
+                                 ShuffleWord>;
+
+    /// Biggest memory-access word that T is a whole multiple of and is not larger
+    /// than the alignment of T
+    using DeviceWord = conditional_t<IsMultiple<std::uint64_t>::IS_MULTIPLE,
+                                   std::uint64_t, VolatileWord>;
+
+    /// Biggest texture reference word that T is a whole multiple of and is not
+    /// larger than the alignment of T
+    using TextureWord = conditional_t<IsMultiple<sycl::int4>::IS_MULTIPLE, sycl::uint4,
+                            conditional_t<IsMultiple<sycl::int2>::IS_MULTIPLE,
+                                   sycl::uint2, ShuffleWord>>;
+};
+
+// float2 specialization workaround (for SM10-SM13)
+template <> struct UnitWord<sycl::float2>
+{
+    typedef int         ShuffleWord;
+    typedef unsigned long long   VolatileWord;
+    typedef unsigned long long   DeviceWord;
+    typedef sycl::float2 TextureWord;
+};
+
+// float4 specialization workaround (for SM10-SM13)
+template <> struct UnitWord<sycl::float4>
+{
+    typedef int         ShuffleWord;
+    typedef unsigned long long  VolatileWord;
+    typedef std::uint64_t DeviceWord;
+    typedef sycl::float4 TextureWord;
+};
+
+
+// char2 specialization workaround (for SM10-SM13)
+template <> struct UnitWord<sycl::char2>
+{
+    typedef unsigned short      ShuffleWord;
+    typedef unsigned short      VolatileWord;
+    typedef unsigned short      DeviceWord;
+    typedef unsigned short      TextureWord;
+};
+
+// clang-format off
+template <typename T> struct UnitWord<volatile T> : UnitWord<T> {};
+template <typename T> struct UnitWord<const T> : UnitWord<T> {};
+template <typename T> struct UnitWord<const volatile T> : UnitWord<T> {};
+// clang-format on
+
+
+
+
+/******************************************************************************
+ * Wrapper types
+ ******************************************************************************/
+
+/**
+ * \brief A storage-backing wrapper that allows types with non-trivial constructors to be aliased in unions
+ */
+template <typename T>
+struct Uninitialized
+{
+    /// Biggest memory-access word that T is a whole multiple of and is not larger than the alignment of T
+    typedef typename UnitWord<T>::DeviceWord DeviceWord;
+
+    static constexpr std::size_t DATA_SIZE = sizeof(T);
+    static constexpr std::size_t WORD_SIZE = sizeof(DeviceWord);
+    static constexpr std::size_t WORDS = DATA_SIZE / WORD_SIZE;
+
+    /// Backing storage
+    DeviceWord storage[WORDS];
+
+    /// Alias
+    __dpct_inline__ T &Alias()
+    {
+        return reinterpret_cast<T&>(*this);
+    }
+};
+
+enum Category
+{
+  NOT_A_NUMBER,
+  SIGNED_INTEGER,
+  UNSIGNED_INTEGER,
+  FLOATING_POINT
+};
+
+
+
+/**
+ * \brief Basic type traits
+ */
+template <Category _CATEGORY, bool _PRIMITIVE, bool _NULL_TYPE, typename _UnsignedBits, typename T>
+struct BaseTraits
+{
+  /// Category
+  static const Category CATEGORY      = _CATEGORY;
+  enum
+  {
+    PRIMITIVE       = _PRIMITIVE,
+    NULL_TYPE       = _NULL_TYPE,
+  };
+};
+
+/**
+ * Basic type traits (unsigned primitive specialization)
+ */
+template <typename _UnsignedBits, typename T>
+struct BaseTraits<UNSIGNED_INTEGER, true, false, _UnsignedBits, T>
+{
+    typedef _UnsignedBits       UnsignedBits;
+
+    static const Category       CATEGORY    = UNSIGNED_INTEGER;
+    static const UnsignedBits   LOWEST_KEY  = UnsignedBits(0);
+    static const UnsignedBits   MAX_KEY     = UnsignedBits(-1);
+
+    enum
+    {
+        PRIMITIVE       = true,
+        NULL_TYPE       = false,
+    };
+
+    static __dpct_inline__ UnsignedBits TwiddleIn(UnsignedBits key)
+    {
+        return key;
+    }
+
+    static __dpct_inline__ UnsignedBits TwiddleOut(UnsignedBits key)
+    {
+        return key;
+    }
+
+    static __dpct_inline__ T Max()
+    {
+        UnsignedBits retval_bits = MAX_KEY;
+        T retval;
+        memcpy(&retval, &retval_bits, sizeof(T));
+        return retval;
+    }
+
+    static __dpct_inline__ T Lowest()
+    {
+        UnsignedBits retval_bits = LOWEST_KEY;
+        T retval;
+        memcpy(&retval, &retval_bits, sizeof(T));
+        return retval;
+    }
+};
+
+
+/**
+ * Basic type traits (signed primitive specialization)
+ */
+template <typename _UnsignedBits, typename T>
+struct BaseTraits<SIGNED_INTEGER, true, false, _UnsignedBits, T>
+{
+  typedef _UnsignedBits       UnsignedBits;
+
+  static const Category       CATEGORY    = SIGNED_INTEGER;
+  static const UnsignedBits   HIGH_BIT    = UnsignedBits(1) << ((sizeof(UnsignedBits) * 8) - 1);
+  static const UnsignedBits   LOWEST_KEY  = HIGH_BIT;
+  static const UnsignedBits   MAX_KEY     = UnsignedBits(-1) ^ HIGH_BIT;
+
+  enum
+  {
+    PRIMITIVE       = true,
+    NULL_TYPE       = false,
+  };
+
+  static __dpct_inline__ UnsignedBits TwiddleIn(UnsignedBits key)
+  {
+  //  out << "high bit=" << HIGH_BIT << "\n";
+    return key ^ HIGH_BIT;
+  };
+
+  static __dpct_inline__ UnsignedBits TwiddleOut(UnsignedBits key)
+  {
+    return key ^ HIGH_BIT;
+  };
+
+  static __dpct_inline__ T Max()
+  {
+    UnsignedBits retval = MAX_KEY;
+    return reinterpret_cast<T&>(retval);
+  }
+
+  static __dpct_inline__ T Lowest()
+  {
+    UnsignedBits retval = LOWEST_KEY;
+    return reinterpret_cast<T&>(retval);
+  }
+};
+
+
+template <typename _T>
+struct FpLimits;
+
+template <>
+struct FpLimits<float>
+{
+    static __dpct_inline__ float Max() {
+        return std::numeric_limits<float>::max();
+    }
+
+    static __dpct_inline__ float Lowest() {
+        return std::numeric_limits<float>::min();
+    }
+};
+
+/*
+ * Basic type traits (fp primitive specialization)
+ */
+template <typename _UnsignedBits, typename T>
+struct BaseTraits<FLOATING_POINT, true, false, _UnsignedBits, T>
+{
+    typedef _UnsignedBits       UnsignedBits;
+
+    static const Category       CATEGORY    = FLOATING_POINT;
+    static const UnsignedBits   HIGH_BIT    = UnsignedBits(1) << ((sizeof(UnsignedBits) * 8) - 1);
+    static const UnsignedBits   LOWEST_KEY  = UnsignedBits(-1);
+    static const UnsignedBits   MAX_KEY     = UnsignedBits(-1) ^ HIGH_BIT;
+
+    enum
+    {
+        PRIMITIVE       = true,
+        NULL_TYPE       = false,
+    };
+
+    static __dpct_inline__ UnsignedBits TwiddleIn(UnsignedBits key)
+    {
+        UnsignedBits mask = (key & HIGH_BIT) ? UnsignedBits(-1) : HIGH_BIT;
+        return key ^ mask;
+    };
+
+    static __dpct_inline__ UnsignedBits TwiddleOut(UnsignedBits key)
+    {
+        UnsignedBits mask = (key & HIGH_BIT) ? HIGH_BIT : UnsignedBits(-1);
+        return key ^ mask;
+    };
+
+    static __dpct_inline__ T Max() {
+        return FpLimits<T>::Max();
+    }
+
+    static __dpct_inline__ T Lowest() {
+        return FpLimits<T>::Lowest();
+    }
+};
+
+template <typename T> struct NumericTraits :            BaseTraits<NOT_A_NUMBER, false, false, T, T> {};
+template <> struct NumericTraits<float> :               BaseTraits<FLOATING_POINT, true, false, unsigned int, float> {};
+template <> struct NumericTraits<int> :                 BaseTraits<SIGNED_INTEGER, true, false,  unsigned int, int> {};
+template <> struct NumericTraits<unsigned int> :        BaseTraits<UNSIGNED_INTEGER, true, false,  unsigned int, unsigned int> {};
+/**
+ *  * \brief Type traits
+ *   */
+template <typename T>
+struct Traits : NumericTraits<typename std::remove_cv<T>::type> {};
+
+/**
+ * \brief Statically determine log2(N), rounded up.
+ *
+ * For example:
+ *     Log2<8>::VALUE   // 3
+ *     Log2<3>::VALUE   // 2
+ */
+template <int N, int CURRENT_VAL = N, int COUNT = 0>
+struct Log2
+{
+    /// Static logarithm value
+    enum { VALUE = Log2<N, (CURRENT_VAL >> 1), COUNT + 1>::VALUE };         // Inductive case
+};
+
+template <int N, int COUNT>
+struct Log2<N, 0, COUNT>
+{
+    enum {VALUE = (1 << (COUNT - 1) < N) ?                                  // Base case
+        COUNT :
+        COUNT - 1 };
+};
+
+/**
+ * \brief Returns the row-major linear thread identifier for a multidimensional thread block
+ */
+__inline__ __attribute__ ((always_inline)) int RowMajorTid(int block_dim_x, int block_dim_y, sycl::nd_item<2> item_ct1)
+{
+  // get_local_linear_id will able to locate the correct id
+  (void) block_dim_x;
+  (void) block_dim_y;
+  return item_ct1.get_local_linear_id();
+}
+
+/**
+ *  * CTA barrier
+ *   */
+__dpct_inline__ void CTA_SYNC(sycl::nd_item<2>& item_ct1)
+{
+  /*
+   *  DPCT1065:8: Consider replacing sycl::nd_item::barrier() with
+   *  sycl::nd_item::barrier(sycl::access::fence_space::local_space) for better
+   *  performance if there is no access to global memory.
+   */
+
+  item_ct1.barrier(sycl::access::fence_space::local_space);
+}
+
+/**
+ * CTA barrier with predicate
+ */
+__dpct_inline__ int CTA_SYNC_AND(int p, sycl::nd_item<2> &item_ct1)
+{
+    /*
+    DPCT1065:9: Consider replacing sycl::nd_item::barrier() with
+    sycl::nd_item::barrier(sycl::access::fence_space::local_space) for better
+    performance if there is no access to global memory.
+    */
+    return (item_ct1.barrier(), sycl::all_of_group(item_ct1.get_group(), p));
+}
+
+
+/**
+ * CTA barrier with predicate
+ */
+__dpct_inline__ int CTA_SYNC_OR(int p, sycl::nd_item<2> &item_ct1)
+{
+    /*
+    DPCT1065:10: Consider replacing sycl::nd_item::barrier() with
+    sycl::nd_item::barrier(sycl::access::fence_space::local_space) for better
+    performance if there is no access to global memory.
+    */
+    return (item_ct1.barrier(), sycl::any_of_group(item_ct1.get_group(), p));
+}
+
+__dpct_inline__ void SUBGROUP_SYNC(sycl::nd_item<2> item_ct1)
+{
+  sycl::group_barrier(item_ct1.get_sub_group());
+}
+
+
+__dpct_inline__ unsigned int LaneId(sycl::nd_item<2> &item_ct1)
+{
+  return item_ct1.get_sub_group().get_local_id()[0];
+}
+
+
+template <typename UnsignedBits>
+__dpct_inline__ unsigned int BFE(
+     UnsignedBits            source,
+     unsigned int            bit_start,
+     unsigned int            num_bits)
+{
+  const unsigned long MASK = (1ull << num_bits) - 1;
+  return (source >> bit_start) & MASK;
+}
+
+/**
+ * Compute a 32b mask of threads having the same least-significant
+ */
+template <typename T>
+__dpct_inline__ T MatchAny(T label, int warp_size, sycl::nd_item<2>& item_ct1)
+{
+  T mask = 0;
+  sycl::sub_group sg = item_ct1.get_sub_group();
+
+#pragma unroll
+  for (auto i = 0; i < warp_size; i++ )
+  {
+    const T temp = sycl::select_from_group(sg, label, i);
+    mask |= (temp == label ? 1u : 0u) << i;
+  }
+  return mask;
+}
+
+
+
+/**
+ *  * \brief Statically determine if N is a power-of-two
+ *   */
+template <int N>
+struct PowerOfTwo
+{
+      enum { VALUE = ((N & (N - 1)) == 0) };
+};
+
+
+#define ONEAPI_MAX(a, b) (((b) > (a)) ? (b) : (a))
+#define ONEAPI_MIN(a, b) (((b) < (a)) ? (b) : (a))
+
+
+/*
+template<typename T1, typename T2>
+static inline T1 divUp(const T1 total, const T2 grain) { return (total + grain - 1) / grain; }
+
+template<typename T1, typename T2>
+static inline T1 align(const T1 total, const T2 grain) { return divUp(total, grain) * grain; }
+*/
+
+template <
+    int NOMINAL_4B_BLOCK_THREADS,
+    int NOMINAL_4B_ITEMS_PER_THREAD,
+    int SUBGROUP,
+    typename T>
+struct RegBoundScaling
+{
+    enum {
+        ITEMS_PER_THREAD    = ONEAPI_MAX(1, NOMINAL_4B_ITEMS_PER_THREAD * 4 / ONEAPI_MAX(4, sizeof(T))),
+        BLOCK_THREADS       = ONEAPI_MIN(NOMINAL_4B_BLOCK_THREADS, (((1024 * 48) / (sizeof(T) * ITEMS_PER_THREAD)) + 31) / 32 * 32),
+        SUBGROUP_THREADS    = 1 << SUBGROUP,
+        LOG_SUBGROUP        = SUBGROUP,
+    };
+};
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/static_check.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/static_check.hpp
new file mode 100644
index 000000000..6f38c840e
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/static_check.hpp
@@ -0,0 +1,71 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_DEVICE_STATIC_CHECK_HPP_
+#define PCL_ONEAPI_DEVICE_STATIC_CHECK_HPP_
+
+#if defined(SYCL_LANGUAGE_VERSION)
+#define __PCL_ONEAPI_HOST_DEVICE__ __dpct_inline__
+#else
+    #define __PCL_ONEAPI_HOST_DEVICE__
+#endif  
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            template<bool expr> struct Static {};
+            
+            template<> struct Static<true> 
+            { 
+                __PCL_ONEAPI_HOST_DEVICE__ static void check() {}; 
+            };
+        }    
+    }
+
+    namespace oneapi
+    {
+        using pcl::oneapi::device::Static;
+    }
+}
+
+#undef __PCL_ONEAPI_HOST_DEVICE__
+
+#endif /* PCL_ONEAPI_DEVICE_STATIC_CHECK_HPP_ */
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/vector_math.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/vector_math.hpp
new file mode 100644
index 000000000..bd59906da
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/vector_math.hpp
@@ -0,0 +1,123 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_UTILS_DEVICE_VECTOR_MATH_HPP_
+#define PCL_ONEAPI_UTILS_DEVICE_VECTOR_MATH_HPP_
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            ////////////////////////////////
+            // one element vectors
+
+            ////////////////////////////////
+            // two element vectors
+
+            ////////////////////////////////
+            // three element vectors
+
+            __dpct_inline__ float dot(const sycl::float3& v1, const sycl::float3& v2)
+            {
+                return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z();
+            }
+
+            __dpct_inline__ sycl::float3
+            cross(const sycl::float3& v1, const sycl::float3& v2)
+            {
+                return sycl::float3(v1.y() * v2.z() - v1.z() * v2.y(),
+                                    v1.z() * v2.x() - v1.x() * v2.z(),
+                                    v1.x() * v2.y() - v1.y() * v2.x());
+            }
+        
+            ////////////////////////////////
+            // four element vectors
+
+            __dpct_inline__ float
+            dot(const sycl::float4& v1, const sycl::float4& v2)
+            {
+                return v1.x() * v2.x() + v1.y() * v2.y() + v1.z() * v2.z() + v1.w() * v2.w();
+            }
+
+            ////////////////////////////////
+            // alltype binary operarators
+
+            ////////////////////////////////
+            // tempalted operations vectors
+
+            template <typename T>
+            __dpct_inline__ float
+            norm(const T& val)
+            {
+                return sycl::sqrt(dot(val, val));
+            }
+
+            template <typename T>
+            __dpct_inline__ float
+            inverse_norm(const T& v)
+            {
+                return sycl::rsqrt(dot(v, v));
+            }
+
+            template <typename T>
+            __dpct_inline__ T
+            normalized(const T& v)
+            {
+                /*
+                DPCT1084:10: The function call has multiple migration results in different
+                template instantiations that could not be unified. You may need to adjust
+                the code.
+                */
+                //return dpct_operator_overloading::operator*(v, inverse_norm(v));
+                return v * inverse_norm(v);
+            }
+
+            template <typename T>
+            __dpct_inline__ T
+            normalized_safe(const T& v)
+            {			
+                return (dot(v, v) > 0) ? (v * rsqrtf(dot(v, v))) : v;            
+            }
+        }
+    }
+}
+
+#endif /* PCL_ONEAPI_UTILS_DEVICE_VECTOR_MATH_HPP_ */
+
diff --git a/oneapi/utils/include/pcl/oneapi/utils/device/warp.hpp b/oneapi/utils/include/pcl/oneapi/utils/device/warp.hpp
new file mode 100644
index 000000000..40876ace9
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/device/warp.hpp
@@ -0,0 +1,250 @@
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_DEVICE_UTILS_WARP_HPP_
+#define PCL_DEVICE_UTILS_WARP_HPP_
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            struct Warp
+            {
+                enum
+                {
+                    LOG_WARP_SIZE = 3,
+                    WARP_SIZE     = 1 << LOG_WARP_SIZE,
+                    STRIDE        = WARP_SIZE
+                };
+
+                /** \brief Returns the warp lane ID of the calling thread. */
+                static __dpct_inline__ unsigned int
+                laneId(sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int ret;
+	            //asm("mov.u32 %0, %laneid;" : "=r"(ret) );
+                    /*Above commented cuda asm can not be converted by dpct
+                     *replace asm with below commented code first then convert
+                     *with dpct.
+                     *ret = threadIdx.x % 32;
+                     */
+                    ret = item_ct1.get_sub_group().get_local_linear_id();
+                    return ret;
+                }
+
+                static __dpct_inline__ int
+                laneMaskLe()
+                {
+                    unsigned int ret = 0;
+                    /*
+                    DPCT1053:12: Migration of device assembly code is not supported.
+                    */
+                    //TODO:Lina: This function is not called and comment it for now.
+                    //asm("mov.u32 %0, %lanemask_le;" : "=r"(ret));
+                    return ret;
+                }
+
+                static __dpct_inline__ int
+                laneMaskLt(sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int ret;
+                    //asm("mov.u32 %0, %lanemask_lt;" : "=r"(ret) );
+                    /*Above commented cuda asm can not be converted by dpct,
+                     *replace asm with below commented code first then convert
+                     *with dpct.
+                     *unsigned int lane;
+                     *lane = threadIdx.x % 32;
+                     *ret = (1 << (lane)) - 1;
+                     */
+                    unsigned int lane;
+                    lane = item_ct1.get_sub_group().get_local_linear_id();
+                    ret = (1 << (lane)) - 1;
+                    return ret;
+                }
+                static __dpct_inline__ unsigned int
+                id(sycl::nd_item<3>& item_ct1)
+                {
+                    int tid = item_ct1.get_local_id(0) * item_ct1.get_local_range().get(2) *
+                                  item_ct1.get_local_range().get(1) +
+                              item_ct1.get_local_id(1) * item_ct1.get_local_range().get(2) +
+                              item_ct1.get_local_id(2);
+                    return tid >> LOG_WARP_SIZE;
+                }
+
+                static __dpct_inline__ int
+                binaryInclScan(int ballot_mask)
+                {
+                     return sycl::popcount(Warp::laneMaskLe() & ballot_mask);
+                }
+
+                static __dpct_inline__ int
+                binaryExclScan(int ballot_mask, sycl::nd_item<3>& item_ct1)
+                {
+                     return sycl::popcount(Warp::laneMaskLt(item_ct1) & ballot_mask);
+                }
+
+                template <typename It, typename T>
+                static __dpct_inline__ void
+                fill(It beg, It end, const T& value, sycl::nd_item<3>& item_ct1)
+                {
+                    /*
+                    DPCT1084:13: The function call has multiple migration results in
+                    different template instantiations that could not be unified. You may
+                    need to adjust the code.
+                    */
+                    for (It t = beg + laneId(item_ct1); t < end; t += STRIDE)
+                        *t = value;
+                }
+
+                template <typename InIt, typename OutIt>
+                static __dpct_inline__ OutIt
+                copy(InIt beg, InIt end, OutIt out, sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    InIt  t = beg + lane;
+                    OutIt o = out + lane;
+
+                    for(; t < end; t += STRIDE, o += STRIDE)
+                        *o = *t;
+                    return o;
+                }
+            
+                template <typename InIt, typename OutIt>
+                static __dpct_inline__ OutIt
+                copy(InIt beg, InIt end, OutIt out, unsigned int lane)
+                {      
+                    //landID shoudn't come from CUDA assembly code, so the caller should specify laneID.
+                    // unsigned int lane = laneId();               
+                    InIt  t = beg + lane;
+                    OutIt o = out + lane;
+
+                    for(; t < end; t += STRIDE, o += STRIDE)
+                        *o = *t;
+                    return o;
+                }
+
+                template <typename InIt, typename OutIt, class UnOp>
+                static __dpct_inline__ OutIt
+                transform(InIt beg, InIt end, OutIt out, UnOp op, sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    InIt  t = beg + lane;
+                    OutIt o = out + lane;
+
+                    /*
+                    DPCT1084:14: The function call has multiple migration results in
+                    different template instantiations that could not be unified. You may
+                    need to adjust the code.
+                    */
+                    for (InIt t = beg + laneId(item_ct1); t < end; t += STRIDE, o += STRIDE)
+                        *o = op(*t);
+                    return o;
+                }
+
+                template <typename InIt1, typename InIt2, typename OutIt, class BinOp>
+                static __dpct_inline__ OutIt
+                transform(InIt1 beg1,
+                          InIt1 end1,
+                          InIt2 beg2,
+                          OutIt out,
+                          BinOp op,
+                          sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    InIt1 t1 = beg1 + lane; 
+                    InIt2 t2 = beg2 + lane;
+                    OutIt o  = out  + lane;
+                
+                    for(; t1 < end1; t1 += STRIDE, t2 += STRIDE, o += STRIDE)
+                        *o = op(*t1, *t2);
+                    return o;
+                }
+
+                template <typename OutIt, typename T>
+                static __dpct_inline__ void
+                yota(OutIt beg, OutIt end, T value, sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    value += lane;
+
+                    for(OutIt t = beg + lane; t < end; t += STRIDE, value += STRIDE)
+                        *t = value;
+                }
+
+                template <typename T, class BinOp>
+                static __dpct_inline__ void
+                reduce(volatile T* buffer, BinOp op, sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    T val =  buffer[lane];                
+
+                    if (lane < 16) 
+                    {
+                        buffer[lane] = val = op(val, buffer[lane + 16]);
+                        buffer[lane] = val = op(val, buffer[lane +  8]);
+                        buffer[lane] = val = op(val, buffer[lane +  4]);
+                        buffer[lane] = val = op(val, buffer[lane +  2]);
+                        buffer[lane] = val = op(val, buffer[lane +  1]);
+                    }
+                }
+
+                template <typename T, class BinOp>
+                static __dpct_inline__ T
+                reduce(volatile T* buffer, T init, BinOp op, sycl::nd_item<3>& item_ct1)
+                {
+                    unsigned int lane = laneId(item_ct1);
+                    T val = buffer[lane] = init;
+
+                    if (lane < 16) 
+                    {
+                        buffer[lane] = val = op(val, buffer[lane + 16]);
+                        buffer[lane] = val = op(val, buffer[lane +  8]);
+                        buffer[lane] = val = op(val, buffer[lane +  4]);
+                        buffer[lane] = val = op(val, buffer[lane +  2]);
+                        buffer[lane] = val = op(val, buffer[lane +  1]);
+                    }
+                    return buffer[0];
+                }       
+            };
+        }
+    }
+}
+
+#endif /* PCL_DEVICE_UTILS_WARP_HPP_ */
diff --git a/oneapi/utils/include/pcl/oneapi/utils/double_buffer.hpp b/oneapi/utils/include/pcl/oneapi/utils/double_buffer.hpp
new file mode 100644
index 000000000..035c1621d
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/double_buffer.hpp
@@ -0,0 +1,90 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __PCL_ONEAPI_DOUBLE_BUFFER_H__
+#define __PCL_ONEAPI_DOUBLE_BUFFER_H__
+
+#pragma once
+
+/**
+ * \brief Double-buffer storage wrapper for multi-pass stream transformations that require more than one storage array for streaming intermediate results back and forth.
+ *
+ * Many multi-pass computations require a pair of "ping-pong" storage
+ * buffers (e.g., one for reading from and the other for writing to, and then
+ * vice-versa for the subsequent pass).  This structure wraps a set of device
+ * buffers and a "selector" member to track which is "current".
+ */
+template <typename T>
+struct DoubleBuffer
+{
+    /// Pair of device buffer pointers
+    T *d_buffers[2];
+
+    ///  Selector into \p d_buffers (i.e., the active/valid buffer)
+    int selector;
+
+    /// \brief Constructor
+    __dpct_inline__ DoubleBuffer()
+    {
+        selector = 0;
+        d_buffers[0] = NULL;
+        d_buffers[1] = NULL;
+    }
+
+    /// \brief Constructor
+    __dpct_inline__
+    DoubleBuffer(T *d_current,   ///< The currently valid buffer
+                 T *d_alternate) ///< Alternate storage buffer of the same size
+                                 ///< as \p d_current
+    {
+        selector = 0;
+        d_buffers[0] = d_current;
+        d_buffers[1] = d_alternate;
+    }
+
+    /// \brief Return pointer to the currently valid buffer
+    __dpct_inline__ T *Current() const  { return d_buffers[selector]; }
+
+    /// \brief Return pointer to the currently invalid buffer
+    __dpct_inline__ T *Alternate() const { return d_buffers[selector ^ 1]; }
+};
+
+
+__inline__ int GetFinalSelector(int selector)
+{
+  return (selector + 1) & 1;
+}
+
+template <typename T>
+__inline__ T* GetFinalOutput(const DoubleBuffer<T> &buffer)
+{
+  const int final_selector = GetFinalSelector(buffer.selector);
+  return buffer.d_buffers[final_selector];
+}
+
+#endif
diff --git a/oneapi/utils/include/pcl/oneapi/utils/safe_call.hpp b/oneapi/utils/include/pcl/oneapi/utils/safe_call.hpp
new file mode 100644
index 000000000..b11a5e509
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/safe_call.hpp
@@ -0,0 +1,81 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef __PCL_ONEAPI_SAFE_CALL_HPP__
+#define __PCL_ONEAPI_SAFE_CALL_HPP__
+
+#include <CL/sycl.hpp>
+#include <dpct/dpct.hpp>
+#include <pcl/oneapi/containers/initialization.h>
+
+#if defined(__GNUC__)
+    #define cudaSafeCall(expr)  pcl::oneapi::___cudaSafeCall(expr, __FILE__, __LINE__, __func__)
+#else /* defined(__CUDACC__) || defined(__MSVC__) */
+    #define cudaSafeCall(expr)  pcl::oneapi::___cudaSafeCall(expr, __FILE__, __LINE__)    
+#endif
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        static inline void
+        ___cudaSafeCall(int err,
+                        const char* file,
+                        const int line,
+                        const char* func = "")
+        {
+            /*
+            DPCT1000:18: Error handling if-stmt was detected but could not be rewritten.
+            */
+            if (0 != err)
+                /*
+                DPCT1001:17: The statement could not be removed.
+                */
+                /*
+                DPCT1009:19: SYCL uses exceptions to report errors and does not use the
+                error codes. The original code was commented out and a warning string
+                was inserted. You need to rewrite this code.
+                */
+                error("cudaGetErrorString not supported" /*cudaGetErrorString(err)*/,
+                      file,
+                      line,
+                      func);
+        }
+    }
+}
+
+
+#endif /* __PCL_ONEAPI_SAFE_CALL_HPP__ */
diff --git a/oneapi/utils/include/pcl/oneapi/utils/segmented_sort.h b/oneapi/utils/include/pcl/oneapi/utils/segmented_sort.h
new file mode 100644
index 000000000..c9a899cd2
--- /dev/null
+++ b/oneapi/utils/include/pcl/oneapi/utils/segmented_sort.h
@@ -0,0 +1,293 @@
+/******************************************************************************
+ * Copyright (c) 2011, Duane Merrill.  All rights reserved.
+ * Copyright (c) 2011-2018, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of the NVIDIA CORPORATION nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL NVIDIA CORPORATION BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ******************************************************************************/
+
+#ifndef __PCL_ONEAPI_SEGMENTED_SORT_H__
+#define __PCL_ONEAPI_SEGMENTED_SORT_H__
+
+#ifdef _WIN32
+#define ONEDPL_USE_PREDEFINED_POLICIES 0
+#endif
+
+#include <pcl/oneapi/utils/device/sort/agent_segmented_radix_sort.hpp>
+#include <pcl/oneapi/utils/double_buffer.hpp>
+#include <pcl/oneapi/containers/device_array.h>
+#include <pcl/oneapi/utils/common.h>
+#include <oneapi/dpl/iterator>
+
+#include <tbb/tbb.h>
+
+
+namespace pcl
+{
+namespace oneapi
+{
+
+template <typename KeyT,
+          typename ValueT>
+struct DeviceSegmentedSortPolicy
+{
+  using DominantT = typename std::conditional<(sizeof(ValueT) > sizeof(KeyT)), ValueT, KeyT>::type;
+
+  constexpr static int BLOCK_THREADS = 128;
+  constexpr static int RADIX_BITS = 4;
+  constexpr static int ITEMS_PER_THREAD = 4;
+  constexpr static int LOG_SUBGROUP = 4;
+
+  using LargeSegmentPolicy = AgentRadixSortDownsweepPolicy<BLOCK_THREADS,
+                                                           ITEMS_PER_THREAD,
+                                                           LOG_SUBGROUP,
+                                                           DominantT,
+                                                           BLOCK_LOAD_DIRECT,
+                                                           RADIX_RANK_MATCH,
+                                                           BLOCK_SCAN_SUBGROUP_SCANS,
+                                                           RADIX_BITS>;
+};
+
+
+template <typename KeyT,
+          typename ValueT,
+          typename OffsetT,
+          typename SegmentPolicyT>
+void DeviceSegmentedSortKernel(
+    const KeyT *d_keys_in_orig,
+    KeyT *d_keys_out_orig,
+    device_double_buffer<KeyT> d_keys_double_buffer,
+    const ValueT *d_values_in_orig,
+    ValueT *d_values_out_orig,
+    device_double_buffer<ValueT> d_values_double_buffer,
+    const OffsetT *d_begin_offsets,
+    const OffsetT *d_end_offsets,
+    sycl::nd_item<2> &item_ct1,
+    typename AgentSegmentedRadixSort<false, SegmentPolicyT, KeyT, ValueT, int>::TempStorage *temp_storage_ct1
+    )
+{
+  const unsigned int segment_id = item_ct1.get_group_linear_id();
+
+  OffsetT segment_begin         = d_begin_offsets[segment_id];
+  OffsetT segment_end           = d_end_offsets[segment_id];
+  OffsetT num_items             = segment_end - segment_begin;
+
+  if (num_items <= 0)
+  {
+    return;
+  }
+
+  using AgentSegmentedRadixSortT =
+    AgentSegmentedRadixSort<false, SegmentPolicyT, KeyT, ValueT, int>;
+
+  union type_ct3 {
+    typename AgentSegmentedRadixSortT::TempStorage block_sort;
+  };
+
+  type_ct3 *temp_storage = (type_ct3 *)temp_storage_ct1;
+
+  AgentSegmentedRadixSortT agent(num_items, temp_storage->block_sort, item_ct1);
+
+  constexpr int  cacheable_tile_size = SegmentPolicyT::BLOCK_THREADS * SegmentPolicyT::ITEMS_PER_THREAD;
+
+  d_keys_in_orig += segment_begin;
+  d_keys_out_orig += segment_begin;
+
+  d_values_in_orig += segment_begin;
+  d_values_out_orig += segment_begin;
+
+  constexpr int begin_bit = 0;
+  constexpr int end_bit = sizeof(KeyT) * 8;
+
+  if (num_items <= cacheable_tile_size)
+  {
+    agent.ProcessSinglePass(begin_bit,
+                            end_bit,
+                            d_keys_in_orig,
+                            d_values_in_orig,
+                            d_keys_out_orig,
+                            d_values_out_orig);
+  }
+  else
+  {
+    int current_bit = begin_bit;
+
+    int pass_bits = ONEAPI_MIN(SegmentPolicyT::RADIX_BITS, (end_bit - current_bit));
+
+    d_keys_double_buffer = device_double_buffer<KeyT>(
+        d_keys_double_buffer.current() + segment_begin,
+        d_keys_double_buffer.alternate() + segment_begin);
+
+    d_values_double_buffer = device_double_buffer<ValueT>(
+        d_values_double_buffer.current() + segment_begin,
+        d_values_double_buffer.alternate() + segment_begin);
+
+
+    agent.ProcessIterative(current_bit,
+                           pass_bits,
+                           d_keys_in_orig,
+                           d_values_in_orig,
+                           d_keys_double_buffer.current(),
+                           d_values_double_buffer.current());
+
+    current_bit += pass_bits;
+
+    #pragma unroll 1
+    while (current_bit < end_bit)
+    {
+      int pass_bits = ONEAPI_MIN(SegmentPolicyT::RADIX_BITS, (end_bit - current_bit));
+
+      CTA_SYNC(item_ct1);
+
+      agent.ProcessIterative(current_bit,
+                           pass_bits,
+                           d_keys_double_buffer.current(),
+                           d_values_double_buffer.current(),
+                           d_keys_double_buffer.alternate(),
+                           d_values_double_buffer.alternate());
+
+      d_keys_double_buffer.swap();
+      d_values_double_buffer.swap();
+      current_bit += pass_bits;
+    }
+  }
+}
+
+template <typename KeyT,
+          typename ValueT>
+void SyclSegmentedSortPairs(
+    sycl::queue &q,
+    DeviceArray<KeyT> &input_keys,
+    DeviceArray<ValueT> &input_values,
+    DeviceArray<KeyT> &output_keys,
+    DeviceArray<ValueT> &output_values,
+    const int *d_offsets,
+    int num_items,
+    int num_segments
+    )
+{
+  if (!((input_keys.size() > 0) && (input_values.size() > 0) &&
+        (d_offsets != nullptr) && (num_items > 0) && (num_segments > 0)))
+  {
+    std::cerr << "Invalid input for segmented sort" << std::endl;
+    return;
+  }
+
+  using LargeSegmentPolicyT = typename DeviceSegmentedSortPolicy<KeyT, ValueT>::LargeSegmentPolicy;
+
+  constexpr int BLOCK_THREADS = LargeSegmentPolicyT::BLOCK_THREADS;
+  constexpr int SUBGROUP_THREADS = LargeSegmentPolicyT::SUBGROUP_THREADS;
+
+  DoubleBuffer<KeyT> d_keys(const_cast<KeyT *>(input_keys.ptr()), output_keys.ptr());
+  DoubleBuffer<ValueT> d_values(const_cast<ValueT *>(input_values.ptr()), output_values.ptr());
+
+  using AgentSegmentedRadixSortT =
+    AgentSegmentedRadixSort<false, LargeSegmentPolicyT, KeyT, ValueT, int>;
+
+  int align_num_items = pcl::oneapi::align(num_segments*BLOCK_THREADS, BLOCK_THREADS);
+
+  KeyT *d_keys_temp = sycl::malloc_shared<KeyT>(num_items, q);
+  ValueT *d_values_temp = sycl::malloc_shared<ValueT>(num_items, q);
+
+  sycl::range<2> global(1, align_num_items);
+  sycl::range<2> local(1, BLOCK_THREADS);
+
+  q.submit([&](sycl::handler &cgh) {
+    sycl::local_accessor<typename AgentSegmentedRadixSortT::TempStorage, 0> temp_storage_ct1(cgh);
+
+    cgh.parallel_for(sycl::nd_range<2>(global, local),
+                     [=](sycl::nd_item<2> item_ct1)  [[intel::reqd_sub_group_size(SUBGROUP_THREADS)]] {
+
+
+      device_double_buffer<KeyT> d_keys_double_buffer(d_keys_temp, d_keys.Alternate());
+      device_double_buffer<ValueT> d_values_double_buffer(d_values_temp, d_values.Alternate());
+
+      DeviceSegmentedSortKernel<KeyT, ValueT, int, LargeSegmentPolicyT>
+          (d_keys.Current(),
+           GetFinalOutput(d_keys),
+           d_keys_double_buffer,
+           d_values.Current(),
+           GetFinalOutput(d_values),
+           d_values_double_buffer,
+           d_offsets, d_offsets + 1, item_ct1, temp_storage_ct1.get_pointer());
+    });
+  }).wait();
+
+  free(d_keys_temp, q);
+  free(d_values_temp, q);
+}
+
+template <typename KeyT,
+          typename ValueT>
+void SegmentedSortPairs(
+    DeviceArray<KeyT> &input_keys,
+    DeviceArray<ValueT> &input_values,
+    DeviceArray<KeyT> &output_keys,
+    DeviceArray<ValueT> &output_values,
+    const int *d_offsets,
+    int num_items,
+    int num_segments
+    )
+{
+  sycl::queue q = dpct::get_default_queue();
+
+  if (q.get_device().is_gpu())
+  {
+    SyclSegmentedSortPairs(q,
+        input_keys,
+        input_values,
+        output_keys,
+        output_values,
+        d_offsets,
+        num_items,
+        num_segments);
+  }
+  else
+  {
+    tbb::parallel_for(tbb::blocked_range<size_t>(0, num_segments),
+      [&](const tbb::blocked_range<size_t> &range) {
+      for (int i = range.begin(); i < range.end(); i++)
+      {
+        const int32_t queries_start_idx = d_offsets[i];
+        const size_t num_queries_i = d_offsets[i+1] - d_offsets[i];
+
+        auto input_begin = ::oneapi::dpl::make_zip_iterator(input_keys + queries_start_idx,
+                              input_values + queries_start_idx);
+
+        tbb::parallel_sort(input_begin, input_begin + num_queries_i,
+           [](auto lhs, auto rhs) { return std::get<0>(lhs) < std::get<0>(rhs); });
+       }
+    });
+
+    output_keys = input_keys;
+    output_values = input_values;
+  }
+}
+
+
+} //namespace oneapi
+} //namespace pcl
+
+#endif
+
+
diff --git a/oneapi/utils/src/internal.hpp b/oneapi/utils/src/internal.hpp
new file mode 100755
index 000000000..bb1d65b78
--- /dev/null
+++ b/oneapi/utils/src/internal.hpp
@@ -0,0 +1,51 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#ifndef PCL_ONEAPI_UTILS_INTERNAL_HPP_
+#define PCL_ONEAPI_UTILS_INTERNAL_HPP_
+
+namespace pcl
+{
+    namespace oneapi
+    {
+        namespace device
+        {
+            void copyFields(int in_size, int out_size, int info[4], int size, const void* input, void* output);
+        }
+    }
+}
+
+#endif
diff --git a/oneapi/utils/src/repacks.cpp b/oneapi/utils/src/repacks.cpp
new file mode 100755
index 000000000..3283e5a92
--- /dev/null
+++ b/oneapi/utils/src/repacks.cpp
@@ -0,0 +1,41 @@
+/*
+ * Software License Agreement (BSD License)
+ *
+ *  Copyright (c) 2011, Willow Garage, Inc.
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above
+ *     copyright notice, this list of conditions and the following
+ *     disclaimer in the documentation and/or other materials provided
+ *     with the distribution.
+ *   * Neither the name of Willow Garage, Inc. nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ *  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ *  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ *  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ *  POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  Author: Anatoly Baskeheev, Itseez Ltd, (myname.mysurname@mycompany.com)
+ */
+
+#include <cassert>
+
+//#include <pcl/gpu/utils/repacks.hpp>
+#include "internal.hpp"
+
-- 
2.30.2

